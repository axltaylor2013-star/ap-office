<roblox version="4">
  <Item class="Lighting" referent="0">
    <Properties>
      <string name="Name">Lighting</string>
    </Properties>
  </Item>
  <Item class="ReplicatedStorage" referent="1">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="2">
      <Properties>
        <string name="Name">Modules</string>
      </Properties>
      <Item class="ModuleScript" referent="3">
        <Properties>
          <string name="Name">Config</string>
          <string name="Source"><![CDATA[-- Config.lua (ModuleScript in ReplicatedStorage/Modules)
-- Game-wide constants and settings

local Config = {}

-- === SKILLS ===
Config.Skills = {
	Mining = { maxLevel = 99, baseXP = 50 },
	Woodcutting = { maxLevel = 99, baseXP = 45 },
	Fishing = { maxLevel = 99, baseXP = 40 },
	Smithing = { maxLevel = 99, baseXP = 60 },
	Cooking = { maxLevel = 99, baseXP = 55 },
	Strength = { maxLevel = 99, baseXP = 70 },
	Defense = { maxLevel = 99, baseXP = 65 },
	Ranged = { maxLevel = 99, baseXP = 65 },
	Fletching = { maxLevel = 99, baseXP = 55 },
	Prayer = { maxLevel = 99, baseXP = 60 },
}

-- === COMBAT SKILLS (used for Combat Level calculation) ===
Config.CombatSkills = {"Strength", "Defense", "Ranged", "Prayer"}

-- === XP MULTIPLIER ===
Config.XPMultiplier = 10 -- Global XP multiplier (10x)

-- XP formula: XP needed for level N = floor(N^2 * 100)
function Config.GetXPForLevel(level)
	return math.floor(level * level * 100)
end

-- Get level from total XP
function Config.GetLevelFromXP(totalXP)
	local level = 1
	while Config.GetXPForLevel(level + 1) <= totalXP and level < 99 do
		level = level + 1
	end
	return level
end

-- === INVENTORY ===
Config.MaxInventorySlots = 28 -- just like RuneScape
Config.MaxBankSlots = 100

-- === WILDERNESS ===
Config.WildernessEnabled = true
Config.SafeZoneOnDeath = true -- respawn in safe zone
Config.LootDropDuration = 60 -- seconds before loot despawns

-- === COMBAT ===
Config.BaseHealth = 100
Config.HealthPerCombatLevel = 5
Config.RespawnTime = 5 -- seconds
Config.AttackCooldown = 1.5 -- seconds between attacks

-- === RESOURCE RESPAWN ===
Config.ResourceRespawnTime = {
	Tree = 15,
	Rock = 20,
	FishingSpot = 10,
}

-- === ZONES ===
Config.Zones = {
	SafeZone = "SafeZone",
	Wilderness = "Wilderness",
}

return Config
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="4">
        <Properties>
          <string name="Name">DataManager</string>
          <string name="Source">-- DataManager.lua (ModuleScript in ReplicatedStorage/Modules)
-- Handles saving/loading player data with DataStoreService and comprehensive error handling

local DataStoreService = game:GetService("DataStoreService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Load ErrorHandler first
local ErrorHandler
local success, err = pcall(function()
	ErrorHandler = require(script.Parent:WaitForChild("ErrorHandler", 5))
end)

if not success then
	-- Fallback if ErrorHandler fails to load
	warn("[DataManager] ErrorHandler not available: " .. tostring(err))
	ErrorHandler = {
		LogInfo = function(self, msg, data) print("[INFO] " .. tostring(msg)) end,
		LogWarning = function(self, msg, data) warn("[WARNING] " .. tostring(msg)) end,
		LogError = function(self, msg, data) warn("[ERROR] " .. tostring(msg)) end,
		SafeDataStoreOperation = function(self, opName, callback, fallback)
			local s, r = pcall(callback)
			return s and r or fallback
		end,
		ValidateNotNil = function(self, val, ctx, fallback) return val or fallback end
	}
end

ErrorHandler:LogInfo("DataManager loading...")

-- Load Config with error handling
local Config
local configSuccess, configErr = pcall(function()
	Config = require(script.Parent:WaitForChild("Config", 5))
end)

if not configSuccess then
	ErrorHandler:LogWarning("Config module not available, using defaults", {error = configErr})
	Config = {
		DATASTORE_NAME = "PlayerData_v1",
		AUTOSAVE_INTERVAL = 60,
		MAX_DATA_SIZE = 10000
	}
end

-- Check if DataStore is available
local dataStoreAvailable = false
local PlayerStore
local memoryCache = {} -- In-memory fallback storage

local function initializeDataStore()
	return ErrorHandler:SafeDataStoreOperation("GetDataStore", function()
		PlayerStore = DataStoreService:GetDataStore(Config.DATASTORE_NAME or "PlayerData_v1")
		dataStoreAvailable = true
		return true
	end, false)
end

-- Initialize DataStore
local initSuccess = initializeDataStore()
if not initSuccess then
	ErrorHandler:LogWarning("DataStore initialization failed, using memory cache only")
	dataStoreAvailable = false
end

local DataManager = {}
DataManager.PlayerData = {}
DataManager.PendingSaves = {}
DataManager.SaveQueue = {}

-- Default player data template
local function getDefaultData()
	return {
		Skills = {
			Mining = 0, Woodcutting = 0, Fishing = 0,
			Smithing = 0, Cooking = 0, Strength = 0, Defense = 0,
			Ranged = 0, Fletching = 0, Prayer = 0,
			Magic = 0, Herblore = 0, Crafting = 0,
			Attack = 0, Hitpoints = 10
		},
		Inventory = {},
		Bank = {},
		Equipment = {
			Head = "", Body = "", Legs = "", 
			Weapon = "", Shield = "", Tool = "", 
			Cape = "", Ammo = "", Ring = "", Neck = ""
		},
		Gold = 0,
		TotalDeaths = 0,
		TotalKills = 0,
		PlayTime = 0,
		PvPEnabled = true,
		FirstJoin = os.time(),
		LastSave = os.time(),
		Hotbar = {},
		Prestige = 0,
		PrayerPoints = 10,
		ActivePrayers = {},
		Quests = {},
		Settings = {
			musicVolume = 0.5,
			sfxVolume = 0.7,
			uiScale = 1.0,
			chatEnabled = true
		}
	}
end

-- Safe data loading with fallback
function DataManager:LoadData(player)
	local userId = tostring(player.UserId)
	local playerData
	
	-- Try DataStore first if available
	if dataStoreAvailable then
		playerData = ErrorHandler:SafeDataStoreOperation(
			"LoadData",
			function()
				return PlayerStore:GetAsync(userId)
			end,
			nil
		)
	end
	
	-- If DataStore failed or returned nil, try memory cache
	if not playerData then
		playerData = memoryCache[userId]
		if playerData then
			ErrorHandler:LogInfo("Loaded from memory cache", {player = player.Name})
		end
	end
	
	-- If still no data, create default
	if not playerData then
		playerData = getDefaultData()
		ErrorHandler:LogInfo("Created new player data", {player = player.Name})
	else
		-- Validate and repair existing data
		playerData = self:_validateAndRepairData(playerData, player)
	end
	
	-- Store in memory
	self.PlayerData[userId] = playerData
	memoryCache[userId] = playerData
	
	ErrorHandler:LogInfo("Data loaded successfully", {
		player = player.Name,
		fromDataStore = dataStoreAvailable and playerData ~= memoryCache[userId],
		gold = playerData.Gold
	})
	
	return playerData
end

-- Safe data saving with queue system
function DataManager:SaveData(player, immediate)
	local userId = tostring(player.UserId)
	local playerData = self.PlayerData[userId]
	
	if not playerData then
		ErrorHandler:LogWarning("No data to save", {player = player.Name})
		return false
	end
	
	-- Update timestamp
	playerData.LastSave = os.time()
	
	-- Queue the save
	self.SaveQueue[userId] = {
		data = playerData,
		timestamp = os.time(),
		playerName = player.Name
	}
	
	-- Immediate save requested
	if immediate then
		return self:_processSaveQueue(userId)
	end
	
	return true
end

-- Process save queue for a specific player
function DataManager:_processSaveQueue(userId)
	local saveJob = self.SaveQueue[userId]
	if not saveJob then return true end
	
	-- Skip DataStore entirely if unavailable (unpublished place) â€” just use memory
	if not dataStoreAvailable then
		memoryCache[userId] = saveJob.data
		self.SaveQueue[userId] = nil
		return true
	end
	
	local success = ErrorHandler:SafeDataStoreOperation(
		"SaveData",
		function()
			PlayerStore:SetAsync(userId, saveJob.data)
			return true
		end,
		false
	)
	
	if success then
		self.SaveQueue[userId] = nil
	else
		memoryCache[userId] = saveJob.data
		ErrorHandler:LogWarning("DataStore save failed, stored in memory", {
			player = saveJob.playerName
		})
	end
	
	return success
end

-- Get player data (safe)
function DataManager:GetData(player)
	-- Validate player is not nil
	if not player or type(player) ~= "userdata" or not player:IsA("Player") then
		ErrorHandler:LogWarning("GetData called with invalid player", {player = tostring(player)})
		return getDefaultData()
	end
	
	local userId = tostring(player.UserId)
	local data = self.PlayerData[userId]
	
	if not data then
		ErrorHandler:LogWarning("Data not found, loading...", {player = player.Name})
		data = self:LoadData(player)
	end
	
	return ErrorHandler:ValidateNotNil(data, {player = player.Name}, getDefaultData())
end

-- Update player data (safe)
function DataManager:UpdateData(player, updates)
	-- Validate player is not nil
	if not player or not player:IsA("Player") then
		ErrorHandler:LogWarning("UpdateData called with invalid player", {player = player})
		return false
	end
	
	local userId = tostring(player.UserId)
	local playerData = self:GetData(player)
	
	if not playerData then
		ErrorHandler:LogError("Cannot update nil player data", {player = player.Name})
		return false
	end
	
	-- Apply updates
	for key, value in pairs(updates) do
		if type(value) == "table" then
			playerData[key] = playerData[key] or {}
			for subKey, subValue in pairs(value) do
				playerData[key][subKey] = subValue
			end
		else
			playerData[key] = value
		end
	end
	
	-- Update storage
	self.PlayerData[userId] = playerData
	memoryCache[userId] = playerData
	
	ErrorHandler:LogDebug("Data updated", {
		player = player.Name,
		updates = updates
	})
	
	return true
end

-- Validate and repair player data
function DataManager:_validateAndRepairData(data, player)
	local defaultData = getDefaultData()
	local repaired = false
	
	-- Ensure all top-level fields exist
	for key, defaultValue in pairs(defaultData) do
		if data[key] == nil then
			data[key] = defaultValue
			repaired = true
		end
	end
	
	-- Ensure Skills table is complete
	if data.Skills then
		for skillName, defaultLevel in pairs(defaultData.Skills) do
			if data.Skills[skillName] == nil then
				data.Skills[skillName] = defaultLevel
				repaired = true
			end
		end
	end
	
	-- Ensure Equipment table is complete
	if data.Equipment then
		for slot, defaultItem in pairs(defaultData.Equipment) do
			if data.Equipment[slot] == nil then
				data.Equipment[slot] = defaultItem
				repaired = true
			end
		end
	end
	
	-- Validate numeric values
	local numericFields = {"Gold", "TotalDeaths", "TotalKills", "PlayTime", "Prestige", "PrayerPoints"}
	for _, field in ipairs(numericFields) do
		if type(data[field]) ~= "number" or data[field] &lt; 0 then
			data[field] = defaultData[field] or 0
			repaired = true
		end
	end
	
	if repaired then
		ErrorHandler:LogInfo("Repaired player data", {player = player.Name})
	end
	
	return data
end

-- Auto-save system
local autoSaveConnections = {}

function DataManager:EnableAutoSave(player, interval)
	interval = interval or Config.AUTOSAVE_INTERVAL or 60
	
	local userId = tostring(player.UserId)
	
	-- Remove existing auto-save if any
	if autoSaveConnections[userId] then
		autoSaveConnections[userId]:Disconnect()
	end
	
	-- Create new auto-save
	autoSaveConnections[userId] = game:GetService("RunService").Heartbeat:Connect(function()
		local playerData = self.PlayerData[userId]
		if playerData and os.time() - playerData.LastSave >= interval then
			self:SaveData(player)
		end
	end)
	
	ErrorHandler:LogInfo("Auto-save enabled", {
		player = player.Name,
		interval = interval
	})
end

function DataManager:DisableAutoSave(player)
	local userId = tostring(player.UserId)
	if autoSaveConnections[userId] then
		autoSaveConnections[userId]:Disconnect()
		autoSaveConnections[userId] = nil
	end
end

-- Player event handlers
Players.PlayerAdded:Connect(function(player)
	ErrorHandler:LogInfo("Player added, loading data", {player = player.Name})
	
	-- Load data with retry
	local retries = 0
	local maxRetries = 3
	
	while retries &lt; maxRetries do
		local success = pcall(function()
			DataManager:LoadData(player)
		end)
		
		if success then
			DataManager:EnableAutoSave(player)
			break
		else
			retries = retries + 1
			ErrorHandler:LogWarning("Data load failed, retrying...", {
				player = player.Name,
				retry = retries,
				maxRetries = maxRetries
			})
			wait(1)
		end
	end
	
	if retries >= maxRetries then
		ErrorHandler:LogError("Failed to load player data after retries", {player = player.Name})
	end
end)

Players.PlayerRemoving:Connect(function(player)
	ErrorHandler:LogInfo("Player leaving, saving data", {player = player.Name})
	
	-- Save data immediately
	DataManager:SaveData(player, true)
	
	-- Clean up
	local userId = tostring(player.UserId)
	DataManager:DisableAutoSave(player)
	DataManager.PlayerData[userId] = nil
	DataManager.SaveQueue[userId] = nil
end)

-- Periodic save queue processing
game:GetService("RunService").Heartbeat:Connect(function()
	for userId, saveJob in pairs(DataManager.SaveQueue) do
		if os.time() - saveJob.timestamp >= 5 then -- Process after 5 seconds
			DataManager:_processSaveQueue(userId)
		end
	end
end)

-- Emergency save on shutdown
game:BindToClose(function()
	ErrorHandler:LogInfo("Server shutting down, saving all data")
	
	for _, player in ipairs(Players:GetPlayers()) do
		pcall(function()
			DataManager:SaveData(player, true)
		end)
	end
	
	-- Process all remaining saves
	for userId, _ in pairs(DataManager.SaveQueue) do
		pcall(function()
			DataManager:_processSaveQueue(userId)
		end)
	end
	
	ErrorHandler:LogInfo("Emergency save complete")
end)

-- Helper methods that other scripts expect
function DataManager:GetSkillLevel(player, skillName)
	local data = self:GetData(player)
	if data and data.Skills and data.Skills[skillName] then
		-- Convert raw XP to level (simple formula: level = floor(xp / 100) + 1)
		return math.floor(data.Skills[skillName] / 100) + 1
	end
	return 1 -- Default level
end

function DataManager:AddSkillXP(player, skillName, xpAmount)
	if not player or not skillName or not xpAmount then return end
	
	local updates = {}
	updates["Skills." .. skillName] = function(currentXP)
		return (currentXP or 0) + xpAmount
	end
	
	self:UpdateData(player, updates)
	
	-- Fire XP update event
	local XPUpdateEvent = ReplicatedStorage:FindFirstChild("Remotes") and ReplicatedStorage.Remotes:FindFirstChild("XPUpdate")
	if XPUpdateEvent then
		XPUpdateEvent:FireClient(player, skillName, xpAmount)
	end
end

function DataManager:HasItem(player, itemName, quantity)
	local data = self:GetData(player)
	if not data or not data.Inventory then return false end
	
	quantity = quantity or 1
	for _, item in ipairs(data.Inventory) do
		if item.name == itemName and (item.quantity or 1) >= quantity then
			return true
		end
	end
	return false
end

function DataManager:RemoveFromInventory(player, itemName, quantity)
	if not self:HasItem(player, itemName, quantity) then return false end
	
	local updates = {}
	updates.Inventory = function(inventory)
		inventory = inventory or {}
		for i, item in ipairs(inventory) do
			if item.name == itemName then
				local currentQty = item.quantity or 1
				if currentQty > quantity then
					item.quantity = currentQty - quantity
				else
					table.remove(inventory, i)
				end
				break
			end
		end
		return inventory
	end
	
	self:UpdateData(player, updates)
	return true
end

function DataManager:AddToInventory(player, itemName, quantity)
	if not player or not itemName then return false end
	
	quantity = quantity or 1
	local updates = {}
	updates.Inventory = function(inventory)
		inventory = inventory or {}
		
		-- Check if item already exists in inventory (stackable items)
		for _, item in ipairs(inventory) do
			if item.name == itemName then
				item.quantity = (item.quantity or 1) + quantity
				return inventory
			end
		end
		
		-- Add new item
		table.insert(inventory, {name = itemName, quantity = quantity})
		return inventory
	end
	
	self:UpdateData(player, updates)
	
	-- Fire inventory update event
	local InventoryUpdateEvent = ReplicatedStorage:FindFirstChild("Remotes") and ReplicatedStorage.Remotes:FindFirstChild("InventoryUpdate")
	if InventoryUpdateEvent then
		InventoryUpdateEvent:FireClient(player)
	end
	
	return true
end

ErrorHandler:LogInfo("DataManager initialized successfully", {
	dataStoreAvailable = dataStoreAvailable,
	autoSaveInterval = Config.AUTOSAVE_INTERVAL or 60
})

return DataManager</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="5">
        <Properties>
          <string name="Name">DataManager_Updated</string>
          <string name="Source">-- DataManager.lua (ModuleScript in ReplicatedStorage/Modules)
-- Handles saving/loading player data with DataStoreService and comprehensive error handling

local DataStoreService = game:GetService("DataStoreService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Load ErrorHandler first
local ErrorHandler
local success, err = pcall(function()
	ErrorHandler = require(script.Parent:WaitForChild("ErrorHandler", 5))
end)

if not success then
	-- Fallback if ErrorHandler fails to load
	warn("[DataManager] ErrorHandler not available: " .. tostring(err))
	ErrorHandler = {
		LogInfo = function(self, msg, data) warn(tostring(msg)) end,
		LogWarning = function(self, msg, data) warn(tostring(msg)) end,
		LogError = function(self, msg, data) warn(tostring(msg)) end,
		SafeDataStoreOperation = function(self, opName, callback, fallback)
			local s, r = pcall(callback)
			return s and r or fallback
		end,
		ValidateNotNil = function(self, val, ctx, fallback) return val or fallback end
	}
end

ErrorHandler:LogInfo("DataManager loading...")

-- Load Config with error handling
local Config
local configSuccess, configErr = pcall(function()
	Config = require(script.Parent:WaitForChild("Config", 5))
end)

if not configSuccess then
	ErrorHandler:LogWarning("Config module not available, using defaults", {error = configErr})
	Config = {
		DATASTORE_NAME = "PlayerData_v1",
		AUTOSAVE_INTERVAL = 60,
		MAX_DATA_SIZE = 10000
	}
end

-- Check if DataStore is available
local dataStoreAvailable = false
local PlayerStore
local memoryCache = {} -- In-memory fallback storage

local function initializeDataStore()
	return ErrorHandler:SafeDataStoreOperation("GetDataStore", function()
		PlayerStore = DataStoreService:GetDataStore(Config.DATASTORE_NAME or "PlayerData_v1")
		dataStoreAvailable = true
		return true
	end, false)
end

-- Initialize DataStore
local initSuccess = initializeDataStore()
if not initSuccess then
	ErrorHandler:LogWarning("DataStore initialization failed, using memory cache only")
	dataStoreAvailable = false
end

local DataManager = {}
DataManager.PlayerData = {}
DataManager.PendingSaves = {}
DataManager.SaveQueue = {}

-- Default player data template
local function getDefaultData()
	return {
		Skills = {
			Mining = 0, Woodcutting = 0, Fishing = 0,
			Smithing = 0, Cooking = 0, Strength = 0, Defense = 0,
			Ranged = 0, Fletching = 0, Prayer = 0,
			Magic = 0, Herblore = 0, Crafting = 0,
			Attack = 0, Hitpoints = 10
		},
		Inventory = {},
		Bank = {},
		Equipment = {
			Head = "", Body = "", Legs = "", 
			Weapon = "", Shield = "", Tool = "", 
			Cape = "", Ammo = "", Ring = "", Neck = ""
		},
		Gold = 0,
		TotalDeaths = 0,
		TotalKills = 0,
		PlayTime = 0,
		PvPEnabled = true,
		FirstJoin = os.time(),
		LastSave = os.time(),
		Hotbar = {},
		Prestige = 0,
		PrayerPoints = 10,
		ActivePrayers = {},
		Quests = {},
		Settings = {
			musicVolume = 0.5,
			sfxVolume = 0.7,
			uiScale = 1.0,
			chatEnabled = true
		}
	}
end

-- Safe data loading with fallback
function DataManager:LoadData(player)
	local userId = tostring(player.UserId)
	local playerData
	
	-- Try DataStore first if available
	if dataStoreAvailable then
		playerData = ErrorHandler:SafeDataStoreOperation(
			"LoadData",
			function()
				return PlayerStore:GetAsync(userId)
			end,
			nil
		)
	end
	
	-- If DataStore failed or returned nil, try memory cache
	if not playerData then
		playerData = memoryCache[userId]
		if playerData then
			ErrorHandler:LogInfo("Loaded from memory cache", {player = player.Name})
		end
	end
	
	-- If still no data, create default
	if not playerData then
		playerData = getDefaultData()
		ErrorHandler:LogInfo("Created new player data", {player = player.Name})
	else
		-- Validate and repair existing data
		playerData = self:_validateAndRepairData(playerData, player)
	end
	
	-- Store in memory
	self.PlayerData[userId] = playerData
	memoryCache[userId] = playerData
	
	ErrorHandler:LogInfo("Data loaded successfully", {
		player = player.Name,
		fromDataStore = dataStoreAvailable and playerData ~= memoryCache[userId],
		gold = playerData.Gold
	})
	
	return playerData
end

-- Safe data saving with queue system
function DataManager:SaveData(player, immediate)
	local userId = tostring(player.UserId)
	local playerData = self.PlayerData[userId]
	
	if not playerData then
		ErrorHandler:LogWarning("No data to save", {player = player.Name})
		return false
	end
	
	-- Update timestamp
	playerData.LastSave = os.time()
	
	-- Queue the save
	self.SaveQueue[userId] = {
		data = playerData,
		timestamp = os.time(),
		playerName = player.Name
	}
	
	-- Immediate save requested
	if immediate then
		return self:_processSaveQueue(userId)
	end
	
	return true
end

-- Process save queue for a specific player
function DataManager:_processSaveQueue(userId)
	local saveJob = self.SaveQueue[userId]
	if not saveJob then return true end
	
	local success = ErrorHandler:SafeDataStoreOperation(
		"SaveData",
		function()
			if dataStoreAvailable then
				PlayerStore:SetAsync(userId, saveJob.data)
				return true
			end
			return false
		end,
		false
	)
	
	if success then
		ErrorHandler:LogDebug("Data saved successfully", {
			player = saveJob.playerName,
			timestamp = saveJob.timestamp
		})
		self.SaveQueue[userId] = nil
	else
		-- Store in memory cache as fallback
		memoryCache[userId] = saveJob.data
		ErrorHandler:LogWarning("DataStore save failed, stored in memory", {
			player = saveJob.playerName
		})
	end
	
	return success
end

-- Get player data (safe)
function DataManager:GetData(player)
	local userId = tostring(player.UserId)
	local data = self.PlayerData[userId]
	
	if not data then
		ErrorHandler:LogWarning("Data not found, loading...", {player = player.Name})
		data = self:LoadData(player)
	end
	
	return ErrorHandler:ValidateNotNil(data, {player = player.Name}, getDefaultData())
end

-- Update player data (safe)
function DataManager:UpdateData(player, updates)
	local userId = tostring(player.UserId)
	local playerData = self:GetData(player)
	
	if not playerData then
		ErrorHandler:LogError("Cannot update nil player data", {player = player.Name})
		return false
	end
	
	-- Apply updates
	for key, value in pairs(updates) do
		if type(value) == "table" then
			playerData[key] = playerData[key] or {}
			for subKey, subValue in pairs(value) do
				playerData[key][subKey] = subValue
			end
		else
			playerData[key] = value
		end
	end
	
	-- Update storage
	self.PlayerData[userId] = playerData
	memoryCache[userId] = playerData
	
	ErrorHandler:LogDebug("Data updated", {
		player = player.Name,
		updates = updates
	})
	
	return true
end

-- Validate and repair player data
function DataManager:_validateAndRepairData(data, player)
	local defaultData = getDefaultData()
	local repaired = false
	
	-- Ensure all top-level fields exist
	for key, defaultValue in pairs(defaultData) do
		if data[key] == nil then
			data[key] = defaultValue
			repaired = true
		end
	end
	
	-- Ensure Skills table is complete
	if data.Skills then
		for skillName, defaultLevel in pairs(defaultData.Skills) do
			if data.Skills[skillName] == nil then
				data.Skills[skillName] = defaultLevel
				repaired = true
			end
		end
	end
	
	-- Ensure Equipment table is complete
	if data.Equipment then
		for slot, defaultItem in pairs(defaultData.Equipment) do
			if data.Equipment[slot] == nil then
				data.Equipment[slot] = defaultItem
				repaired = true
			end
		end
	end
	
	-- Validate numeric values
	local numericFields = {"Gold", "TotalDeaths", "TotalKills", "PlayTime", "Prestige", "PrayerPoints"}
	for _, field in ipairs(numericFields) do
		if type(data[field]) ~= "number" or data[field] &lt; 0 then
			data[field] = defaultData[field] or 0
			repaired = true
		end
	end
	
	if repaired then
		ErrorHandler:LogInfo("Repaired player data", {player = player.Name})
	end
	
	return data
end

-- Auto-save system
local autoSaveConnections = {}

function DataManager:EnableAutoSave(player, interval)
	interval = interval or Config.AUTOSAVE_INTERVAL or 60
	
	local userId = tostring(player.UserId)
	
	-- Remove existing auto-save if any
	if autoSaveConnections[userId] then
		autoSaveConnections[userId]:Disconnect()
	end
	
	-- Create new auto-save
	autoSaveConnections[userId] = game:GetService("RunService").Heartbeat:Connect(function()
		local playerData = self.PlayerData[userId]
		if playerData and os.time() - playerData.LastSave >= interval then
			self:SaveData(player)
		end
	end)
	
	ErrorHandler:LogInfo("Auto-save enabled", {
		player = player.Name,
		interval = interval
	})
end

function DataManager:DisableAutoSave(player)
	local userId = tostring(player.UserId)
	if autoSaveConnections[userId] then
		autoSaveConnections[userId]:Disconnect()
		autoSaveConnections[userId] = nil
	end
end

-- Player event handlers
Players.PlayerAdded:Connect(function(player)
	ErrorHandler:LogInfo("Player added, loading data", {player = player.Name})
	
	-- Load data with retry
	local retries = 0
	local maxRetries = 3
	
	while retries &lt; maxRetries do
		local success = pcall(function()
			DataManager:LoadData(player)
		end)
		
		if success then
			DataManager:EnableAutoSave(player)
			break
		else
			retries = retries + 1
			ErrorHandler:LogWarning("Data load failed, retrying...", {
				player = player.Name,
				retry = retries,
				maxRetries = maxRetries
			})
			wait(1)
		end
	end
	
	if retries >= maxRetries then
		ErrorHandler:LogError("Failed to load player data after retries", {player = player.Name})
	end
end)

Players.PlayerRemoving:Connect(function(player)
	ErrorHandler:LogInfo("Player leaving, saving data", {player = player.Name})
	
	-- Save data immediately
	DataManager:SaveData(player, true)
	
	-- Clean up
	local userId = tostring(player.UserId)
	DataManager:DisableAutoSave(player)
	DataManager.PlayerData[userId] = nil
	DataManager.SaveQueue[userId] = nil
end)

-- Periodic save queue processing
game:GetService("RunService").Heartbeat:Connect(function()
	for userId, saveJob in pairs(DataManager.SaveQueue) do
		if os.time() - saveJob.timestamp >= 5 then -- Process after 5 seconds
			DataManager:_processSaveQueue(userId)
		end
	end
end)

-- Emergency save on shutdown
game:BindToClose(function()
	ErrorHandler:LogInfo("Server shutting down, saving all data")
	
	for _, player in ipairs(Players:GetPlayers()) do
		pcall(function()
			DataManager:SaveData(player, true)
		end)
	end
	
	-- Process all remaining saves
	for userId, _ in pairs(DataManager.SaveQueue) do
		pcall(function()
			DataManager:_processSaveQueue(userId)
		end)
	end
	
	ErrorHandler:LogInfo("Emergency save complete")
end)

ErrorHandler:LogInfo("DataManager initialized successfully", {
	dataStoreAvailable = dataStoreAvailable,
	autoSaveInterval = Config.AUTOSAVE_INTERVAL or 60
})

return DataManager</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="6">
        <Properties>
          <string name="Name">ErrorHandler</string>
          <string name="Source">-- ErrorHandler.lua
-- Centralized error handling and debugging system

local ErrorHandler = {}

-- Configuration
local CONFIG = {
	DEBUG_MODE = true,
	LOG_TO_OUTPUT = true,
	LOG_TO_FILE = false,
	MAX_LOG_SIZE = 10000,
	DATASTORE_FALLBACK = true,
	DEFAULT_TIMEOUT = 5, -- seconds
}

-- Log storage
local logs = {}
local logIndex = 1

-- Memory cache for DataStore fallback
local memoryCache = {}

-- Helper: Safe WaitForChild with timeout
function ErrorHandler:SafeWaitForChild(parent, childName, timeout)
	timeout = timeout or CONFIG.DEFAULT_TIMEOUT
	local startTime = tick()
	
	while tick() - startTime &lt; timeout do
		local child = parent:FindFirstChild(childName)
		if child then
			return child
		end
		wait(0.1)
	end
	
	self:LogWarning("SafeWaitForChild timeout", {
		parent = parent:GetFullName(),
		childName = childName,
		timeout = timeout
	})
	
	return nil
end

-- Helper: Safe require with fallback
function ErrorHandler:SafeRequire(moduleScript, fallbackValue)
	if not moduleScript then
		self:LogError("SafeRequire: moduleScript is nil")
		return fallbackValue or {}
	end
	
	local success, result = pcall(function()
		return require(moduleScript)
	end)
	
	if success then
		return result
	else
		self:LogError("SafeRequire failed", {
			module = moduleScript:GetFullName(),
			error = result
		})
		return fallbackValue or {}
	end
end

-- Helper: Safe DataStore operations
function ErrorHandler:SafeDataStoreOperation(operationName, callback, fallbackValue)
	if not CONFIG.DATASTORE_FALLBACK then
		local success, result = pcall(callback)
		if success then
			return result
		else
			self:LogError("DataStore operation failed", {
				operation = operationName,
				error = result
			})
			return fallbackValue
		end
	end
	
	-- Try DataStore first
	local success, result = pcall(callback)
	if success then
		return result
	end
	
	-- Log the DataStore error
	self:LogWarning("DataStore fallback to memory", {
		operation = operationName,
		error = result
	})
	
	-- Use memory cache as fallback
	return fallbackValue
end

-- Helper: Validate not nil
function ErrorHandler:ValidateNotNil(value, context, fallbackValue)
	if value == nil then
		self:LogWarning("Nil value detected", context)
		return fallbackValue
	end
	return value
end

-- Helper: Safe remote event fire
function ErrorHandler:SafeFireRemote(remoteEvent, player, ...)
	if not remoteEvent then
		self:LogError("SafeFireRemote: remoteEvent is nil")
		return false
	end
	
	local args = {...}
	local success, result = pcall(function()
		if player then
			remoteEvent:FireClient(player, unpack(args))
		else
			remoteEvent:FireAllClients(unpack(args))
		end
	end)
	
	if not success then
		self:LogError("Remote event fire failed", {
			remote = remoteEvent:GetFullName(),
			player = player and player.Name or "AllClients",
			error = result
		})
		return false
	end
	
	return true
end

-- Helper: Safe remote event connect
function ErrorHandler:SafeConnectRemote(remoteEvent, callback)
	if not remoteEvent then
		self:LogError("SafeConnectRemote: remoteEvent is nil")
		return nil
	end
	
	return remoteEvent.OnServerEvent:Connect(function(...)
		local success, result = pcall(callback, ...)
		if not success then
			self:LogError("Remote event callback failed", {
				remote = remoteEvent:GetFullName(),
				error = result
			})
		end
	end)
end

-- Logging functions
function ErrorHandler:LogDebug(message, data)
	if not CONFIG.DEBUG_MODE then return end
	
	local logEntry = {
		type = "DEBUG",
		time = os.date("%H:%M:%S"),
		message = message,
		data = data
	}
	
	self:_addLog(logEntry)
	
	if CONFIG.LOG_TO_OUTPUT then
		print(string.format("[DEBUG %s] %s", logEntry.time, tostring(message)))
		if data and type(data) == "table" then
			for k, v in pairs(data) do
				print(string.format("  %s: %s", k, tostring(v)))
			end
		elseif data then
			print(string.format("  data: %s", tostring(data)))
		end
	end
end

function ErrorHandler:LogInfo(message, data)
	local logEntry = {
		type = "INFO",
		time = os.date("%H:%M:%S"),
		message = message,
		data = data
	}
	
	self:_addLog(logEntry)
	
	if CONFIG.LOG_TO_OUTPUT then
		print(string.format("[INFO %s] %s", logEntry.time, tostring(message)))
	end
end

function ErrorHandler:LogWarning(message, data)
	local logEntry = {
		type = "WARNING",
		time = os.date("%H:%M:%S"),
		message = message,
		data = data
	}
	
	self:_addLog(logEntry)
	
	if CONFIG.LOG_TO_OUTPUT then
		warn(string.format("[WARNING %s] %s", logEntry.time, tostring(message)))
		if data and type(data) == "table" then
			for k, v in pairs(data) do
				warn(string.format("  %s: %s", k, tostring(v)))
			end
		elseif data then
			warn(string.format("  data: %s", tostring(data)))
		end
	end
end

function ErrorHandler:LogError(message, data)
	local logEntry = {
		type = "ERROR",
		time = os.date("%H:%M:%S"),
		message = message,
		data = data
	}
	
	self:_addLog(logEntry)
	
	if CONFIG.LOG_TO_OUTPUT then
		error(string.format("[ERROR %s] %s", logEntry.time, tostring(message)))
		if data and type(data) == "table" then
			for k, v in pairs(data) do
				error(string.format("  %s: %s", k, tostring(v)))
			end
		elseif data then
			error(string.format("  data: %s", tostring(data)))
		end
	end
end

-- Internal: Add log entry
function ErrorHandler:_addLog(entry)
	logs[logIndex] = entry
	logIndex = logIndex + 1
	
	-- Manage log size
	if logIndex > CONFIG.MAX_LOG_SIZE then
		-- Remove oldest logs (first 10%)
		local removeCount = math.floor(CONFIG.MAX_LOG_SIZE * 0.1)
		for i = 1, removeCount do
			logs[i] = nil
		end
		-- Shift remaining logs
		local newLogs = {}
		local newIndex = 1
		for i = removeCount + 1, logIndex - 1 do
			newLogs[newIndex] = logs[i]
			newIndex = newIndex + 1
		end
		logs = newLogs
		logIndex = newIndex
	end
end

-- Get all logs
function ErrorHandler:GetLogs()
	return logs
end

-- Clear logs
function ErrorHandler:ClearLogs()
	logs = {}
	logIndex = 1
end

-- Initialize
function ErrorHandler:Init()
	self:LogInfo("ErrorHandler initialized", {
		debugMode = CONFIG.DEBUG_MODE,
		dataStoreFallback = CONFIG.DATASTORE_FALLBACK
	})
	
	-- Set up global error handler for uncaught errors
	local function globalErrorHandler(message, stackTrace)
		self:LogError("Uncaught error", {
			message = message,
			stackTrace = stackTrace
		})
	end
	
	-- Override default error handler
	xpcall(function() end, globalErrorHandler)
	
	return self
end

return ErrorHandler:Init()</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="7">
        <Properties>
          <string name="Name">ItemDatabase</string>
          <string name="Source"><![CDATA[-- ItemDatabase.lua (ModuleScript in ReplicatedStorage/Modules)
-- Every item in the game defined here

local ItemDatabase = {}

ItemDatabase.Items = {
	-- === ORES (from Mining) ===
	["Copper Ore"] = {
		id = "copper_ore",
		type = "resource",
		rarity = "common",
		skill = "Mining",
		levelReq = 1,
		xp = 20,
		stackable = true,
		value = 5,
		description = "A chunk of copper ore.",
	},
	["Iron Ore"] = {
		id = "iron_ore",
		type = "resource",
		rarity = "uncommon",
		skill = "Mining",
		levelReq = 15,
		xp = 35,
		stackable = true,
		value = 15,
		description = "A chunk of iron ore.",
	},
	["Tin Ore"] = {
		id = "tin_ore",
		type = "resource",
		rarity = "common",
		skill = "Mining",
		levelReq = 1,
		xp = 25,
		stackable = true,
		value = 8,
		description = "A chunk of tin ore. Used with copper to make bronze.",
	},
	["Coal Ore"] = {
		id = "coal_ore",
		type = "resource",
		rarity = "uncommon",
		skill = "Mining",
		levelReq = 30,
		xp = 50,
		stackable = true,
		value = 25,
		description = "A lump of coal. Essential for smelting.",
	},
	["Mithril Ore"] = {
		id = "mithril_ore",
		type = "resource",
		rarity = "rare",
		skill = "Mining",
		levelReq = 55,
		xp = 80,
		stackable = true,
		value = 100,
		description = "A shimmering mithril ore. Light but strong.",
	},
	["Adamant Ore"] = {
		id = "adamant_ore",
		type = "resource",
		rarity = "epic",
		skill = "Mining",
		levelReq = 70,
		xp = 95,
		stackable = true,
		value = 150,
		description = "A dense adamantite ore. Extremely durable.",
	},
	["Gold Ore"] = {
		id = "gold_ore",
		type = "resource",
		rarity = "rare",
		skill = "Mining",
		levelReq = 40,
		xp = 65,
		stackable = true,
		value = 50,
		description = "A chunk of gold ore. Valuable.",
	},
	["Runite Ore"] = {
		id = "runite_ore",
		type = "resource",
		rarity = "epic",
		skill = "Mining",
		levelReq = 70,
		xp = 125,
		stackable = true,
		value = 200,
		description = "Extremely rare ore. Only found in the Wilderness.",
		wildernessOnly = true,
	},

	-- === LOGS (from Woodcutting) ===
	["Oak Log"] = {
		id = "oak_log",
		type = "resource",
		rarity = "common",
		skill = "Woodcutting",
		levelReq = 1,
		xp = 18,
		stackable = true,
		value = 4,
		description = "A sturdy oak log.",
	},
	["Willow Log"] = {
		id = "willow_log",
		type = "resource",
		rarity = "uncommon",
		skill = "Woodcutting",
		levelReq = 20,
		xp = 40,
		stackable = true,
		value = 12,
		description = "A flexible willow log.",
	},
	["Yew Log"] = {
		id = "yew_log",
		type = "resource",
		rarity = "rare",
		skill = "Woodcutting",
		levelReq = 50,
		xp = 80,
		stackable = true,
		value = 75,
		description = "Dense yew wood. Prized by fletchers.",
	},
	["Magic Log"] = {
		id = "magic_log",
		type = "resource",
		rarity = "epic",
		skill = "Woodcutting",
		levelReq = 75,
		xp = 150,
		stackable = true,
		value = 250,
		description = "Pulsing with energy. Wilderness only.",
		wildernessOnly = true,
	},

	-- === FISH (from Fishing) ===
	["Shrimp"] = {
		id = "shrimp",
		type = "resource",
		skill = "Fishing",
		levelReq = 1,
		xp = 15,
		stackable = true,
		value = 3,
		cookable = true,
		healAmount = 5,
		description = "A small shrimp.",
	},
	["Trout"] = {
		id = "trout",
		type = "resource",
		skill = "Fishing",
		levelReq = 20,
		xp = 35,
		stackable = true,
		value = 10,
		cookable = true,
		healAmount = 15,
		description = "A fresh trout.",
	},
	["Lobster"] = {
		id = "lobster",
		type = "resource",
		skill = "Fishing",
		levelReq = 40,
		xp = 60,
		stackable = true,
		value = 40,
		cookable = true,
		healAmount = 30,
		description = "A large lobster.",
	},
	["Salmon"] = {
		id = "salmon",
		type = "resource",
		skill = "Fishing",
		levelReq = 30,
		xp = 45,
		stackable = true,
		value = 15,
		cookable = true,
		healAmount = 20,
		description = "A fresh salmon. Good for cooking.",
	},
	["Swordfish"] = {
		id = "swordfish",
		type = "resource",
		skill = "Fishing",
		levelReq = 50,
		xp = 75,
		stackable = true,
		value = 60,
		cookable = true,
		healAmount = 40,
		description = "A swordfish with a long, sharp bill.",
	},
	["Shark"] = {
		id = "shark",
		type = "resource",
		skill = "Fishing",
		levelReq = 70,
		xp = 110,
		stackable = true,
		value = 150,
		cookable = true,
		healAmount = 60,
		description = "A fearsome shark. Provides a lot of meat.",
	},
	["Dark Crab"] = {
		id = "dark_crab",
		type = "resource",
		skill = "Fishing",
		levelReq = 70,
		xp = 130,
		stackable = true,
		value = 180,
		cookable = true,
		healAmount = 50,
		description = "Found only in Wilderness waters.",
		wildernessOnly = true,
	},

	-- === BARS (from Smithing) ===
	["Copper Bar"] = {
		id = "copper_bar",
		type = "crafted",
		skill = "Smithing",
		levelReq = 1,
		xp = 25,
		stackable = true,
		value = 12,
		recipe = { ["Copper Ore"] = 1 },
		description = "A smelted copper bar.",
	},
	["Iron Bar"] = {
		id = "iron_bar",
		type = "crafted",
		skill = "Smithing",
		levelReq = 15,
		xp = 45,
		stackable = true,
		value = 35,
		recipe = { ["Iron Ore"] = 1 },
		description = "A smelted iron bar.",
	},
	["Gold Bar"] = {
		id = "gold_bar",
		type = "crafted",
		skill = "Smithing",
		levelReq = 40,
		xp = 75,
		stackable = true,
		value = 120,
		recipe = { ["Gold Ore"] = 1 },
		description = "A gleaming gold bar.",
	},

	-- === WEAPONS ===
	["Copper Sword"] = {
		id = "copper_sword",
		type = "weapon",
		equipSlot = "Weapon",
		skill = "Smithing",
		levelReq = 1,
		combatReq = 1,
		xp = 50,
		stackable = false,
		value = 30,
		damage = 8,
		attackSpeed = 1.5,
		recipe = { ["Copper Bar"] = 2 },
		description = "A basic copper sword.",
	},
	["Iron Sword"] = {
		id = "iron_sword",
		type = "weapon",
		equipSlot = "Weapon",
		skill = "Smithing",
		levelReq = 20,
		combatReq = 15,
		xp = 80,
		stackable = false,
		value = 85,
		damage = 15,
		attackSpeed = 1.4,
		recipe = { ["Iron Bar"] = 2 },
		description = "A solid iron blade.",
	},
	["Gold Sword"] = {
		id = "gold_sword",
		type = "weapon",
		equipSlot = "Weapon",
		skill = "Smithing",
		levelReq = 45,
		combatReq = 40,
		xp = 120,
		stackable = false,
		value = 300,
		damage = 25,
		attackSpeed = 1.3,
		recipe = { ["Gold Bar"] = 3 },
		description = "A powerful gold sword.",
	},

	-- === COOKED FOOD ===
	["Cooked Shrimp"] = {
		id = "cooked_shrimp",
		type = "food",
		skill = "Cooking",
		levelReq = 1,
		xp = 20,
		stackable = true,
		value = 8,
		healAmount = 10,
		recipe = { ["Shrimp"] = 1 },
		description = "Heals 10 HP.",
	},
	["Cooked Trout"] = {
		id = "cooked_trout",
		type = "food",
		skill = "Cooking",
		levelReq = 20,
		xp = 40,
		stackable = true,
		value = 25,
		healAmount = 25,
		recipe = { ["Trout"] = 1 },
		description = "Heals 25 HP.",
	},
	["Cooked Lobster"] = {
		id = "cooked_lobster",
		type = "food",
		skill = "Cooking",
		levelReq = 40,
		xp = 65,
		stackable = true,
		value = 90,
		healAmount = 45,
		recipe = { ["Lobster"] = 1 },
		description = "Heals 45 HP.",
	},
	["Cooked Salmon"] = {
		id = "cooked_salmon",
		type = "food",
		skill = "Cooking",
		levelReq = 30,
		xp = 50,
		stackable = true,
		value = 35,
		healAmount = 30,
		recipe = { ["Salmon"] = 1 },
		description = "Heals 30 HP.",
	},
	["Cooked Swordfish"] = {
		id = "cooked_swordfish",
		type = "food",
		skill = "Cooking",
		levelReq = 50,
		xp = 80,
		stackable = true,
		value = 120,
		healAmount = 55,
		recipe = { ["Swordfish"] = 1 },
		description = "Heals 55 HP.",
	},
	["Cooked Shark"] = {
		id = "cooked_shark",
		type = "food",
		skill = "Cooking",
		levelReq = 70,
		xp = 120,
		stackable = true,
		value = 300,
		healAmount = 80,
		recipe = { ["Shark"] = 1 },
		description = "Heals 80 HP.",
	},
	["Cooked Dark Crab"] = {
		id = "cooked_dark_crab",
		type = "food",
		skill = "Cooking",
		levelReq = 70,
		xp = 140,
		stackable = true,
		value = 350,
		healAmount = 70,
		recipe = { ["Dark Crab"] = 1 },
		description = "Heals 70 HP. The best food in the game.",
	},

	-- === BASIC FOOD & SUPPLIES ===
	["Bread"] = {
		id = "bread",
		type = "food",
		stackable = true,
		value = 10,
		healAmount = 3,
		description = "Simple bread. Heals 3 HP.",
	},
	["Meat Pie"] = {
		id = "meat_pie",
		type = "food",
		stackable = true,
		value = 25,
		healAmount = 8,
		description = "A hearty meat pie. Heals 8 HP.",
	},
	["Healing Potion"] = {
		id = "healing_potion",
		type = "food",
		stackable = true,
		value = 50,
		healAmount = 15,
		description = "A magical healing potion. Heals 15 HP.",
	},
	["Fishing Bait"] = {
		id = "fishing_bait",
		type = "material",
		stackable = true,
		value = 3,
		description = "Essential for fishing. Attracts fish.",
	},
	["Rope"] = {
		id = "rope",
		type = "material",
		stackable = true,
		value = 15,
		description = "Strong rope. Useful for various tasks.",
	},
	["Tinderbox"] = {
		id = "tinderbox",
		type = "tool",
		stackable = true,
		value = 8,
		description = "Used to start fires. Essential for cooking.",
	},

	-- === BURNT FOOD ===
	["Burnt Shrimp"] = {
		id = "burnt_shrimp", type = "junk", stackable = true, value = 1,
		description = "Oops. Completely inedible.",
	},
	["Burnt Trout"] = {
		id = "burnt_trout", type = "junk", stackable = true, value = 1,
		description = "A blackened trout. Smells terrible.",
	},
	["Burnt Lobster"] = {
		id = "burnt_lobster", type = "junk", stackable = true, value = 1,
		description = "A charred lobster. Not appetizing.",
	},
	["Burnt Dark Crab"] = {
		id = "burnt_dark_crab", type = "junk", stackable = true, value = 1,
		description = "An overcooked dark crab. What a waste.",
	},

	-- === MONSTER DROPS ===
	["Feather"] = {
		id = "feather",
		type = "resource",
		stackable = true,
		value = 2,
		description = "A soft feather.",
	},
	["Raw Chicken"] = {
		id = "raw_chicken",
		type = "resource",
		skill = "Cooking",
		levelReq = 1,
		xp = 15,
		cookable = true,
		healAmount = 3,
		value = 3,
		description = "Raw chicken meat.",
	},
	["Cooked Chicken"] = {
		id = "cooked_chicken",
		type = "food",
		stackable = true,
		value = 8,
		healAmount = 8,
		recipe = { ["Raw Chicken"] = 1 },
		description = "Heals 8 HP.",
	},
	["Cowhide"] = {
		id = "cowhide",
		type = "resource",
		stackable = true,
		value = 5,
		description = "Can be crafted into leather.",
	},
	["Raw Beef"] = {
		id = "raw_beef",
		type = "resource",
		skill = "Cooking",
		levelReq = 1,
		xp = 18,
		cookable = true,
		healAmount = 4,
		value = 4,
		description = "A slab of raw beef.",
	},
	["Cooked Beef"] = {
		id = "cooked_beef",
		type = "food",
		stackable = true,
		value = 12,
		healAmount = 12,
		recipe = { ["Raw Beef"] = 1 },
		description = "Heals 12 HP.",
	},
	["Goblin Mail"] = {
		id = "goblin_mail",
		type = "armor",
		equipSlot = "Body",
		combatReq = 1,
		stackable = false,
		value = 25,
		defense = 3,
		description = "Crude goblin armor.",
	},
	["Bones"] = {
		id = "bones",
		type = "resource",
		stackable = true,
		value = 3,
		description = "Can be buried for Prayer XP.",
	},
	["Dog Tag"] = {
		id = "dog_tag",
		type = "resource",
		stackable = true,
		value = 50,
		description = "A shiny dog tag. Rare collectible.",
	},
	["Rat Tail"] = {
		id = "rat_tail",
		type = "resource",
		stackable = true,
		value = 5,
		description = "Gross but useful for potions.",
	},
	["Raw Rat Meat"] = {
		id = "raw_rat_meat",
		type = "resource",
		skill = "Cooking",
		levelReq = 1,
		xp = 10,
		cookable = true,
		healAmount = 2,
		value = 2,
		description = "Not appetizing.",
	},
	["Cooked Rat Meat"] = {
		id = "cooked_rat_meat",
		type = "food",
		stackable = true,
		value = 5,
		healAmount = 5,
		recipe = { ["Raw Rat Meat"] = 1 },
		description = "Barely edible. Heals 5 HP.",
	},
	["Wizard Robe"] = {
		id = "wizard_robe",
		type = "armor",
		equipSlot = "Body",
		combatReq = 30,
		stackable = false,
		value = 200,
		defense = 12,
		description = "Enchanted wizard robes.",
	},
	["Demon Heart"] = {
		id = "demon_heart",
		type = "resource",
		stackable = true,
		value = 500,
		description = "Pulsing with dark energy.",
	},
	["Dragon Scale"] = {
		id = "dragon_scale",
		type = "resource",
		stackable = true,
		value = 1000,
		description = "Nearly indestructible.",
	},
	["Dragon Sword"] = {
		id = "dragon_sword",
		type = "weapon",
		equipSlot = "Weapon",
		combatReq = 75,
		stackable = false,
		value = 5000,
		damage = 50,
		attackSpeed = 1.1,
		description = "Forged from dragon fire.",
	},
	["Shadow Gem"] = {
		id = "shadow_gem",
		type = "resource",
		stackable = true,
		value = 2000,
		description = "Radiates shadow energy.",
	},
	["Bronze Helmet"] = {
		id = "bronze_helmet",
		type = "armor",
		equipSlot = "Head",
		combatReq = 1,
		stackable = false,
		value = 20,
		defense = 2,
		description = "A basic bronze helmet.",
	},
	-- === LEG ARMOR (full tier set) ===
	["Bronze Platelegs"] = {
		id = "bronze_platelegs", type = "armor", equipSlot = "Legs",
		combatReq = 1, stackable = false, value = 20, defense = 3,
		description = "Basic bronze leg armor.",
	},
	["Iron Platelegs"] = {
		id = "iron_platelegs", type = "armor", equipSlot = "Legs",
		combatReq = 15, stackable = false, value = 60, defense = 8,
		description = "Sturdy iron leg armor.",
	},
	["Gold Platelegs"] = {
		id = "gold_platelegs", type = "armor", equipSlot = "Legs",
		combatReq = 30, stackable = false, value = 200, defense = 14,
		description = "Ornate gold-plated leg armor.",
	},
	["Runite Platelegs"] = {
		id = "runite_platelegs", type = "armor", equipSlot = "Legs",
		combatReq = 50, stackable = false, value = 800, defense = 22,
		description = "Powerful runite leg armor.",
	},
	["Dragon Platelegs"] = {
		id = "dragon_platelegs", type = "armor", equipSlot = "Legs",
		combatReq = 70, stackable = false, value = 3000, defense = 35,
		rarity = "legendary",
		description = "Legendary dragon leg armor, forged in dragonfire.",
	},

	-- === CHEST ARMOR (full tier set) ===
	["Bronze Platebody"] = {
		id = "bronze_platebody", type = "armor", equipSlot = "Body",
		combatReq = 1, stackable = false, value = 30, defense = 5,
		description = "Basic bronze chest plate.",
	},
	["Iron Platebody"] = {
		id = "iron_platebody", type = "armor", equipSlot = "Body",
		combatReq = 15, stackable = false, value = 80, defense = 12,
		description = "Solid iron chest armor.",
	},
	["Gold Platebody"] = {
		id = "gold_platebody", type = "armor", equipSlot = "Body",
		combatReq = 30, stackable = false, value = 300, defense = 20,
		description = "A gilded gold chest plate.",
	},
	["Runite Platebody"] = {
		id = "runite_platebody", type = "armor", equipSlot = "Body",
		combatReq = 50, stackable = false, value = 1200, defense = 30,
		description = "Elite runite chest armor.",
	},
	["Dragon Platebody"] = {
		id = "dragon_platebody", type = "armor", equipSlot = "Body",
		combatReq = 70, stackable = false, value = 5000, defense = 45,
		rarity = "legendary",
		description = "Legendary dragon chest armor, nearly indestructible.",
	},

	-- === CHAINMAIL (lighter body armor, lower defense but allows ranged) ===
	["Iron Chainbody"] = {
		id = "iron_chainbody", type = "armor", equipSlot = "Body",
		combatReq = 10, stackable = false, value = 40, defense = 6,
		description = "Light iron chainmail, good for rangers.",
	},
	["Gold Chainbody"] = {
		id = "gold_chainbody", type = "armor", equipSlot = "Body",
		combatReq = 25, stackable = false, value = 150, defense = 12,
		description = "Flexible gold chainmail.",
	},
	["Runite Chainbody"] = {
		id = "runite_chainbody", type = "armor", equipSlot = "Body",
		combatReq = 45, stackable = false, value = 600, defense = 20,
		description = "Strong yet flexible runite chainmail.",
	},

	-- === LEATHER ARMOR (ranger gear) ===
	["Leather Body"] = {
		id = "leather_body", type = "armor", equipSlot = "Body",
		combatReq = 1, stackable = false, value = 15, defense = 3,
		description = "Simple leather tunic.",
	},
	["Leather Chaps"] = {
		id = "leather_chaps", type = "armor", equipSlot = "Legs",
		combatReq = 1, stackable = false, value = 12, defense = 2,
		description = "Basic leather leg protection.",
	},
	["Studded Body"] = {
		id = "studded_body", type = "armor", equipSlot = "Body",
		combatReq = 20, stackable = false, value = 80, defense = 8,
		description = "Leather armor reinforced with metal studs.",
	},
	["Studded Chaps"] = {
		id = "studded_chaps", type = "armor", equipSlot = "Legs",
		combatReq = 20, stackable = false, value = 60, defense = 6,
		description = "Studded leather leg armor.",
	},
	["Dragonhide Body"] = {
		id = "dragonhide_body", type = "armor", equipSlot = "Body",
		combatReq = 60, stackable = false, value = 2000, defense = 28,
		rarity = "epic",
		description = "Armor crafted from dragon scales, prized by rangers.",
	},
	["Dragonhide Chaps"] = {
		id = "dragonhide_chaps", type = "armor", equipSlot = "Legs",
		combatReq = 60, stackable = false, value = 1500, defense = 22,
		rarity = "epic",
		description = "Leg armor from dragon scales, light and durable.",
	},

	-- Keep old Iron Legs as alias
	["Iron Legs"] = {
		id = "iron_legs", type = "armor", equipSlot = "Legs",
		combatReq = 15, stackable = false, value = 60, defense = 8,
		description = "Sturdy iron leg armor.",
	},
	["Wooden Shield"] = {
		id = "wooden_shield",
		type = "armor",
		equipSlot = "Shield",
		combatReq = 1,
		stackable = false,
		value = 15,
		defense = 2,
		description = "A simple wooden shield.",
	},
	["Bronze Coins"] = {
		id = "bronze_coins",
		type = "currency",
		stackable = true,
		value = 1,
		description = "Standard currency.",
	},

	-- === RANGED WEAPONS ===
	["Oak Shortbow"] = {
		id = "oak_shortbow",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 6,
		rangedReq = 1,
		stackable = false,
		value = 15,
		description = "A basic oak shortbow.",
	},
	["Oak Longbow"] = {
		id = "oak_longbow",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 10,
		rangedReq = 10,
		stackable = false,
		value = 30,
		description = "A sturdy oak longbow.",
	},
	["Willow Shortbow"] = {
		id = "willow_shortbow",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 12,
		rangedReq = 20,
		stackable = false,
		value = 50,
		description = "A flexible willow shortbow.",
	},
	["Iron Crossbow"] = {
		id = "iron_crossbow",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 18,
		rangedReq = 30,
		stackable = false,
		value = 100,
		recipe = { ["Iron Bar"] = 3 },
		description = "A powerful iron crossbow.",
	},
	["Willow Longbow"] = {
		id = "willow_longbow",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 18,
		rangedReq = 40,
		stackable = false,
		value = 120,
		description = "A long willow bow with great range.",
	},
	["Yew Shortbow"] = {
		id = "yew_shortbow",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 22,
		rangedReq = 55,
		stackable = false,
		value = 200,
		description = "A yew shortbow. Fast and accurate.",
	},
	["Gold Crossbow"] = {
		id = "gold_crossbow",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 28,
		rangedReq = 65,
		stackable = false,
		value = 400,
		recipe = { ["Gold Bar"] = 3 },
		description = "A gleaming gold crossbow.",
	},
	["Yew Longbow"] = {
		id = "yew_longbow",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 30,
		rangedReq = 70,
		stackable = false,
		value = 350,
		description = "A powerful yew longbow.",
	},
	["Magic Shortbow"] = {
		id = "magic_shortbow",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 35,
		rangedReq = 85,
		stackable = false,
		value = 800,
		description = "Imbued with magical energy.",
	},
	["Dragon Crossbow"] = {
		id = "dragon_crossbow",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 45,
		rangedReq = 95,
		stackable = false,
		value = 8000,
		description = "Forged from dragonfire. The ultimate ranged weapon.",
	},

	-- === AMMUNITION ===
	["Bronze Arrows"] = {
		id = "bronze_arrows",
		type = "ammo",
		stackable = true,
		bonusDmg = 1,
		value = 1,
		description = "Basic bronze-tipped arrows.",
	},
	["Iron Arrows"] = {
		id = "iron_arrows",
		type = "ammo",
		stackable = true,
		bonusDmg = 3,
		value = 3,
		description = "Iron-tipped arrows.",
	},
	["Steel Arrows"] = {
		id = "steel_arrows",
		type = "ammo",
		stackable = true,
		bonusDmg = 5,
		value = 5,
		description = "Steel-tipped arrows. Stronger than iron.",
	},
	["Mithril Arrows"] = {
		id = "mithril_arrows",
		type = "ammo",
		stackable = true,
		bonusDmg = 7,
		value = 12,
		description = "Mithril-tipped arrows. Light and deadly.",
	},
	["Adamant Arrows"] = {
		id = "adamant_arrows",
		type = "ammo",
		stackable = true,
		bonusDmg = 9,
		value = 18,
		description = "Adamantite-tipped arrows. Extremely powerful.",
	},
	["Gold Arrows"] = {
		id = "gold_arrows",
		type = "ammo",
		stackable = true,
		bonusDmg = 6,
		value = 8,
		description = "Gold-tipped arrows.",
	},
	["Runite Arrows"] = {
		id = "runite_arrows",
		type = "ammo",
		stackable = true,
		bonusDmg = 10,
		value = 25,
		description = "Runite-tipped arrows. Devastating.",
	},
	["Iron Bolts"] = {
		id = "iron_bolts",
		type = "ammo",
		stackable = true,
		bonusDmg = 4,
		value = 4,
		description = "Iron crossbow bolts.",
	},
	["Steel Bolts"] = {
		id = "steel_bolts",
		type = "ammo",
		stackable = true,
		bonusDmg = 6,
		value = 6,
		description = "Steel crossbow bolts. More penetration than iron.",
	},
	["Mithril Bolts"] = {
		id = "mithril_bolts",
		type = "ammo",
		stackable = true,
		bonusDmg = 9,
		value = 15,
		description = "Mithril crossbow bolts. Lightweight and accurate.",
	},
	["Gold Bolts"] = {
		id = "gold_bolts",
		type = "ammo",
		stackable = true,
		bonusDmg = 8,
		value = 10,
		description = "Gold crossbow bolts.",
	},
	["Runite Bolts"] = {
		id = "runite_bolts",
		type = "ammo",
		stackable = true,
		bonusDmg = 12,
		value = 30,
		description = "Runite crossbow bolts.",
	},
	["Bowstring"] = {
		id = "bowstring",
		type = "resource",
		stackable = true,
		value = 5,
		description = "Used for crafting bows.",
	},
	["Arrow Shafts"] = {
		id = "arrow_shafts",
		type = "resource",
		stackable = true,
		value = 1,
		description = "Used for crafting arrows.",
	},
	["Magic Bowstring"] = {
		id = "magic_bowstring",
		type = "resource",
		stackable = true,
		value = 500,
		rarity = "epic",
		description = "A bowstring pulsing with magical energy.",
	},

	-- === SHIELDS ===
	["Iron Shield"] = {
		id = "iron_shield",
		type = "armor",
		equipSlot = "Shield",
		defense = 10,
		combatReq = 15,
		stackable = false,
		value = 60,
		description = "A sturdy iron shield.",
	},
	["Gold Shield"] = {
		id = "gold_shield",
		type = "armor",
		equipSlot = "Shield",
		defense = 18,
		combatReq = 40,
		stackable = false,
		value = 250,
		description = "A gleaming gold shield.",
	},
	["Runite Shield"] = {
		id = "runite_shield",
		type = "armor",
		equipSlot = "Shield",
		defense = 30,
		combatReq = 70,
		stackable = false,
		value = 1500,
		description = "A nearly indestructible runite shield.",
	},
	["Dragon Shield"] = {
		id = "dragon_shield",
		type = "armor",
		equipSlot = "Shield",
		defense = 45,
		combatReq = 80,
		stackable = false,
		value = 7000,
		rarity = "legendary",
		description = "Forged from dragon scales.",
	},

	-- === MORE WEAPONS ===
	["Runite Sword"] = {
		id = "runite_sword",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 40,
		combatReq = 70,
		stackable = false,
		value = 2000,
		rarity = "epic",
		description = "A deadly runite blade.",
	},
	-- === PICKAXES ===
	["Bronze Pickaxe"] = {
		id = "bronze_pickaxe", type = "tool", equipSlot = "Tool", toolType = "pickaxe",
		levelReq = 1, skill = "Mining", gatherSpeed = 1.0, stackable = false, value = 10,
		description = "A basic bronze pickaxe.",
	},
	["Iron Pickaxe"] = {
		id = "iron_pickaxe", type = "tool", equipSlot = "Tool", toolType = "pickaxe",
		levelReq = 15, skill = "Mining", gatherSpeed = 0.8, stackable = false, value = 50,
		description = "A sturdy iron pickaxe.",
	},
	["Gold Pickaxe"] = {
		id = "gold_pickaxe", type = "tool", equipSlot = "Tool", toolType = "pickaxe",
		levelReq = 40, skill = "Mining", gatherSpeed = 0.6, stackable = false, value = 200,
		description = "A heavy gold pickaxe.",
	},
	["Runite Pickaxe"] = {
		id = "runite_pickaxe", type = "tool", equipSlot = "Tool", toolType = "pickaxe",
		levelReq = 70, skill = "Mining", gatherSpeed = 0.4, stackable = false, value = 1000,
		description = "The finest pickaxe money can buy.",
	},
	["Dragon Pickaxe"] = {
		id = "dragon_pickaxe", type = "tool", equipSlot = "Tool", toolType = "pickaxe",
		levelReq = 85, skill = "Mining", gatherSpeed = 0.3, stackable = false, value = 5000,
		rarity = "legendary", description = "Forged from dragonfire. Mines at incredible speed.",
	},

	-- === AXES (Woodcutting) ===
	["Bronze Axe"] = {
		id = "bronze_axe", type = "tool", equipSlot = "Tool", toolType = "axe",
		levelReq = 1, skill = "Woodcutting", gatherSpeed = 1.0, stackable = false, value = 10,
		description = "A basic bronze axe.",
	},
	["Iron Axe"] = {
		id = "iron_axe", type = "tool", equipSlot = "Tool", toolType = "axe",
		levelReq = 15, skill = "Woodcutting", gatherSpeed = 0.8, stackable = false, value = 50,
		description = "A sharp iron axe.",
	},
	["Gold Axe"] = {
		id = "gold_axe", type = "tool", equipSlot = "Tool", toolType = "axe",
		levelReq = 40, skill = "Woodcutting", gatherSpeed = 0.6, stackable = false, value = 200,
		description = "A gleaming gold axe.",
	},
	["Runite Axe"] = {
		id = "runite_axe", type = "tool", equipSlot = "Tool", toolType = "axe",
		levelReq = 70, skill = "Woodcutting", gatherSpeed = 0.4, stackable = false, value = 1000,
		description = "Cuts through anything.",
	},
	["Dragon Axe"] = {
		id = "dragon_axe", type = "tool", equipSlot = "Tool", toolType = "axe",
		levelReq = 85, skill = "Woodcutting", gatherSpeed = 0.3, stackable = false, value = 5000,
		rarity = "legendary", description = "The ultimate woodcutting tool.",
	},

	-- === FISHING RODS ===
	["Wooden Rod"] = {
		id = "wooden_rod", type = "tool", equipSlot = "Tool", toolType = "fishing_rod",
		levelReq = 1, skill = "Fishing", gatherSpeed = 1.0, stackable = false, value = 10,
		description = "A simple wooden fishing rod.",
	},
	["Iron Rod"] = {
		id = "iron_rod", type = "tool", equipSlot = "Tool", toolType = "fishing_rod",
		levelReq = 15, skill = "Fishing", gatherSpeed = 0.8, stackable = false, value = 50,
		description = "A rod with an iron reel.",
	},
	["Gold Rod"] = {
		id = "gold_rod", type = "tool", equipSlot = "Tool", toolType = "fishing_rod",
		levelReq = 40, skill = "Fishing", gatherSpeed = 0.6, stackable = false, value = 200,
		description = "A fine gold fishing rod.",
	},
	["Runite Rod"] = {
		id = "runite_rod", type = "tool", equipSlot = "Tool", toolType = "fishing_rod",
		levelReq = 70, skill = "Fishing", gatherSpeed = 0.4, stackable = false, value = 1000,
		description = "Fish practically leap onto this rod.",
	},
	["Dragon Rod"] = {
		id = "dragon_rod", type = "tool", equipSlot = "Tool", toolType = "fishing_rod",
		levelReq = 85, skill = "Fishing", gatherSpeed = 0.3, stackable = false, value = 5000,
		rarity = "legendary", description = "The fish don't stand a chance.",
	},

	-- === NEW BOSS DROP ITEMS ===
	-- King Rooster drops
	["Golden Feather"] = {
		id = "golden_feather",
		type = "material",
		rarity = "rare",
		stackable = true,
		value = 500,
		description = "A magnificent golden feather from the King Rooster.",
	},
	["King's Crest"] = {
		id = "kings_crest",
		type = "material",
		rarity = "uncommon",
		stackable = true,
		value = 750,
		description = "The royal crest of the chicken kingdom.",
	},

	-- Elder Treant drops
	["Heartwood"] = {
		id = "heartwood",
		type = "material",
		rarity = "rare",
		stackable = true,
		value = 1200,
		description = "The magical core wood of an ancient treant.",
	},
	["Ancient Bark"] = {
		id = "ancient_bark",
		type = "material",
		stackable = true,
		value = 200,
		description = "Bark from a millennia-old treant.",
	},
	["Elder Seed"] = {
		id = "elder_seed",
		type = "material",
		rarity = "epic",
		stackable = true,
		value = 3000,
		description = "A mystical seed that could grow into a great treant.",
	},

	-- Iron Golem drops
	["Golem Core"] = {
		id = "golem_core",
		type = "material",
		rarity = "epic",
		stackable = true,
		value = 5000,
		description = "The magical power source of an iron golem.",
	},
	["Golem Shield"] = {
		id = "golem_shield",
		type = "armor",
		equipSlot = "Shield",
		defBonus = 25,
		rarity = "rare",
		stackable = false,
		value = 2500,
		description = "A massive shield crafted from golem materials.",
	},

	-- Lake Serpent drops
	["Serpent Scale"] = {
		id = "serpent_scale",
		type = "material",
		rarity = "epic",
		stackable = true,
		value = 4000,
		description = "A shimmering scale from the legendary Lake Serpent.",
	},
	["Sea Fang"] = {
		id = "sea_fang",
		type = "weapon",
		damage = 35,
		rarity = "rare",
		stackable = false,
		value = 2000,
		description = "A sharp fang that can pierce through armor.",
	},
	["Serpent's Eye"] = {
		id = "serpents_eye",
		type = "material",
		rarity = "legendary",
		stackable = true,
		value = 10000,
		description = "The mystical eye of the Lake Serpent, pulsing with ancient magic.",
	},

	-- Corrupted Guardian drops
	["Guardian's Blessing"] = {
		id = "guardians_blessing",
		type = "material",
		rarity = "legendary",
		stackable = true,
		value = 15000,
		description = "A powerful blessing that purifies corruption and grants protection.",
	},
	["Corrupted Plate"] = {
		id = "corrupted_plate",
		type = "armor",
		equipSlot = "Body",
		defBonus = 40,
		rarity = "epic",
		stackable = false,
		value = 8000,
		description = "Heavy armor plate infused with dark magic.",
	},
	["Ancient Key"] = {
		id = "ancient_key",
		type = "material",
		rarity = "rare",
		stackable = true,
		value = 3000,
		description = "An ornate key that may unlock ancient mysteries.",
	},

	-- === CRIMSON WARLORD DROPS (Mid-Tier Boss) ===

	["Warlord's Greatsword"] = {
		id = "warlords_greatsword",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 55,
		weaponType = "sword",
		levelReq = 50,
		rarity = "epic",
		stackable = false,
		value = 12000,
		description = "A massive crimson-edged greatsword. The Warlord's signature weapon â€” its blade still burns with fury.",
	},
	["Crimson Platebody"] = {
		id = "crimson_platebody",
		type = "armor",
		equipSlot = "Body",
		defBonus = 35,
		levelReq = 50,
		rarity = "epic",
		stackable = false,
		value = 10000,
		description = "Blood-red armor forged in battle. Offers excellent protection with a menacing presence.",
	},
	["Crimson Platelegs"] = {
		id = "crimson_platelegs",
		type = "armor",
		equipSlot = "Legs",
		defBonus = 28,
		levelReq = 50,
		rarity = "epic",
		stackable = false,
		value = 8000,
		description = "Heavy crimson leg armor. The Warlord's greaves, still warm to the touch.",
	},
	["Warlord's Helm"] = {
		id = "warlords_helm",
		type = "armor",
		equipSlot = "Head",
		defBonus = 22,
		levelReq = 50,
		rarity = "epic",
		stackable = false,
		value = 9000,
		description = "A horned helm of dark iron, crowned with a burning ruby. Intimidation incarnate.",
	},
	["Crimson Cape"] = {
		id = "crimson_cape",
		type = "armor",
		equipSlot = "Cape",
		defBonus = 12,
		levelReq = 50,
		rarity = "legendary",
		stackable = false,
		value = 20000,
		description = "The Warlord's battle cape â€” torn, bloodstained, legendary. The rarest drop in the safe zone.",
	},
	["Warlord's Shield"] = {
		id = "warlords_shield",
		type = "armor",
		equipSlot = "Shield",
		defBonus = 30,
		levelReq = 50,
		rarity = "epic",
		stackable = false,
		value = 11000,
		description = "A heavy crimson shield bearing the Warlord's crest. Absorbs punishment like nothing else.",
	},
	["Blood Rune"] = {
		id = "blood_rune",
		type = "material",
		rarity = "rare",
		stackable = true,
		value = 500,
		description = "A rune infused with blood magic. Used in high-level crafting.",
	},

	-- === NEW AREA MONSTER DROPS (MapSetup5) ===
	
	-- Pirate Ghost drops
	["Ghost Doubloon"] = {
		id = "ghost_doubloon",
		type = "currency",
		rarity = "uncommon",
		stackable = true,
		value = 25,
		description = "A spectral coin from the world beyond.",
	},
	["Pirate Cutlass"] = {
		id = "pirate_cutlass",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 22,
		combatReq = 25,
		rarity = "uncommon",
		stackable = false,
		value = 150,
		description = "A curved blade favored by ghostly pirates.",
	},
	["Spectral Cloth"] = {
		id = "spectral_cloth",
		type = "material",
		rarity = "uncommon",
		stackable = true,
		value = 40,
		description = "Ethereal fabric that phases between worlds.",
	},
	
	-- Ice Elemental drops
	["Frozen Shard"] = {
		id = "frozen_shard",
		type = "material",
		rarity = "uncommon",
		stackable = true,
		value = 30,
		description = "A shard of pure ice that never melts.",
	},
	["Ice Crystal"] = {
		id = "ice_crystal",
		type = "material",
		rarity = "rare",
		stackable = true,
		value = 120,
		description = "A perfect crystal formed in the heart of winter.",
	},
	["Frost Essence"] = {
		id = "frost_essence",
		type = "material",
		rarity = "epic",
		stackable = true,
		value = 300,
		description = "The very essence of eternal winter.",
	},
	["Permafrost Ore"] = {
		id = "permafrost_ore",
		type = "resource",
		rarity = "uncommon",
		skill = "Mining",
		levelReq = 30,
		xp = 50,
		stackable = true,
		value = 45,
		description = "Ore that remains frozen even in fire.",
	},
	
	-- Lava Golem drops
	["Magma Core"] = {
		id = "magma_core",
		type = "material",
		rarity = "epic",
		stackable = true,
		value = 400,
		description = "The molten heart of a lava golem.",
	},
	["Obsidian Shard"] = {
		id = "obsidian_shard",
		type = "material",
		rarity = "uncommon",
		stackable = true,
		value = 35,
		description = "Sharp volcanic glass formed in extreme heat.",
	},
	["Volcanic Ash"] = {
		id = "volcanic_ash",
		type = "material",
		rarity = "common",
		stackable = true,
		value = 8,
		description = "Fine ash from volcanic eruptions.",
	},
	["Lava Blade"] = {
		id = "lava_blade",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 45,
		combatReq = 55,
		rarity = "epic",
		stackable = false,
		value = 800,
		description = "A blade forged in the heart of a volcano, glowing with internal fire.",
	},
	
	-- Fairy Dragon drops
	["Fairy Dust"] = {
		id = "fairy_dust",
		type = "material",
		rarity = "uncommon",
		stackable = true,
		value = 20,
		description = "Magical dust that sparkles with rainbow colors.",
	},
	["Dragon Scale"] = {
		id = "dragon_scale",
		type = "material",
		rarity = "rare",
		stackable = true,
		value = 150,
		description = "A scale from a mighty dragon, shimmering with magic.",
	},
	["Enchanted Petal"] = {
		id = "enchanted_petal",
		type = "material",
		rarity = "uncommon",
		stackable = true,
		value = 25,
		description = "A flower petal infused with fairy magic.",
	},
	["Rainbow Gem"] = {
		id = "rainbow_gem",
		type = "material",
		rarity = "epic",
		stackable = true,
		value = 500,
		description = "A rare gem that refracts light into beautiful rainbows.",
	},
	
	-- Ancient Guardian drops
	["Ancient Relic"] = {
		id = "ancient_relic",
		type = "material",
		rarity = "epic",
		stackable = true,
		value = 600,
		description = "A mysterious artifact from a lost civilization.",
	},
	["Guardian Essence"] = {
		id = "guardian_essence",
		type = "material",
		rarity = "rare",
		stackable = true,
		value = 250,
		description = "The protective spirit of an ancient guardian.",
	},
	["Rune of Power"] = {
		id = "rune_of_power",
		type = "material",
		rarity = "legendary",
		stackable = true,
		value = 1500,
		description = "A mystical rune that pulses with ancient power.",
	},
	["Ancient Armor"] = {
		id = "ancient_armor",
		type = "armor",
		equipSlot = "Body",
		combatReq = 70,
		rarity = "legendary",
		stackable = false,
		value = 2000,
		defense = 35,
		description = "Armor forged by masters of a forgotten age.",
	},
	
	-- Frost Wyrm drops
	["Wyrm Scale"] = {
		id = "wyrm_scale",
		type = "material",
		rarity = "rare",
		stackable = true,
		value = 180,
		description = "A crystalline scale from a frost wyrm.",
	},
	["Frozen Heart"] = {
		id = "frozen_heart",
		type = "material",
		rarity = "legendary",
		stackable = true,
		value = 1200,
		description = "The still-beating heart of a frost wyrm, forever frozen.",
	},
	["Ice Fang"] = {
		id = "ice_fang",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 38,
		combatReq = 60,
		rarity = "rare",
		stackable = false,
		value = 600,
		description = "A fang weapon that chills enemies to the bone.",
	},
	["Frost Armor"] = {
		id = "frost_armor",
		type = "armor",
		equipSlot = "Body",
		combatReq = 60,
		rarity = "rare",
		stackable = false,
		value = 800,
		defense = 28,
		description = "Armor that emanates a perpetual chill.",
	},

	-- === LICH KING MALACHAR DROPS ===
	["Lich Crown"] = {
		id = "lich_crown",
		type = "armor",
		equipSlot = "Head",
		combatReq = 85,
		rarity = "legendary",
		stackable = false,
		value = 12000,
		defense = 40,
		description = "A crown of bone and shadow, pulsing with necrotic power.",
	},
	["Soul Staff"] = {
		id = "soul_staff",
		type = "weapon",
		equipSlot = "Weapon",
		combatReq = 85,
		rarity = "legendary",
		stackable = false,
		value = 15000,
		damage = 55,
		attackSpeed = 1.0,
		description = "A staff that drains the very essence of life from its victims.",
	},
	["Dark Essence"] = {
		id = "dark_essence",
		type = "material",
		rarity = "epic",
		stackable = true,
		value = 2000,
		description = "Pure concentrated darkness, harvested from the Lich King's domain.",
	},
	["Necrotic Robe"] = {
		id = "necrotic_robe",
		type = "armor",
		equipSlot = "Body",
		combatReq = 80,
		rarity = "epic",
		stackable = false,
		value = 6000,
		defense = 32,
		description = "Robes woven from the fabric between life and death.",
	},
	["Bone Dust"] = {
		id = "bone_dust",
		type = "material",
		rarity = "uncommon",
		stackable = true,
		value = 15,
		description = "Fine powder ground from ancient bones. Used in dark rituals.",
	},

	-- === PRESTIGE CAPES ===
	["Prestige Cape I"] = {
		id = "prestige_cape_1",
		type = "armor",
		equipSlot = "Cape",
		defense = 5,
		rarity = "rare",
		value = 0,
		premium = false,
		tradeable = false,
		droppable = false,
		stackable = false,
		prestige = 1,
		description = "First prestige. The journey begins anew.",
	},
	["Prestige Cape II"] = {
		id = "prestige_cape_2",
		type = "armor",
		equipSlot = "Cape",
		defense = 10,
		rarity = "rare",
		value = 0,
		tradeable = false,
		droppable = false,
		stackable = false,
		prestige = 2,
		description = "Second prestige. Wisdom through repetition.",
	},
	["Prestige Cape III"] = {
		id = "prestige_cape_3",
		type = "armor",
		equipSlot = "Cape",
		defense = 15,
		rarity = "epic",
		value = 0,
		tradeable = false,
		droppable = false,
		stackable = false,
		prestige = 3,
		description = "Third prestige. Mastery takes shape.",
	},
	["Prestige Cape IV"] = {
		id = "prestige_cape_4",
		type = "armor",
		equipSlot = "Cape",
		defense = 20,
		rarity = "epic",
		value = 0,
		tradeable = false,
		droppable = false,
		stackable = false,
		prestige = 4,
		description = "Fourth prestige. Few reach this height.",
	},
	["Prestige Cape V"] = {
		id = "prestige_cape_5",
		type = "armor",
		equipSlot = "Cape",
		defense = 25,
		rarity = "epic",
		value = 0,
		tradeable = false,
		droppable = false,
		stackable = false,
		prestige = 5,
		description = "Fifth prestige. Halfway to legend.",
	},
	["Prestige Cape VI"] = {
		id = "prestige_cape_6",
		type = "armor",
		equipSlot = "Cape",
		defense = 30,
		rarity = "legendary",
		value = 0,
		tradeable = false,
		droppable = false,
		stackable = false,
		prestige = 6,
		description = "Sixth prestige. The grind is real.",
	},
	["Prestige Cape VII"] = {
		id = "prestige_cape_7",
		type = "armor",
		equipSlot = "Cape",
		defense = 35,
		rarity = "legendary",
		value = 0,
		tradeable = false,
		droppable = false,
		stackable = false,
		prestige = 7,
		description = "Seventh prestige. Feared and respected.",
	},
	["Prestige Cape VIII"] = {
		id = "prestige_cape_8",
		type = "armor",
		equipSlot = "Cape",
		defense = 40,
		rarity = "legendary",
		value = 0,
		tradeable = false,
		droppable = false,
		stackable = false,
		prestige = 8,
		description = "Eighth prestige. Ascension approaches.",
	},
	["Prestige Cape IX"] = {
		id = "prestige_cape_9",
		type = "armor",
		equipSlot = "Cape",
		defense = 45,
		rarity = "legendary",
		value = 0,
		tradeable = false,
		droppable = false,
		stackable = false,
		prestige = 9,
		description = "Ninth prestige. One step from godhood.",
	},
	["Prestige Cape X"] = {
		id = "prestige_cape_10",
		type = "armor",
		equipSlot = "Cape",
		defense = 50,
		rarity = "legendary",
		value = 0,
		tradeable = false,
		droppable = false,
		stackable = false,
		prestige = 10,
		description = "Tenth prestige. A living legend. The universe bows.",
	},

	-- === PREMIUM GEAR - TIER 30 "STARWEAVE" SET ===
	["Starweave Sword"] = {
		id = "starweave_sword",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 22,
		rarity = "rare",
		stackable = false,
		tradeable = false,
		droppable = false,
		value = 0,
		premium = true,
		robuxPrice = 50,
		description = "Forged from fallen starlight. Cuts through darkness.",
	},
	["Starweave Helm"] = {
		id = "starweave_helm",
		type = "armor",
		equipSlot = "Head",
		defense = 12,
		rarity = "rare",
		stackable = false,
		tradeable = false,
		droppable = false,
		value = 0,
		premium = true,
		robuxPrice = 50,
		description = "A celestial helmet forged from starweave metal, shimmering with silver and blue light.",
	},
	["Starweave Platebody"] = {
		id = "starweave_platebody",
		type = "armor",
		equipSlot = "Body",
		defense = 18,
		rarity = "rare",
		stackable = false,
		tradeable = false,
		droppable = false,
		value = 0,
		premium = true,
		robuxPrice = 50,
		description = "An elegant chestplate woven from stardust and moonbeams, providing divine protection.",
	},
	["Starweave Platelegs"] = {
		id = "starweave_platelegs",
		type = "armor",
		equipSlot = "Legs",
		defense = 15,
		rarity = "rare",
		stackable = false,
		tradeable = false,
		droppable = false,
		value = 0,
		premium = true,
		robuxPrice = 50,
		description = "Leg armor that gleams with celestial energy, lighter than silk yet stronger than steel.",
	},
	["Starweave Shield"] = {
		id = "starweave_shield",
		type = "armor",
		equipSlot = "Shield",
		defense = 14,
		rarity = "rare",
		stackable = false,
		tradeable = false,
		droppable = false,
		value = 0,
		premium = true,
		robuxPrice = 50,
		description = "A shield crafted from cosmic energies, capable of deflecting even the darkest magic.",
	},

	-- === PREMIUM GEAR - TIER 50 "EMBERFROST" SET ===
	["Emberfrost Blade"] = {
		id = "emberfrost_blade",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 35,
		rarity = "epic",
		stackable = false,
		tradeable = false,
		droppable = false,
		value = 0,
		premium = true,
		robuxPrice = 100,
		description = "A sword that burns with eternal flame yet remains cold to the touch. Fire and ice in perfect balance.",
	},
	["Emberfrost Crown"] = {
		id = "emberfrost_crown",
		type = "armor",
		equipSlot = "Head",
		defense = 20,
		rarity = "epic",
		stackable = false,
		tradeable = false,
		droppable = false,
		value = 0,
		premium = true,
		robuxPrice = 100,
		description = "A crown that channels the opposing forces of fire and frost, granting wisdom through duality.",
	},
	["Emberfrost Platebody"] = {
		id = "emberfrost_platebody",
		type = "armor",
		equipSlot = "Body",
		defense = 28,
		rarity = "epic",
		stackable = false,
		tradeable = false,
		droppable = false,
		value = 0,
		premium = true,
		robuxPrice = 100,
		description = "Armor that pulses with orange flames on one side and cyan frost on the other, creating perfect equilibrium.",
	},
	["Emberfrost Platelegs"] = {
		id = "emberfrost_platelegs",
		type = "armor",
		equipSlot = "Legs",
		defense = 24,
		rarity = "epic",
		stackable = false,
		tradeable = false,
		droppable = false,
		value = 0,
		premium = true,
		robuxPrice = 100,
		description = "Leg guards that embody the eternal struggle between heat and cold, forged in the heart of a frozen volcano.",
	},
	["Emberfrost Bulwark"] = {
		id = "emberfrost_bulwark",
		type = "armor",
		equipSlot = "Shield",
		defense = 22,
		rarity = "epic",
		stackable = false,
		tradeable = false,
		droppable = false,
		value = 0,
		premium = true,
		robuxPrice = 100,
		description = "A shield that can withstand any temperature, from the deepest freeze to the hottest inferno.",
	},

	-- === PREMIUM GEAR - TIER 65 "VOIDBORN" SET ===
	["Voidborn Greatsword"] = {
		id = "voidborn_greatsword",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 48,
		rarity = "legendary",
		stackable = false,
		tradeable = false,
		droppable = false,
		value = 0,
		premium = true,
		robuxPrice = 500,
		description = "Forged in the space between worlds, this blade cuts through reality itself. Gold veins pulse with otherworldly power.",
	},
	["Voidborn Visage"] = {
		id = "voidborn_visage",
		type = "armor",
		equipSlot = "Head",
		defense = 28,
		rarity = "legendary",
		stackable = false,
		tradeable = false,
		droppable = false,
		value = 0,
		premium = true,
		robuxPrice = 500,
		description = "A helm that peers into the void itself. Those who wear it can see truths that others cannot.",
	},
	["Voidborn Platebody"] = {
		id = "voidborn_platebody",
		type = "armor",
		equipSlot = "Body",
		defense = 38,
		rarity = "legendary",
		stackable = false,
		tradeable = false,
		droppable = false,
		value = 0,
		premium = true,
		robuxPrice = 500,
		description = "Armor woven from the fabric of the void, adorned with golden accents that bind the darkness within.",
	},
	["Voidborn Platelegs"] = {
		id = "voidborn_platelegs",
		type = "armor",
		equipSlot = "Legs",
		defense = 33,
		rarity = "legendary",
		stackable = false,
		tradeable = false,
		droppable = false,
		value = 0,
		premium = true,
		robuxPrice = 500,
		description = "Leg armor that draws power from the endless void, strengthened by threads of pure gold.",
	},
	["Voidborn Aegis"] = {
		id = "voidborn_aegis",
		type = "armor",
		equipSlot = "Shield",
		defense = 30,
		rarity = "legendary",
		stackable = false,
		tradeable = false,
		droppable = false,
		value = 0,
		premium = true,
		robuxPrice = 500,
		description = "A shield that exists partially in the void, making it nearly impossible to damage or destroy.",
	},
}

-- Auto-assign rarity based on value if not set
for name, item in pairs(ItemDatabase.Items) do
	if not item.rarity then
		local v = item.value or 0
		if v >= 1000 then
			item.rarity = "legendary"
		elseif v >= 200 then
			item.rarity = "epic"
		elseif v >= 50 then
			item.rarity = "rare"
		elseif v >= 10 then
			item.rarity = "uncommon"
		else
			item.rarity = "common"
		end
	end
end

-- Helper: get item by name
function ItemDatabase.GetItem(name)
	return ItemDatabase.Items[name]
end

-- Helper: get all items for a skill
function ItemDatabase.GetItemsBySkill(skill)
	local results = {}
	for name, item in pairs(ItemDatabase.Items) do
		if item.skill == skill then
			results[name] = item
		end
	end
	return results
end

-- Helper: get wilderness-only items
function ItemDatabase.GetWildernessItems()
	local results = {}
	for name, item in pairs(ItemDatabase.Items) do
		if item.wildernessOnly then
			results[name] = item
		end
	end
	return results
end

-- Helper: get all items matching a type (food, weapon, armor, resource, currency, crafted, etc.)
function ItemDatabase.GetItemsByType(itemType)
	local results = {}
	for name, item in pairs(ItemDatabase.Items) do
		if item.type == itemType then
			results[name] = item
		end
	end
	return results
end

return ItemDatabase
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="8">
        <Properties>
          <string name="Name">ItemVisuals</string>
          <string name="Source">-- ItemVisuals.lua (ModuleScript in ReplicatedStorage/Modules)
-- Unique visual representations for every item in the game

local ItemVisuals = {}

ItemVisuals.Items = {
	-- === ORES (Mining) ===
	["Copper Ore"] = { emoji = "ðŸª¨", color = Color3.fromRGB(184, 115, 51), shape = "ore", glowColor = nil },
	["Iron Ore"] = { emoji = "â›ï¸", color = Color3.fromRGB(169, 169, 169), shape = "ore", glowColor = nil },
	["Gold Ore"] = { emoji = "ðŸ’Ž", color = Color3.fromRGB(255, 215, 0), shape = "ore", glowColor = Color3.fromRGB(255, 255, 0) },
	["Runite Ore"] = { emoji = "ðŸ’ ", color = Color3.fromRGB(0, 139, 139), shape = "ore", glowColor = Color3.fromRGB(0, 255, 255) },

	-- === LOGS (Woodcutting) ===
	["Oak Log"] = { emoji = "ðŸªµ", color = Color3.fromRGB(139, 90, 43), shape = "log", glowColor = nil },
	["Willow Log"] = { emoji = "ðŸŒ¿", color = Color3.fromRGB(85, 107, 47), shape = "log", glowColor = nil },
	["Yew Log"] = { emoji = "ðŸŒ²", color = Color3.fromRGB(34, 139, 34), shape = "log", glowColor = nil },
	["Magic Log"] = { emoji = "âœ¨", color = Color3.fromRGB(138, 43, 226), shape = "log", glowColor = Color3.fromRGB(255, 0, 255) },

	-- === FISH (Fishing) ===
	["Shrimp"] = { emoji = "ðŸ¦", color = Color3.fromRGB(255, 160, 122), shape = "fish", glowColor = nil },
	["Trout"] = { emoji = "ðŸŸ", color = Color3.fromRGB(105, 105, 105), shape = "fish", glowColor = nil },
	["Lobster"] = { emoji = "ðŸ¦ž", color = Color3.fromRGB(220, 20, 60), shape = "fish", glowColor = nil },
	["Dark Crab"] = { emoji = "ðŸ¦€", color = Color3.fromRGB(75, 0, 130), shape = "fish", glowColor = Color3.fromRGB(138, 43, 226) },

	-- === BARS (Smithing) ===
	["Copper Bar"] = { emoji = "âš±ï¸", color = Color3.fromRGB(184, 115, 51), shape = "bar", glowColor = nil },
	["Iron Bar"] = { emoji = "ðŸ”©", color = Color3.fromRGB(169, 169, 169), shape = "bar", glowColor = nil },
	["Gold Bar"] = { emoji = "ðŸ¥‡", color = Color3.fromRGB(255, 215, 0), shape = "bar", glowColor = Color3.fromRGB(255, 255, 0) },

	-- === WEAPONS ===
	["Copper Sword"] = { emoji = "âš”ï¸", color = Color3.fromRGB(184, 115, 51), shape = "sword", glowColor = nil },
	["Iron Sword"] = { emoji = "âš”ï¸", color = Color3.fromRGB(180, 180, 190), shape = "sword", glowColor = nil },
	["Gold Sword"] = { emoji = "ðŸ—¡ï¸", color = Color3.fromRGB(255, 215, 0), shape = "sword", glowColor = Color3.fromRGB(255, 255, 0) },
	["Runite Sword"] = { emoji = "ðŸ—¡ï¸", color = Color3.fromRGB(0, 139, 139), shape = "sword", glowColor = Color3.fromRGB(0, 255, 255) },
	["Dragon Sword"] = { emoji = "âš”ï¸", color = Color3.fromRGB(255, 69, 0), shape = "sword", glowColor = Color3.fromRGB(255, 140, 0) },

	-- === COOKED FOOD ===
	["Cooked Shrimp"] = { emoji = "ðŸ¤", color = Color3.fromRGB(255, 182, 193), shape = "food", glowColor = nil },
	["Cooked Trout"] = { emoji = "ðŸŸ", color = Color3.fromRGB(160, 82, 45), shape = "food", glowColor = nil },
	["Cooked Lobster"] = { emoji = "ðŸ¦ž", color = Color3.fromRGB(255, 99, 71), shape = "food", glowColor = nil },
	["Cooked Dark Crab"] = { emoji = "ðŸ¦€", color = Color3.fromRGB(128, 0, 128), shape = "food", glowColor = Color3.fromRGB(255, 0, 255) },

	-- === RAW FOOD ===
	["Raw Chicken"] = { emoji = "ðŸ”", color = Color3.fromRGB(255, 182, 193), shape = "food", glowColor = nil },
	["Cooked Chicken"] = { emoji = "ðŸ—", color = Color3.fromRGB(210, 180, 140), shape = "food", glowColor = nil },
	["Raw Beef"] = { emoji = "ðŸ¥©", color = Color3.fromRGB(139, 69, 19), shape = "food", glowColor = nil },
	["Cooked Beef"] = { emoji = "ðŸ¥©", color = Color3.fromRGB(160, 82, 45), shape = "food", glowColor = nil },
	["Raw Rat Meat"] = { emoji = "ðŸ­", color = Color3.fromRGB(105, 105, 105), shape = "food", glowColor = nil },
	["Cooked Rat Meat"] = { emoji = "ðŸ–", color = Color3.fromRGB(139, 69, 19), shape = "food", glowColor = nil },

	-- === MONSTER DROPS ===
	["Feather"] = { emoji = "ðŸª¶", color = Color3.fromRGB(245, 245, 220), shape = "feather", glowColor = nil },
	["Cowhide"] = { emoji = "ðŸ„", color = Color3.fromRGB(160, 82, 45), shape = "misc", glowColor = nil },
	["Goblin Mail"] = { emoji = "ðŸ‘•", color = Color3.fromRGB(85, 107, 47), shape = "misc", glowColor = nil },
	["Bones"] = { emoji = "ðŸ’€", color = Color3.fromRGB(255, 248, 220), shape = "bone", glowColor = nil },
	["Dog Tag"] = { emoji = "ðŸ·ï¸", color = Color3.fromRGB(192, 192, 192), shape = "misc", glowColor = nil },
	["Rat Tail"] = { emoji = "ðŸ€", color = Color3.fromRGB(105, 105, 105), shape = "misc", glowColor = nil },
	["Wizard Robe"] = { emoji = "ðŸ§™", color = Color3.fromRGB(75, 0, 130), shape = "misc", glowColor = Color3.fromRGB(138, 43, 226) },
	["Demon Heart"] = { emoji = "ðŸ’œ", color = Color3.fromRGB(139, 0, 0), shape = "gem", glowColor = Color3.fromRGB(255, 0, 0) },
	["Dragon Scale"] = { emoji = "ðŸ²", color = Color3.fromRGB(255, 69, 0), shape = "misc", glowColor = Color3.fromRGB(255, 140, 0) },
	["Shadow Gem"] = { emoji = "ðŸ’Ž", color = Color3.fromRGB(75, 0, 130), shape = "gem", glowColor = Color3.fromRGB(138, 43, 226) },
	["Bronze Coins"] = { emoji = "ðŸª™", color = Color3.fromRGB(205, 127, 50), shape = "misc", glowColor = nil },

	-- === ARMOR ===
	["Bronze Helmet"] = { emoji = "â›‘ï¸", color = Color3.fromRGB(205, 127, 50), shape = "misc", glowColor = nil },
	["Iron Legs"] = { emoji = "ðŸ¦µ", color = Color3.fromRGB(169, 169, 169), shape = "misc", glowColor = nil },
	["Wooden Shield"] = { emoji = "ðŸ›¡ï¸", color = Color3.fromRGB(160, 82, 45), shape = "shield", glowColor = nil },
	["Iron Shield"] = { emoji = "ðŸ›¡ï¸", color = Color3.fromRGB(169, 169, 169), shape = "shield", glowColor = nil },
	["Gold Shield"] = { emoji = "ðŸ›¡ï¸", color = Color3.fromRGB(255, 215, 0), shape = "shield", glowColor = Color3.fromRGB(255, 255, 0) },
	["Runite Shield"] = { emoji = "ðŸ›¡ï¸", color = Color3.fromRGB(0, 139, 139), shape = "shield", glowColor = Color3.fromRGB(0, 255, 255) },
	["Dragon Shield"] = { emoji = "ðŸ›¡ï¸", color = Color3.fromRGB(255, 69, 0), shape = "shield", glowColor = Color3.fromRGB(255, 140, 0) },

	-- === RANGED WEAPONS ===
	["Oak Shortbow"] = { emoji = "ðŸ¹", color = Color3.fromRGB(139, 90, 43), shape = "bow", glowColor = nil },
	["Oak Longbow"] = { emoji = "ðŸ¹", color = Color3.fromRGB(139, 90, 43), shape = "bow", glowColor = nil },
	["Willow Shortbow"] = { emoji = "ðŸ¹", color = Color3.fromRGB(85, 107, 47), shape = "bow", glowColor = nil },
	["Iron Crossbow"] = { emoji = "ðŸ¹", color = Color3.fromRGB(169, 169, 169), shape = "bow", glowColor = nil },
	["Willow Longbow"] = { emoji = "ðŸ¹", color = Color3.fromRGB(85, 107, 47), shape = "bow", glowColor = nil },
	["Yew Shortbow"] = { emoji = "ðŸ¹", color = Color3.fromRGB(34, 139, 34), shape = "bow", glowColor = nil },
	["Gold Crossbow"] = { emoji = "ðŸ¹", color = Color3.fromRGB(255, 215, 0), shape = "bow", glowColor = Color3.fromRGB(255, 255, 0) },
	["Yew Longbow"] = { emoji = "ðŸ¹", color = Color3.fromRGB(34, 139, 34), shape = "bow", glowColor = nil },
	["Magic Shortbow"] = { emoji = "ðŸ¹", color = Color3.fromRGB(138, 43, 226), shape = "bow", glowColor = Color3.fromRGB(255, 0, 255) },
	["Dragon Crossbow"] = { emoji = "ðŸ¹", color = Color3.fromRGB(255, 69, 0), shape = "bow", glowColor = Color3.fromRGB(255, 140, 0) },

	-- === AMMUNITION ===
	["Bronze Arrows"] = { emoji = "âž¤", color = Color3.fromRGB(205, 127, 50), shape = "arrow", glowColor = nil },
	["Iron Arrows"] = { emoji = "âž¤", color = Color3.fromRGB(169, 169, 169), shape = "arrow", glowColor = nil },
	["Gold Arrows"] = { emoji = "âž¤", color = Color3.fromRGB(255, 215, 0), shape = "arrow", glowColor = Color3.fromRGB(255, 255, 0) },
	["Runite Arrows"] = { emoji = "âž¤", color = Color3.fromRGB(0, 139, 139), shape = "arrow", glowColor = Color3.fromRGB(0, 255, 255) },
	["Iron Bolts"] = { emoji = "â‡¨", color = Color3.fromRGB(169, 169, 169), shape = "arrow", glowColor = nil },
	["Gold Bolts"] = { emoji = "â‡¨", color = Color3.fromRGB(255, 215, 0), shape = "arrow", glowColor = Color3.fromRGB(255, 255, 0) },
	["Runite Bolts"] = { emoji = "â‡¨", color = Color3.fromRGB(0, 139, 139), shape = "arrow", glowColor = Color3.fromRGB(0, 255, 255) },
	["Bowstring"] = { emoji = "ðŸ§µ", color = Color3.fromRGB(245, 245, 220), shape = "misc", glowColor = nil },
	["Arrow Shafts"] = { emoji = "ðŸªµ", color = Color3.fromRGB(139, 90, 43), shape = "misc", glowColor = nil },
	["Magic Bowstring"] = { emoji = "âœ¨", color = Color3.fromRGB(138, 43, 226), shape = "misc", glowColor = Color3.fromRGB(255, 0, 255) },

	-- === TOOLS ===
	["Bronze Pickaxe"] = { emoji = "â›ï¸", color = Color3.fromRGB(205, 127, 50), shape = "misc", glowColor = nil },
	["Iron Pickaxe"] = { emoji = "â›ï¸", color = Color3.fromRGB(169, 169, 169), shape = "misc", glowColor = nil },
	["Gold Pickaxe"] = { emoji = "â›ï¸", color = Color3.fromRGB(255, 215, 0), shape = "misc", glowColor = Color3.fromRGB(255, 255, 0) },
	["Runite Pickaxe"] = { emoji = "â›ï¸", color = Color3.fromRGB(0, 139, 139), shape = "misc", glowColor = Color3.fromRGB(0, 255, 255) },
	["Dragon Pickaxe"] = { emoji = "â›ï¸", color = Color3.fromRGB(255, 69, 0), shape = "misc", glowColor = Color3.fromRGB(255, 140, 0) },
	["Bronze Axe"] = { emoji = "ðŸª“", color = Color3.fromRGB(205, 127, 50), shape = "misc", glowColor = nil },
	["Iron Axe"] = { emoji = "ðŸª“", color = Color3.fromRGB(169, 169, 169), shape = "misc", glowColor = nil },
	["Gold Axe"] = { emoji = "ðŸª“", color = Color3.fromRGB(255, 215, 0), shape = "misc", glowColor = Color3.fromRGB(255, 255, 0) },
	["Runite Axe"] = { emoji = "ðŸª“", color = Color3.fromRGB(0, 139, 139), shape = "misc", glowColor = Color3.fromRGB(0, 255, 255) },
	["Dragon Axe"] = { emoji = "ðŸª“", color = Color3.fromRGB(255, 69, 0), shape = "misc", glowColor = Color3.fromRGB(255, 140, 0) },
	["Wooden Rod"] = { emoji = "ðŸŽ£", color = Color3.fromRGB(139, 90, 43), shape = "misc", glowColor = nil },
	["Iron Rod"] = { emoji = "ðŸŽ£", color = Color3.fromRGB(169, 169, 169), shape = "misc", glowColor = nil },
	["Gold Rod"] = { emoji = "ðŸŽ£", color = Color3.fromRGB(255, 215, 0), shape = "misc", glowColor = Color3.fromRGB(255, 255, 0) },
	["Runite Rod"] = { emoji = "ðŸŽ£", color = Color3.fromRGB(0, 139, 139), shape = "misc", glowColor = Color3.fromRGB(0, 255, 255) },
	["Dragon Rod"] = { emoji = "ðŸŽ£", color = Color3.fromRGB(255, 69, 0), shape = "misc", glowColor = Color3.fromRGB(255, 140, 0) },

	-- === NEW BOSS DROP ITEMS ===
	["Golden Feather"] = { emoji = "ðŸª¶", color = Color3.fromRGB(255, 215, 0), shape = "feather", glowColor = Color3.fromRGB(255, 255, 0) },
	["King's Crest"] = { emoji = "ðŸ‘‘", color = Color3.fromRGB(255, 215, 0), shape = "gem", glowColor = Color3.fromRGB(255, 255, 0) },
	["Heartwood"] = { emoji = "ðŸ’š", color = Color3.fromRGB(34, 139, 34), shape = "misc", glowColor = Color3.fromRGB(0, 255, 0) },
	["Ancient Bark"] = { emoji = "ðŸŒ³", color = Color3.fromRGB(139, 90, 43), shape = "misc", glowColor = nil },
	["Elder Seed"] = { emoji = "ðŸŒ°", color = Color3.fromRGB(34, 139, 34), shape = "gem", glowColor = Color3.fromRGB(0, 255, 0) },
	["Golem Core"] = { emoji = "ðŸ’Ž", color = Color3.fromRGB(169, 169, 169), shape = "gem", glowColor = Color3.fromRGB(255, 255, 255) },
	["Golem Shield"] = { emoji = "ðŸ›¡ï¸", color = Color3.fromRGB(169, 169, 169), shape = "shield", glowColor = Color3.fromRGB(255, 255, 255) },
	["Serpent Scale"] = { emoji = "ðŸ", color = Color3.fromRGB(0, 128, 128), shape = "misc", glowColor = Color3.fromRGB(0, 255, 255) },
	["Sea Fang"] = { emoji = "ðŸ¦·", color = Color3.fromRGB(255, 248, 220), shape = "sword", glowColor = nil },
	["Serpent's Eye"] = { emoji = "ðŸ‘ï¸", color = Color3.fromRGB(0, 128, 128), shape = "gem", glowColor = Color3.fromRGB(0, 255, 255) },
	["Guardian's Blessing"] = { emoji = "âœ¨", color = Color3.fromRGB(255, 248, 220), shape = "gem", glowColor = Color3.fromRGB(255, 255, 255) },
	["Corrupted Plate"] = { emoji = "ðŸ›¡ï¸", color = Color3.fromRGB(75, 0, 130), shape = "shield", glowColor = Color3.fromRGB(138, 43, 226) },
	["Ancient Key"] = { emoji = "ðŸ—ï¸", color = Color3.fromRGB(255, 215, 0), shape = "misc", glowColor = Color3.fromRGB(255, 255, 0) },

	-- === PLATELEGS ===
	["Bronze Platelegs"] = { emoji = "ðŸ¦¿", color = Color3.fromRGB(176, 141, 87), shape = "shield", glowColor = nil },
	["Iron Platelegs"] = { emoji = "ðŸ¦¿", color = Color3.fromRGB(169, 169, 169), shape = "shield", glowColor = nil },
	["Gold Platelegs"] = { emoji = "ðŸ¦¿", color = Color3.fromRGB(255, 215, 0), shape = "shield", glowColor = Color3.fromRGB(255, 255, 0) },
	["Runite Platelegs"] = { emoji = "ðŸ¦¿", color = Color3.fromRGB(0, 139, 139), shape = "shield", glowColor = Color3.fromRGB(0, 255, 255) },
	["Dragon Platelegs"] = { emoji = "ðŸ¦¿", color = Color3.fromRGB(178, 34, 34), shape = "shield", glowColor = Color3.fromRGB(255, 0, 0) },

	-- === PLATEBODIES ===
	["Bronze Platebody"] = { emoji = "ðŸ›¡ï¸", color = Color3.fromRGB(176, 141, 87), shape = "shield", glowColor = nil },
	["Iron Platebody"] = { emoji = "ðŸ›¡ï¸", color = Color3.fromRGB(169, 169, 169), shape = "shield", glowColor = nil },
	["Gold Platebody"] = { emoji = "ðŸ›¡ï¸", color = Color3.fromRGB(255, 215, 0), shape = "shield", glowColor = Color3.fromRGB(255, 255, 0) },
	["Runite Platebody"] = { emoji = "ðŸ›¡ï¸", color = Color3.fromRGB(0, 139, 139), shape = "shield", glowColor = Color3.fromRGB(0, 255, 255) },
	["Dragon Platebody"] = { emoji = "ðŸ›¡ï¸", color = Color3.fromRGB(178, 34, 34), shape = "shield", glowColor = Color3.fromRGB(255, 0, 0) },

	-- === CHAINMAIL ===
	["Iron Chainbody"] = { emoji = "â›“ï¸", color = Color3.fromRGB(169, 169, 169), shape = "shield", glowColor = nil },
	["Gold Chainbody"] = { emoji = "â›“ï¸", color = Color3.fromRGB(255, 215, 0), shape = "shield", glowColor = nil },
	["Runite Chainbody"] = { emoji = "â›“ï¸", color = Color3.fromRGB(0, 139, 139), shape = "shield", glowColor = nil },

	-- === LEATHER/RANGER ARMOR ===
	["Leather Body"] = { emoji = "ðŸ‘•", color = Color3.fromRGB(139, 90, 43), shape = "shield", glowColor = nil },
	["Leather Chaps"] = { emoji = "ðŸ‘–", color = Color3.fromRGB(139, 90, 43), shape = "shield", glowColor = nil },
	["Studded Body"] = { emoji = "ðŸ‘•", color = Color3.fromRGB(101, 67, 33), shape = "shield", glowColor = nil },
	["Studded Chaps"] = { emoji = "ðŸ‘–", color = Color3.fromRGB(101, 67, 33), shape = "shield", glowColor = nil },
	["Dragonhide Body"] = { emoji = "ðŸ‘•", color = Color3.fromRGB(0, 100, 0), shape = "shield", glowColor = Color3.fromRGB(0, 255, 0) },
	["Dragonhide Chaps"] = { emoji = "ðŸ‘–", color = Color3.fromRGB(0, 100, 0), shape = "shield", glowColor = Color3.fromRGB(0, 255, 0) },

	-- === NEW AREA MONSTER DROPS (MapSetup5) ===
	
	-- Pirate Ghost drops
	["Ghost Doubloon"] = { emoji = "ðŸ‘»", color = Color3.fromRGB(200, 220, 255), shape = "misc", glowColor = Color3.fromRGB(100, 200, 255) },
	["Pirate Cutlass"] = { emoji = "âš”ï¸", color = Color3.fromRGB(192, 192, 192), shape = "sword", glowColor = Color3.fromRGB(100, 200, 255) },
	["Spectral Cloth"] = { emoji = "ðŸ•¸ï¸", color = Color3.fromRGB(240, 248, 255), shape = "misc", glowColor = Color3.fromRGB(200, 220, 255) },
	
	-- Ice Elemental drops
	["Frozen Shard"] = { emoji = "â„ï¸", color = Color3.fromRGB(173, 216, 230), shape = "gem", glowColor = Color3.fromRGB(0, 255, 255) },
	["Ice Crystal"] = { emoji = "ðŸ’Ž", color = Color3.fromRGB(173, 216, 230), shape = "gem", glowColor = Color3.fromRGB(100, 200, 255) },
	["Frost Essence"] = { emoji = "ðŸ§Š", color = Color3.fromRGB(240, 248, 255), shape = "gem", glowColor = Color3.fromRGB(200, 230, 255) },
	["Permafrost Ore"] = { emoji = "ðŸ§Š", color = Color3.fromRGB(173, 216, 230), shape = "ore", glowColor = Color3.fromRGB(0, 255, 255) },
	
	-- Lava Golem drops
	["Magma Core"] = { emoji = "ðŸŒ‹", color = Color3.fromRGB(255, 69, 0), shape = "gem", glowColor = Color3.fromRGB(255, 140, 0) },
	["Obsidian Shard"] = { emoji = "ðŸ–¤", color = Color3.fromRGB(20, 20, 20), shape = "gem", glowColor = nil },
	["Volcanic Ash"] = { emoji = "ðŸŒ‹", color = Color3.fromRGB(64, 64, 64), shape = "misc", glowColor = nil },
	["Lava Blade"] = { emoji = "ðŸ”¥", color = Color3.fromRGB(255, 69, 0), shape = "sword", glowColor = Color3.fromRGB(255, 140, 0) },
	
	-- Fairy Dragon drops
	["Fairy Dust"] = { emoji = "âœ¨", color = Color3.fromRGB(255, 192, 203), shape = "misc", glowColor = Color3.fromRGB(255, 20, 147) },
	["Dragon Scale"] = { emoji = "ðŸ²", color = Color3.fromRGB(255, 69, 0), shape = "misc", glowColor = Color3.fromRGB(255, 140, 0) },
	["Enchanted Petal"] = { emoji = "ðŸŒ¸", color = Color3.fromRGB(255, 182, 193), shape = "misc", glowColor = Color3.fromRGB(255, 20, 147) },
	["Rainbow Gem"] = { emoji = "ðŸŒˆ", color = Color3.fromRGB(255, 255, 255), shape = "gem", glowColor = Color3.fromRGB(255, 0, 255) },
	
	-- Ancient Guardian drops
	["Ancient Relic"] = { emoji = "ðŸº", color = Color3.fromRGB(139, 134, 130), shape = "misc", glowColor = Color3.fromRGB(0, 255, 0) },
	["Guardian Essence"] = { emoji = "ðŸ’š", color = Color3.fromRGB(0, 255, 0), shape = "gem", glowColor = Color3.fromRGB(50, 255, 50) },
	["Rune of Power"] = { emoji = "ðŸ”®", color = Color3.fromRGB(138, 43, 226), shape = "gem", glowColor = Color3.fromRGB(180, 50, 255) },
	["Ancient Armor"] = { emoji = "ðŸ›¡ï¸", color = Color3.fromRGB(139, 134, 130), shape = "shield", glowColor = Color3.fromRGB(0, 255, 0) },
	
	-- Frost Wyrm drops
	["Wyrm Scale"] = { emoji = "ðŸ", color = Color3.fromRGB(173, 216, 230), shape = "misc", glowColor = Color3.fromRGB(100, 200, 255) },
	["Frozen Heart"] = { emoji = "ðŸ’™", color = Color3.fromRGB(173, 216, 230), shape = "gem", glowColor = Color3.fromRGB(0, 255, 255) },
	["Ice Fang"] = { emoji = "ðŸ§Š", color = Color3.fromRGB(240, 248, 255), shape = "sword", glowColor = Color3.fromRGB(100, 200, 255) },
	["Frost Armor"] = { emoji = "ðŸ§Š", color = Color3.fromRGB(173, 216, 230), shape = "shield", glowColor = Color3.fromRGB(0, 255, 255) },

	-- === LICH KING MALACHAR DROPS ===
	["Lich Crown"] = { emoji = "ðŸ‘‘", color = Color3.fromRGB(200, 195, 175), shape = "default", glowColor = Color3.fromRGB(0, 255, 80) },
	["Soul Staff"] = { emoji = "ðŸ”®", color = Color3.fromRGB(40, 20, 15), shape = "sword", glowColor = Color3.fromRGB(0, 255, 80) },
	["Dark Essence"] = { emoji = "ðŸ’€", color = Color3.fromRGB(20, 20, 30), shape = "gem", glowColor = Color3.fromRGB(0, 200, 60) },
	["Necrotic Robe"] = { emoji = "ðŸ§¥", color = Color3.fromRGB(15, 10, 25), shape = "default", glowColor = Color3.fromRGB(0, 180, 50) },
	["Bone Dust"] = { emoji = "ðŸ’¨", color = Color3.fromRGB(220, 215, 200), shape = "default", glowColor = nil },

	-- === PRESTIGE CAPES ===
	["Prestige Cape I"] = { emoji = "ðŸŽ–ï¸", color = Color3.fromRGB(192, 192, 192), shape = "misc", glowColor = nil },
	["Prestige Cape II"] = { emoji = "ðŸŽ–ï¸", color = Color3.fromRGB(200, 200, 220), shape = "misc", glowColor = Color3.fromRGB(180, 180, 255) },
	["Prestige Cape III"] = { emoji = "ðŸ…", color = Color3.fromRGB(0, 120, 215), shape = "misc", glowColor = Color3.fromRGB(0, 180, 255) },
	["Prestige Cape IV"] = { emoji = "ðŸ…", color = Color3.fromRGB(0, 180, 0), shape = "misc", glowColor = Color3.fromRGB(0, 255, 100) },
	["Prestige Cape V"] = { emoji = "â­", color = Color3.fromRGB(255, 215, 0), shape = "misc", glowColor = Color3.fromRGB(255, 255, 0) },
	["Prestige Cape VI"] = { emoji = "â­", color = Color3.fromRGB(255, 100, 0), shape = "misc", glowColor = Color3.fromRGB(255, 160, 0) },
	["Prestige Cape VII"] = { emoji = "ðŸ’Ž", color = Color3.fromRGB(220, 20, 60), shape = "misc", glowColor = Color3.fromRGB(255, 50, 50) },
	["Prestige Cape VIII"] = { emoji = "ðŸ’Ž", color = Color3.fromRGB(138, 43, 226), shape = "misc", glowColor = Color3.fromRGB(200, 100, 255) },
	["Prestige Cape IX"] = { emoji = "ðŸ‘‘", color = Color3.fromRGB(20, 20, 20), shape = "misc", glowColor = Color3.fromRGB(255, 0, 0) },
	["Prestige Cape X"] = { emoji = "ðŸ‘‘", color = Color3.fromRGB(25, 0, 50), shape = "misc", glowColor = Color3.fromRGB(255, 215, 0) },

	-- === PREMIUM GEAR VISUALS - STARWEAVE SET ===
	["Starweave Sword"] = { emoji = "âš”ï¸", color = Color3.fromRGB(192, 210, 235), shape = "sword", glowColor = Color3.fromRGB(100, 180, 255) },
	["Starweave Helm"] = { emoji = "â›‘ï¸", color = Color3.fromRGB(192, 210, 235), shape = "misc", glowColor = Color3.fromRGB(100, 180, 255) },
	["Starweave Platebody"] = { emoji = "ðŸ›¡ï¸", color = Color3.fromRGB(192, 210, 235), shape = "misc", glowColor = Color3.fromRGB(100, 180, 255) },
	["Starweave Platelegs"] = { emoji = "ðŸ¦¿", color = Color3.fromRGB(192, 210, 235), shape = "misc", glowColor = Color3.fromRGB(100, 180, 255) },
	["Starweave Shield"] = { emoji = "ðŸ›¡ï¸", color = Color3.fromRGB(192, 210, 235), shape = "shield", glowColor = Color3.fromRGB(100, 180, 255) },

	-- === PREMIUM GEAR VISUALS - EMBERFROST SET ===
	["Emberfrost Blade"] = { emoji = "âš”ï¸", color = Color3.fromRGB(255, 140, 50), shape = "sword", glowColor = Color3.fromRGB(0, 255, 255) },
	["Emberfrost Crown"] = { emoji = "ðŸ‘‘", color = Color3.fromRGB(255, 140, 50), shape = "misc", glowColor = Color3.fromRGB(0, 255, 255) },
	["Emberfrost Platebody"] = { emoji = "ðŸ›¡ï¸", color = Color3.fromRGB(255, 140, 50), shape = "misc", glowColor = Color3.fromRGB(0, 255, 255) },
	["Emberfrost Platelegs"] = { emoji = "ðŸ¦¿", color = Color3.fromRGB(255, 140, 50), shape = "misc", glowColor = Color3.fromRGB(0, 255, 255) },
	["Emberfrost Bulwark"] = { emoji = "ðŸ›¡ï¸", color = Color3.fromRGB(255, 140, 50), shape = "shield", glowColor = Color3.fromRGB(0, 255, 255) },

	-- === PREMIUM GEAR VISUALS - VOIDBORN SET ===
	["Voidborn Greatsword"] = { emoji = "âš”ï¸", color = Color3.fromRGB(80, 0, 160), shape = "sword", glowColor = Color3.fromRGB(255, 215, 0) },
	["Voidborn Visage"] = { emoji = "ðŸ‘¹", color = Color3.fromRGB(80, 0, 160), shape = "misc", glowColor = Color3.fromRGB(255, 215, 0) },
	["Voidborn Platebody"] = { emoji = "ðŸ›¡ï¸", color = Color3.fromRGB(80, 0, 160), shape = "misc", glowColor = Color3.fromRGB(255, 215, 0) },
	["Voidborn Platelegs"] = { emoji = "ðŸ¦¿", color = Color3.fromRGB(80, 0, 160), shape = "misc", glowColor = Color3.fromRGB(255, 215, 0) },
	["Voidborn Aegis"] = { emoji = "ðŸ›¡ï¸", color = Color3.fromRGB(80, 0, 160), shape = "shield", glowColor = Color3.fromRGB(255, 215, 0) },
}

-- Helper function to get item visuals by name
function ItemVisuals.GetVisual(itemName)
	return ItemVisuals.Items[itemName] or {
		emoji = "â“",
		color = Color3.fromRGB(128, 128, 128),
		shape = "misc",
		glowColor = nil
	}
end

-- Helper function to get item color
function ItemVisuals.GetColor(itemName)
	local visual = ItemVisuals.GetVisual(itemName)
	return visual.color
end

-- Helper function to get item emoji
function ItemVisuals.GetEmoji(itemName)
	local visual = ItemVisuals.GetVisual(itemName)
	return visual.emoji
end

-- Helper function to get item shape for 3D drops
function ItemVisuals.GetShape(itemName)
	local visual = ItemVisuals.GetVisual(itemName)
	return visual.shape
end

-- Helper function to get glow color (if any)
function ItemVisuals.GetGlowColor(itemName)
	local visual = ItemVisuals.GetVisual(itemName)
	return visual.glowColor
end

return ItemVisuals</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="9">
        <Properties>
          <string name="Name">MonsterDatabase</string>
          <string name="Source"><![CDATA[--[[
	MonsterDatabase.lua
	ModuleScript - ReplicatedStorage/Modules/MonsterDatabase

	Central registry of all monster definitions, drop tables, and visual configs.
	Drop items use DISPLAY NAMES (matching ItemDatabase keys).
]]

local MonsterDatabase = {}

MonsterDatabase.Monsters = {

	----------------------------------------------------------------------------
	-- SAFE ZONE
	----------------------------------------------------------------------------

	Chicken = {
		name        = "Chicken",
		hp          = 50,
		damage      = 3,
		level       = 1,
		xp          = 5,
		respawnTime = 15,
		zone        = "Safe",
		passive     = true,
		drops = {
			{ item = "Feather",      chance = 1.00, minQty = 1, maxQty = 2 },
			{ item = "Raw Chicken",  chance = 0.80, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(255, 250, 240),
			size = Vector3.new(1.5, 1.2, 2),
			headSize = 0.6,
			extras = {
				-- Original parts
				{ name = "Comb", shape = "Block", size = Vector3.new(0.3, 0.5, 0.6), offset = Vector3.new(0, 0.5, 0.3), color = Color3.fromRGB(220, 30, 30) },
				{ name = "Beak", shape = "Block", size = Vector3.new(0.3, 0.2, 0.5), offset = Vector3.new(0, 0, 0.6), color = Color3.fromRGB(255, 180, 50) },
				{ name = "LegL", shape = "Block", size = Vector3.new(0.2, 1, 0.2), offset = Vector3.new(-0.4, -1.1, 0), color = Color3.fromRGB(255, 180, 50), bodyRelative = true },
				{ name = "LegR", shape = "Block", size = Vector3.new(0.2, 1, 0.2), offset = Vector3.new(0.4, -1.1, 0), color = Color3.fromRGB(255, 180, 50), bodyRelative = true },
				{ name = "Tail", shape = "Block", size = Vector3.new(0.3, 1, 0.8), offset = Vector3.new(0, 0.3, -1.2), color = Color3.fromRGB(255, 250, 240), bodyRelative = true },
				-- Eyes
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.12, 0.12, 0.12), offset = Vector3.new(-0.18, 0.12, 0.32), color = Color3.fromRGB(20, 20, 20) },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.12, 0.12, 0.12), offset = Vector3.new(0.18, 0.12, 0.32), color = Color3.fromRGB(20, 20, 20) },
				-- Wattle under beak
				{ name = "Wattle", shape = "Block", size = Vector3.new(0.15, 0.3, 0.15), offset = Vector3.new(0, -0.25, 0.55), color = Color3.fromRGB(220, 30, 30) },
				-- Wing left
				{ name = "WingL", shape = "Block", size = Vector3.new(0.15, 0.7, 1.2), offset = Vector3.new(-0.85, 0.1, -0.1), color = Color3.fromRGB(245, 238, 220), bodyRelative = true },
				-- Wing right
				{ name = "WingR", shape = "Block", size = Vector3.new(0.15, 0.7, 1.2), offset = Vector3.new(0.85, 0.1, -0.1), color = Color3.fromRGB(245, 238, 220), bodyRelative = true },
				-- Wing tips (darker feathers)
				{ name = "WingTipL", shape = "Block", size = Vector3.new(0.1, 0.4, 0.6), offset = Vector3.new(-0.95, -0.15, -0.6), color = Color3.fromRGB(200, 190, 170), bodyRelative = true },
				{ name = "WingTipR", shape = "Block", size = Vector3.new(0.1, 0.4, 0.6), offset = Vector3.new(0.95, -0.15, -0.6), color = Color3.fromRGB(200, 190, 170), bodyRelative = true },
				-- Tail feather fan
				{ name = "TailFan1", shape = "Block", size = Vector3.new(0.5, 0.8, 0.1), offset = Vector3.new(0, 0.5, -1.4), color = Color3.fromRGB(240, 235, 215), bodyRelative = true },
				{ name = "TailFan2", shape = "Block", size = Vector3.new(0.4, 0.6, 0.1), offset = Vector3.new(-0.2, 0.6, -1.3), color = Color3.fromRGB(230, 225, 205), bodyRelative = true },
				-- Feet detail
				{ name = "FootL", shape = "Block", size = Vector3.new(0.4, 0.08, 0.5), offset = Vector3.new(-0.4, -1.65, 0.1), color = Color3.fromRGB(255, 180, 50), bodyRelative = true },
				{ name = "FootR", shape = "Block", size = Vector3.new(0.4, 0.08, 0.5), offset = Vector3.new(0.4, -1.65, 0.1), color = Color3.fromRGB(255, 180, 50), bodyRelative = true },
				-- Breast feather puff
				{ name = "Breast", shape = "Ball", size = Vector3.new(1.2, 0.8, 0.8), offset = Vector3.new(0, -0.2, 0.5), color = Color3.fromRGB(255, 252, 245), bodyRelative = true },
			},
		},
	},

	Cow = {
		name        = "Cow",
		hp          = 150,
		damage      = 9,
		level       = 3,
		xp          = 15,
		respawnTime = 20,
		zone        = "Safe",
		passive     = true,
		drops = {
			{ item = "Cowhide",  chance = 1.00, minQty = 1, maxQty = 1 },
			{ item = "Raw Beef", chance = 0.70, minQty = 1, maxQty = 1 },
			{ item = "Bones",    chance = 0.50, minQty = 1, maxQty = 1 },
			{ item = "Bowstring", chance = 0.10, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(255, 245, 235), -- base creamy white
			size = Vector3.new(3.5, 2.2, 4.8), -- proper rectangular body
			headSize = 1.0,
			extras = {
				-- PROPER COW HEAD with snout
				{ name = "Snout", shape = "Block", size = Vector3.new(0.8, 0.6, 1.0), offset = Vector3.new(0, -0.15, 0.75), color = Color3.fromRGB(255, 240, 225) },
				-- Nostrils on snout
				{ name = "NostrilL", shape = "Ball", size = Vector3.new(0.12, 0.1, 0.08), offset = Vector3.new(-0.15, -0.2, 1.2), color = Color3.fromRGB(40, 30, 25) },
				{ name = "NostrilR", shape = "Ball", size = Vector3.new(0.12, 0.1, 0.08), offset = Vector3.new(0.15, -0.2, 1.2), color = Color3.fromRGB(40, 30, 25) },
				-- Large cow eyes
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.28, 0.28, 0.28), offset = Vector3.new(-0.35, 0.2, 0.4), color = Color3.fromRGB(20, 15, 10) },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.28, 0.28, 0.28), offset = Vector3.new(0.35, 0.2, 0.4), color = Color3.fromRGB(20, 15, 10) },
				-- Curved horns
				{ name = "HornL", shape = "Block", size = Vector3.new(0.18, 0.9, 0.18), offset = Vector3.new(-0.4, 0.9, 0.1), color = Color3.fromRGB(210, 200, 180), rotation = Vector3.new(0, 0, -15) },
				{ name = "HornR", shape = "Block", size = Vector3.new(0.18, 0.9, 0.18), offset = Vector3.new(0.4, 0.9, 0.1), color = Color3.fromRGB(210, 200, 180), rotation = Vector3.new(0, 0, 15) },
				-- Large hanging ears
				{ name = "EarL", shape = "Block", size = Vector3.new(0.6, 0.8, 0.12), offset = Vector3.new(-0.7, 0.1, 0.2), color = Color3.fromRGB(255, 235, 215) },
				{ name = "EarR", shape = "Block", size = Vector3.new(0.6, 0.8, 0.12), offset = Vector3.new(0.7, 0.1, 0.2), color = Color3.fromRGB(255, 235, 215) },
				-- PROPER 4 LEGS with better proportions
				{ name = "LegFL", shape = "Block", size = Vector3.new(0.6, 2.4, 0.6), offset = Vector3.new(-1.2, -2.3, 1.6), color = Color3.fromRGB(255, 245, 235), bodyRelative = true },
				{ name = "LegFR", shape = "Block", size = Vector3.new(0.6, 2.4, 0.6), offset = Vector3.new(1.2, -2.3, 1.6), color = Color3.fromRGB(255, 245, 235), bodyRelative = true },
				{ name = "LegBL", shape = "Block", size = Vector3.new(0.6, 2.4, 0.6), offset = Vector3.new(-1.2, -2.3, -1.6), color = Color3.fromRGB(255, 245, 235), bodyRelative = true },
				{ name = "LegBR", shape = "Block", size = Vector3.new(0.6, 2.4, 0.6), offset = Vector3.new(1.2, -2.3, -1.6), color = Color3.fromRGB(255, 245, 235), bodyRelative = true },
				-- Black hooves
				{ name = "HoofFL", shape = "Block", size = Vector3.new(0.65, 0.25, 0.65), offset = Vector3.new(-1.2, -3.6, 1.6), color = Color3.fromRGB(35, 25, 20), bodyRelative = true },
				{ name = "HoofFR", shape = "Block", size = Vector3.new(0.65, 0.25, 0.65), offset = Vector3.new(1.2, -3.6, 1.6), color = Color3.fromRGB(35, 25, 20), bodyRelative = true },
				{ name = "HoofBL", shape = "Block", size = Vector3.new(0.65, 0.25, 0.65), offset = Vector3.new(-1.2, -3.6, -1.6), color = Color3.fromRGB(35, 25, 20), bodyRelative = true },
				{ name = "HoofBR", shape = "Block", size = Vector3.new(0.65, 0.25, 0.65), offset = Vector3.new(1.2, -3.6, -1.6), color = Color3.fromRGB(35, 25, 20), bodyRelative = true },
				-- DISTINCT BLACK SPOTS pattern
				{ name = "SpotMajor1", shape = "Block", size = Vector3.new(1.8, 1.2, 1.5), offset = Vector3.new(-0.5, 0.4, 0.8), color = Color3.fromRGB(30, 20, 15), bodyRelative = true },
				{ name = "SpotMajor2", shape = "Block", size = Vector3.new(1.4, 1.0, 1.2), offset = Vector3.new(1.0, 0.2, -0.8), color = Color3.fromRGB(25, 15, 10), bodyRelative = true },
				{ name = "SpotMajor3", shape = "Block", size = Vector3.new(1.2, 0.8, 1.0), offset = Vector3.new(-0.8, -0.3, -1.5), color = Color3.fromRGB(35, 25, 20), bodyRelative = true },
				-- Medium spots
				{ name = "SpotMed1", shape = "Ball", size = Vector3.new(0.8, 0.8, 0.8), offset = Vector3.new(1.3, 0.6, 1.2), color = Color3.fromRGB(40, 30, 25), bodyRelative = true },
				{ name = "SpotMed2", shape = "Ball", size = Vector3.new(0.6, 0.6, 0.6), offset = Vector3.new(-1.4, 0.8, 0.2), color = Color3.fromRGB(30, 20, 15), bodyRelative = true },
				{ name = "SpotMed3", shape = "Ball", size = Vector3.new(0.7, 0.7, 0.7), offset = Vector3.new(0.4, -0.6, 1.8), color = Color3.fromRGB(35, 25, 20), bodyRelative = true },
				-- Small spots for variety
				{ name = "SpotSmall1", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(-1.6, 0.2, 1.0), color = Color3.fromRGB(25, 15, 10), bodyRelative = true },
				{ name = "SpotSmall2", shape = "Ball", size = Vector3.new(0.35, 0.35, 0.35), offset = Vector3.new(1.5, 0.9, -1.2), color = Color3.fromRGB(30, 20, 15), bodyRelative = true },
				{ name = "SpotSmall3", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(0.8, -0.4, -0.3), color = Color3.fromRGB(40, 30, 25), bodyRelative = true },
				-- UDDER (female variant)
				{ name = "Udder", shape = "Ball", size = Vector3.new(1.2, 0.8, 1.0), offset = Vector3.new(0, -1.6, -0.5), color = Color3.fromRGB(255, 210, 190), bodyRelative = true },
				{ name = "Teat1", shape = "Ball", size = Vector3.new(0.15, 0.25, 0.15), offset = Vector3.new(-0.3, -2.1, -0.3), color = Color3.fromRGB(240, 190, 170), bodyRelative = true },
				{ name = "Teat2", shape = "Ball", size = Vector3.new(0.15, 0.25, 0.15), offset = Vector3.new(0.3, -2.1, -0.3), color = Color3.fromRGB(240, 190, 170), bodyRelative = true },
				{ name = "Teat3", shape = "Ball", size = Vector3.new(0.15, 0.25, 0.15), offset = Vector3.new(-0.3, -2.1, -0.8), color = Color3.fromRGB(240, 190, 170), bodyRelative = true },
				{ name = "Teat4", shape = "Ball", size = Vector3.new(0.15, 0.25, 0.15), offset = Vector3.new(0.3, -2.1, -0.8), color = Color3.fromRGB(240, 190, 170), bodyRelative = true },
				-- TAIL with proper tuft
				{ name = "TailBase", shape = "Block", size = Vector3.new(0.25, 0.8, 0.25), offset = Vector3.new(0, 0.3, -2.6), color = Color3.fromRGB(255, 245, 235), bodyRelative = true },
				{ name = "TailMid", shape = "Block", size = Vector3.new(0.2, 0.6, 0.2), offset = Vector3.new(0, 0.1, -3.2), color = Color3.fromRGB(250, 240, 230), bodyRelative = true },
				{ name = "TailTuft", shape = "Ball", size = Vector3.new(0.6, 0.8, 0.6), offset = Vector3.new(0, 0, -3.8), color = Color3.fromRGB(30, 20, 15), bodyRelative = true },
				-- Cow bell with strap
				{ name = "BellStrap", shape = "Block", size = Vector3.new(1.6, 0.18, 0.18), offset = Vector3.new(0, -0.4, 0.3), color = Color3.fromRGB(120, 70, 30) },
				{ name = "Bell", shape = "Ball", size = Vector3.new(0.4, 0.5, 0.4), offset = Vector3.new(0, -0.7, 0.3), color = Color3.fromRGB(200, 160, 40), material = Enum.Material.Metal },
				-- Mouth line
				{ name = "Mouth", shape = "Block", size = Vector3.new(0.4, 0.08, 0.1), offset = Vector3.new(0, -0.35, 1.15), color = Color3.fromRGB(60, 50, 45) },
			},
		},
	},

	Goblin = {
		name        = "Goblin",
		hp          = 250,
		damage      = 15,
		level       = 5,
		xp          = 25,
		respawnTime = 25,
		zone        = "Safe",
		passive     = false,
		drops = {
			{ item = "Goblin Mail",   chance = 0.30, minQty = 1, maxQty = 1  },
			{ item = "Bronze Coins",  chance = 1.00, minQty = 5, maxQty = 15 },
			{ item = "Copper Sword",  chance = 0.10, minQty = 1, maxQty = 1 },
			{ item = "Bones",         chance = 0.80, minQty = 1, maxQty = 1 },
			{ item = "Bronze Arrows", chance = 0.30, minQty = 5, maxQty = 15 },
			{ item = "Oak Shortbow",  chance = 0.05, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(80, 160, 60),
			size = Vector3.new(1.8, 2.5, 1.2),
			headSize = 1.0,
			extras = {
				-- Original parts
				{ name = "EarL", shape = "Block", size = Vector3.new(0.8, 0.3, 0.2), offset = Vector3.new(-0.8, 0.2, 0), color = Color3.fromRGB(80, 160, 60) },
				{ name = "EarR", shape = "Block", size = Vector3.new(0.8, 0.3, 0.2), offset = Vector3.new(0.8, 0.2, 0), color = Color3.fromRGB(80, 160, 60) },
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(-0.25, 0.15, 0.5), color = Color3.fromRGB(255, 50, 50), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(0.25, 0.15, 0.5), color = Color3.fromRGB(255, 50, 50), material = Enum.Material.Neon },
				{ name = "Armor", shape = "Block", size = Vector3.new(2, 1.2, 1.4), offset = Vector3.new(0, 0.2, 0), color = Color3.fromRGB(100, 80, 40), bodyRelative = true, material = Enum.Material.Slate },
				{ name = "LegL", shape = "Block", size = Vector3.new(0.5, 1.5, 0.5), offset = Vector3.new(-0.4, -2, 0), color = Color3.fromRGB(80, 160, 60), bodyRelative = true },
				{ name = "LegR", shape = "Block", size = Vector3.new(0.5, 1.5, 0.5), offset = Vector3.new(0.4, -2, 0), color = Color3.fromRGB(80, 160, 60), bodyRelative = true },
				{ name = "Club", shape = "Block", size = Vector3.new(0.3, 2, 0.3), offset = Vector3.new(1.2, -0.5, 0), color = Color3.fromRGB(120, 90, 50), bodyRelative = true, material = Enum.Material.Wood },
				-- Pointed nose
				{ name = "Nose", shape = "Block", size = Vector3.new(0.2, 0.2, 0.5), offset = Vector3.new(0, -0.05, 0.65), color = Color3.fromRGB(70, 145, 50) },
				-- Pupils (small dark centers)
				{ name = "PupilL", shape = "Ball", size = Vector3.new(0.12, 0.12, 0.12), offset = Vector3.new(-0.25, 0.15, 0.63), color = Color3.fromRGB(30, 10, 10) },
				{ name = "PupilR", shape = "Ball", size = Vector3.new(0.12, 0.12, 0.12), offset = Vector3.new(0.25, 0.15, 0.63), color = Color3.fromRGB(30, 10, 10) },
				-- War paint stripes on face
				{ name = "PaintL", shape = "Block", size = Vector3.new(0.08, 0.4, 0.1), offset = Vector3.new(-0.35, -0.05, 0.48), color = Color3.fromRGB(180, 30, 30) },
				{ name = "PaintR", shape = "Block", size = Vector3.new(0.08, 0.4, 0.1), offset = Vector3.new(0.35, -0.05, 0.48), color = Color3.fromRGB(180, 30, 30) },
				{ name = "PaintC", shape = "Block", size = Vector3.new(0.06, 0.3, 0.1), offset = Vector3.new(0, 0.35, 0.48), color = Color3.fromRGB(180, 30, 30) },
				-- Loincloth
				{ name = "Loincloth", shape = "Block", size = Vector3.new(1.2, 1.0, 0.15), offset = Vector3.new(0, -1.5, -0.55), color = Color3.fromRGB(80, 60, 30), bodyRelative = true },
				{ name = "LoinclothF", shape = "Block", size = Vector3.new(1.0, 0.8, 0.15), offset = Vector3.new(0, -1.5, 0.55), color = Color3.fromRGB(80, 60, 30), bodyRelative = true },
				-- Crude shield in left hand
				{ name = "Shield", shape = "Block", size = Vector3.new(0.15, 1.2, 1.0), offset = Vector3.new(-1.3, -0.3, 0), color = Color3.fromRGB(90, 70, 35), bodyRelative = true, material = Enum.Material.Wood },
				{ name = "ShieldBoss", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(-1.4, -0.3, 0), color = Color3.fromRGB(130, 110, 70), bodyRelative = true },
				-- Club knob
				{ name = "ClubKnob", shape = "Ball", size = Vector3.new(0.5, 0.5, 0.5), offset = Vector3.new(1.2, -1.7, 0), color = Color3.fromRGB(100, 75, 40), bodyRelative = true, material = Enum.Material.Wood },
				-- Belt
				{ name = "Belt", shape = "Block", size = Vector3.new(2.1, 0.25, 1.3), offset = Vector3.new(0, -0.8, 0), color = Color3.fromRGB(70, 50, 25), bodyRelative = true },
				-- Teeth (two fangs)
				{ name = "FangL", shape = "Block", size = Vector3.new(0.08, 0.15, 0.08), offset = Vector3.new(-0.12, -0.28, 0.48), color = Color3.fromRGB(230, 220, 190) },
				{ name = "FangR", shape = "Block", size = Vector3.new(0.08, 0.15, 0.08), offset = Vector3.new(0.12, -0.28, 0.48), color = Color3.fromRGB(230, 220, 190) },
			},
		},
	},

	GuardDog = {
		name        = "Guard Dog",
		hp          = 200,
		damage      = 21,
		level       = 4,
		xp          = 20,
		respawnTime = 20,
		zone        = "Safe",
		passive     = false,
		drops = {
			{ item = "Bones",   chance = 1.00, minQty = 1, maxQty = 1 },
			{ item = "Dog Tag", chance = 0.10, minQty = 1, maxQty = 1 },
			{ item = "Raw Beef", chance = 0.30, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(139, 90, 43),
			size = Vector3.new(1.8, 1.8, 3.2),
			headSize = 0.9,
			extras = {
				-- Original parts
				{ name = "Snout", shape = "Block", size = Vector3.new(0.55, 0.45, 0.7), offset = Vector3.new(0, -0.15, 0.7), color = Color3.fromRGB(120, 75, 35) },
				{ name = "EarL", shape = "Block", size = Vector3.new(0.5, 0.6, 0.2), offset = Vector3.new(-0.5, 0.5, -0.1), color = Color3.fromRGB(100, 65, 30) },
				{ name = "EarR", shape = "Block", size = Vector3.new(0.5, 0.6, 0.2), offset = Vector3.new(0.5, 0.5, -0.1), color = Color3.fromRGB(100, 65, 30) },
				{ name = "LegFL", shape = "Block", size = Vector3.new(0.45, 1.6, 0.45), offset = Vector3.new(-0.6, -1.7, 1.1), color = Color3.fromRGB(139, 90, 43), bodyRelative = true },
				{ name = "LegFR", shape = "Block", size = Vector3.new(0.45, 1.6, 0.45), offset = Vector3.new(0.6, -1.7, 1.1), color = Color3.fromRGB(139, 90, 43), bodyRelative = true },
				{ name = "LegBL", shape = "Block", size = Vector3.new(0.45, 1.6, 0.45), offset = Vector3.new(-0.6, -1.7, -1.1), color = Color3.fromRGB(139, 90, 43), bodyRelative = true },
				{ name = "LegBR", shape = "Block", size = Vector3.new(0.45, 1.6, 0.45), offset = Vector3.new(0.6, -1.7, -1.1), color = Color3.fromRGB(139, 90, 43), bodyRelative = true },
				{ name = "Tail", shape = "Block", size = Vector3.new(0.2, 0.2, 1.5), offset = Vector3.new(0, 0.5, -2.2), color = Color3.fromRGB(139, 90, 43), bodyRelative = true },
				-- Eyes (fierce)
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.2, 0.2, 0.2), offset = Vector3.new(-0.25, 0.15, 0.4), color = Color3.fromRGB(200, 160, 30) },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.2, 0.2, 0.2), offset = Vector3.new(0.25, 0.15, 0.4), color = Color3.fromRGB(200, 160, 30) },
				{ name = "PupilL", shape = "Ball", size = Vector3.new(0.1, 0.1, 0.1), offset = Vector3.new(-0.25, 0.15, 0.48), color = Color3.fromRGB(10, 10, 10) },
				{ name = "PupilR", shape = "Ball", size = Vector3.new(0.1, 0.1, 0.1), offset = Vector3.new(0.25, 0.15, 0.48), color = Color3.fromRGB(10, 10, 10) },
				-- Nose
				{ name = "Nose", shape = "Ball", size = Vector3.new(0.2, 0.15, 0.15), offset = Vector3.new(0, -0.05, 1.05), color = Color3.fromRGB(30, 20, 15) },
				-- Teeth showing
				{ name = "ToothL", shape = "Block", size = Vector3.new(0.06, 0.12, 0.06), offset = Vector3.new(-0.12, -0.3, 0.9), color = Color3.fromRGB(240, 235, 220) },
				{ name = "ToothR", shape = "Block", size = Vector3.new(0.06, 0.12, 0.06), offset = Vector3.new(0.12, -0.3, 0.9), color = Color3.fromRGB(240, 235, 220) },
				{ name = "ToothMidL", shape = "Block", size = Vector3.new(0.05, 0.08, 0.05), offset = Vector3.new(-0.2, -0.28, 0.85), color = Color3.fromRGB(240, 235, 220) },
				{ name = "ToothMidR", shape = "Block", size = Vector3.new(0.05, 0.08, 0.05), offset = Vector3.new(0.2, -0.28, 0.85), color = Color3.fromRGB(240, 235, 220) },
				-- Collar
				{ name = "Collar", shape = "Block", size = Vector3.new(1.9, 0.25, 0.25), offset = Vector3.new(0, -0.05, 1.3), color = Color3.fromRGB(180, 30, 30), bodyRelative = true },
				{ name = "CollarTag", shape = "Ball", size = Vector3.new(0.2, 0.25, 0.1), offset = Vector3.new(0, -0.22, 1.4), color = Color3.fromRGB(210, 180, 50), bodyRelative = true, material = Enum.Material.Metal },
				-- Muscular chest
				{ name = "Chest", shape = "Ball", size = Vector3.new(1.6, 1.4, 1.0), offset = Vector3.new(0, 0.1, 0.8), color = Color3.fromRGB(150, 100, 50), bodyRelative = true },
				-- Dark muzzle markings
				{ name = "MuzzleTop", shape = "Block", size = Vector3.new(0.45, 0.1, 0.5), offset = Vector3.new(0, 0.05, 0.85), color = Color3.fromRGB(80, 50, 25) },
				-- Paws
				{ name = "PawFL", shape = "Block", size = Vector3.new(0.5, 0.15, 0.55), offset = Vector3.new(-0.6, -2.55, 1.1), color = Color3.fromRGB(110, 70, 35), bodyRelative = true },
				{ name = "PawFR", shape = "Block", size = Vector3.new(0.5, 0.15, 0.55), offset = Vector3.new(0.6, -2.55, 1.1), color = Color3.fromRGB(110, 70, 35), bodyRelative = true },
				{ name = "PawBL", shape = "Block", size = Vector3.new(0.5, 0.15, 0.55), offset = Vector3.new(-0.6, -2.55, -1.1), color = Color3.fromRGB(110, 70, 35), bodyRelative = true },
				{ name = "PawBR", shape = "Block", size = Vector3.new(0.5, 0.15, 0.55), offset = Vector3.new(0.6, -2.55, -1.1), color = Color3.fromRGB(110, 70, 35), bodyRelative = true },
			},
		},
	},

	GiantRat = {
		name        = "Giant Rat",
		hp          = 125,
		damage      = 12,
		level       = 2,
		xp          = 12,
		respawnTime = 15,
		zone        = "Safe",
		passive     = true,
		drops = {
			{ item = "Rat Tail",      chance = 0.50, minQty = 1, maxQty = 1 },
			{ item = "Raw Rat Meat",  chance = 0.80, minQty = 1, maxQty = 1 },
			{ item = "Bones",         chance = 0.30, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(100, 80, 60),
			size = Vector3.new(1.2, 1, 2.5),
			headSize = 0.6,
			extras = {
				-- Original parts
				{ name = "Nose", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(0, -0.1, 0.5), color = Color3.fromRGB(200, 100, 100) },
				{ name = "EarL", shape = "Ball", size = Vector3.new(0.5, 0.5, 0.12), offset = Vector3.new(-0.3, 0.45, 0), color = Color3.fromRGB(200, 150, 150) },
				{ name = "EarR", shape = "Ball", size = Vector3.new(0.5, 0.5, 0.12), offset = Vector3.new(0.3, 0.45, 0), color = Color3.fromRGB(200, 150, 150) },
				{ name = "Tail", shape = "Block", size = Vector3.new(0.15, 0.15, 3), offset = Vector3.new(0, 0, -2.8), color = Color3.fromRGB(180, 140, 120), bodyRelative = true },
				{ name = "LegFL", shape = "Block", size = Vector3.new(0.3, 0.8, 0.3), offset = Vector3.new(-0.4, -0.9, 0.8), color = Color3.fromRGB(100, 80, 60), bodyRelative = true },
				{ name = "LegFR", shape = "Block", size = Vector3.new(0.3, 0.8, 0.3), offset = Vector3.new(0.4, -0.9, 0.8), color = Color3.fromRGB(100, 80, 60), bodyRelative = true },
				{ name = "LegBL", shape = "Block", size = Vector3.new(0.3, 0.8, 0.3), offset = Vector3.new(-0.4, -0.9, -0.8), color = Color3.fromRGB(100, 80, 60), bodyRelative = true },
				{ name = "LegBR", shape = "Block", size = Vector3.new(0.3, 0.8, 0.3), offset = Vector3.new(0.4, -0.9, -0.8), color = Color3.fromRGB(100, 80, 60), bodyRelative = true },
				-- Eyes (beady)
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.15, 0.15, 0.15), offset = Vector3.new(-0.18, 0.1, 0.3), color = Color3.fromRGB(200, 30, 30) },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.15, 0.15, 0.15), offset = Vector3.new(0.18, 0.1, 0.3), color = Color3.fromRGB(200, 30, 30) },
				-- Whiskers
				{ name = "WhiskerL1", shape = "Block", size = Vector3.new(0.6, 0.03, 0.03), offset = Vector3.new(-0.35, -0.05, 0.45), color = Color3.fromRGB(160, 130, 110) },
				{ name = "WhiskerL2", shape = "Block", size = Vector3.new(0.55, 0.03, 0.03), offset = Vector3.new(-0.33, -0.1, 0.45), color = Color3.fromRGB(160, 130, 110) },
				{ name = "WhiskerR1", shape = "Block", size = Vector3.new(0.6, 0.03, 0.03), offset = Vector3.new(0.35, -0.05, 0.45), color = Color3.fromRGB(160, 130, 110) },
				{ name = "WhiskerR2", shape = "Block", size = Vector3.new(0.55, 0.03, 0.03), offset = Vector3.new(0.33, -0.1, 0.45), color = Color3.fromRGB(160, 130, 110) },
				-- Matted fur texture patches (Fabric material)
				{ name = "FurPatch1", shape = "Block", size = Vector3.new(0.8, 0.5, 1.2), offset = Vector3.new(0.2, 0.3, 0.3), color = Color3.fromRGB(85, 65, 45), bodyRelative = true, material = Enum.Material.Fabric },
				{ name = "FurPatch2", shape = "Block", size = Vector3.new(0.6, 0.4, 0.9), offset = Vector3.new(-0.3, 0.25, -0.6), color = Color3.fromRGB(90, 70, 50), bodyRelative = true, material = Enum.Material.Fabric },
				{ name = "FurPatch3", shape = "Block", size = Vector3.new(0.5, 0.3, 0.7), offset = Vector3.new(0.1, 0.35, -1.0), color = Color3.fromRGB(80, 60, 40), bodyRelative = true, material = Enum.Material.Fabric },
				-- Ear inner pink
				{ name = "EarInnerL", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.05), offset = Vector3.new(-0.3, 0.45, -0.04), color = Color3.fromRGB(220, 170, 170) },
				{ name = "EarInnerR", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.05), offset = Vector3.new(0.3, 0.45, -0.04), color = Color3.fromRGB(220, 170, 170) },
				-- Teeth
				{ name = "ToothL", shape = "Block", size = Vector3.new(0.05, 0.1, 0.05), offset = Vector3.new(-0.06, -0.22, 0.45), color = Color3.fromRGB(230, 220, 200) },
				{ name = "ToothR", shape = "Block", size = Vector3.new(0.05, 0.1, 0.05), offset = Vector3.new(0.06, -0.22, 0.45), color = Color3.fromRGB(230, 220, 200) },
				-- Claws on front feet
				{ name = "ClawFL", shape = "Block", size = Vector3.new(0.15, 0.05, 0.15), offset = Vector3.new(-0.4, -1.35, 0.95), color = Color3.fromRGB(60, 45, 30), bodyRelative = true },
				{ name = "ClawFR", shape = "Block", size = Vector3.new(0.15, 0.05, 0.15), offset = Vector3.new(0.4, -1.35, 0.95), color = Color3.fromRGB(60, 45, 30), bodyRelative = true },
			},
		},
	},

	TrainingDummy = {
		name        = "Training Dummy",
		hp          = 999999,
		damage      = 0,
		level       = 0,
		xp          = 2,
		respawnTime = 5,
		zone        = "Safe",
		passive     = true,
		stationary  = true,
		immortal    = true,
		drops       = {},
		model = {
			bodyColor = Color3.fromRGB(180, 140, 80),
			size = Vector3.new(2, 4, 1),
			headSize = 1.0,
			extras = {
				-- Original parts
				{ name = "Arms", shape = "Block", size = Vector3.new(5, 0.5, 0.5), offset = Vector3.new(0, 0.5, 0), color = Color3.fromRGB(180, 140, 80), bodyRelative = true, material = Enum.Material.Wood },
				{ name = "Target", shape = "Block", size = Vector3.new(1.5, 1.5, 0.3), offset = Vector3.new(0, 0.5, 0.5), color = Color3.fromRGB(200, 50, 50), bodyRelative = true },
				{ name = "Post", shape = "Block", size = Vector3.new(0.5, 2, 0.5), offset = Vector3.new(0, -3, 0), color = Color3.fromRGB(120, 90, 50), bodyRelative = true, material = Enum.Material.Wood },
				-- Eyes (painted on - flat circles)
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.2, 0.2, 0.1), offset = Vector3.new(-0.25, 0.1, 0.48), color = Color3.fromRGB(30, 30, 30) },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.2, 0.2, 0.1), offset = Vector3.new(0.25, 0.1, 0.48), color = Color3.fromRGB(30, 30, 30) },
				-- X mouth (painted)
				{ name = "MouthX1", shape = "Block", size = Vector3.new(0.3, 0.05, 0.05), offset = Vector3.new(0, -0.15, 0.5), color = Color3.fromRGB(30, 30, 30), rotation = Vector3.new(0, 0, 30) },
				{ name = "MouthX2", shape = "Block", size = Vector3.new(0.3, 0.05, 0.05), offset = Vector3.new(0, -0.15, 0.5), color = Color3.fromRGB(30, 30, 30), rotation = Vector3.new(0, 0, -30) },
				-- Target ring
				{ name = "TargetRing", shape = "Block", size = Vector3.new(0.8, 0.8, 0.32), offset = Vector3.new(0, 0.5, 0.5), color = Color3.fromRGB(240, 240, 220), bodyRelative = true },
				{ name = "TargetBull", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.15), offset = Vector3.new(0, 0.5, 0.52), color = Color3.fromRGB(200, 50, 50), bodyRelative = true },
				-- Straw stuffing poking out
				{ name = "StrawTop", shape = "Block", size = Vector3.new(0.4, 0.6, 0.3), offset = Vector3.new(0.3, 2.1, 0.1), color = Color3.fromRGB(220, 200, 100), bodyRelative = true },
				{ name = "StrawL", shape = "Block", size = Vector3.new(0.3, 0.5, 0.2), offset = Vector3.new(-1.1, 0.7, 0.2), color = Color3.fromRGB(220, 200, 100), bodyRelative = true },
				{ name = "StrawR", shape = "Block", size = Vector3.new(0.3, 0.5, 0.2), offset = Vector3.new(1.1, 0.7, 0.2), color = Color3.fromRGB(220, 200, 100), bodyRelative = true },
				{ name = "StrawMid", shape = "Block", size = Vector3.new(0.2, 0.4, 0.3), offset = Vector3.new(-0.2, -0.5, 0.4), color = Color3.fromRGB(210, 190, 90), bodyRelative = true },
				-- Rope bindings
				{ name = "RopeTop", shape = "Block", size = Vector3.new(2.2, 0.15, 1.15), offset = Vector3.new(0, 1.3, 0), color = Color3.fromRGB(160, 130, 80), bodyRelative = true },
				{ name = "RopeMid", shape = "Block", size = Vector3.new(2.2, 0.15, 1.15), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(160, 130, 80), bodyRelative = true },
				{ name = "RopeBot", shape = "Block", size = Vector3.new(2.2, 0.15, 1.15), offset = Vector3.new(0, -1.2, 0), color = Color3.fromRGB(160, 130, 80), bodyRelative = true },
				-- Wear marks (darker scratches)
				{ name = "Scratch1", shape = "Block", size = Vector3.new(0.08, 1.2, 0.05), offset = Vector3.new(0.4, 0, 0.52), color = Color3.fromRGB(100, 70, 35), bodyRelative = true },
				{ name = "Scratch2", shape = "Block", size = Vector3.new(0.08, 0.8, 0.05), offset = Vector3.new(-0.3, 0.3, 0.52), color = Color3.fromRGB(100, 70, 35), bodyRelative = true },
				{ name = "Scratch3", shape = "Block", size = Vector3.new(0.06, 0.6, 0.05), offset = Vector3.new(0.1, -0.5, 0.52), color = Color3.fromRGB(110, 75, 40), bodyRelative = true },
				-- Wooden body texture
				{ name = "WoodGrain1", shape = "Block", size = Vector3.new(0.04, 3.5, 0.05), offset = Vector3.new(-0.5, 0, -0.52), color = Color3.fromRGB(160, 120, 65), bodyRelative = true },
				{ name = "WoodGrain2", shape = "Block", size = Vector3.new(0.04, 3.5, 0.05), offset = Vector3.new(0.5, 0, -0.52), color = Color3.fromRGB(160, 120, 65), bodyRelative = true },
				-- Post base
				{ name = "PostBase", shape = "Block", size = Vector3.new(1.5, 0.3, 1.5), offset = Vector3.new(0, -4.1, 0), color = Color3.fromRGB(100, 75, 40), bodyRelative = true, material = Enum.Material.Wood },
			},
		},
	},

	----------------------------------------------------------------------------
	-- WILDERNESS
	----------------------------------------------------------------------------

	Skeleton = {
		name        = "Skeleton",
		hp          = 400,
		damage      = 36,
		level       = 20,
		xp          = 50,
		respawnTime = 40,
		zone        = "Wilderness",
		passive     = false,
		drops = {
			{ item = "Bones",      chance = 1.00, minQty = 1, maxQty = 2 },
			{ item = "Iron Sword", chance = 0.08, minQty = 1, maxQty = 1 },
			{ item = "Iron Ore",   chance = 0.30, minQty = 1, maxQty = 3 },
			{ item = "Copper Sword", chance = 0.15, minQty = 1, maxQty = 1 },
			{ item = "Iron Arrows",  chance = 0.25, minQty = 10, maxQty = 20 },
			{ item = "Iron Crossbow", chance = 0.05, minQty = 1, maxQty = 1 },
			{ item = "Iron Shield",  chance = 0.08, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(230, 225, 210),
			size = Vector3.new(1.5, 4, 1),
			headSize = 1.0,
			extras = {
				-- Original parts
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.25, 0.25, 0.25), offset = Vector3.new(-0.25, 0.1, 0.45), color = Color3.fromRGB(255, 50, 50), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.25, 0.25, 0.25), offset = Vector3.new(0.25, 0.1, 0.45), color = Color3.fromRGB(255, 50, 50), material = Enum.Material.Neon },
				{ name = "Rib1", shape = "Block", size = Vector3.new(2, 0.15, 0.8), offset = Vector3.new(0, 0.8, 0), color = Color3.fromRGB(220, 215, 200), bodyRelative = true },
				{ name = "Rib2", shape = "Block", size = Vector3.new(2, 0.15, 0.8), offset = Vector3.new(0, 0.4, 0), color = Color3.fromRGB(220, 215, 200), bodyRelative = true },
				{ name = "Rib3", shape = "Block", size = Vector3.new(2, 0.15, 0.8), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(220, 215, 200), bodyRelative = true },
				{ name = "ArmL", shape = "Block", size = Vector3.new(0.3, 3, 0.3), offset = Vector3.new(-1.1, -0.5, 0), color = Color3.fromRGB(230, 225, 210), bodyRelative = true },
				{ name = "ArmR", shape = "Block", size = Vector3.new(0.3, 3, 0.3), offset = Vector3.new(1.1, -0.5, 0), color = Color3.fromRGB(230, 225, 210), bodyRelative = true },
				{ name = "Sword", shape = "Block", size = Vector3.new(0.2, 3, 0.5), offset = Vector3.new(1.5, -1.5, 0), color = Color3.fromRGB(180, 180, 180), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "LegL", shape = "Block", size = Vector3.new(0.4, 2.5, 0.4), offset = Vector3.new(-0.4, -3.2, 0), color = Color3.fromRGB(230, 225, 210), bodyRelative = true },
				{ name = "LegR", shape = "Block", size = Vector3.new(0.4, 2.5, 0.4), offset = Vector3.new(0.4, -3.2, 0), color = Color3.fromRGB(230, 225, 210), bodyRelative = true },
				-- Jaw (separate mandible)
				{ name = "Jaw", shape = "Block", size = Vector3.new(0.7, 0.2, 0.6), offset = Vector3.new(0, -0.35, 0.1), color = Color3.fromRGB(220, 215, 200) },
				-- Teeth
				{ name = "TeethUpper", shape = "Block", size = Vector3.new(0.5, 0.1, 0.08), offset = Vector3.new(0, -0.18, 0.5), color = Color3.fromRGB(210, 205, 190) },
				{ name = "TeethLower", shape = "Block", size = Vector3.new(0.5, 0.1, 0.08), offset = Vector3.new(0, -0.3, 0.5), color = Color3.fromRGB(210, 205, 190) },
				-- Nose cavity
				{ name = "NoseCavity", shape = "Block", size = Vector3.new(0.15, 0.15, 0.1), offset = Vector3.new(0, -0.05, 0.48), color = Color3.fromRGB(50, 40, 35) },
				-- Shield in left hand
				{ name = "Shield", shape = "Block", size = Vector3.new(0.15, 1.8, 1.4), offset = Vector3.new(-1.5, -0.8, 0), color = Color3.fromRGB(100, 90, 80), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "ShieldBoss", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(-1.6, -0.8, 0), color = Color3.fromRGB(140, 130, 110), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "ShieldRim", shape = "Block", size = Vector3.new(0.18, 1.9, 0.15), offset = Vector3.new(-1.5, -0.8, 0.7), color = Color3.fromRGB(120, 110, 100), bodyRelative = true, material = Enum.Material.Metal },
				-- Tattered cloth on shoulders
				{ name = "ClothL", shape = "Block", size = Vector3.new(0.8, 1.5, 0.6), offset = Vector3.new(-0.5, 1.2, 0), color = Color3.fromRGB(80, 70, 55), bodyRelative = true, material = Enum.Material.Fabric, transparency = 0.2 },
				{ name = "ClothR", shape = "Block", size = Vector3.new(0.6, 1.0, 0.5), offset = Vector3.new(0.5, 1.0, 0), color = Color3.fromRGB(75, 65, 50), bodyRelative = true, material = Enum.Material.Fabric, transparency = 0.3 },
				-- Bone crown
				{ name = "CrownBase", shape = "Block", size = Vector3.new(1.1, 0.15, 1.1), offset = Vector3.new(0, 0.5, 0), color = Color3.fromRGB(210, 200, 180) },
				{ name = "CrownSpike1", shape = "Block", size = Vector3.new(0.1, 0.4, 0.1), offset = Vector3.new(0, 0.75, 0.4), color = Color3.fromRGB(210, 200, 180) },
				{ name = "CrownSpike2", shape = "Block", size = Vector3.new(0.1, 0.35, 0.1), offset = Vector3.new(0.35, 0.7, 0.2), color = Color3.fromRGB(210, 200, 180) },
				{ name = "CrownSpike3", shape = "Block", size = Vector3.new(0.1, 0.3, 0.1), offset = Vector3.new(-0.35, 0.7, 0.2), color = Color3.fromRGB(210, 200, 180) },
				-- Spectral wisps
				{ name = "Wisp1", shape = "Ball", size = Vector3.new(0.5, 0.8, 0.5), offset = Vector3.new(0.7, 0.5, 0.5), color = Color3.fromRGB(100, 200, 150), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.6 },
				{ name = "Wisp2", shape = "Ball", size = Vector3.new(0.4, 0.6, 0.4), offset = Vector3.new(-0.8, -0.3, -0.3), color = Color3.fromRGB(100, 200, 150), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.7 },
				{ name = "Wisp3", shape = "Ball", size = Vector3.new(0.3, 0.5, 0.3), offset = Vector3.new(0.2, -2.5, 0.4), color = Color3.fromRGB(120, 220, 170), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.65 },
				-- Sword crossguard
				{ name = "SwordGuard", shape = "Block", size = Vector3.new(0.1, 0.15, 0.8), offset = Vector3.new(1.5, 0, 0), color = Color3.fromRGB(140, 130, 110), bodyRelative = true, material = Enum.Material.Metal },
				-- Hand bones (knuckles)
				{ name = "HandL", shape = "Block", size = Vector3.new(0.35, 0.3, 0.35), offset = Vector3.new(-1.1, -2.2, 0), color = Color3.fromRGB(225, 220, 205), bodyRelative = true },
				{ name = "HandR", shape = "Block", size = Vector3.new(0.35, 0.3, 0.35), offset = Vector3.new(1.1, -2.2, 0), color = Color3.fromRGB(225, 220, 205), bodyRelative = true },
				-- Foot bones
				{ name = "FootL", shape = "Block", size = Vector3.new(0.5, 0.15, 0.6), offset = Vector3.new(-0.4, -4.5, 0.1), color = Color3.fromRGB(225, 220, 205), bodyRelative = true },
				{ name = "FootR", shape = "Block", size = Vector3.new(0.5, 0.15, 0.6), offset = Vector3.new(0.4, -4.5, 0.1), color = Color3.fromRGB(225, 220, 205), bodyRelative = true },
				-- Pelvis
				{ name = "Pelvis", shape = "Block", size = Vector3.new(1.3, 0.4, 0.8), offset = Vector3.new(0, -1.5, 0), color = Color3.fromRGB(225, 220, 205), bodyRelative = true },
			},
		},
	},

	DarkWizard = {
		name        = "Dark Wizard",
		hp          = 600,
		damage      = 54,
		level       = 35,
		xp          = 80,
		respawnTime = 50,
		zone        = "Wilderness",
		passive     = false,
		drops = {
			{ item = "Wizard Robe", chance = 0.10, minQty = 1, maxQty = 1 },
			{ item = "Magic Log",   chance = 0.20, minQty = 1, maxQty = 1 },
			{ item = "Gold Ore",    chance = 0.40, minQty = 2, maxQty = 4 },
			{ item = "Iron Sword",  chance = 0.12, minQty = 1, maxQty = 1 },
			{ item = "Gold Sword",  chance = 0.03, minQty = 1, maxQty = 1 },
			{ item = "Yew Shortbow", chance = 0.05, minQty = 1, maxQty = 1 },
			{ item = "Gold Arrows", chance = 0.15, minQty = 10, maxQty = 25 },
		},
		model = {
			bodyColor = Color3.fromRGB(40, 15, 70),
			size = Vector3.new(2, 5, 1.5),
			headSize = 1.0,
			extras = {
				-- Original parts
				{ name = "Hood", shape = "Block", size = Vector3.new(1.4, 0.8, 1.4), offset = Vector3.new(0, 1.2, -0.1), color = Color3.fromRGB(30, 10, 55) },
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.2, 0.2, 0.2), offset = Vector3.new(-0.2, 0.1, 0.45), color = Color3.fromRGB(180, 50, 255), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.2, 0.2, 0.2), offset = Vector3.new(0.2, 0.1, 0.45), color = Color3.fromRGB(180, 50, 255), material = Enum.Material.Neon },
				{ name = "Robe", shape = "Block", size = Vector3.new(2.5, 3, 2), offset = Vector3.new(0, -1.5, 0), color = Color3.fromRGB(40, 15, 70), bodyRelative = true },
				{ name = "Staff", shape = "Block", size = Vector3.new(0.3, 6, 0.3), offset = Vector3.new(1.5, 0, 0), color = Color3.fromRGB(80, 50, 30), bodyRelative = true, material = Enum.Material.Wood },
				{ name = "StaffOrb", shape = "Ball", size = Vector3.new(0.8, 0.8, 0.8), offset = Vector3.new(1.5, 3.2, 0), color = Color3.fromRGB(180, 50, 255), bodyRelative = true, material = Enum.Material.Neon },
				{ name = "HandL", shape = "Ball", size = Vector3.new(0.5, 0.5, 0.5), offset = Vector3.new(-1.3, 0, 0.5), color = Color3.fromRGB(150, 40, 200), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.3 },
				-- Longer robe skirt
				{ name = "RobeSkirt", shape = "Block", size = Vector3.new(2.8, 2, 2.3), offset = Vector3.new(0, -3.2, 0), color = Color3.fromRGB(35, 12, 60), bodyRelative = true },
				{ name = "RobeHem", shape = "Block", size = Vector3.new(3.0, 0.2, 2.5), offset = Vector3.new(0, -4.2, 0), color = Color3.fromRGB(25, 8, 45), bodyRelative = true },
				-- Hood peak (taller hood)
				{ name = "HoodPeak", shape = "Block", size = Vector3.new(0.8, 0.6, 0.8), offset = Vector3.new(0, 1.1, -0.2), color = Color3.fromRGB(25, 8, 50) },
				-- Spell book in left hand
				{ name = "Book", shape = "Block", size = Vector3.new(0.6, 0.8, 0.15), offset = Vector3.new(-1.5, -0.5, 0.4), color = Color3.fromRGB(60, 20, 20), bodyRelative = true },
				{ name = "BookPages", shape = "Block", size = Vector3.new(0.55, 0.75, 0.08), offset = Vector3.new(-1.5, -0.5, 0.48), color = Color3.fromRGB(230, 220, 180), bodyRelative = true },
				{ name = "BookClasp", shape = "Block", size = Vector3.new(0.1, 0.1, 0.18), offset = Vector3.new(-1.5, -0.15, 0.4), color = Color3.fromRGB(180, 150, 50), bodyRelative = true, material = Enum.Material.Metal },
				-- Floating magic orbs
				{ name = "FloatOrb1", shape = "Ball", size = Vector3.new(0.35, 0.35, 0.35), offset = Vector3.new(-0.8, 2.5, -0.5), color = Color3.fromRGB(160, 40, 220), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.3 },
				{ name = "FloatOrb2", shape = "Ball", size = Vector3.new(0.25, 0.25, 0.25), offset = Vector3.new(0.5, 2.8, 0.3), color = Color3.fromRGB(140, 30, 200), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
				{ name = "FloatOrb3", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(-0.3, 3.0, 0.6), color = Color3.fromRGB(170, 60, 240), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.35 },
				-- Rune circle at feet
				{ name = "RuneCircle", shape = "Block", size = Vector3.new(4, 0.05, 4), offset = Vector3.new(0, -4.5, 0), color = Color3.fromRGB(120, 30, 180), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.5 },
				{ name = "RuneInner", shape = "Ball", size = Vector3.new(2.5, 0.08, 2.5), offset = Vector3.new(0, -4.48, 0), color = Color3.fromRGB(100, 20, 160), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.6 },
				-- Rune symbols floating
				{ name = "RuneFloat1", shape = "Block", size = Vector3.new(0.3, 0.3, 0.05), offset = Vector3.new(1.5, -4.3, 1.5), color = Color3.fromRGB(180, 50, 255), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
				{ name = "RuneFloat2", shape = "Block", size = Vector3.new(0.3, 0.3, 0.05), offset = Vector3.new(-1.5, -4.3, -1.5), color = Color3.fromRGB(180, 50, 255), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
				{ name = "RuneFloat3", shape = "Block", size = Vector3.new(0.3, 0.3, 0.05), offset = Vector3.new(-1.5, -4.3, 1.5), color = Color3.fromRGB(180, 50, 255), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
				{ name = "RuneFloat4", shape = "Block", size = Vector3.new(0.3, 0.3, 0.05), offset = Vector3.new(1.5, -4.3, -1.5), color = Color3.fromRGB(180, 50, 255), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
				-- Belt/sash
				{ name = "Sash", shape = "Block", size = Vector3.new(2.3, 0.2, 1.6), offset = Vector3.new(0, -0.3, 0), color = Color3.fromRGB(80, 30, 120), bodyRelative = true },
				-- Robe trim
				{ name = "TrimFront", shape = "Block", size = Vector3.new(0.15, 4.5, 0.1), offset = Vector3.new(0, -1.5, -1.0), color = Color3.fromRGB(100, 40, 150), bodyRelative = true },
				-- Staff glow ring
				{ name = "StaffRing", shape = "Block", size = Vector3.new(0.5, 0.1, 0.5), offset = Vector3.new(1.5, 2.6, 0), color = Color3.fromRGB(150, 40, 220), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.3 },
				-- Dark energy hand glow (right)
				{ name = "HandR", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(1.3, 0, 0.5), color = Color3.fromRGB(150, 40, 200), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
			},
		},
	},

	Demon = {
		name        = "Demon",
		hp          = 1000,
		damage      = 75,
		level       = 50,
		xp          = 150,
		respawnTime = 70,
		zone        = "Wilderness",
		passive     = false,
		drops = {
			{ item = "Demon Heart",  chance = 0.15, minQty = 1, maxQty = 1 },
			{ item = "Gold Sword",   chance = 0.05, minQty = 1, maxQty = 1 },
			{ item = "Runite Ore",   chance = 0.25, minQty = 1, maxQty = 3 },
			{ item = "Gold Ore",     chance = 0.40, minQty = 2, maxQty = 5 },
			{ item = "Bones",        chance = 1.00, minQty = 2, maxQty = 3 },
			{ item = "Gold Crossbow", chance = 0.04, minQty = 1, maxQty = 1 },
			{ item = "Runite Arrows", chance = 0.10, minQty = 5, maxQty = 15 },
			{ item = "Gold Shield",  chance = 0.08, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(120, 20, 20), -- darker red-black
			size = Vector3.new(2.8, 4.5, 2.0), -- muscular humanoid proportions
			headSize = 1.2,
			extras = {
				-- === MUSCULAR HUMANOID DEMON ===
				-- MASSIVE curved horns (demonic)
				{ name = "HornL", shape = "Block", size = Vector3.new(0.35, 2.0, 0.35), offset = Vector3.new(-0.5, 1.4, 0.2), color = Color3.fromRGB(30, 5, 5), rotation = Vector3.new(0, 15, -25) },
				{ name = "HornR", shape = "Block", size = Vector3.new(0.35, 2.0, 0.35), offset = Vector3.new(0.5, 1.4, 0.2), color = Color3.fromRGB(30, 5, 5), rotation = Vector3.new(0, -15, 25) },
				-- Horn tips (wickedly sharp)
				{ name = "HornTipL", shape = "Block", size = Vector3.new(0.2, 0.8, 0.2), offset = Vector3.new(-0.8, 2.8, 0.4), color = Color3.fromRGB(20, 3, 3), rotation = Vector3.new(0, 15, -35) },
				{ name = "HornTipR", shape = "Block", size = Vector3.new(0.2, 0.8, 0.2), offset = Vector3.new(0.8, 2.8, 0.4), color = Color3.fromRGB(20, 3, 3), rotation = Vector3.new(0, -15, 35) },
				-- Glowing demonic eyes
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(-0.3, 0.2, 0.65), color = Color3.fromRGB(255, 50, 0), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(0.3, 0.2, 0.65), color = Color3.fromRGB(255, 50, 0), material = Enum.Material.Neon },
				{ name = "PupilL", shape = "Block", size = Vector3.new(0.1, 0.3, 0.1), offset = Vector3.new(-0.3, 0.2, 0.8), color = Color3.fromRGB(10, 0, 0) },
				{ name = "PupilR", shape = "Block", size = Vector3.new(0.1, 0.3, 0.1), offset = Vector3.new(0.3, 0.2, 0.8), color = Color3.fromRGB(10, 0, 0) },
				-- MUSCULAR CHEST & TORSO
				{ name = "PectoralL", shape = "Ball", size = Vector3.new(1.2, 1.0, 0.8), offset = Vector3.new(-0.7, 1.5, 0.6), color = Color3.fromRGB(130, 25, 25), bodyRelative = true },
				{ name = "PectoralR", shape = "Ball", size = Vector3.new(1.2, 1.0, 0.8), offset = Vector3.new(0.7, 1.5, 0.6), color = Color3.fromRGB(130, 25, 25), bodyRelative = true },
				{ name = "AbMuscles", shape = "Block", size = Vector3.new(1.8, 1.5, 0.8), offset = Vector3.new(0, 0.2, 0.8), color = Color3.fromRGB(110, 20, 20), bodyRelative = true },
				-- Glowing core/heart
				{ name = "DemonicHeart", shape = "Ball", size = Vector3.new(0.6, 0.8, 0.4), offset = Vector3.new(0, 0.8, 1.2), color = Color3.fromRGB(255, 30, 0), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.3 },
				-- MUSCULAR ARMS (humanoid)
				{ name = "ShoulderL", shape = "Ball", size = Vector3.new(0.8, 0.8, 0.8), offset = Vector3.new(-1.8, 1.8, 0), color = Color3.fromRGB(125, 22, 22), bodyRelative = true },
				{ name = "ShoulderR", shape = "Ball", size = Vector3.new(0.8, 0.8, 0.8), offset = Vector3.new(1.8, 1.8, 0), color = Color3.fromRGB(125, 22, 22), bodyRelative = true },
				{ name = "BicepL", shape = "Block", size = Vector3.new(0.7, 1.8, 0.7), offset = Vector3.new(-1.8, 0.5, 0), color = Color3.fromRGB(120, 20, 20), bodyRelative = true },
				{ name = "BicepR", shape = "Block", size = Vector3.new(0.7, 1.8, 0.7), offset = Vector3.new(1.8, 0.5, 0), color = Color3.fromRGB(120, 20, 20), bodyRelative = true },
				{ name = "ForearmL", shape = "Block", size = Vector3.new(0.6, 1.5, 0.6), offset = Vector3.new(-1.8, -1.0, 0), color = Color3.fromRGB(115, 18, 18), bodyRelative = true },
				{ name = "ForearmR", shape = "Block", size = Vector3.new(0.6, 1.5, 0.6), offset = Vector3.new(1.8, -1.0, 0), color = Color3.fromRGB(115, 18, 18), bodyRelative = true },
				-- CLAWED HANDS wreathed in fire
				{ name = "HandL", shape = "Block", size = Vector3.new(0.8, 0.4, 1.0), offset = Vector3.new(-1.8, -2.0, 0), color = Color3.fromRGB(100, 15, 15), bodyRelative = true },
				{ name = "HandR", shape = "Block", size = Vector3.new(0.8, 0.4, 1.0), offset = Vector3.new(1.8, -2.0, 0), color = Color3.fromRGB(100, 15, 15), bodyRelative = true },
				-- Individual claws
				{ name = "ClawL1", shape = "Block", size = Vector3.new(0.1, 0.5, 0.1), offset = Vector3.new(-2.0, -2.3, 0.4), color = Color3.fromRGB(20, 3, 3), bodyRelative = true },
				{ name = "ClawL2", shape = "Block", size = Vector3.new(0.1, 0.6, 0.1), offset = Vector3.new(-1.9, -2.4, 0.2), color = Color3.fromRGB(20, 3, 3), bodyRelative = true },
				{ name = "ClawL3", shape = "Block", size = Vector3.new(0.1, 0.5, 0.1), offset = Vector3.new(-1.8, -2.3, 0), color = Color3.fromRGB(20, 3, 3), bodyRelative = true },
				{ name = "ClawR1", shape = "Block", size = Vector3.new(0.1, 0.5, 0.1), offset = Vector3.new(2.0, -2.3, 0.4), color = Color3.fromRGB(20, 3, 3), bodyRelative = true },
				{ name = "ClawR2", shape = "Block", size = Vector3.new(0.1, 0.6, 0.1), offset = Vector3.new(1.9, -2.4, 0.2), color = Color3.fromRGB(20, 3, 3), bodyRelative = true },
				{ name = "ClawR3", shape = "Block", size = Vector3.new(0.1, 0.5, 0.1), offset = Vector3.new(1.8, -2.3, 0), color = Color3.fromRGB(20, 3, 3), bodyRelative = true },
				-- Fire wreathing hands
				{ name = "FireHandL", shape = "Ball", size = Vector3.new(1.2, 1.0, 1.2), offset = Vector3.new(-1.8, -2.0, 0), color = Color3.fromRGB(255, 80, 0), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.5 },
				{ name = "FireHandR", shape = "Ball", size = Vector3.new(1.2, 1.0, 1.2), offset = Vector3.new(1.8, -2.0, 0), color = Color3.fromRGB(255, 80, 0), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.5 },
				-- MUSCULAR LEGS (humanoid stance)
				{ name = "ThighL", shape = "Block", size = Vector3.new(0.9, 2.0, 0.9), offset = Vector3.new(-0.7, -3.2, 0), color = Color3.fromRGB(115, 20, 20), bodyRelative = true },
				{ name = "ThighR", shape = "Block", size = Vector3.new(0.9, 2.0, 0.9), offset = Vector3.new(0.7, -3.2, 0), color = Color3.fromRGB(115, 20, 20), bodyRelative = true },
				{ name = "CalfL", shape = "Block", size = Vector3.new(0.7, 1.8, 0.7), offset = Vector3.new(-0.7, -5.1, 0), color = Color3.fromRGB(110, 18, 18), bodyRelative = true },
				{ name = "CalfR", shape = "Block", size = Vector3.new(0.7, 1.8, 0.7), offset = Vector3.new(0.7, -5.1, 0), color = Color3.fromRGB(110, 18, 18), bodyRelative = true },
				-- Hooved feet
				{ name = "HoofL", shape = "Block", size = Vector3.new(0.9, 0.3, 1.2), offset = Vector3.new(-0.7, -6.1, 0.1), color = Color3.fromRGB(15, 2, 2), bodyRelative = true },
				{ name = "HoofR", shape = "Block", size = Vector3.new(0.9, 0.3, 1.2), offset = Vector3.new(0.7, -6.1, 0.1), color = Color3.fromRGB(15, 2, 2), bodyRelative = true },
				-- Menacing face features
				{ name = "Jaw", shape = "Block", size = Vector3.new(0.8, 0.4, 0.6), offset = Vector3.new(0, -0.4, 0.3), color = Color3.fromRGB(100, 15, 15) },
				{ name = "FangL", shape = "Block", size = Vector3.new(0.12, 0.4, 0.12), offset = Vector3.new(-0.2, -0.6, 0.6), color = Color3.fromRGB(240, 230, 200) },
				{ name = "FangR", shape = "Block", size = Vector3.new(0.12, 0.4, 0.12), offset = Vector3.new(0.2, -0.6, 0.6), color = Color3.fromRGB(240, 230, 200) },
				-- Small demonic wings (not dragon wings)
				{ name = "WingL", shape = "Block", size = Vector3.new(0.15, 1.8, 1.5), offset = Vector3.new(-1.6, 1.2, -0.8), color = Color3.fromRGB(60, 10, 10), bodyRelative = true, rotation = Vector3.new(0, 20, -30) },
				{ name = "WingR", shape = "Block", size = Vector3.new(0.15, 1.8, 1.5), offset = Vector3.new(1.6, 1.2, -0.8), color = Color3.fromRGB(60, 10, 10), bodyRelative = true, rotation = Vector3.new(0, -20, 30) },
				-- Spaded tail
				{ name = "TailBase", shape = "Block", size = Vector3.new(0.3, 0.3, 1.5), offset = Vector3.new(0, -1.5, -1.5), color = Color3.fromRGB(110, 18, 18), bodyRelative = true },
				{ name = "TailMid", shape = "Block", size = Vector3.new(0.25, 0.25, 1.2), offset = Vector3.new(0, -1.5, -2.9), color = Color3.fromRGB(105, 16, 16), bodyRelative = true },
				{ name = "TailSpade", shape = "Block", size = Vector3.new(0.8, 0.1, 0.6), offset = Vector3.new(0, -1.5, -3.8), color = Color3.fromRGB(80, 12, 12), bodyRelative = true },
				-- Demonic armor/scarring
				{ name = "ChestScar1", shape = "Block", size = Vector3.new(1.2, 0.08, 0.1), offset = Vector3.new(0, 1.0, 1.1), color = Color3.fromRGB(80, 10, 10), bodyRelative = true },
				{ name = "ChestScar2", shape = "Block", size = Vector3.new(0.8, 0.08, 0.1), offset = Vector3.new(0.3, 0.5, 1.1), color = Color3.fromRGB(80, 10, 10), bodyRelative = true },
				-- Shoulder spikes
				{ name = "SpikeL", shape = "Block", size = Vector3.new(0.25, 0.8, 0.25), offset = Vector3.new(-1.8, 2.5, 0), color = Color3.fromRGB(40, 6, 6), bodyRelative = true },
				{ name = "SpikeR", shape = "Block", size = Vector3.new(0.25, 0.8, 0.25), offset = Vector3.new(1.8, 2.5, 0), color = Color3.fromRGB(40, 6, 6), bodyRelative = true },
			},
		},
	},

	ShadowDragon = {
		name        = "Shadow Dragon",
		hp          = 5000,
		damage      = 120,
		level       = 80,
		xp          = 500,
		respawnTime = 180,
		zone        = "Wilderness",
		passive     = false,
		boss        = true,
		drops = {
			{ item = "Dragon Scale",  chance = 1.00, minQty = 1, maxQty = 3 },
			{ item = "Dragon Sword",  chance = 0.05, minQty = 1, maxQty = 1 },
			{ item = "Shadow Gem",    chance = 0.10, minQty = 1, maxQty = 1 },
			{ item = "Runite Ore",    chance = 0.50, minQty = 3, maxQty = 5 },
			{ item = "Gold Sword",    chance = 0.15, minQty = 1, maxQty = 1 },
			{ item = "Demon Heart",   chance = 0.20, minQty = 1, maxQty = 1 },
			{ item = "Dragon Crossbow", chance = 0.02, minQty = 1, maxQty = 1 },
			{ item = "Dragon Shield", chance = 0.03, minQty = 1, maxQty = 1 },
			{ item = "Magic Bowstring", chance = 0.15, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(30, 10, 55),
			size = Vector3.new(4, 3, 6), -- SMALL core torso, dragon built from extras
			elevation = 7, -- raise body so legs reach the ground properly
			headSize = 1.8, -- smaller head ball, snout extends it
			extras = {
				-- === SHADOW DRAGON - shaped from parts, not one big box ===
				-- TORSO SHAPING: rounded belly and back to hide the box
				{ name = "Chest", shape = "Ball", size = Vector3.new(5, 4, 7), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(35, 12, 60), bodyRelative = true },
				{ name = "Haunches", shape = "Ball", size = Vector3.new(4.5, 3.5, 5), offset = Vector3.new(0, -0.3, -3), color = Color3.fromRGB(30, 10, 55), bodyRelative = true },
				-- LONG NECK: multiple segments reaching up and forward
				{ name = "Neck1", shape = "Block", size = Vector3.new(2.0, 2.0, 3.0), offset = Vector3.new(0, 1.5, 4.5), color = Color3.fromRGB(30, 10, 55), bodyRelative = true },
				{ name = "Neck2", shape = "Block", size = Vector3.new(1.6, 1.6, 3.0), offset = Vector3.new(0, 3.0, 6.5), color = Color3.fromRGB(35, 12, 60), bodyRelative = true },
				{ name = "Neck3", shape = "Block", size = Vector3.new(1.3, 1.3, 2.5), offset = Vector3.new(0, 4.5, 8.0), color = Color3.fromRGB(38, 14, 65), bodyRelative = true },
				-- HEAD: snout, jaw, brow ridges (offset from head ball via neck)
				{ name = "Snout", shape = "Block", size = Vector3.new(1.4, 1.0, 2.5), offset = Vector3.new(0, -0.3, 2.0), color = Color3.fromRGB(30, 10, 55) },
				{ name = "Jaw", shape = "Block", size = Vector3.new(1.2, 0.5, 2.0), offset = Vector3.new(0, -0.9, 1.5), color = Color3.fromRGB(25, 8, 48) },
				{ name = "BrowL", shape = "Block", size = Vector3.new(0.6, 0.25, 0.5), offset = Vector3.new(-0.6, 0.6, 1.0), color = Color3.fromRGB(28, 10, 50) },
				{ name = "BrowR", shape = "Block", size = Vector3.new(0.6, 0.25, 0.5), offset = Vector3.new(0.6, 0.6, 1.0), color = Color3.fromRGB(28, 10, 50) },
				-- EYES: glowing purple
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.5, 0.5, 0.5), offset = Vector3.new(-0.6, 0.3, 1.0), color = Color3.fromRGB(200, 50, 255), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.5, 0.5, 0.5), offset = Vector3.new(0.6, 0.3, 1.0), color = Color3.fromRGB(200, 50, 255), material = Enum.Material.Neon },
				{ name = "PupilL", shape = "Block", size = Vector3.new(0.08, 0.35, 0.08), offset = Vector3.new(-0.6, 0.3, 1.25), color = Color3.fromRGB(10, 0, 15) },
				{ name = "PupilR", shape = "Block", size = Vector3.new(0.08, 0.35, 0.08), offset = Vector3.new(0.6, 0.3, 1.25), color = Color3.fromRGB(10, 0, 15) },
				-- HORNS: swept back
				{ name = "HornL", shape = "Block", size = Vector3.new(0.35, 2.0, 0.35), offset = Vector3.new(-0.7, 1.5, -0.3), color = Color3.fromRGB(60, 15, 80), rotation = Vector3.new(0, 0, -20) },
				{ name = "HornR", shape = "Block", size = Vector3.new(0.35, 2.0, 0.35), offset = Vector3.new(0.7, 1.5, -0.3), color = Color3.fromRGB(60, 15, 80), rotation = Vector3.new(0, 0, 20) },
				-- FANGS
				{ name = "FangL", shape = "Block", size = Vector3.new(0.15, 0.5, 0.15), offset = Vector3.new(-0.4, -0.8, 2.8), color = Color3.fromRGB(230, 220, 200) },
				{ name = "FangR", shape = "Block", size = Vector3.new(0.15, 0.5, 0.15), offset = Vector3.new(0.4, -0.8, 2.8), color = Color3.fromRGB(230, 220, 200) },
				-- NECK SPINES
				{ name = "NeckSpine1", shape = "Block", size = Vector3.new(0.35, 1.2, 0.35), offset = Vector3.new(0, 2.8, 5.0), color = Color3.fromRGB(50, 10, 70), bodyRelative = true },
				{ name = "NeckSpine2", shape = "Block", size = Vector3.new(0.3, 1.0, 0.3), offset = Vector3.new(0, 4.0, 7.0), color = Color3.fromRGB(50, 10, 70), bodyRelative = true },
				-- WINGS: angled out and up like real dragon wings
				{ name = "WingArmL", shape = "Block", size = Vector3.new(0.5, 6, 1.0), offset = Vector3.new(-3.5, 4, 0), color = Color3.fromRGB(20, 4, 40), bodyRelative = true, rotation = Vector3.new(0, 0, -35) },
				{ name = "WingArmR", shape = "Block", size = Vector3.new(0.5, 6, 1.0), offset = Vector3.new(3.5, 4, 0), color = Color3.fromRGB(20, 4, 40), bodyRelative = true, rotation = Vector3.new(0, 0, 35) },
				{ name = "WingMemL", shape = "Block", size = Vector3.new(0.1, 5, 6), offset = Vector3.new(-6, 5, -1), color = Color3.fromRGB(40, 15, 65), bodyRelative = true, transparency = 0.2 },
				{ name = "WingMemR", shape = "Block", size = Vector3.new(0.1, 5, 6), offset = Vector3.new(6, 5, -1), color = Color3.fromRGB(40, 15, 65), bodyRelative = true, transparency = 0.2 },
				{ name = "WingFingerL1", shape = "Block", size = Vector3.new(0.08, 4.5, 0.15), offset = Vector3.new(-6.5, 5, 1), color = Color3.fromRGB(40, 15, 68), bodyRelative = true },
				{ name = "WingFingerL2", shape = "Block", size = Vector3.new(0.08, 4.0, 0.15), offset = Vector3.new(-7, 5, -2), color = Color3.fromRGB(40, 15, 68), bodyRelative = true },
				{ name = "WingFingerR1", shape = "Block", size = Vector3.new(0.08, 4.5, 0.15), offset = Vector3.new(6.5, 5, 1), color = Color3.fromRGB(40, 15, 68), bodyRelative = true },
				{ name = "WingFingerR2", shape = "Block", size = Vector3.new(0.08, 4.0, 0.15), offset = Vector3.new(7, 5, -2), color = Color3.fromRGB(40, 15, 68), bodyRelative = true },
				-- BACK SPINES
				{ name = "BackSpine1", shape = "Block", size = Vector3.new(0.4, 1.5, 0.4), offset = Vector3.new(0, 2.5, 1), color = Color3.fromRGB(55, 12, 75), bodyRelative = true },
				{ name = "BackSpine2", shape = "Block", size = Vector3.new(0.35, 1.3, 0.35), offset = Vector3.new(0, 2.3, -1), color = Color3.fromRGB(55, 12, 75), bodyRelative = true },
				{ name = "BackSpine3", shape = "Block", size = Vector3.new(0.3, 1.1, 0.3), offset = Vector3.new(0, 2.1, -3), color = Color3.fromRGB(55, 12, 75), bodyRelative = true },
				{ name = "BackSpine4", shape = "Block", size = Vector3.new(0.25, 0.9, 0.25), offset = Vector3.new(0, 1.9, -5), color = Color3.fromRGB(55, 12, 75), bodyRelative = true },
				-- LEGS: strong, dinosaur-like
				{ name = "LegFL", shape = "Block", size = Vector3.new(1.2, 4, 1.2), offset = Vector3.new(-2, -3.5, 3), color = Color3.fromRGB(30, 10, 55), bodyRelative = true },
				{ name = "LegFR", shape = "Block", size = Vector3.new(1.2, 4, 1.2), offset = Vector3.new(2, -3.5, 3), color = Color3.fromRGB(30, 10, 55), bodyRelative = true },
				{ name = "LegBL", shape = "Block", size = Vector3.new(1.4, 4.5, 1.4), offset = Vector3.new(-2, -3.8, -3), color = Color3.fromRGB(30, 10, 55), bodyRelative = true },
				{ name = "LegBR", shape = "Block", size = Vector3.new(1.4, 4.5, 1.4), offset = Vector3.new(2, -3.8, -3), color = Color3.fromRGB(30, 10, 55), bodyRelative = true },
				-- CLAWS
				{ name = "ClawFL", shape = "Block", size = Vector3.new(0.2, 0.5, 0.6), offset = Vector3.new(-2, -5.7, 3.5), color = Color3.fromRGB(20, 6, 35), bodyRelative = true },
				{ name = "ClawFR", shape = "Block", size = Vector3.new(0.2, 0.5, 0.6), offset = Vector3.new(2, -5.7, 3.5), color = Color3.fromRGB(20, 6, 35), bodyRelative = true },
				{ name = "ClawBL", shape = "Block", size = Vector3.new(0.2, 0.5, 0.6), offset = Vector3.new(-2, -6.2, -2.5), color = Color3.fromRGB(20, 6, 35), bodyRelative = true },
				{ name = "ClawBR", shape = "Block", size = Vector3.new(0.2, 0.5, 0.6), offset = Vector3.new(2, -6.2, -2.5), color = Color3.fromRGB(20, 6, 35), bodyRelative = true },
				-- TAIL: long, tapering, with blade tip
				{ name = "Tail1", shape = "Block", size = Vector3.new(1.2, 1.2, 5), offset = Vector3.new(0, 0, -8), color = Color3.fromRGB(30, 10, 55), bodyRelative = true },
				{ name = "Tail2", shape = "Block", size = Vector3.new(0.9, 0.9, 4), offset = Vector3.new(0, 0, -12.5), color = Color3.fromRGB(12, 2, 30), bodyRelative = true },
				{ name = "Tail3", shape = "Block", size = Vector3.new(0.6, 0.6, 3), offset = Vector3.new(0, 0, -16), color = Color3.fromRGB(28, 10, 50), bodyRelative = true },
				{ name = "TailBlade", shape = "Block", size = Vector3.new(1.5, 0.4, 2.0), offset = Vector3.new(0, 0, -18.5), color = Color3.fromRGB(150, 40, 200), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.2 },
				-- TAIL SPINES
				{ name = "TailSpine1", shape = "Block", size = Vector3.new(0.2, 0.6, 0.2), offset = Vector3.new(0, 0.8, -9), color = Color3.fromRGB(55, 12, 75), bodyRelative = true },
				{ name = "TailSpine2", shape = "Block", size = Vector3.new(0.18, 0.5, 0.18), offset = Vector3.new(0, 0.6, -12), color = Color3.fromRGB(55, 12, 75), bodyRelative = true },
				-- SHADOW AURA
				{ name = "ShadowAura", shape = "Ball", size = Vector3.new(10, 4, 14), offset = Vector3.new(0, -1, -2), color = Color3.fromRGB(22, 8, 42), bodyRelative = true, transparency = 0.75 },
				-- BREATH: purple fire wisps from mouth
				{ name = "Breath1", shape = "Ball", size = Vector3.new(1.0, 0.7, 1.0), offset = Vector3.new(0, -0.6, 3.5), color = Color3.fromRGB(150, 30, 200), material = Enum.Material.Neon, transparency = 0.4 },
				{ name = "Breath2", shape = "Ball", size = Vector3.new(1.5, 1.0, 1.5), offset = Vector3.new(0, -0.7, 4.5), color = Color3.fromRGB(100, 15, 160), material = Enum.Material.Neon, transparency = 0.55 },
			},
		},
	},

	-- NEW SAFE ZONE BOSSES --
	["King Rooster"] = {
		name        = "King Rooster",
		hp          = 300,
		damage      = 15,
		level       = 20,
		xp          = 300, -- level * 15
		respawnTime = 120,
		zone        = "Safe",
		passive     = false,
		boss        = true,
		drops = {
			{ item = "Golden Feather", chance = 0.80, minQty = 1, maxQty = 1 },
			{ item = "King's Crest", chance = 0.60, minQty = 1, maxQty = 1 },
			{ item = "Raw Chicken", chance = 1.00, minQty = 3, maxQty = 3 },
		},
		model = {
			bodyColor = Color3.fromRGB(220, 180, 50),
			size = Vector3.new(3.5, 2.8, 4), -- larger than regular chicken
			headSize = 1.2,
			extras = {
				-- Giant golden comb
				{ name = "KingComb", shape = "Block", size = Vector3.new(0.8, 1.5, 1.2), offset = Vector3.new(0, 1.0, 0.6), color = Color3.fromRGB(255, 215, 0) },
				-- Large beak
				{ name = "KingBeak", shape = "Block", size = Vector3.new(0.6, 0.4, 1.0), offset = Vector3.new(0, 0, 1.2), color = Color3.fromRGB(255, 180, 0) },
				-- Thick legs
				{ name = "LegL", shape = "Block", size = Vector3.new(0.4, 2.0, 0.4), offset = Vector3.new(-0.8, -2.4, 0), color = Color3.fromRGB(255, 180, 0), bodyRelative = true },
				{ name = "LegR", shape = "Block", size = Vector3.new(0.4, 2.0, 0.4), offset = Vector3.new(0.8, -2.4, 0), color = Color3.fromRGB(255, 180, 0), bodyRelative = true },
				-- Majestic tail feathers
				{ name = "TailMain", shape = "Block", size = Vector3.new(0.6, 2.5, 1.8), offset = Vector3.new(0, 0.8, -2.5), color = Color3.fromRGB(200, 150, 30), bodyRelative = true },
				-- Eyes - fierce red
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.25, 0.25, 0.25), offset = Vector3.new(-0.35, 0.2, 0.6), color = Color3.fromRGB(200, 20, 20) },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.25, 0.25, 0.25), offset = Vector3.new(0.35, 0.2, 0.6), color = Color3.fromRGB(200, 20, 20) },
				-- Golden wattle
				{ name = "KingWattle", shape = "Block", size = Vector3.new(0.3, 0.6, 0.3), offset = Vector3.new(0, -0.4, 1.1), color = Color3.fromRGB(255, 215, 0) },
				-- Large wings
				{ name = "WingL", shape = "Block", size = Vector3.new(0.3, 1.4, 2.8), offset = Vector3.new(-2.0, 0.2, -0.2), color = Color3.fromRGB(200, 160, 40), bodyRelative = true },
				{ name = "WingR", shape = "Block", size = Vector3.new(0.3, 1.4, 2.8), offset = Vector3.new(2.0, 0.2, -0.2), color = Color3.fromRGB(200, 160, 40), bodyRelative = true },
			},
		},
	},

	["Elder Treant"] = {
		name        = "Elder Treant",
		hp          = 600,
		damage      = 25,
		level       = 35,
		xp          = 525, -- level * 15
		respawnTime = 180,
		zone        = "Safe",
		passive     = false,
		boss        = true,
		drops = {
			{ item = "Heartwood", chance = 0.70, minQty = 1, maxQty = 1 },
			{ item = "Ancient Bark", chance = 1.00, minQty = 5, maxQty = 5 },
			{ item = "Magic Logs", chance = 0.90, minQty = 3, maxQty = 3 },
			{ item = "Elder Seed", chance = 0.40, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(101, 67, 33),
			size = Vector3.new(4, 5, 4), -- massive tree trunk
			headSize = 1.5,
			extras = {
				-- Tree bark texture blocks
				{ name = "BarkLayer1", shape = "Block", size = Vector3.new(4.2, 5.2, 4.2), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(85, 55, 25), bodyRelative = true, material = Enum.Material.Wood },
				-- Branch arms (thick)
				{ name = "BranchL", shape = "Block", size = Vector3.new(1.2, 0.8, 3.5), offset = Vector3.new(-3.0, 1.5, 0), color = Color3.fromRGB(90, 60, 30), bodyRelative = true },
				{ name = "BranchR", shape = "Block", size = Vector3.new(1.2, 0.8, 3.5), offset = Vector3.new(3.0, 1.5, 0), color = Color3.fromRGB(90, 60, 30), bodyRelative = true },
				-- Root legs
				{ name = "RootL", shape = "Block", size = Vector3.new(1.0, 3.0, 1.0), offset = Vector3.new(-1.5, -4.0, 0), color = Color3.fromRGB(80, 50, 25), bodyRelative = true },
				{ name = "RootR", shape = "Block", size = Vector3.new(1.0, 3.0, 1.0), offset = Vector3.new(1.5, -4.0, 0), color = Color3.fromRGB(80, 50, 25), bodyRelative = true },
				-- Glowing eyes in bark
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(-0.5, 0.3, 0.8), color = Color3.fromRGB(0, 255, 100), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(0.5, 0.3, 0.8), color = Color3.fromRGB(0, 255, 100), material = Enum.Material.Neon },
				-- Leaves on top
				{ name = "LeafCanopy", shape = "Ball", size = Vector3.new(6, 3, 6), offset = Vector3.new(0, 4.0, 0), color = Color3.fromRGB(34, 139, 34), bodyRelative = true },
				-- Moss patches
				{ name = "Moss1", shape = "Block", size = Vector3.new(1.0, 0.8, 0.2), offset = Vector3.new(1.5, 0.5, 2.2), color = Color3.fromRGB(107, 142, 35), bodyRelative = true },
				{ name = "Moss2", shape = "Block", size = Vector3.new(0.8, 1.2, 0.2), offset = Vector3.new(-1.8, -0.5, 2.2), color = Color3.fromRGB(107, 142, 35), bodyRelative = true },
			},
		},
	},

	["Iron Golem"] = {
		name        = "Iron Golem",
		hp          = 1000,
		damage      = 35,
		level       = 50,
		xp          = 750, -- level * 15
		respawnTime = 240,
		zone        = "Safe",
		passive     = false,
		boss        = true,
		drops = {
			{ item = "Golem Core", chance = 0.50, minQty = 1, maxQty = 1 },
			{ item = "Iron Bar", chance = 1.00, minQty = 10, maxQty = 10 },
			{ item = "Runite Ore", chance = 0.80, minQty = 3, maxQty = 3 },
			{ item = "Golem Shield", chance = 0.60, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(105, 105, 105),
			size = Vector3.new(4, 6, 3), -- massive iron body
			headSize = 1.8,
			extras = {
				-- Iron plating
				{ name = "ChestPlate", shape = "Block", size = Vector3.new(4.2, 3, 3.2), offset = Vector3.new(0, 1.5, 0), color = Color3.fromRGB(95, 95, 95), bodyRelative = true, material = Enum.Material.Metal },
				-- Massive arms
				{ name = "ArmL", shape = "Block", size = Vector3.new(1.5, 1.2, 4.5), offset = Vector3.new(-3.5, 2.0, 0), color = Color3.fromRGB(100, 100, 100), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "ArmR", shape = "Block", size = Vector3.new(1.5, 1.2, 4.5), offset = Vector3.new(3.5, 2.0, 0), color = Color3.fromRGB(100, 100, 100), bodyRelative = true, material = Enum.Material.Metal },
				-- Iron legs
				{ name = "LegL", shape = "Block", size = Vector3.new(1.2, 4.0, 1.2), offset = Vector3.new(-1.0, -5.0, 0), color = Color3.fromRGB(90, 90, 90), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "LegR", shape = "Block", size = Vector3.new(1.2, 4.0, 1.2), offset = Vector3.new(1.0, -5.0, 0), color = Color3.fromRGB(90, 90, 90), bodyRelative = true, material = Enum.Material.Metal },
				-- Glowing core in chest
				{ name = "Core", shape = "Ball", size = Vector3.new(0.8, 0.8, 0.8), offset = Vector3.new(0, 1.0, 1.8), color = Color3.fromRGB(255, 100, 0), material = Enum.Material.Neon, bodyRelative = true },
				-- Glowing eyes
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.35, 0.35, 0.35), offset = Vector3.new(-0.6, 0.4, 1.0), color = Color3.fromRGB(255, 0, 0), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.35, 0.35, 0.35), offset = Vector3.new(0.6, 0.4, 1.0), color = Color3.fromRGB(255, 0, 0), material = Enum.Material.Neon },
				-- Shoulder spikes
				{ name = "SpikeL", shape = "Block", size = Vector3.new(0.4, 1.0, 0.4), offset = Vector3.new(-2.5, 3.5, 0), color = Color3.fromRGB(80, 80, 80), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "SpikeR", shape = "Block", size = Vector3.new(0.4, 1.0, 0.4), offset = Vector3.new(2.5, 3.5, 0), color = Color3.fromRGB(80, 80, 80), bodyRelative = true, material = Enum.Material.Metal },
			},
		},
	},

	["Lake Serpent"] = {
		name        = "Lake Serpent",
		hp          = 1500,
		damage      = 45,
		level       = 65,
		xp          = 975, -- level * 15
		respawnTime = 270,
		zone        = "Safe",
		passive     = false,
		boss        = true,
		drops = {
			{ item = "Serpent Scale", chance = 0.60, minQty = 1, maxQty = 1 },
			{ item = "Sea Fang", chance = 0.50, minQty = 1, maxQty = 1 },
			{ item = "Raw Swordfish", chance = 1.00, minQty = 5, maxQty = 5 },
			{ item = "Serpent's Eye", chance = 0.30, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(0, 100, 120),
			size = Vector3.new(3, 2.5, 8), -- long serpentine body
			headSize = 2.0,
			extras = {
				-- Serpent scales
				{ name = "ScaleLayer", shape = "Block", size = Vector3.new(3.2, 2.7, 8.2), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(0, 85, 100), bodyRelative = true, material = Enum.Material.SmoothPlastic },
				-- Long tail
				{ name = "Tail1", shape = "Block", size = Vector3.new(2.5, 2.0, 6), offset = Vector3.new(0, 0, -7.0), color = Color3.fromRGB(0, 95, 110), bodyRelative = true },
				{ name = "Tail2", shape = "Block", size = Vector3.new(2.0, 1.5, 4), offset = Vector3.new(0, 0, -11.0), color = Color3.fromRGB(0, 90, 105), bodyRelative = true },
				{ name = "TailEnd", shape = "Block", size = Vector3.new(1.5, 1.0, 2), offset = Vector3.new(0, 0, -13.5), color = Color3.fromRGB(0, 85, 100), bodyRelative = true },
				-- Fins
				{ name = "FinL", shape = "Block", size = Vector3.new(0.2, 1.5, 3.0), offset = Vector3.new(-1.8, 0, -2.0), color = Color3.fromRGB(0, 120, 140), bodyRelative = true },
				{ name = "FinR", shape = "Block", size = Vector3.new(0.2, 1.5, 3.0), offset = Vector3.new(1.8, 0, -2.0), color = Color3.fromRGB(0, 120, 140), bodyRelative = true },
				-- Large serpent eyes
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.6, 0.6, 0.6), offset = Vector3.new(-0.8, 0.5, 1.2), color = Color3.fromRGB(255, 255, 0), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.6, 0.6, 0.6), offset = Vector3.new(0.8, 0.5, 1.2), color = Color3.fromRGB(255, 255, 0), material = Enum.Material.Neon },
				-- Fangs
				{ name = "FangL", shape = "Block", size = Vector3.new(0.15, 0.8, 0.15), offset = Vector3.new(-0.4, -0.3, 1.8), color = Color3.fromRGB(245, 245, 245) },
				{ name = "FangR", shape = "Block", size = Vector3.new(0.15, 0.8, 0.15), offset = Vector3.new(0.4, -0.3, 1.8), color = Color3.fromRGB(245, 245, 245) },
				-- Dorsal spines
				{ name = "Spine1", shape = "Block", size = Vector3.new(0.3, 1.0, 0.3), offset = Vector3.new(0, 1.5, 2.0), color = Color3.fromRGB(0, 70, 90), bodyRelative = true },
				{ name = "Spine2", shape = "Block", size = Vector3.new(0.3, 1.2, 0.3), offset = Vector3.new(0, 1.6, 0), color = Color3.fromRGB(0, 70, 90), bodyRelative = true },
				{ name = "Spine3", shape = "Block", size = Vector3.new(0.3, 1.0, 0.3), offset = Vector3.new(0, 1.5, -2.0), color = Color3.fromRGB(0, 70, 90), bodyRelative = true },
			},
		},
	},

	["Corrupted Guardian"] = {
		name        = "Corrupted Guardian",
		hp          = 2500,
		damage      = 60,
		level       = 80,
		xp          = 1200, -- level * 15
		respawnTime = 300,
		zone        = "Safe",
		passive     = false,
		boss        = true,
		drops = {
			{ item = "Guardian's Blessing", chance = 0.25, minQty = 1, maxQty = 1 },
			{ item = "Corrupted Plate", chance = 0.40, minQty = 1, maxQty = 1 },
			{ item = "Gold Bar", chance = 1.00, minQty = 10, maxQty = 10 },
			{ item = "Ancient Key", chance = 0.50, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(60, 60, 80),
			size = Vector3.new(4.5, 7, 3.5), -- massive corrupted guardian
			headSize = 2.2,
			extras = {
				-- Corrupted armor plating
				{ name = "CorruptedPlate", shape = "Block", size = Vector3.new(4.7, 4, 3.7), offset = Vector3.new(0, 1.5, 0), color = Color3.fromRGB(45, 45, 65), bodyRelative = true, material = Enum.Material.Metal },
				-- Massive corrupted arms
				{ name = "ArmL", shape = "Block", size = Vector3.new(1.8, 1.5, 5.5), offset = Vector3.new(-4.0, 2.5, 0), color = Color3.fromRGB(50, 50, 70), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "ArmR", shape = "Block", size = Vector3.new(1.8, 1.5, 5.5), offset = Vector3.new(4.0, 2.5, 0), color = Color3.fromRGB(50, 50, 70), bodyRelative = true, material = Enum.Material.Metal },
				-- Corrupted legs
				{ name = "LegL", shape = "Block", size = Vector3.new(1.5, 5.0, 1.5), offset = Vector3.new(-1.2, -6.0, 0), color = Color3.fromRGB(40, 40, 60), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "LegR", shape = "Block", size = Vector3.new(1.5, 5.0, 1.5), offset = Vector3.new(1.2, -6.0, 0), color = Color3.fromRGB(40, 40, 60), bodyRelative = true, material = Enum.Material.Metal },
				-- Corrupted glow core
				{ name = "CorruptedCore", shape = "Ball", size = Vector3.new(1.2, 1.2, 1.2), offset = Vector3.new(0, 1.5, 2.0), color = Color3.fromRGB(120, 0, 120), material = Enum.Material.Neon, bodyRelative = true },
				-- Glowing corrupted eyes
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(-0.7, 0.6, 1.2), color = Color3.fromRGB(120, 0, 120), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(0.7, 0.6, 1.2), color = Color3.fromRGB(120, 0, 120), material = Enum.Material.Neon },
				-- Shoulder corruption spikes
				{ name = "CorruptSpikeL", shape = "Block", size = Vector3.new(0.5, 1.5, 0.5), offset = Vector3.new(-3.0, 4.0, 0), color = Color3.fromRGB(30, 0, 30), bodyRelative = true, material = Enum.Material.Neon },
				{ name = "CorruptSpikeR", shape = "Block", size = Vector3.new(0.5, 1.5, 0.5), offset = Vector3.new(3.0, 4.0, 0), color = Color3.fromRGB(30, 0, 30), bodyRelative = true, material = Enum.Material.Neon },
				-- Corrupted energy tendrils
				{ name = "Tendril1", shape = "Ball", size = Vector3.new(0.8, 0.3, 1.5), offset = Vector3.new(2.0, 0.5, 0), color = Color3.fromRGB(80, 0, 80), material = Enum.Material.Neon, transparency = 0.4, bodyRelative = true },
				{ name = "Tendril2", shape = "Ball", size = Vector3.new(0.6, 0.4, 1.2), offset = Vector3.new(-2.2, 0.8, 0), color = Color3.fromRGB(80, 0, 80), material = Enum.Material.Neon, transparency = 0.4, bodyRelative = true },
			},
		},
	},

	----------------------------------------------------------------------------
	-- NEW AREA MONSTERS (MapSetup5)
	----------------------------------------------------------------------------

	["Pirate Ghost"] = {
		name        = "Pirate Ghost",
		hp          = 200,
		damage      = 18,
		level       = 25,
		xp          = 150,
		respawnTime = 30,
		zone        = "Safe",
		passive     = false,
		drops = {
			{ item = "Ghost Doubloon", chance = 0.30, minQty = 1, maxQty = 3 },
			{ item = "Pirate Cutlass", chance = 0.05, minQty = 1, maxQty = 1 },
			{ item = "Spectral Cloth", chance = 0.20, minQty = 1, maxQty = 2 },
		},
		model = {
			bodyColor = Color3.fromRGB(200, 220, 255),
			size = Vector3.new(2, 4, 1.5),
			headSize = 1.2,
			extras = {
				-- Ghostly transparency
				{ name = "GhostAura", shape = "Block", size = Vector3.new(2.2, 4.2, 1.7), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(180, 200, 255), bodyRelative = true, transparency = 0.4, material = Enum.Material.ForceField },
				-- Tricorn hat
				{ name = "TricornHat", shape = "Block", size = Vector3.new(2, 0.5, 2), offset = Vector3.new(0, 0.8, 0), color = Color3.fromRGB(40, 40, 40), transparency = 0.3 },
				{ name = "HatBrim", shape = "Block", size = Vector3.new(2.5, 0.2, 2.5), offset = Vector3.new(0, 0.5, 0), color = Color3.fromRGB(30, 30, 30), transparency = 0.3 },
				-- Sword arm (right)
				{ name = "SwordArm", shape = "Block", size = Vector3.new(0.6, 0.6, 3), offset = Vector3.new(1.5, 0.5, 0), color = Color3.fromRGB(180, 180, 180), bodyRelative = true, transparency = 0.2, material = Enum.Material.Metal },
				{ name = "SwordBlade", shape = "Block", size = Vector3.new(0.3, 0.3, 4), offset = Vector3.new(1.5, 0.5, 2), color = Color3.fromRGB(200, 200, 200), bodyRelative = true, transparency = 0.1, material = Enum.Material.Metal },
				-- Glowing eyes
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.2, 0.2, 0.2), offset = Vector3.new(-0.25, 0.15, 0.65), color = Color3.fromRGB(100, 200, 255), material = Enum.Material.Neon, transparency = 0.2 },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.2, 0.2, 0.2), offset = Vector3.new(0.25, 0.15, 0.65), color = Color3.fromRGB(100, 200, 255), material = Enum.Material.Neon, transparency = 0.2 },
				-- Ghostly coat
				{ name = "PirateCoat", shape = "Block", size = Vector3.new(2.2, 3, 1.6), offset = Vector3.new(0, -0.5, 0), color = Color3.fromRGB(60, 40, 80), bodyRelative = true, transparency = 0.5 },
				-- Belt with skull buckle
				{ name = "PirateBelt", shape = "Block", size = Vector3.new(2.3, 0.3, 1.7), offset = Vector3.new(0, -0.5, 0), color = Color3.fromRGB(80, 60, 40), bodyRelative = true, transparency = 0.3 },
				{ name = "SkullBuckle", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.2), offset = Vector3.new(0, -0.5, 0.9), color = Color3.fromRGB(220, 220, 200), bodyRelative = true, transparency = 0.2 },
				-- Ghostly beard
				{ name = "GhostBeard", shape = "Block", size = Vector3.new(0.8, 0.6, 0.4), offset = Vector3.new(0, -0.3, 0.5), color = Color3.fromRGB(150, 150, 150), transparency = 0.5 },
				-- Spectral particles
				{ name = "SpectralMist1", shape = "Ball", size = Vector3.new(0.8, 0.8, 0.8), offset = Vector3.new(-0.5, -2, -0.3), color = Color3.fromRGB(120, 180, 255), bodyRelative = true, transparency = 0.7, material = Enum.Material.Neon },
				{ name = "SpectralMist2", shape = "Ball", size = Vector3.new(0.6, 0.6, 0.6), offset = Vector3.new(0.7, -1.5, 0.2), color = Color3.fromRGB(100, 160, 235), bodyRelative = true, transparency = 0.8, material = Enum.Material.Neon },
			},
		},
	},

	["Ice Elemental"] = {
		name        = "Ice Elemental",
		hp          = 500,
		damage      = 28,
		level       = 40,
		xp          = 300,
		respawnTime = 45,
		zone        = "Safe",
		passive     = false,
		drops = {
			{ item = "Frozen Shard", chance = 0.40, minQty = 1, maxQty = 3 },
			{ item = "Ice Crystal", chance = 0.15, minQty = 1, maxQty = 1 },
			{ item = "Frost Essence", chance = 0.10, minQty = 1, maxQty = 1 },
			{ item = "Permafrost Ore", chance = 0.25, minQty = 1, maxQty = 2 },
		},
		model = {
			bodyColor = Color3.fromRGB(173, 216, 230),
			size = Vector3.new(2.5, 4, 2.5),
			headSize = 1.3,
			extras = {
				-- Crystalline body
				{ name = "CrystalCore", shape = "Block", size = Vector3.new(2.7, 4.2, 2.7), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(150, 200, 255), bodyRelative = true, transparency = 0.3, material = Enum.Material.Ice },
				-- Ice shards orbiting (small neon cyan parts)
				{ name = "IceShard1", shape = "Block", size = Vector3.new(0.4, 1.2, 0.4), offset = Vector3.new(2.5, 1, 0), color = Color3.fromRGB(0, 255, 255), bodyRelative = true, transparency = 0.2, material = Enum.Material.Neon },
				{ name = "IceShard2", shape = "Block", size = Vector3.new(0.4, 1, 0.4), offset = Vector3.new(-2.3, 0.5, 1), color = Color3.fromRGB(100, 255, 255), bodyRelative = true, transparency = 0.2, material = Enum.Material.Neon },
				{ name = "IceShard3", shape = "Block", size = Vector3.new(0.4, 1.1, 0.4), offset = Vector3.new(1, 2, 2.2), color = Color3.fromRGB(50, 255, 255), bodyRelative = true, transparency = 0.2, material = Enum.Material.Neon },
				{ name = "IceShard4", shape = "Block", size = Vector3.new(0.4, 0.9, 0.4), offset = Vector3.new(-1.5, -1, -2.5), color = Color3.fromRGB(0, 200, 255), bodyRelative = true, transparency = 0.2, material = Enum.Material.Neon },
				{ name = "IceShard5", shape = "Block", size = Vector3.new(0.4, 1.3, 0.4), offset = Vector3.new(0.5, -2, 1.8), color = Color3.fromRGB(70, 220, 255), bodyRelative = true, transparency = 0.2, material = Enum.Material.Neon },
				-- Cold mist base
				{ name = "ColdMist", shape = "Ball", size = Vector3.new(4, 1, 4), offset = Vector3.new(0, -2.2, 0), color = Color3.fromRGB(200, 230, 255), bodyRelative = true, transparency = 0.6, material = Enum.Material.ForceField },
				-- Jagged ice crown
				{ name = "IceCrown", shape = "Block", size = Vector3.new(1.8, 1.5, 1.8), offset = Vector3.new(0, 1, 0), color = Color3.fromRGB(180, 220, 255), transparency = 0.2, material = Enum.Material.Ice },
				{ name = "CrownSpike1", shape = "Block", size = Vector3.new(0.3, 1, 0.3), offset = Vector3.new(0, 1.8, 0.6), color = Color3.fromRGB(150, 200, 255), transparency = 0.1 },
				{ name = "CrownSpike2", shape = "Block", size = Vector3.new(0.3, 0.8, 0.3), offset = Vector3.new(-0.5, 1.7, 0.3), color = Color3.fromRGB(150, 200, 255), transparency = 0.1 },
				{ name = "CrownSpike3", shape = "Block", size = Vector3.new(0.3, 0.9, 0.3), offset = Vector3.new(0.5, 1.7, 0.3), color = Color3.fromRGB(150, 200, 255), transparency = 0.1 },
				-- Glowing eyes
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(-0.3, 0.2, 0.7), color = Color3.fromRGB(0, 255, 255), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(0.3, 0.2, 0.7), color = Color3.fromRGB(0, 255, 255), material = Enum.Material.Neon },
			},
		},
	},

	["Lava Golem"] = {
		name        = "Lava Golem",
		hp          = 900,
		damage      = 38,
		level       = 55,
		xp          = 500,
		respawnTime = 60,
		zone        = "Wilderness",
		passive     = false,
		drops = {
			{ item = "Magma Core", chance = 0.20, minQty = 1, maxQty = 1 },
			{ item = "Obsidian Shard", chance = 0.35, minQty = 1, maxQty = 3 },
			{ item = "Volcanic Ash", chance = 0.50, minQty = 2, maxQty = 5 },
			{ item = "Lava Blade", chance = 0.03, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(80, 40, 40),
			size = Vector3.new(3.5, 5, 3),
			headSize = 1.8,
			extras = {
				-- Large dark rock body
				{ name = "RockBody", shape = "Block", size = Vector3.new(3.7, 5.2, 3.2), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(60, 30, 30), bodyRelative = true, material = Enum.Material.Rock },
				-- Lava cracks (neon orange lines/parts)
				{ name = "LavaCrack1", shape = "Block", size = Vector3.new(0.2, 4, 0.2), offset = Vector3.new(1, 0, 1.7), color = Color3.fromRGB(255, 100, 0), bodyRelative = true, transparency = 0.2, material = Enum.Material.Neon },
				{ name = "LavaCrack2", shape = "Block", size = Vector3.new(0.2, 3.5, 0.2), offset = Vector3.new(-0.8, 0.5, 1.7), color = Color3.fromRGB(255, 69, 0), bodyRelative = true, transparency = 0.2, material = Enum.Material.Neon },
				{ name = "LavaCrack3", shape = "Block", size = Vector3.new(3.2, 0.2, 0.2), offset = Vector3.new(0, -1, 1.7), color = Color3.fromRGB(255, 140, 0), bodyRelative = true, transparency = 0.3, material = Enum.Material.Neon },
				{ name = "LavaCrack4", shape = "Block", size = Vector3.new(2.8, 0.2, 0.2), offset = Vector3.new(0, 1.5, 1.7), color = Color3.fromRGB(255, 100, 0), bodyRelative = true, transparency = 0.2, material = Enum.Material.Neon },
				-- Magma dripping arms
				{ name = "ArmL", shape = "Block", size = Vector3.new(1.2, 4, 1.2), offset = Vector3.new(-3, -0.5, 0), color = Color3.fromRGB(70, 35, 35), bodyRelative = true, material = Enum.Material.Rock },
				{ name = "ArmR", shape = "Block", size = Vector3.new(1.2, 4, 1.2), offset = Vector3.new(3, -0.5, 0), color = Color3.fromRGB(70, 35, 35), bodyRelative = true, material = Enum.Material.Rock },
				{ name = "MagmaDripL", shape = "Ball", size = Vector3.new(0.6, 0.8, 0.6), offset = Vector3.new(-3, -2.8, 0), color = Color3.fromRGB(255, 69, 0), bodyRelative = true, transparency = 0.3, material = Enum.Material.Neon },
				{ name = "MagmaDripR", shape = "Ball", size = Vector3.new(0.6, 0.8, 0.6), offset = Vector3.new(3, -2.8, 0), color = Color3.fromRGB(255, 69, 0), bodyRelative = true, transparency = 0.3, material = Enum.Material.Neon },
				-- Fire eyes
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(-0.4, 0.3, 1.0), color = Color3.fromRGB(255, 50, 0), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(0.4, 0.3, 1.0), color = Color3.fromRGB(255, 50, 0), material = Enum.Material.Neon },
				-- Obsidian horns
				{ name = "HornL", shape = "Block", size = Vector3.new(0.4, 1.5, 0.4), offset = Vector3.new(-0.6, 1.2, 0), color = Color3.fromRGB(20, 20, 20), material = Enum.Material.Glass },
				{ name = "HornR", shape = "Block", size = Vector3.new(0.4, 1.5, 0.4), offset = Vector3.new(0.6, 1.2, 0), color = Color3.fromRGB(20, 20, 20), material = Enum.Material.Glass },
				-- Legs
				{ name = "LegL", shape = "Block", size = Vector3.new(1.5, 3, 1.5), offset = Vector3.new(-1, -4, 0), color = Color3.fromRGB(60, 30, 30), bodyRelative = true, material = Enum.Material.Rock },
				{ name = "LegR", shape = "Block", size = Vector3.new(1.5, 3, 1.5), offset = Vector3.new(1, -4, 0), color = Color3.fromRGB(60, 30, 30), bodyRelative = true, material = Enum.Material.Rock },
			},
		},
	},

	["Fairy Dragon"] = {
		name        = "Fairy Dragon",
		hp          = 350,
		damage      = 20,
		level       = 30,
		xp          = 200,
		respawnTime = 35,
		zone        = "Safe",
		passive     = false,
		drops = {
			{ item = "Fairy Dust", chance = 0.40, minQty = 1, maxQty = 5 },
			{ item = "Dragon Scale", chance = 0.15, minQty = 1, maxQty = 1 },
			{ item = "Enchanted Petal", chance = 0.30, minQty = 1, maxQty = 3 },
			{ item = "Rainbow Gem", chance = 0.05, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(255, 20, 147),
			size = Vector3.new(2, 3, 4),
			headSize = 1.0,
			extras = {
				-- Small colorful body (pink/purple)
				{ name = "FairyBody", shape = "Block", size = Vector3.new(2.2, 3.2, 4.2), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(238, 130, 238), bodyRelative = true },
				-- Butterfly wings (thin transparent rainbow parts)
				{ name = "WingLUpper", shape = "Block", size = Vector3.new(0.1, 2.5, 3), offset = Vector3.new(-2.2, 0.5, -1), color = Color3.fromRGB(255, 0, 255), bodyRelative = true, transparency = 0.3, material = Enum.Material.Neon },
				{ name = "WingRUpper", shape = "Block", size = Vector3.new(0.1, 2.5, 3), offset = Vector3.new(2.2, 0.5, -1), color = Color3.fromRGB(255, 0, 255), bodyRelative = true, transparency = 0.3, material = Enum.Material.Neon },
				{ name = "WingLLower", shape = "Block", size = Vector3.new(0.1, 1.8, 2), offset = Vector3.new(-2.0, -1, -0.5), color = Color3.fromRGB(0, 255, 255), bodyRelative = true, transparency = 0.3, material = Enum.Material.Neon },
				{ name = "WingRLower", shape = "Block", size = Vector3.new(0.1, 1.8, 2), offset = Vector3.new(2.0, -1, -0.5), color = Color3.fromRGB(0, 255, 255), bodyRelative = true, transparency = 0.3, material = Enum.Material.Neon },
				-- Sparkle trail
				{ name = "Sparkle1", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(-0.5, 0.5, -2.5), color = Color3.fromRGB(255, 255, 0), bodyRelative = true, transparency = 0.2, material = Enum.Material.Neon },
				{ name = "Sparkle2", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(0.3, -0.3, -3), color = Color3.fromRGB(255, 0, 255), bodyRelative = true, transparency = 0.3, material = Enum.Material.Neon },
				{ name = "Sparkle3", shape = "Ball", size = Vector3.new(0.2, 0.2, 0.2), offset = Vector3.new(0, 1, -2), color = Color3.fromRGB(0, 255, 255), bodyRelative = true, transparency = 0.4, material = Enum.Material.Neon },
				-- Cute face
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(-0.25, 0.2, 0.6), color = Color3.fromRGB(0, 255, 0), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(0.25, 0.2, 0.6), color = Color3.fromRGB(0, 255, 0), material = Enum.Material.Neon },
				-- Small horns
				{ name = "HornL", shape = "Block", size = Vector3.new(0.2, 0.6, 0.2), offset = Vector3.new(-0.3, 0.7, 0.2), color = Color3.fromRGB(255, 215, 0) },
				{ name = "HornR", shape = "Block", size = Vector3.new(0.2, 0.6, 0.2), offset = Vector3.new(0.3, 0.7, 0.2), color = Color3.fromRGB(255, 215, 0) },
				-- Tail
				{ name = "Tail", shape = "Block", size = Vector3.new(0.8, 0.8, 3), offset = Vector3.new(0, 0, -3.5), color = Color3.fromRGB(255, 105, 180), bodyRelative = true },
				{ name = "TailTip", shape = "Ball", size = Vector3.new(0.6, 0.6, 0.6), offset = Vector3.new(0, 0, -5.2), color = Color3.fromRGB(255, 255, 0), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.2 },
			},
		},
	},

	["Ancient Guardian"] = {
		name        = "Ancient Guardian",
		hp          = 2000,
		damage      = 50,
		level       = 70,
		xp          = 800,
		respawnTime = 90,
		zone        = "Wilderness",
		passive     = false,
		boss        = true,
		drops = {
			{ item = "Ancient Relic", chance = 0.25, minQty = 1, maxQty = 1 },
			{ item = "Guardian Essence", chance = 0.15, minQty = 1, maxQty = 1 },
			{ item = "Rune of Power", chance = 0.05, minQty = 1, maxQty = 1 },
			{ item = "Ancient Armor", chance = 0.03, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(105, 105, 105),
			size = Vector3.new(6, 8, 4), -- MASSIVE size (4x normal)
			headSize = 2.5,
			extras = {
				-- MASSIVE stone construct
				{ name = "StoneBody", shape = "Block", size = Vector3.new(6.5, 8.5, 4.5), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(85, 85, 85), bodyRelative = true, material = Enum.Material.Cobblestone },
				-- Glowing rune eyes (neon green)
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.8, 0.8, 0.8), offset = Vector3.new(-0.8, 0.5, 1.4), color = Color3.fromRGB(0, 255, 0), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.8, 0.8, 0.8), offset = Vector3.new(0.8, 0.5, 1.4), color = Color3.fromRGB(0, 255, 0), material = Enum.Material.Neon },
				-- Cracked stone texture
				{ name = "Crack1", shape = "Block", size = Vector3.new(0.3, 6, 0.3), offset = Vector3.new(1.5, 0, 2.4), color = Color3.fromRGB(40, 40, 40), bodyRelative = true },
				{ name = "Crack2", shape = "Block", size = Vector3.new(5, 0.3, 0.3), offset = Vector3.new(0, 2, 2.4), color = Color3.fromRGB(40, 40, 40), bodyRelative = true },
				{ name = "Crack3", shape = "Block", size = Vector3.new(0.3, 5, 0.3), offset = Vector3.new(-2, -1, 2.4), color = Color3.fromRGB(40, 40, 40), bodyRelative = true },
				-- Floating stone pieces orbiting
				{ name = "FloatStone1", shape = "Ball", size = Vector3.new(1.2, 1.2, 1.2), offset = Vector3.new(4, 2, 1), color = Color3.fromRGB(120, 120, 120), bodyRelative = true, material = Enum.Material.Rock, transparency = 0.1 },
				{ name = "FloatStone2", shape = "Ball", size = Vector3.new(1, 1, 1), offset = Vector3.new(-4.5, 1, -1), color = Color3.fromRGB(110, 110, 110), bodyRelative = true, material = Enum.Material.Rock, transparency = 0.1 },
				{ name = "FloatStone3", shape = "Ball", size = Vector3.new(0.8, 0.8, 0.8), offset = Vector3.new(2, 4, -2), color = Color3.fromRGB(100, 100, 100), bodyRelative = true, material = Enum.Material.Rock, transparency = 0.1 },
				{ name = "FloatStone4", shape = "Ball", size = Vector3.new(1.1, 1.1, 1.1), offset = Vector3.new(-3, -3, 2), color = Color3.fromRGB(130, 130, 130), bodyRelative = true, material = Enum.Material.Rock, transparency = 0.1 },
				-- Ancient weapon arms
				{ name = "WeaponArmL", shape = "Block", size = Vector3.new(1.8, 1.8, 6), offset = Vector3.new(-4.5, 1, 0), color = Color3.fromRGB(80, 80, 80), bodyRelative = true, material = Enum.Material.Cobblestone },
				{ name = "WeaponArmR", shape = "Block", size = Vector3.new(1.8, 1.8, 6), offset = Vector3.new(4.5, 1, 0), color = Color3.fromRGB(80, 80, 80), bodyRelative = true, material = Enum.Material.Cobblestone },
				{ name = "AncientMaceL", shape = "Ball", size = Vector3.new(2.5, 2.5, 2.5), offset = Vector3.new(-4.5, 1, 4), color = Color3.fromRGB(60, 60, 60), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "AncientMaceR", shape = "Ball", size = Vector3.new(2.5, 2.5, 2.5), offset = Vector3.new(4.5, 1, 4), color = Color3.fromRGB(60, 60, 60), bodyRelative = true, material = Enum.Material.Metal },
				-- Ancient legs
				{ name = "LegL", shape = "Block", size = Vector3.new(2, 6, 2), offset = Vector3.new(-1.5, -7, 0), color = Color3.fromRGB(90, 90, 90), bodyRelative = true, material = Enum.Material.Cobblestone },
				{ name = "LegR", shape = "Block", size = Vector3.new(2, 6, 2), offset = Vector3.new(1.5, -7, 0), color = Color3.fromRGB(90, 90, 90), bodyRelative = true, material = Enum.Material.Cobblestone },
				-- Runes on body
				{ name = "BodyRune1", shape = "Block", size = Vector3.new(1, 1, 0.2), offset = Vector3.new(0, 1, 2.4), color = Color3.fromRGB(0, 255, 0), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.3 },
				{ name = "BodyRune2", shape = "Block", size = Vector3.new(0.8, 0.8, 0.2), offset = Vector3.new(-1.5, -1, 2.4), color = Color3.fromRGB(0, 200, 0), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
				{ name = "BodyRune3", shape = "Ball", size = Vector3.new(1.2, 1.2, 0.2), offset = Vector3.new(1.8, 0, 2.4), color = Color3.fromRGB(50, 255, 50), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.2 },
			},
		},
	},

	["Frost Wyrm"] = {
		name        = "Frost Wyrm",
		hp          = 1200,
		damage      = 42,
		level       = 60,
		xp          = 600,
		respawnTime = 80,
		zone        = "Safe",
		passive     = false,
		boss        = true,
		drops = {
			{ item = "Wyrm Scale", chance = 0.30, minQty = 1, maxQty = 3 },
			{ item = "Frozen Heart", chance = 0.10, minQty = 1, maxQty = 1 },
			{ name = "Ice Fang", chance = 0.05, minQty = 1, maxQty = 1 },
			{ item = "Frost Armor", chance = 0.08, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(173, 216, 230),
			size = Vector3.new(3, 3, 8), -- long serpentine body
			headSize = 1.8,
			extras = {
				-- Long serpentine body (multiple connected light blue parts)
				{ name = "WyrmSegment1", shape = "Block", size = Vector3.new(2.8, 2.8, 6), offset = Vector3.new(0, 0, -7), color = Color3.fromRGB(150, 200, 255), bodyRelative = true, material = Enum.Material.Ice, transparency = 0.1 },
				{ name = "WyrmSegment2", shape = "Block", size = Vector3.new(2.5, 2.5, 5), offset = Vector3.new(0, 0, -12.5), color = Color3.fromRGB(140, 190, 245), bodyRelative = true, material = Enum.Material.Ice, transparency = 0.1 },
				{ name = "WyrmSegment3", shape = "Block", size = Vector3.new(2.2, 2.2, 4), offset = Vector3.new(0, 0, -17), color = Color3.fromRGB(130, 180, 235), bodyRelative = true, material = Enum.Material.Ice, transparency = 0.1 },
				{ name = "WyrmTail", shape = "Block", size = Vector3.new(1.8, 1.8, 3), offset = Vector3.new(0, 0, -20.5), color = Color3.fromRGB(120, 170, 225), bodyRelative = true, material = Enum.Material.Ice, transparency = 0.1 },
				-- Ice horns
				{ name = "IceHornL", shape = "Block", size = Vector3.new(0.5, 2, 0.5), offset = Vector3.new(-0.7, 1.5, 0.3), color = Color3.fromRGB(200, 230, 255), material = Enum.Material.Ice, transparency = 0.1 },
				{ name = "IceHornR", shape = "Block", size = Vector3.new(0.5, 2, 0.5), offset = Vector3.new(0.7, 1.5, 0.3), color = Color3.fromRGB(200, 230, 255), material = Enum.Material.Ice, transparency = 0.1 },
				-- Frost breath particles
				{ name = "FrostBreath1", shape = "Ball", size = Vector3.new(1.5, 1, 1.5), offset = Vector3.new(-0.3, -0.2, 2.5), color = Color3.fromRGB(220, 240, 255), material = Enum.Material.Neon, transparency = 0.5 },
				{ name = "FrostBreath2", shape = "Ball", size = Vector3.new(1.2, 0.8, 1.2), offset = Vector3.new(0.2, 0.1, 3.2), color = Color3.fromRGB(200, 220, 255), material = Enum.Material.Neon, transparency = 0.6 },
				{ name = "FrostBreath3", shape = "Ball", size = Vector3.new(0.8, 0.6, 0.8), offset = Vector3.new(0, -0.3, 4), color = Color3.fromRGB(180, 200, 255), material = Enum.Material.Neon, transparency = 0.7 },
				-- Crystal scales
				{ name = "CrystalScale1", shape = "Block", size = Vector3.new(0.6, 0.6, 0.3), offset = Vector3.new(1.2, 0.8, 1), color = Color3.fromRGB(180, 220, 255), material = Enum.Material.Ice, transparency = 0.2 },
				{ name = "CrystalScale2", shape = "Block", size = Vector3.new(0.5, 0.5, 0.3), offset = Vector3.new(-1.3, 0.9, -1), color = Color3.fromRGB(170, 210, 245), material = Enum.Material.Ice, transparency = 0.2 },
				{ name = "CrystalScale3", shape = "Block", size = Vector3.new(0.7, 0.7, 0.3), offset = Vector3.new(0, 1.2, -3), color = Color3.fromRGB(190, 230, 255), material = Enum.Material.Ice, transparency = 0.2 },
				-- Ice tail spike
				{ name = "TailSpike", shape = "Block", size = Vector3.new(1, 1, 2.5), offset = Vector3.new(0, 0, -22.7), color = Color3.fromRGB(150, 190, 230), bodyRelative = true, material = Enum.Material.Ice, transparency = 0.1 },
				-- Glowing eyes
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(-0.5, 0.3, 1.0), color = Color3.fromRGB(100, 200, 255), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(0.5, 0.3, 1.0), color = Color3.fromRGB(100, 200, 255), material = Enum.Material.Neon },
			},
		},
	},
	["Lich King Malachar"] = {
		name        = "Lich King Malachar",
		hp          = 4000,
		damage      = 75,
		level       = 90,
		xp          = 1350,
		respawnTime = 600,
		zone        = "Wilderness",
		passive     = false,
		boss        = true,
		drops = {
			{ item = "Lich Crown",     chance = 0.03, minQty = 1, maxQty = 1 },
			{ item = "Soul Staff",     chance = 0.02, minQty = 1, maxQty = 1 },
			{ item = "Dark Essence",   chance = 0.15, minQty = 1, maxQty = 1 },
			{ item = "Necrotic Robe",  chance = 0.05, minQty = 1, maxQty = 1 },
			{ item = "Bone Dust",      chance = 0.40, minQty = 5, maxQty = 5 },
			{ item = "Shadow Gem",     chance = 0.10, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(20, 20, 30),
			size = Vector3.new(3, 6, 2),
			headSize = 1.5,
			extras = {
				-- SKELETAL BODY: Gaunt undead form visible through robes
				{ name = "Ribcage", shape = "Block", size = Vector3.new(2.5, 3, 1.5), offset = Vector3.new(0, 1, 0), color = Color3.fromRGB(200, 195, 180), bodyRelative = true },
				{ name = "Rib1", shape = "Block", size = Vector3.new(2.8, 0.12, 0.8), offset = Vector3.new(0, 2.0, 0), color = Color3.fromRGB(210, 205, 190), bodyRelative = true },
				{ name = "Rib2", shape = "Block", size = Vector3.new(2.8, 0.12, 0.8), offset = Vector3.new(0, 1.5, 0), color = Color3.fromRGB(210, 205, 190), bodyRelative = true },
				{ name = "Rib3", shape = "Block", size = Vector3.new(2.8, 0.12, 0.8), offset = Vector3.new(0, 1.0, 0), color = Color3.fromRGB(210, 205, 190), bodyRelative = true },
				{ name = "Spine", shape = "Block", size = Vector3.new(0.4, 5, 0.4), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(200, 195, 180), bodyRelative = true },
				-- DARK ROBES: Flowing tattered robes
				{ name = "RobeUpper", shape = "Block", size = Vector3.new(3.5, 4, 2.5), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(15, 10, 25), bodyRelative = true, material = Enum.Material.Fabric },
				{ name = "RobeSkirt", shape = "Block", size = Vector3.new(4, 3, 3), offset = Vector3.new(0, -3.5, 0), color = Color3.fromRGB(12, 8, 20), bodyRelative = true, material = Enum.Material.Fabric },
				{ name = "RobeHem", shape = "Block", size = Vector3.new(4.5, 0.3, 3.5), offset = Vector3.new(0, -5, 0), color = Color3.fromRGB(8, 5, 15), bodyRelative = true, material = Enum.Material.Fabric },
				{ name = "RobeTrim", shape = "Block", size = Vector3.new(0.15, 5, 0.1), offset = Vector3.new(0, -2, 1.3), color = Color3.fromRGB(60, 0, 80), bodyRelative = true },
				-- HOOD: Oversized dark hood
				{ name = "Hood", shape = "Block", size = Vector3.new(2.0, 1.2, 1.8), offset = Vector3.new(0, 0.8, -0.2), color = Color3.fromRGB(12, 8, 22) },
				{ name = "HoodPeak", shape = "Block", size = Vector3.new(1.2, 0.8, 1.0), offset = Vector3.new(0, 1.5, -0.3), color = Color3.fromRGB(8, 5, 18) },
				-- SKULL FACE: Skeletal head with glowing green eyes
				{ name = "SkullFace", shape = "Block", size = Vector3.new(1.0, 1.0, 0.6), offset = Vector3.new(0, 0, 0.5), color = Color3.fromRGB(220, 215, 200) },
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.35, 0.35, 0.35), offset = Vector3.new(-0.3, 0.2, 0.8), color = Color3.fromRGB(0, 255, 80), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.35, 0.35, 0.35), offset = Vector3.new(0.3, 0.2, 0.8), color = Color3.fromRGB(0, 255, 80), material = Enum.Material.Neon },
				{ name = "JawBone", shape = "Block", size = Vector3.new(0.8, 0.25, 0.5), offset = Vector3.new(0, -0.4, 0.5), color = Color3.fromRGB(210, 205, 190) },
				-- CROWN OF BONES: Jagged bone crown
				{ name = "CrownBase", shape = "Block", size = Vector3.new(1.6, 0.2, 1.6), offset = Vector3.new(0, 0.6, 0), color = Color3.fromRGB(200, 195, 175) },
				{ name = "CrownSpike1", shape = "Block", size = Vector3.new(0.12, 0.8, 0.12), offset = Vector3.new(0, 1.1, 0.6), color = Color3.fromRGB(200, 195, 175) },
				{ name = "CrownSpike2", shape = "Block", size = Vector3.new(0.12, 1.0, 0.12), offset = Vector3.new(0.5, 1.2, 0.3), color = Color3.fromRGB(200, 195, 175) },
				{ name = "CrownSpike3", shape = "Block", size = Vector3.new(0.12, 0.9, 0.12), offset = Vector3.new(-0.5, 1.15, 0.3), color = Color3.fromRGB(200, 195, 175) },
				{ name = "CrownSpike4", shape = "Block", size = Vector3.new(0.12, 0.7, 0.12), offset = Vector3.new(0.5, 1.0, -0.3), color = Color3.fromRGB(200, 195, 175) },
				{ name = "CrownSpike5", shape = "Block", size = Vector3.new(0.12, 0.85, 0.12), offset = Vector3.new(-0.5, 1.1, -0.3), color = Color3.fromRGB(200, 195, 175) },
				{ name = "CrownGem", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(0, 1.15, 0.65), color = Color3.fromRGB(0, 255, 80), material = Enum.Material.Neon },
				-- STAFF WITH SKULL: Held in right hand
				{ name = "Staff", shape = "Block", size = Vector3.new(0.3, 7, 0.3), offset = Vector3.new(2.0, 0.5, 0), color = Color3.fromRGB(40, 20, 15), bodyRelative = true, material = Enum.Material.Wood },
				{ name = "StaffSkull", shape = "Ball", size = Vector3.new(0.8, 0.8, 0.8), offset = Vector3.new(2.0, 4.3, 0), color = Color3.fromRGB(220, 215, 200), bodyRelative = true },
				{ name = "StaffSkullGlow", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(2.0, 4.3, 0.4), color = Color3.fromRGB(0, 255, 80), bodyRelative = true, material = Enum.Material.Neon },
				{ name = "StaffRing1", shape = "Block", size = Vector3.new(0.5, 0.1, 0.5), offset = Vector3.new(2.0, 3.5, 0), color = Color3.fromRGB(80, 60, 30), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "StaffRing2", shape = "Block", size = Vector3.new(0.5, 0.1, 0.5), offset = Vector3.new(2.0, 2.5, 0), color = Color3.fromRGB(80, 60, 30), bodyRelative = true, material = Enum.Material.Metal },
				-- FLOATING SPELL BOOK: In left hand, open and glowing
				{ name = "SpellBookL", shape = "Block", size = Vector3.new(0.08, 1.0, 0.8), offset = Vector3.new(-2.0, 0.5, 0.5), color = Color3.fromRGB(40, 15, 15), bodyRelative = true },
				{ name = "SpellBookR", shape = "Block", size = Vector3.new(0.08, 1.0, 0.8), offset = Vector3.new(-1.85, 0.5, 0.5), color = Color3.fromRGB(40, 15, 15), bodyRelative = true },
				{ name = "SpellBookPages", shape = "Block", size = Vector3.new(0.03, 0.9, 0.75), offset = Vector3.new(-1.93, 0.5, 0.5), color = Color3.fromRGB(0, 200, 60), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.3 },
				-- SOUL ORBS: 3 orbiting spectral green orbs
				{ name = "SoulOrb1", shape = "Ball", size = Vector3.new(0.7, 0.7, 0.7), offset = Vector3.new(2.5, 3, 1.5), color = Color3.fromRGB(0, 255, 80), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.3 },
				{ name = "SoulOrb2", shape = "Ball", size = Vector3.new(0.6, 0.6, 0.6), offset = Vector3.new(-2.8, 2, -1), color = Color3.fromRGB(0, 220, 60), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.35 },
				{ name = "SoulOrb3", shape = "Ball", size = Vector3.new(0.5, 0.5, 0.5), offset = Vector3.new(0.5, 4, -0.5), color = Color3.fromRGB(0, 200, 50), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
				{ name = "SoulTrail1", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.8), offset = Vector3.new(2.0, 2.8, 1.0), color = Color3.fromRGB(0, 180, 50), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.6 },
				{ name = "SoulTrail2", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.6), offset = Vector3.new(-2.3, 1.8, -0.5), color = Color3.fromRGB(0, 180, 50), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.65 },
				-- SKELETAL ARMS: Bony arms reaching from robes
				{ name = "ArmL", shape = "Block", size = Vector3.new(0.3, 3.5, 0.3), offset = Vector3.new(-1.8, -0.5, 0), color = Color3.fromRGB(200, 195, 180), bodyRelative = true },
				{ name = "ArmR", shape = "Block", size = Vector3.new(0.3, 3.5, 0.3), offset = Vector3.new(1.8, -0.5, 0), color = Color3.fromRGB(200, 195, 180), bodyRelative = true },
				{ name = "HandL", shape = "Block", size = Vector3.new(0.4, 0.3, 0.4), offset = Vector3.new(-1.8, -2.5, 0.3), color = Color3.fromRGB(200, 195, 180), bodyRelative = true },
				{ name = "HandR", shape = "Block", size = Vector3.new(0.4, 0.3, 0.4), offset = Vector3.new(1.8, -2.5, 0.3), color = Color3.fromRGB(200, 195, 180), bodyRelative = true },
				-- NECROTIC ENERGY: Green magic circle at feet
				{ name = "MagicCircle", shape = "Block", size = Vector3.new(6, 0.05, 6), offset = Vector3.new(0, -5.2, 0), color = Color3.fromRGB(0, 180, 50), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
				{ name = "MagicInner", shape = "Ball", size = Vector3.new(4, 0.08, 4), offset = Vector3.new(0, -5.18, 0), color = Color3.fromRGB(0, 150, 40), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.5 },
				-- DEATH MIST: Swirling dark green fog
				{ name = "DeathMist1", shape = "Ball", size = Vector3.new(3, 1.5, 3), offset = Vector3.new(1, -4, 1), color = Color3.fromRGB(0, 80, 30), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.7 },
				{ name = "DeathMist2", shape = "Ball", size = Vector3.new(2.5, 1, 2.5), offset = Vector3.new(-1.5, -4.5, -1), color = Color3.fromRGB(0, 60, 20), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.75 },
				-- SHOULDER PAULDRONS: Dark armor on shoulders
				{ name = "PauldronL", shape = "Block", size = Vector3.new(1.2, 0.6, 1.2), offset = Vector3.new(-2.2, 2.5, 0), color = Color3.fromRGB(30, 20, 40), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "PauldronR", shape = "Block", size = Vector3.new(1.2, 0.6, 1.2), offset = Vector3.new(2.2, 2.5, 0), color = Color3.fromRGB(30, 20, 40), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "PauldronSpikeL", shape = "Block", size = Vector3.new(0.15, 0.6, 0.15), offset = Vector3.new(-2.2, 3.2, 0), color = Color3.fromRGB(200, 195, 175), bodyRelative = true },
				{ name = "PauldronSpikeR", shape = "Block", size = Vector3.new(0.15, 0.6, 0.15), offset = Vector3.new(2.2, 3.2, 0), color = Color3.fromRGB(200, 195, 175), bodyRelative = true },
			},
		},
	},
	----------------------------------------------------------------------------
	-- CRIMSON WARLORD â€” Mid-tier Safe Zone Centerpiece Boss (Lv55)
	-- A towering armored warrior king wielding a massive greatsword.
	-- Crimson/black armor with glowing red accents, battle-worn cape,
	-- horned crown, and a burning aura. THE mid-game boss to farm.
	----------------------------------------------------------------------------
	["Crimson Warlord"] = {
		name        = "Crimson Warlord",
		hp          = 1800,
		damage      = 45,
		level       = 55,
		xp          = 825,
		respawnTime = 180,
		zone        = "Safe",
		passive     = false,
		boss        = true,
		drops = {
			-- Signature drops â€” powerful Lv50 gear
			{ item = "Warlord's Greatsword",  chance = 0.20, minQty = 1, maxQty = 1 },
			{ item = "Crimson Platebody",     chance = 0.18, minQty = 1, maxQty = 1 },
			{ item = "Crimson Platelegs",     chance = 0.22, minQty = 1, maxQty = 1 },
			{ item = "Warlord's Helm",        chance = 0.15, minQty = 1, maxQty = 1 },
			{ item = "Crimson Cape",          chance = 0.08, minQty = 1, maxQty = 1 },
			{ item = "Warlord's Shield",      chance = 0.12, minQty = 1, maxQty = 1 },
			-- Common drops
			{ item = "Gold Bar",              chance = 1.00, minQty = 5, maxQty = 12 },
			{ item = "Lobster",               chance = 0.80, minQty = 3, maxQty = 5 },
			{ item = "Iron Ore",              chance = 0.60, minQty = 5, maxQty = 10 },
			{ item = "Blood Rune",            chance = 0.35, minQty = 1, maxQty = 3 },
		},
		model = {
			bodyColor = Color3.fromRGB(100, 20, 20),
			size = Vector3.new(4, 5.5, 3),
			headSize = 1.8,
			elevation = 3,
			extras = {
				-- === ARMOR PLATING (layered over body) ===
				{ name = "ChestPlate", shape = "Block", size = Vector3.new(4.3, 4, 3.3), offset = Vector3.new(0, 0.5, 0), color = Color3.fromRGB(40, 8, 8), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "AbdomenPlate", shape = "Block", size = Vector3.new(3.8, 2, 2.8), offset = Vector3.new(0, -1.5, 0), color = Color3.fromRGB(30, 5, 5), bodyRelative = true, material = Enum.Material.Metal },

				-- === MASSIVE LEGS ===
				-- Upper legs (thighs)
				{ name = "ThighL", shape = "Block", size = Vector3.new(1.6, 3, 1.6), offset = Vector3.new(-1.2, -4.5, 0), color = Color3.fromRGB(35, 8, 8), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "ThighR", shape = "Block", size = Vector3.new(1.6, 3, 1.6), offset = Vector3.new(1.2, -4.5, 0), color = Color3.fromRGB(35, 8, 8), bodyRelative = true, material = Enum.Material.Metal },
				-- Lower legs (greaves)
				{ name = "GreaveL", shape = "Block", size = Vector3.new(1.4, 3, 1.4), offset = Vector3.new(-1.2, -7.5, 0), color = Color3.fromRGB(50, 12, 12), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "GreaveR", shape = "Block", size = Vector3.new(1.4, 3, 1.4), offset = Vector3.new(1.2, -7.5, 0), color = Color3.fromRGB(50, 12, 12), bodyRelative = true, material = Enum.Material.Metal },
				-- Boots (wide base)
				{ name = "BootL", shape = "Block", size = Vector3.new(1.6, 1, 2), offset = Vector3.new(-1.2, -9.5, 0.2), color = Color3.fromRGB(25, 5, 5), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "BootR", shape = "Block", size = Vector3.new(1.6, 1, 2), offset = Vector3.new(1.2, -9.5, 0.2), color = Color3.fromRGB(25, 5, 5), bodyRelative = true, material = Enum.Material.Metal },

				-- === MASSIVE ARMS ===
				-- Shoulder pauldrons (huge spiked)
				{ name = "PauldronL", shape = "Block", size = Vector3.new(2.2, 1.2, 2.2), offset = Vector3.new(-3.2, 2.5, 0), color = Color3.fromRGB(50, 10, 10), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "PauldronR", shape = "Block", size = Vector3.new(2.2, 1.2, 2.2), offset = Vector3.new(3.2, 2.5, 0), color = Color3.fromRGB(50, 10, 10), bodyRelative = true, material = Enum.Material.Metal },
				-- Pauldron spikes
				{ name = "SpikeL1", shape = "Block", size = Vector3.new(0.3, 1.5, 0.3), offset = Vector3.new(-3.5, 3.8, 0), color = Color3.fromRGB(180, 30, 30), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "SpikeR1", shape = "Block", size = Vector3.new(0.3, 1.5, 0.3), offset = Vector3.new(3.5, 3.8, 0), color = Color3.fromRGB(180, 30, 30), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "SpikeL2", shape = "Block", size = Vector3.new(0.2, 1.0, 0.2), offset = Vector3.new(-3.8, 3.5, 0.5), color = Color3.fromRGB(160, 25, 25), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "SpikeR2", shape = "Block", size = Vector3.new(0.2, 1.0, 0.2), offset = Vector3.new(3.8, 3.5, 0.5), color = Color3.fromRGB(160, 25, 25), bodyRelative = true, material = Enum.Material.Metal },
				-- Upper arms
				{ name = "ArmUpL", shape = "Block", size = Vector3.new(1.4, 2.5, 1.4), offset = Vector3.new(-3.2, 0, 0), color = Color3.fromRGB(40, 8, 8), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "ArmUpR", shape = "Block", size = Vector3.new(1.4, 2.5, 1.4), offset = Vector3.new(3.2, 0, 0), color = Color3.fromRGB(40, 8, 8), bodyRelative = true, material = Enum.Material.Metal },
				-- Gauntlets (forearms)
				{ name = "GauntletL", shape = "Block", size = Vector3.new(1.2, 2.5, 1.2), offset = Vector3.new(-3.2, -2.5, 0.5), color = Color3.fromRGB(55, 12, 12), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "GauntletR", shape = "Block", size = Vector3.new(1.2, 2.5, 1.2), offset = Vector3.new(3.2, -2.5, 0.5), color = Color3.fromRGB(55, 12, 12), bodyRelative = true, material = Enum.Material.Metal },

				-- === THE GREATSWORD (right hand, massive) ===
				-- Handle
				{ name = "SwordHandle", shape = "Block", size = Vector3.new(0.3, 2.5, 0.3), offset = Vector3.new(3.5, -4.5, 1.5), color = Color3.fromRGB(60, 30, 15), bodyRelative = true, material = Enum.Material.Wood },
				-- Crossguard
				{ name = "SwordGuard", shape = "Block", size = Vector3.new(2.5, 0.4, 0.5), offset = Vector3.new(3.5, -3.0, 1.5), color = Color3.fromRGB(180, 30, 30), bodyRelative = true, material = Enum.Material.Metal },
				-- Blade (long and wide)
				{ name = "SwordBlade", shape = "Block", size = Vector3.new(0.8, 6, 0.15), offset = Vector3.new(3.5, 0.5, 1.5), color = Color3.fromRGB(200, 200, 210), bodyRelative = true, material = Enum.Material.Metal },
				-- Blade edge glow
				{ name = "SwordGlow", shape = "Block", size = Vector3.new(0.4, 5.5, 0.08), offset = Vector3.new(3.5, 0.5, 1.58), color = Color3.fromRGB(255, 40, 40), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.3 },
				-- Blade tip
				{ name = "SwordTip", shape = "Block", size = Vector3.new(0.5, 1, 0.15), offset = Vector3.new(3.5, 3.8, 1.5), color = Color3.fromRGB(200, 200, 210), bodyRelative = true, material = Enum.Material.Metal, rotation = Vector3.new(0, 0, 15) },

				-- === SHIELD (left hand) ===
				{ name = "ShieldFace", shape = "Block", size = Vector3.new(0.4, 3.5, 2.5), offset = Vector3.new(-3.8, -2, 1), color = Color3.fromRGB(40, 8, 8), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "ShieldBoss", shape = "Ball", size = Vector3.new(0.8, 0.8, 0.8), offset = Vector3.new(-4.1, -1.5, 1), color = Color3.fromRGB(180, 30, 30), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "ShieldRim", shape = "Block", size = Vector3.new(0.1, 3.8, 2.8), offset = Vector3.new(-4.2, -2, 1), color = Color3.fromRGB(180, 30, 30), bodyRelative = true, material = Enum.Material.Metal },

				-- === HORNED CROWN ===
				{ name = "CrownBase", shape = "Block", size = Vector3.new(2.2, 0.6, 2.2), offset = Vector3.new(0, 1.5, 0), color = Color3.fromRGB(180, 30, 30), material = Enum.Material.Metal },
				{ name = "CrownHornL", shape = "Block", size = Vector3.new(0.25, 1.8, 0.25), offset = Vector3.new(-0.8, 2.8, 0), color = Color3.fromRGB(30, 5, 5), material = Enum.Material.Metal, rotation = Vector3.new(0, 0, -15) },
				{ name = "CrownHornR", shape = "Block", size = Vector3.new(0.25, 1.8, 0.25), offset = Vector3.new(0.8, 2.8, 0), color = Color3.fromRGB(30, 5, 5), material = Enum.Material.Metal, rotation = Vector3.new(0, 0, 15) },
				{ name = "CrownGem", shape = "Ball", size = Vector3.new(0.5, 0.5, 0.5), offset = Vector3.new(0, 1.8, 1.0), color = Color3.fromRGB(255, 20, 20), material = Enum.Material.Neon },

				-- === GLOWING RED EYES ===
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(-0.5, 0.4, 1.0), color = Color3.fromRGB(255, 0, 0), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(0.5, 0.4, 1.0), color = Color3.fromRGB(255, 0, 0), material = Enum.Material.Neon },

				-- === BATTLE CAPE (flowing behind) ===
				{ name = "CapeTop", shape = "Block", size = Vector3.new(3.5, 2, 0.2), offset = Vector3.new(0, 1, -1.8), color = Color3.fromRGB(120, 15, 15), bodyRelative = true, material = Enum.Material.Fabric },
				{ name = "CapeMid", shape = "Block", size = Vector3.new(3.2, 3, 0.15), offset = Vector3.new(0, -1.5, -2.2), color = Color3.fromRGB(100, 12, 12), bodyRelative = true, material = Enum.Material.Fabric },
				{ name = "CapeBottom", shape = "Block", size = Vector3.new(2.8, 2, 0.1), offset = Vector3.new(0, -4, -2.5), color = Color3.fromRGB(80, 10, 10), bodyRelative = true, material = Enum.Material.Fabric },
				-- Cape trim (gold)
				{ name = "CapeTrimBottom", shape = "Block", size = Vector3.new(3.0, 0.15, 0.12), offset = Vector3.new(0, -5, -2.5), color = Color3.fromRGB(255, 200, 50), bodyRelative = true, material = Enum.Material.Metal },

				-- === CRIMSON AURA (ground effect) ===
				{ name = "AuraRing", shape = "Block", size = Vector3.new(8, 0.1, 8), offset = Vector3.new(0, -9.8, 0), color = Color3.fromRGB(180, 0, 0), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.5 },
				{ name = "AuraInner", shape = "Ball", size = Vector3.new(6, 0.15, 6), offset = Vector3.new(0, -9.75, 0), color = Color3.fromRGB(255, 30, 30), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.6 },
				-- Floating embers around body
				{ name = "Ember1", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(2, 3.5, 1.5), color = Color3.fromRGB(255, 100, 0), bodyRelative = true, material = Enum.Material.Neon },
				{ name = "Ember2", shape = "Ball", size = Vector3.new(0.25, 0.25, 0.25), offset = Vector3.new(-1.5, 4, -1), color = Color3.fromRGB(255, 60, 0), bodyRelative = true, material = Enum.Material.Neon },
				{ name = "Ember3", shape = "Ball", size = Vector3.new(0.2, 0.2, 0.2), offset = Vector3.new(0.5, 5, 0.8), color = Color3.fromRGB(255, 150, 30), bodyRelative = true, material = Enum.Material.Neon },

				-- === BELT WITH SKULL BUCKLE ===
				{ name = "Belt", shape = "Block", size = Vector3.new(4.1, 0.5, 3.1), offset = Vector3.new(0, -0.8, 0), color = Color3.fromRGB(60, 30, 15), bodyRelative = true, material = Enum.Material.Leather },
				{ name = "BeltBuckle", shape = "Ball", size = Vector3.new(0.7, 0.7, 0.7), offset = Vector3.new(0, -0.8, 1.6), color = Color3.fromRGB(255, 200, 50), bodyRelative = true, material = Enum.Material.Metal },
			},
		},
	},
}

return MonsterDatabase
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="10">
        <Properties>
          <string name="Name">QuestDatabase</string>
          <string name="Source"><![CDATA[local QuestDatabase = {}

QuestDatabase.Quests = {
	{
		id = "quest_01",
		name = "A New Arrival",
		giver = "Aldric",
		level = 1,
		description = "Prove your worth by gathering basic supplies for the village of Thornhold.",
		objectives = {
			{ type = "gather", item = "Copper Ore", amount = 5, label = "Mine 5 Copper Ore" },
			{ type = "gather", item = "Oak Log", amount = 5, label = "Chop 5 Oak Logs" },
			{ type = "gather", item = "Raw Shrimp", amount = 5, label = "Catch 5 Shrimp" },
		},
		rewards = {
			xp = {
				Mining = 600,
				Woodcutting = 600,
				Fishing = 600,
			},
			gold = 500,
			items = { "Copper Sword", "Bronze Helmet" },
		},
		nextQuest = "quest_02",
		choices = nil,
		dialog = {
			start = "Welcome to Thornhold, stranger. We could use an extra pair of hands. Bring me some copper ore, oak logs, and shrimp â€” prove you can pull your weight around here.",
			progress = "Still working on those supplies? We need all five of each before I can trust you with anything bigger.",
			complete = "Well done! You've got grit. Take this sword and helmet â€” you've earned them. Speak with Brother Elden at the chapel when you're ready for more.",
		},
	},

	{
		id = "quest_02",
		name = "The Restless Dead",
		giver = "Brother Elden",
		level = 5,
		description = "Skeletons have risen in the old cemetery. Put them to rest and consult the hermit Morath.",
		objectives = {
			{ type = "kill", target = "Skeleton", amount = 10, label = "Destroy 10 Skeletons" },
			{ type = "talk", target = "Morath", label = "Speak with Morath the Hermit" },
		},
		rewards = {
			xp = {
				Strength = 1500,
				Defense = 600,
			},
			gold = 1000,
			items = {},
		},
		nextQuest = "quest_03",
		choices = nil,
		dialog = {
			start = "The dead do not sleep, friend. Skeletons claw their way from the cemetery each night. Destroy ten of them, then seek out Morath in his cave â€” he may know the source of this darkness.",
			progress = "The bones still rattle in the night. Finish the job and find Morath.",
			complete = "Morath spoke of a dark energy seeping from the wilderness. Thank the Light you're here. Take this gold and steel yourself for what lies ahead.",
		},
	},

	{
		id = "quest_03",
		name = "Into the Wilderness",
		giver = "Scout Wren",
		level = 10,
		description = "Scout the dangerous wilderness beyond Thornhold and deal with the goblin menace.",
		objectives = {
			{ type = "visit", location = "Darkwood Clearing", label = "Visit Darkwood Clearing" },
			{ type = "visit", location = "Broken Bridge", label = "Visit the Broken Bridge" },
			{ type = "visit", location = "Goblin Camp", label = "Visit the Goblin Camp" },
			{ type = "kill", target = "Goblin", amount = 5, label = "Kill 5 Goblins" },
		},
		rewards = {
			xp = {
				Strength = 1200,
				Defense = 900,
			},
			gold = 1500,
			items = { "Wooden Shield" },
		},
		nextQuest = "quest_04",
		choices = nil,
		dialog = {
			start = "The wilderness is crawling with goblins and worse. I need you to scout three key locations and thin out their numbers. Take this shield when you're done â€” you'll need it.",
			progress = "You haven't finished scouting yet. Check all three locations and clear those goblins.",
			complete = "Excellent report. The goblins are more organized than I feared. Take this shield â€” a witch in the swamp may know more about what's stirring them up.",
		},
	},

	{
		id = "quest_04",
		name = "The Witch's Bargain",
		giver = "Witch Thessaly",
		level = 15,
		description = "The swamp witch Thessaly demands rare ingredients in exchange for crucial information.",
		objectives = {
			{ type = "gather", item = "Moonpetal", amount = 3, label = "Gather 3 Moonpetals" },
			{ type = "gather", item = "Swamp Fungus", amount = 5, label = "Gather 5 Swamp Fungus" },
			{ type = "gather", item = "Serpent Scale", amount = 2, label = "Collect 2 Serpent Scales" },
		},
		rewards = {
			xp = {
				Cooking = 1500,
				Fletching = 900,
			},
			gold = 2000,
			items = {},
		},
		nextQuest = "quest_05",
		choices = nil,
		dialog = {
			start = "Oh, a visitor! How delightful. You want answers? Nothing is free, dearie. Bring me moonpetals, swamp fungus, and serpent scales. Then we'll talk.",
			progress = "Incomplete ingredients make for incomplete potions. And incomplete answers. Hurry along now.",
			complete = "Mmm, perfect. Now listen closely â€” bandits on the north road are working for something far darker than greed. Speak with Captain Aldric. And take this gold... you'll need supplies.",
		},
	},

	{
		id = "quest_05",
		name = "The Bandit Problem",
		giver = "Captain Aldric",
		level = 20,
		description = "Bandits block the northern trade route. Choose how to resolve the crisis.",
		objectives = {
			{ type = "travel", location = "Bandit Fortress", label = "Reach the Bandit Fortress" },
			{ type = "choice", label = "Decide: Fight or Negotiate" },
		},
		rewards = {
			gold = 3000,
			items = {},
		},
		nextQuest = "quest_06",
		choices = {
			{
				id = "fight",
				label = "Storm the Fortress",
				description = "Lead an assault on the bandit fortress. A direct approach for the strong.",
				objectives = {
					{ type = "kill", target = "Bandit", amount = 15, label = "Defeat 15 Bandits" },
					{ type = "kill", target = "Bandit Chief", amount = 1, label = "Defeat the Bandit Chief" },
				},
				rewards = {
					xp = {
						Strength = 3000,
					},
				},
			},
			{
				id = "negotiate",
				label = "Negotiate a Truce",
				description = "Use cunning and diplomacy to turn the bandits into allies.",
				objectives = {
					{ type = "gather", item = "Trade Goods", amount = 10, label = "Acquire 10 Trade Goods" },
					{ type = "talk", target = "Bandit Chief", label = "Negotiate with the Bandit Chief" },
				},
				rewards = {
					xp = {
						Defense = 2400,
						Ranged = 1200,
					},
				},
			},
		},
		dialog = {
			start = "The bandits have fortified the northern pass. We can storm the fortress or try to negotiate. Your call, adventurer â€” but either way, that road must open.",
			progress = "The north road remains blocked. Finish what you started.",
			complete = "The road is open again. You've done Thornhold a great service. Now, there's a ghost haunting the old ruins south of here...",
		},
	},

	{
		id = "quest_06",
		name = "Echoes of Sir Aldren",
		giver = "Ghost of Sir Aldren",
		level = 25,
		description = "The restless spirit of a fallen knight begs for release â€” or offers forbidden power.",
		objectives = {
			{ type = "travel", location = "Aldren's Tomb", label = "Enter Aldren's Tomb" },
			{ type = "gather", item = "Soul Fragment", amount = 3, label = "Collect 3 Soul Fragments" },
			{ type = "choice", label = "Decide the knight's fate" },
		},
		rewards = {
			gold = 2000,
			items = {},
		},
		nextQuest = "quest_07",
		choices = {
			{
				id = "free",
				label = "Free the Spirit",
				description = "Reunite the soul fragments and release Sir Aldren to the afterlife.",
				objectives = {
					{ type = "interact", target = "Altar of Light", label = "Use the Altar of Light" },
				},
				rewards = {
					xp = {
						Defense = 2400,
						Smithing = 1500,
					},
				},
			},
			{
				id = "bind",
				label = "Bind His Power",
				description = "Absorb the knight's essence and claim his dark strength.",
				objectives = {
					{ type = "interact", target = "Shadow Obelisk", label = "Use the Shadow Obelisk" },
				},
				rewards = {
					xp = {
						Ranged = 2400,
						Strength = 1500,
					},
				},
			},
		},
		dialog = {
			start = "Please... I have been trapped here for centuries. My soul is shattered across this tomb. Gather the fragments and choose â€” set me free, or take my power for yourself.",
			progress = "The fragments... find them all. Then decide my fate.",
			complete = "It is done. Whatever you chose, the echoes have faded. Seek the Oracle in the eastern mountains â€” she foresaw your coming.",
		},
	},

	{
		id = "quest_07",
		name = "The Oracle's Vision",
		giver = "The Oracle",
		level = 30,
		description = "The Oracle has foreseen a great darkness. Retrieve a vision crystal and prove your strength against shadow wraiths.",
		objectives = {
			{ type = "gather", item = "Vision Crystal", amount = 1, label = "Retrieve the Vision Crystal" },
			{ type = "kill", target = "Shadow Wraith", amount = 8, label = "Destroy 8 Shadow Wraiths" },
			{ type = "talk", target = "The Oracle", label = "Return to the Oracle" },
		},
		rewards = {
			xp = {
				Ranged = 1800,
				Defense = 1200,
				Strength = 1500,
			},
			gold = 3000,
			items = {},
		},
		nextQuest = "quest_08",
		choices = nil,
		dialog = {
			start = "I have seen you in my visions, child. A dragon stirs beneath the mountain. Bring me a vision crystal from the Whispering Caves and cleanse the wraiths that guard it.",
			progress = "The shadows grow restless. You must hurry.",
			complete = "The crystal confirms my fears. A dragon wakes, and a necromancer feeds it souls. You must cross the Dark Waters to reach the Dragon's Spine. Seek the ferryman Charon.",
		},
	},

	{
		id = "quest_08",
		name = "Crossing the Dark Waters",
		giver = "Charon",
		level = 35,
		description = "Pay the ferryman and survive the crossing of the cursed sea.",
		objectives = {
			{ type = "pay", amount = 5000, label = "Pay Charon 5,000 Gold" },
			{ type = "kill", target = "Sea Serpent", amount = 1, label = "Slay the Sea Serpent" },
		},
		rewards = {
			xp = {
				Strength = 2400,
				Fishing = 1200,
			},
			gold = 4000,
			items = {},
		},
		nextQuest = "quest_09",
		choices = nil,
		dialog = {
			start = "You wish to cross? The waters are cursed, and a serpent guards the passage. Pay my fee of five thousand gold, and I will ferry you â€” but you must deal with the beast yourself.",
			progress = "The serpent still lives. I won't move this boat until the waters are safe.",
			complete = "Impressive. The serpent is slain and the crossing is clear. The Dragon's Spine awaits you on the far shore. Seek the ranger Lyra â€” she knows the mountain paths.",
		},
	},

	{
		id = "quest_09",
		name = "The Dragon's Spine",
		giver = "Lyra",
		level = 40,
		description = "Climb the treacherous Dragon's Spine mountain and defeat the necromancer who feeds the dragon.",
		objectives = {
			{ type = "visit", location = "Lower Ridge", label = "Reach the Lower Ridge" },
			{ type = "visit", location = "Frozen Pass", label = "Cross the Frozen Pass" },
			{ type = "visit", location = "Summit Plateau", label = "Reach the Summit" },
			{ type = "kill", target = "Necromancer Valkor", amount = 1, label = "Defeat Necromancer Valkor" },
		},
		rewards = {
			xp = {
				Strength = 4500,
				Smithing = 1500,
				Ranged = 1500,
			},
			gold = 8000,
			items = {},
		},
		nextQuest = "quest_10",
		choices = nil,
		dialog = {
			start = "The necromancer Valkor sits atop the Dragon's Spine, channeling souls into the sleeping dragon. We must climb the mountain and stop him before the ritual completes.",
			progress = "Keep climbing. Valkor must be stopped before the dragon fully wakes.",
			complete = "Valkor is dead, but we're too late â€” the dragon stirs. This is it, adventurer. The final battle. Are you ready?",
		},
	},

	{
		id = "quest_10",
		name = "The Dragon Awakens",
		giver = "Lyra",
		level = 45,
		description = "The ancient dragon has awakened. Face it and decide the fate of the realm.",
		objectives = {
			{ type = "travel", location = "Dragon's Lair", label = "Enter the Dragon's Lair" },
			{ type = "choice", label = "Choose your destiny" },
		},
		rewards = {
			gold = 25000,
			items = {},
		},
		nextQuest = nil,
		choices = {
			{
				id = "slay",
				label = "Slay the Dragon",
				description = "End the dragon's threat forever with blade and fury.",
				objectives = {
					{ type = "kill", target = "Ancient Dragon", amount = 1, label = "Slay the Ancient Dragon" },
				},
				rewards = {
					xp = {
						Strength = 15000,
					},
				},
			},
			{
				id = "bond",
				label = "Bond with the Dragon",
				description = "Forge a soul-bond with the dragon, turning ancient fury into an eternal alliance.",
				objectives = {
					{ type = "interact", target = "Dragon Soul Altar", label = "Perform the Bonding Ritual" },
					{ type = "kill", target = "Shadow Echo", amount = 5, label = "Defeat 5 Shadow Echoes" },
				},
				rewards = {
					xp = {
						Ranged = 9000,
						Defense = 6000,
					},
				},
			},
		},
		dialog = {
			start = "This is it. The dragon is awake, and only you can face it. You can try to slay the beast... or there is an ancient ritual that could bond your soul to it. Either path will decide the fate of the realm.",
			progress = "The dragon waits. There is no turning back now.",
			complete = "It's over. Whatever you chose, the realm will never forget what you've done. You are a legend now, adventurer. Welcome to the end of your story â€” and the beginning of your legacy.",
		},
	},
}

-- Build lookup by quest id
QuestDatabase.ById = {}
for _, quest in QuestDatabase.Quests do
	QuestDatabase.ById[quest.id] = quest
end

return QuestDatabase
]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="11">
      <Properties>
        <string name="Name">Remotes</string>
      </Properties>
      <Item class="RemoteEvent" referent="12">
        <Properties>
          <string name="Name">AchievementProgress</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="13">
        <Properties>
          <string name="Name">AchievementUnlock</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="14">
        <Properties>
          <string name="Name">Attack</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="15">
        <Properties>
          <string name="Name">AttackVisual</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="16">
        <Properties>
          <string name="Name">BankAction</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="17">
        <Properties>
          <string name="Name">BankOpen</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="18">
        <Properties>
          <string name="Name">BankUpdate</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="19">
        <Properties>
          <string name="Name">BuryBones</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="20">
        <Properties>
          <string name="Name">BuyItem</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="21">
        <Properties>
          <string name="Name">ChatCommand</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="22">
        <Properties>
          <string name="Name">CookItem</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="23">
        <Properties>
          <string name="Name">CookingComplete</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="24">
        <Properties>
          <string name="Name">CookingProgress</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="25">
        <Properties>
          <string name="Name">CraftComplete</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="26">
        <Properties>
          <string name="Name">CraftRequest</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="27">
        <Properties>
          <string name="Name">CraftUpdate</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="28">
        <Properties>
          <string name="Name">DamageDealt</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="29">
        <Properties>
          <string name="Name">DoubleXPStatus</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="30">
        <Properties>
          <string name="Name">DropItem</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="31">
        <Properties>
          <string name="Name">EatFood</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="32">
        <Properties>
          <string name="Name">EquipItem</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="33">
        <Properties>
          <string name="Name">EquipmentInfo</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="34">
        <Properties>
          <string name="Name">EquipmentUpdate</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="35">
        <Properties>
          <string name="Name">FishCaught</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="36">
        <Properties>
          <string name="Name">FishingComplete</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="37">
        <Properties>
          <string name="Name">FishingProgress</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="38">
        <Properties>
          <string name="Name">FletchingComplete</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="39">
        <Properties>
          <string name="Name">FletchingProgress</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="40">
        <Properties>
          <string name="Name">FriendAccept</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="41">
        <Properties>
          <string name="Name">FriendDecline</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="42">
        <Properties>
          <string name="Name">FriendRemove</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="43">
        <Properties>
          <string name="Name">FriendRequest</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="44">
        <Properties>
          <string name="Name">FriendUpdate</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="45">
        <Properties>
          <string name="Name">GatherFeedback</string>
        </Properties>
      </Item>
      <Item class="RemoteFunction" referent="46">
        <Properties>
          <string name="Name">GetAchievements</string>
        </Properties>
      </Item>
      <Item class="RemoteFunction" referent="47">
        <Properties>
          <string name="Name">GetCombatLevel</string>
        </Properties>
      </Item>
      <Item class="RemoteFunction" referent="48">
        <Properties>
          <string name="Name">GetLeaderboard</string>
        </Properties>
      </Item>
      <Item class="RemoteFunction" referent="49">
        <Properties>
          <string name="Name">GetPlayerData</string>
        </Properties>
      </Item>
      <Item class="RemoteFunction" referent="50">
        <Properties>
          <string name="Name">GetPrayerData</string>
        </Properties>
      </Item>
      <Item class="RemoteFunction" referent="51">
        <Properties>
          <string name="Name">GetPrestigeInfo</string>
        </Properties>
      </Item>
      <Item class="RemoteFunction" referent="52">
        <Properties>
          <string name="Name">GetSkillData</string>
        </Properties>
      </Item>
      <Item class="RemoteFunction" referent="53">
        <Properties>
          <string name="Name">GetStatsPanel</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="54">
        <Properties>
          <string name="Name">GraveInteract</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="55">
        <Properties>
          <string name="Name">HitEffect</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="56">
        <Properties>
          <string name="Name">HotbarUse</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="57">
        <Properties>
          <string name="Name">InventoryUpdate</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="58">
        <Properties>
          <string name="Name">LeaderboardUpdate</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="59">
        <Properties>
          <string name="Name">LevelUp</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="60">
        <Properties>
          <string name="Name">LoadSettings</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="61">
        <Properties>
          <string name="Name">LootBagOpen</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="62">
        <Properties>
          <string name="Name">LootBagTake</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="63">
        <Properties>
          <string name="Name">LootBagUpdate</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="64">
        <Properties>
          <string name="Name">MiningComplete</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="65">
        <Properties>
          <string name="Name">MiningProgress</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="66">
        <Properties>
          <string name="Name">MonsterAttackVisual</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="67">
        <Properties>
          <string name="Name">MonsterDamage</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="68">
        <Properties>
          <string name="Name">MonsterDeath</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="69">
        <Properties>
          <string name="Name">MonsterLoot</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="70">
        <Properties>
          <string name="Name">NPCInteract</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="71">
        <Properties>
          <string name="Name">PartyAccept</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="72">
        <Properties>
          <string name="Name">PartyChat</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="73">
        <Properties>
          <string name="Name">PartyInvite</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="74">
        <Properties>
          <string name="Name">PartyKick</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="75">
        <Properties>
          <string name="Name">PartyLeave</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="76">
        <Properties>
          <string name="Name">PartyMessage</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="77">
        <Properties>
          <string name="Name">PartyUpdate</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="78">
        <Properties>
          <string name="Name">PlayerDied</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="79">
        <Properties>
          <string name="Name">PrayerUpdate</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="80">
        <Properties>
          <string name="Name">Prestige</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="81">
        <Properties>
          <string name="Name">PurchasePremiumItem</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="82">
        <Properties>
          <string name="Name">PvPAttack</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="83">
        <Properties>
          <string name="Name">PvPDeath</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="84">
        <Properties>
          <string name="Name">QuestAccept</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="85">
        <Properties>
          <string name="Name">QuestComplete</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="86">
        <Properties>
          <string name="Name">QuestList</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="87">
        <Properties>
          <string name="Name">QuestProgress</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="88">
        <Properties>
          <string name="Name">RangedAmmoUpdate</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="89">
        <Properties>
          <string name="Name">RangedAttack</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="90">
        <Properties>
          <string name="Name">RangedHit</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="91">
        <Properties>
          <string name="Name">RespawnPlayer</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="92">
        <Properties>
          <string name="Name">SaveSettings</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="93">
        <Properties>
          <string name="Name">SellItem</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="94">
        <Properties>
          <string name="Name">ShowDeathScreen</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="95">
        <Properties>
          <string name="Name">SkullUpdate</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="96">
        <Properties>
          <string name="Name">SmithingComplete</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="97">
        <Properties>
          <string name="Name">SmithingProgress</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="98">
        <Properties>
          <string name="Name">StartFishing</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="99">
        <Properties>
          <string name="Name">StartFletching</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="100">
        <Properties>
          <string name="Name">StartMining</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="101">
        <Properties>
          <string name="Name">StartSmithing</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="102">
        <Properties>
          <string name="Name">StartWoodcutting</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="103">
        <Properties>
          <string name="Name">TogglePrayer</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="104">
        <Properties>
          <string name="Name">TradeAccept</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="105">
        <Properties>
          <string name="Name">TradeCancel</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="106">
        <Properties>
          <string name="Name">TradeComplete</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="107">
        <Properties>
          <string name="Name">TradeConfirm</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="108">
        <Properties>
          <string name="Name">TradeRequest</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="109">
        <Properties>
          <string name="Name">TradeResponse</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="110">
        <Properties>
          <string name="Name">TradeUpdate</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="111">
        <Properties>
          <string name="Name">TutorialComplete</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="112">
        <Properties>
          <string name="Name">TutorialSkip</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="113">
        <Properties>
          <string name="Name">TutorialStep</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="114">
        <Properties>
          <string name="Name">UnequipItem</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="115">
        <Properties>
          <string name="Name">UseItem</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="116">
        <Properties>
          <string name="Name">WhisperMessage</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="117">
        <Properties>
          <string name="Name">WildernessWarning</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="118">
        <Properties>
          <string name="Name">WoodcuttingComplete</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="119">
        <Properties>
          <string name="Name">WoodcuttingProgress</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="120">
        <Properties>
          <string name="Name">XPPopup</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="121">
        <Properties>
          <string name="Name">XPUpdate</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="122">
        <Properties>
          <string name="Name">ZoneChanged</string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="123">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Script" referent="124">
      <Properties>
        <string name="Name">AchievementManager</string>
        <token name="RunContext">0</token>
        <string name="Source">-- AchievementManager.server.lua
-- Achievement system for Wilderness MMO

print("[AchievementManager] Starting...")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Wait for dependencies with timeouts
local Modules = ReplicatedStorage:WaitForChild("Modules", 10)
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)

-- Load required modules
local DataManager = require(Modules:WaitForChild("DataManager", 10))

-- Get remotes
local AchievementUnlock = Remotes:WaitForChild("AchievementUnlock", 5)
local AchievementProgress = Remotes:WaitForChild("AchievementProgress", 5)
local GetAchievements = Remotes:WaitForChild("GetAchievements", 5)

-- Validate remotes
if not AchievementUnlock or not AchievementProgress or not GetAchievements then
	warn("[AchievementManager] Missing remotes!")
	return
end

-- Achievement definitions
local ACHIEVEMENTS = {
	{
		id = "first_kill",
		name = "First Blood",
		description = "Defeat your first monster",
		category = "Combat",
		icon = "âš”ï¸",
		check = function(player, data)
			return data.monstersKilled >= 1
		end,
		progress = function(player, data)
			return math.min(data.monstersKilled or 0, 1), 1
		end
	},
	{
		id = "level_10_skill",
		name = "Skilled",
		description = "Reach level 10 in any skill",
		category = "Skills",
		icon = "ðŸ“ˆ",
		check = function(player, data)
			for skill, level in pairs(data.skillLevels or {}) do
				if level >= 10 then
					return true
				end
			end
			return false
		end,
		progress = function(player, data)
			local maxLevel = 0
			for skill, level in pairs(data.skillLevels or {}) do
				if level > maxLevel then
					maxLevel = level
				end
			end
			return math.min(maxLevel, 10), 10
		end
	},
	{
		id = "catch_100_fish",
		name = "Master Angler",
		description = "Catch 100 fish",
		category = "Skills",
		icon = "ðŸŽ£",
		check = function(player, data)
			return (data.fishCaught or 0) >= 100
		end,
		progress = function(player, data)
			return math.min(data.fishCaught or 0, 100), 100
		end
	},
	{
		id = "kill_dragon",
		name = "Dragon Slayer",
		description = "Defeat a Dragon",
		category = "Combat",
		icon = "ðŸ‰",
		check = function(player, data)
			return (data.dragonsKilled or 0) >= 1
		end,
		progress = function(player, data)
			return math.min(data.dragonsKilled or 0, 1), 1
		end
	},
	{
		id = "mine_500_ore",
		name = "Mining Expert",
		description = "Mine 500 ores",
		category = "Skills",
		icon = "â›ï¸",
		check = function(player, data)
			return (data.oresMined or 0) >= 500
		end,
		progress = function(player, data)
			return math.min(data.oresMined or 0, 500), 500
		end
	},
	{
		id = "chop_500_logs",
		name = "Lumberjack",
		description = "Chop 500 logs",
		category = "Skills",
		icon = "ðŸª“",
		check = function(player, data)
			return (data.logsChopped or 0) >= 500
		end,
		progress = function(player, data)
			return math.min(data.logsChopped or 0, 500), 500
		end
	},
	{
		id = "reach_combat_50",
		name = "Warrior",
		description = "Reach combat level 50",
		category = "Combat",
		icon = "ðŸ›¡ï¸",
		check = function(player, data)
			return (data.combatLevel or 0) >= 50
		end,
		progress = function(player, data)
			return math.min(data.combatLevel or 0, 50), 50
		end
	},
	{
		id = "earn_100k_gold",
		name = "Rich",
		description = "Earn 100,000 gold",
		category = "Wealth",
		icon = "ðŸ’°",
		check = function(player, data)
			return (data.totalGoldEarned or 0) >= 100000
		end,
		progress = function(player, data)
			return math.min(data.totalGoldEarned or 0, 100000), 100000
		end
	},
	{
		id = "complete_10_quests",
		name = "Quest Master",
		description = "Complete 10 quests",
		category = "Quests",
		icon = "ðŸ“œ",
		check = function(player, data)
			return (data.questsCompleted or 0) >= 10
		end,
		progress = function(player, data)
			return math.min(data.questsCompleted or 0, 10), 10
		end
	},
	{
		id = "craft_100_items",
		name = "Master Crafter",
		description = "Craft 100 items",
		category = "Skills",
		icon = "ðŸ”¨",
		check = function(player, data)
			return (data.itemsCrafted or 0) >= 100
		end,
		progress = function(player, data)
			return math.min(data.itemsCrafted or 0, 100), 100
		end
	},
	{
		id = "kill_1000_monsters",
		name = "Monster Hunter",
		description = "Defeat 1,000 monsters",
		category = "Combat",
		icon = "ðŸ‘¹",
		check = function(player, data)
			return (data.monstersKilled or 0) >= 1000
		end,
		progress = function(player, data)
			return math.min(data.monstersKilled or 0, 1000), 1000
		end
	},
	{
		id = "reach_total_500",
		name = "Legend",
		description = "Reach total skill level 500",
		category = "Skills",
		icon = "ðŸŒŸ",
		check = function(player, data)
			local total = 0
			for skill, level in pairs(data.skillLevels or {}) do
				total = total + level
			end
			return total >= 500
		end,
		progress = function(player, data)
			local total = 0
			for skill, level in pairs(data.skillLevels or {}) do
				total = total + level
			end
			return math.min(total, 500), 500
		end
	},
	{
		id = "explore_all_areas",
		name = "Explorer",
		description = "Discover all areas",
		category = "Exploration",
		icon = "ðŸ—ºï¸",
		check = function(player, data)
			return (data.areasDiscovered or 0) >= 15
		end,
		progress = function(player, data)
			return math.min(data.areasDiscovered or 0, 15), 15
		end
	},
	{
		id = "win_50_pvp",
		name = "Champion",
		description = "Win 50 PvP battles",
		category = "PvP",
		icon = "âš”ï¸",
		check = function(player, data)
			return (data.pvpWins or 0) >= 50
		end,
		progress = function(player, data)
			return math.min(data.pvpWins or 0, 50), 50
		end
	},
	{
		id = "cook_100_food",
		name = "Master Chef",
		description = "Cook 100 food items",
		category = "Skills",
		icon = "ðŸ³",
		check = function(player, data)
			return (data.foodCooked or 0) >= 100
		end,
		progress = function(player, data)
			return math.min(data.foodCooked or 0, 100), 100
		end
	},
	{
		id = "fletch_100_arrows",
		name = "Fletcher",
		description = "Fletch 100 arrows",
		category = "Skills",
		icon = "ðŸ¹",
		check = function(player, data)
			return (data.arrowsFletched or 0) >= 100
		end,
		progress = function(player, data)
			return math.min(data.arrowsFletched or 0, 100), 100
		end
	},
	{
		id = "smith_100_bars",
		name = "Blacksmith",
		description = "Smith 100 metal bars",
		category = "Skills",
		icon = "ðŸ”¥",
		check = function(player, data)
			return (data.barsSmithed or 0) >= 100
		end,
		progress = function(player, data)
			return math.min(data.barsSmithed or 0, 100), 100
		end
	},
	{
		id = "join_party",
		name = "Team Player",
		description = "Join a party",
		category = "Social",
		icon = "ðŸ‘¥",
		check = function(player, data)
			return (data.partiesJoined or 0) >= 1
		end,
		progress = function(player, data)
			return math.min(data.partiesJoined or 0, 1), 1
		end
	},
	{
		id = "die_10_times",
		name = "Persistent",
		description = "Die 10 times",
		category = "Combat",
		icon = "ðŸ’€",
		check = function(player, data)
			return (data.deaths or 0) >= 10
		end,
		progress = function(player, data)
			return math.min(data.deaths or 0, 10), 10
		end
	},
	{
		id = "reach_max_level",
		name = "Maxed Out",
		description = "Reach level 99 in a skill",
		category = "Skills",
		icon = "ðŸ†",
		check = function(player, data)
			for skill, level in pairs(data.skillLevels or {}) do
				if level >= 99 then
					return true
				end
			end
			return false
		end,
		progress = function(player, data)
			local maxLevel = 0
			for skill, level in pairs(data.skillLevels or {}) do
				if level > maxLevel then
					maxLevel = level
				end
			end
			return math.min(maxLevel, 99), 99
		end
	}
}

-- Player achievement data cache
local playerAchievements = {}

-- Helper function to get player achievement data
local function getPlayerAchievementData(player)
	if not player then return nil end
	
	if not playerAchievements[player.UserId] then
		-- Load from DataManager
		local data = DataManager:GetData(player)
		playerAchievements[player.UserId] = {
			unlocked = data.achievementsUnlocked or {},
			progress = data.achievementProgress or {}
		}
	end
	
	return playerAchievements[player.UserId]
end

-- Helper function to save player achievement data
local function savePlayerAchievementData(player)
	if not player then return end
	
	local data = playerAchievements[player.UserId]
	if data then
		DataManager.UpdatePlayerData(player, {
			achievementsUnlocked = data.unlocked,
			achievementProgress = data.progress
		})
	end
end

-- Check achievements for a player
local function checkAchievements(player, eventType, eventData)
	local achievementData = getPlayerAchievementData(player)
	if not achievementData then return end
	
	local playerData = DataManager:GetData(player)
	local unlockedAny = false
	
	for _, achievement in ipairs(ACHIEVEMENTS) do
		-- Skip if already unlocked
		if not achievementData.unlocked[achievement.id] then
			-- Check if achievement is unlocked
			if achievement.check(player, playerData) then
				-- Unlock achievement
				achievementData.unlocked[achievement.id] = os.time()
				unlockedAny = true
				
				-- Fire unlock event
				AchievementUnlock:FireClient(player, {
					id = achievement.id,
					name = achievement.name,
					description = achievement.description,
					category = achievement.category,
					icon = achievement.icon
				})
				
				-- Save immediately
				savePlayerAchievementData(player)
			else
				-- Update progress
				local current, target = achievement.progress(player, playerData)
				if current > (achievementData.progress[achievement.id] or 0) then
					achievementData.progress[achievement.id] = current
					
					-- Fire progress event
					AchievementProgress:FireClient(player, {
						id = achievement.id,
						current = current,
						target = target
					})
				end
			end
		end
	end
	
	if unlockedAny then
		savePlayerAchievementData(player)
	end
end

-- Handle GetAchievements remote function
GetAchievements.OnServerInvoke = function(player)
	local achievementData = getPlayerAchievementData(player)
	local playerData = DataManager:GetData(player)
	
	local result = {}
	
	for _, achievement in ipairs(ACHIEVEMENTS) do
		local unlocked = achievementData.unlocked[achievement.id]
		local current, target = achievement.progress(player, playerData)
		
		table.insert(result, {
			id = achievement.id,
			name = achievement.name,
			description = achievement.description,
			category = achievement.category,
			icon = achievement.icon,
			unlocked = unlocked,
			unlockTime = unlocked,
			current = current,
			target = target,
			progress = target > 0 and math.floor((current / target) * 100) or 0
		})
	end
	
	return result
end

-- Hook into game events
local function setupEventHooks()
	-- Player joined
	Players.PlayerAdded:Connect(function(player)
		-- Initial achievement check
		task.wait(2) -- Wait for data to load
		checkAchievements(player, "join", {})
	end)
	
	-- Player data changed (other systems should call this)
	-- Example: when player kills a monster, levels up, etc.
end

-- Public API for other systems
local AchievementManager = {
	CheckAchievements = checkAchievements,
	GetAchievementData = getPlayerAchievementData
}

-- Clean up on player leave
Players.PlayerRemoving:Connect(function(player)
	playerAchievements[player.UserId] = nil
end)

-- Initialize
setupEventHooks()
print("[AchievementManager] Ready with " .. tostring(#ACHIEVEMENTS) .. " achievements!")

return AchievementManager</string>
      </Properties>
    </Item>
    <Item class="Script" referent="125">
      <Properties>
        <string name="Name">AttackVisualHandler</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	AttackVisualHandler.server.lua
	ServerScriptService

	Bridges combat events between server and all clients.
	- Broadcasts player attack visuals to nearby clients
	- Broadcasts monster attack visuals when monsters attack
	- Sends hit effect events for damage numbers, blocks, etc.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--------------------------------------------------------------------------------
-- REMOTE EVENTS (create if missing)
--------------------------------------------------------------------------------
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 5)

local function getRemote(name)
	return Remotes:WaitForChild(name, 10)
end

local AttackVisualEvent = getRemote("AttackVisual")
local HitEffectEvent = getRemote("HitEffect")
local MonsterAttackVisualEvent = getRemote("MonsterAttackVisual")
local MonsterDamageEvent = getRemote("MonsterDamage")
local MonsterDeathEvent = getRemote("MonsterDeath")

--------------------------------------------------------------------------------
-- BROADCAST RADIUS
--------------------------------------------------------------------------------
local BROADCAST_RADIUS = 100

local function getNearbyPlayers(position, radius)
	local result = {}
	for _, p in Players:GetPlayers() do
		local char = p.Character
		if char then
			local hrp = char:FindFirstChild("HumanoidRootPart")
			if hrp then
				local dist = (hrp.Position - position).Magnitude
				if dist <= radius then
					table.insert(result, p)
				end
			end
		end
	end
	return result
end

--------------------------------------------------------------------------------
-- PLAYER ATTACK BROADCAST
-- When a player attacks, broadcast the visual to nearby clients
--------------------------------------------------------------------------------
local Remotes = ReplicatedStorage:FindFirstChild("Remotes")
if Remotes then
	local attack = Remotes:FindFirstChild("Attack")
	if attack then
		-- We listen to DamageDealt to broadcast visuals
		-- But attack visuals are better triggered client-side per-attacker
		-- This handler is for OTHER players to see the attack animation
	end
end

-- Expose a function for MonsterManager to call when monsters attack
shared.AttackVisualHandler = {
	-- Call this when a monster attacks a player
	BroadcastMonsterAttack = function(monsterModel, targetPlayer, monsterName)
		if not monsterModel or not monsterModel.PrimaryPart then return end
		local pos = monsterModel.PrimaryPart.Position
		local nearby = getNearbyPlayers(pos, BROADCAST_RADIUS)
		for _, p in nearby do
			MonsterAttackVisualEvent:FireClient(p, monsterModel, targetPlayer, monsterName)
		end
	end,

	-- Call this when a player takes damage (from monster or PvP)
	BroadcastHitEffect = function(position, damage, effectType, isCritical, targetPlayer)
		if targetPlayer then
			HitEffectEvent:FireClient(targetPlayer, position, damage, effectType, isCritical)
		end
	end,

	-- Broadcast a player's attack animation to other nearby players
	BroadcastPlayerAttack = function(attackerPlayer, targetModel, weaponType, isCritical)
		local char = attackerPlayer.Character
		if not char then return end
		local hrp = char:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		local nearby = getNearbyPlayers(hrp.Position, BROADCAST_RADIUS)
		for _, p in nearby do
			if p ~= attackerPlayer then
				AttackVisualEvent:FireClient(p, attackerPlayer, targetModel, weaponType, isCritical)
			end
		end
	end,
}

print("[AttackVisualHandler] Visual handler loaded!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="126">
      <Properties>
        <string name="Name">BankManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- BankManager.server.lua
-- Bank NPC + deposit/withdraw system

print("ðŸ¦ [FORCE RELOAD] BankManager v2.0 STARTING - BANKER SHOULD MOVE! - " .. tick())

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local DataManager = require(ReplicatedStorage.Modules.DataManager)
local Config = require(ReplicatedStorage.Modules.Config)

local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)

-- Get bank remotes
local bankOpenRemote = Remotes:WaitForChild("BankOpen", 10)
local bankActionRemote = Remotes:WaitForChild("BankAction", 10)
local bankUpdateRemote = Remotes:WaitForChild("BankUpdate", 10)

-- === CREATE BANK NPC ===
task.wait(3) -- wait for MapSetup

local function createBankNPC()
	print("[BankManager] Creating Banker NPC at position (35, 7, 45)")
	
	local safeZone = Workspace:FindFirstChild("SafeZone")
	if not safeZone then
		safeZone = Instance.new("Folder")
		safeZone.Name = "SafeZone"
		safeZone.Parent = Workspace
	end

	-- Check if banker already exists
	local existingBanker = safeZone:FindFirstChild("BankNPC")
	if existingBanker then
		print("[BankManager] WARNING: Banker already exists, destroying old one")
		existingBanker:Destroy()
	end

	-- NPC body (positioned inside bank building at x=20, z=20)
	local npcModel = Instance.new("Model")
	npcModel.Name = "BankNPC"
	
	if not safeZone then
		warn("[BankManager] ERROR: safeZone is nil!")
		return
	end
	if not npcModel then
		warn("[BankManager] ERROR: npcModel creation failed!")
		return
	end
	
	npcModel.Parent = safeZone

	-- Torso (main body) â€” floor appears to be around Y=5
	local torso = Instance.new("Part")
	torso.Name = "HumanoidRootPart"
	torso.Size = Vector3.new(2, 2, 1)
	torso.Position = Vector3.new(35, 7, 45)
	torso.Anchored = true
	torso.CanCollide = true
	torso.BrickColor = BrickColor.new("Bright blue")
	torso.Material = Enum.Material.SmoothPlastic
	torso.Parent = npcModel

	npcModel.PrimaryPart = torso

	-- Head
	local head = Instance.new("Part")
	head.Name = "Head"
	head.Shape = Enum.PartType.Ball
	head.Size = Vector3.new(1.5, 1.5, 1.5)
	head.Position = Vector3.new(35, 8.5, 45)
	head.Anchored = true
	head.CanCollide = false
	head.BrickColor = BrickColor.new("Light orange")
	head.Material = Enum.Material.SmoothPlastic
	head.Parent = npcModel

	-- Hat (banker hat)
	local hat = Instance.new("Part")
	hat.Name = "Hat"
	hat.Size = Vector3.new(2, 0.5, 2)
	hat.Position = Vector3.new(35, 9.5, 45)
	hat.Anchored = true
	hat.CanCollide = false
	hat.BrickColor = BrickColor.new("Dark stone grey")
	hat.Material = Enum.Material.SmoothPlastic
	hat.Parent = npcModel

	-- Legs
	local leftLeg = Instance.new("Part")
	leftLeg.Name = "LeftLeg"
	leftLeg.Size = Vector3.new(0.8, 1, 0.8)
	leftLeg.Position = Vector3.new(34.5, 5.5, 45)
	leftLeg.Anchored = true
	leftLeg.CanCollide = false
	leftLeg.BrickColor = BrickColor.new("Dark stone grey")
	leftLeg.Material = Enum.Material.SmoothPlastic
	leftLeg.Parent = npcModel

	local rightLeg = Instance.new("Part")
	rightLeg.Name = "RightLeg"
	rightLeg.Size = Vector3.new(0.8, 1, 0.8)
	rightLeg.Position = Vector3.new(35.5, 5.5, 45)
	rightLeg.Anchored = true
	rightLeg.CanCollide = false
	rightLeg.BrickColor = BrickColor.new("Dark stone grey")
	rightLeg.Material = Enum.Material.SmoothPlastic
	rightLeg.Parent = npcModel

	-- Arms
	local leftArm = Instance.new("Part")
	leftArm.Name = "LeftArm"
	leftArm.Size = Vector3.new(0.6, 1.8, 0.6)
	leftArm.Position = Vector3.new(33.7, 7, 45)
	leftArm.Anchored = true
	leftArm.CanCollide = false
	leftArm.BrickColor = BrickColor.new("Bright blue")
	leftArm.Material = Enum.Material.SmoothPlastic
	leftArm.Parent = npcModel

	local rightArm = Instance.new("Part")
	rightArm.Name = "RightArm"
	rightArm.Size = Vector3.new(0.6, 1.8, 0.6)
	rightArm.Position = Vector3.new(36.3, 7, 45)
	rightArm.Anchored = true
	rightArm.CanCollide = false
	rightArm.BrickColor = BrickColor.new("Bright blue")
	rightArm.Material = Enum.Material.SmoothPlastic
	rightArm.Parent = npcModel

	-- (Counter/gold bars are built by MapSetup in BankBuilding)
	local goldStack = Instance.new("Part")
	goldStack.Name = "GoldBarsNPC"
	goldStack.Size = Vector3.new(0, 0, 0)
	goldStack.Transparency = 1
	goldStack.Transparency = 0.1
	goldStack.Parent = safeZone

	-- NPC Name billboard
	local nameBillboard = Instance.new("BillboardGui")
	nameBillboard.Size = UDim2.new(6, 0, 1.5, 0)
	nameBillboard.StudsOffset = Vector3.new(0, 3, 0)
	nameBillboard.Parent = head

	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
	nameLabel.Position = UDim2.new(0, 0, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = "Banker"
	nameLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
	nameLabel.TextScaled = true
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.TextStrokeTransparency = 0.5
	nameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	nameLabel.Parent = nameBillboard

	local subLabel = Instance.new("TextLabel")
	subLabel.Size = UDim2.new(1, 0, 0.4, 0)
	subLabel.Position = UDim2.new(0, 0, 0.55, 0)
	subLabel.BackgroundTransparency = 1
	subLabel.Text = "Click to open bank"
	subLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	subLabel.TextScaled = true
	subLabel.Font = Enum.Font.Gotham
	subLabel.TextStrokeTransparency = 0.7
	subLabel.Parent = nameBillboard

	-- Click detector on torso (increased range)
	local clickDetector = Instance.new("ClickDetector")
	clickDetector.MaxActivationDistance = 25
	clickDetector.Parent = torso

	-- Also add click detector to head for easier clicking
	local headClick = Instance.new("ClickDetector")
	headClick.MaxActivationDistance = 25
	headClick.Parent = head

	local function onBankClick(player)
		-- Only allow in safe zone
		local character = player.Character
		if character then
			local root = character:FindFirstChild("HumanoidRootPart")
			if root and root.Position.Z < -100 then
				-- In wilderness, can't use bank
				return
			end
		end

		local data = DataManager:GetData(player)
		if not data then return end

		-- Send bank data to client
		bankOpenRemote:FireClient(player, data.Bank, data.Inventory)
		print("[Bank] " .. player.Name .. " opened the bank")
	end

	clickDetector.MouseClick:Connect(onBankClick)
	headClick.MouseClick:Connect(onBankClick)

	print("[BankManager] Bank NPC created at safe zone")
	return npcModel
end

-- === HANDLE BANK ACTIONS ===
bankActionRemote.OnServerEvent:Connect(function(player, action, itemName, quantity)
	if not player or not action or not itemName then return end
	quantity = tonumber(quantity) or 1
	if quantity < 1 then return end

	local data = DataManager:GetData(player)
	if not data then return end

	local success = false

	if action == "deposit" then
		success = DataManager.DepositToBank(player, itemName, quantity)
		if success then
			print("[Bank] " .. player.Name .. " deposited " .. quantity .. "x " .. itemName)
		end
	elseif action == "withdraw" then
		success = DataManager.WithdrawFromBank(player, itemName, quantity)
		if success then
			print("[Bank] " .. player.Name .. " withdrew " .. quantity .. "x " .. itemName)
		end
	elseif action == "deposit_all" then
		-- Deposit entire inventory
		local deposited = 0
		-- Make a copy of inventory since we're modifying it
		local invCopy = {}
		for _, slot in ipairs(data.Inventory) do
			table.insert(invCopy, { name = slot.name, quantity = slot.quantity })
		end
		for _, slot in ipairs(invCopy) do
			if DataManager.DepositToBank(player, slot.name, slot.quantity) then
				deposited = deposited + slot.quantity
			end
		end
		success = deposited > 0
		if success then
			print("[Bank] " .. player.Name .. " deposited all (" .. deposited .. " items)")
		end
	end

	-- Send updated bank + inventory data back
	local updatedData = DataManager:GetData(player)
	bankUpdateRemote:FireClient(player, updatedData.Bank, updatedData.Inventory, success, action)

	-- Also update inventory UI
	local invRemote = Remotes:FindFirstChild("InventoryUpdate")
	if invRemote then
		invRemote:FireClient(player, updatedData.Inventory)
	end
end)

-- Create the NPC
createBankNPC()

print("[BankManager] Bank system active!")




]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="127">
      <Properties>
        <string name="Name">ChatCommandHandler</string>
        <token name="RunContext">0</token>
        <string name="Source">-- ChatCommandHandler.server.lua
-- Server-side chat command handler with error handling

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local TextChatService = game:GetService("TextChatService")
local RunService = game:GetService("RunService")

-- Wait for dependencies with timeouts
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 5)
local Modules = ReplicatedStorage:WaitForChild("Modules", 5)

-- Load ErrorHandler first for error handling
local ErrorHandler
local errorHandlerSuccess, errorHandlerResult = pcall(function()
	return require(Modules:WaitForChild("ErrorHandler", 5))
end)

if errorHandlerSuccess then
	ErrorHandler = errorHandlerResult
else
	-- Fallback ErrorHandler with self parameter
	ErrorHandler = {
		LogWarning = function(self, msg, data) warn("[ChatCommandHandler] " .. tostring(msg)) end,
		LogError = function(self, msg, data) error("[ChatCommandHandler] " .. tostring(msg)) end,
		ValidateNotNil = function(self, val, ctx, fallback) return val or fallback end,
		LogDebug = function(self, msg, data) print("[DEBUG] " .. tostring(msg)) end,
		LogInfo = function(self, msg, data) print("[INFO] " .. tostring(msg)) end
	}
end

-- RemoteEvents with validation
local ChatCommandEvent = Remotes and Remotes:WaitForChild("ChatCommand", 5)
local WhisperMessageEvent = Remotes and Remotes:WaitForChild("WhisperMessage", 5)
local PartyMessageEvent = Remotes and Remotes:WaitForChild("PartyMessage", 5)

-- Validate remotes
if not ChatCommandEvent then
	ErrorHandler:LogError(ErrorHandler, "ChatCommand remote not found")
	return
end

-- Load other managers if available
local PartyManager
local TradeManager
local DataManager

local function loadManagers()
	-- Try to load PartyManager
	local partySuccess, partyResult = pcall(function()
		return require(Modules:WaitForChild("PartyManager", 5))
	end)
	
	if partySuccess then
		PartyManager = partyResult
	else
		PartyManager = nil
		ErrorHandler:LogWarning(ErrorHandler, "PartyManager not available", {error = partyResult})
	end
	
	-- Try to load TradeManager
	local tradeSuccess, tradeResult = pcall(function()
		return require(Modules:WaitForChild("TradeManager", 5))
	end)
	
	if tradeSuccess then
		TradeManager = tradeResult
	else
		TradeManager = nil
		ErrorHandler:LogWarning(ErrorHandler, "TradeManager not available", {error = tradeResult})
	end
	
	-- Try to load DataManager
	local dataSuccess, dataResult = pcall(function()
		return require(Modules:WaitForChild("DataManager", 5))
	end)
	
	if dataSuccess then
		DataManager = dataResult
	else
		DataManager = nil
		ErrorHandler:LogWarning(ErrorHandler, "DataManager not available", {error = dataResult})
	end
end

-- Initialize managers
loadManagers()

-- Command configuration
local COMMAND_CONFIG = {
	PREFIX = "/",
	COMMANDS = {
		["trade"] = {
			description = "Request a trade with another player",
			usage = "/trade &lt;playerName>",
			minArgs = 1,
			handler = "handleTradeCommand"
		},
		["party"] = {
			description = "Party commands: invite, leave, kick, chat",
			usage = "/party &lt;invite|leave|kick|chat> [args]",
			minArgs = 1,
			handler = "handlePartyCommand"
		},
		["whisper"] = {
			description = "Send a private message to another player",
			usage = "/whisper &lt;playerName> &lt;message>",
			minArgs = 2,
			handler = "handleWhisperCommand"
		},
		["help"] = {
			description = "Show available commands",
			usage = "/help [command]",
			minArgs = 0,
			handler = "handleHelpCommand"
		},
		["stats"] = {
			description = "Show your character statistics",
			usage = "/stats",
			minArgs = 0,
			handler = "handleStatsCommand"
		},
		["me"] = {
			description = "Roleplay action",
			usage = "/me &lt;action>",
			minArgs = 1,
			handler = "handleMeCommand"
		},
		["roll"] = {
			description = "Roll a dice (1-100)",
			usage = "/roll [max]",
			minArgs = 0,
			handler = "handleRollCommand"
		},
		["time"] = {
			description = "Show server time",
			usage = "/time",
			minArgs = 0,
			handler = "handleTimeCommand"
		},
		["players"] = {
			description = "Show online players",
			usage = "/players",
			minArgs = 0,
			handler = "handlePlayersCommand"
		},
		["ignore"] = {
			description = "Ignore a player's messages",
			usage = "/ignore &lt;playerName>",
			minArgs = 1,
			handler = "handleIgnoreCommand"
		},
		["unignore"] = {
			description = "Stop ignoring a player",
			usage = "/unignore &lt;playerName>",
			minArgs = 1,
			handler = "handleUnignoreCommand"
		}
	}
}

-- Helper: Get player by name (case-insensitive)
local function getPlayerByName(playerName)
	if not playerName or type(playerName) ~= "string" then
		return nil
	end
	
	playerName = playerName:lower()
	
	for _, player in ipairs(Players:GetPlayers()) do
		if player.Name:lower() == playerName then
			return player
		end
	end
	
	return nil
end

-- Helper: Send message to player
local function sendMessageToPlayer(player, message, messageType)
	-- messageType: "system", "error", "success", "whisper", "party"
	local color = Color3.fromRGB(255, 255, 255)
	
	if messageType == "error" then
		color = Color3.fromRGB(255, 100, 100)
	elseif messageType == "success" then
		color = Color3.fromRGB(100, 255, 100)
	elseif messageType == "system" then
		color = Color3.fromRGB(100, 200, 255)
	elseif messageType == "whisper" then
		color = Color3.fromRGB(255, 200, 100)
	elseif messageType == "party" then
		color = Color3.fromRGB(200, 100, 255)
	end
	
	-- Use TextChatService if available
	if TextChatService then
		local textChannel = TextChatService:FindFirstChild("TextChannels"):FindFirstChild("RBXSystem")
		if textChannel then
			textChannel:DisplaySystemMessage(message, player)
		else
			-- Fallback to RemoteEvent
			if Remotes:FindFirstChild("SystemMessage") then
				Remotes.SystemMessage:FireClient(player, message, color)
			end
		end
	else
		-- Fallback to RemoteEvent
		if Remotes:FindFirstChild("SystemMessage") then
			Remotes.SystemMessage:FireClient(player, message, color)
		end
	end
end

-- Helper: Broadcast message to all players
local function broadcastMessage(message, messageType)
	for _, player in ipairs(Players:GetPlayers()) do
		sendMessageToPlayer(player, message, messageType)
	end
end

-- Helper: Parse command arguments
local function parseCommand(input)
	if not input or type(input) ~= "string" then
		return nil, nil
	end
	
	-- Remove leading/trailing whitespace
	input = input:gsub("^%s*(.-)%s*$", "%1")
	
	-- Check if it's a command
	if not input:sub(1, 1) == COMMAND_CONFIG.PREFIX then
		return nil, nil
	end
	
	-- Remove prefix
	input = input:sub(2)
	
	-- Split into command and arguments
	local parts = {}
	for part in input:gmatch("%S+") do
		table.insert(parts, part)
	end
	
	if #parts == 0 then
		return nil, nil
	end
	
	local command = parts[1]:lower()
	table.remove(parts, 1)
	
	return command, parts
end

-- Command handlers
local function handleTradeCommand(player, args)
	if not TradeManager then
		sendMessageToPlayer(player, "Trading system is currently unavailable.", "error")
		return
	end
	
	if #args &lt; 1 then
		sendMessageToPlayer(player, "Usage: /trade &lt;playerName>", "error")
		return
	end
	
	local targetName = args[1]
	local targetPlayer = getPlayerByName(targetName)
	
	if not targetPlayer then
		sendMessageToPlayer(player, "Player not found: " .. targetName, "error")
		return
	end
	
	if targetPlayer == player then
		sendMessageToPlayer(player, "You cannot trade with yourself.", "error")
		return
	end
	
	-- Check if target is ignoring player
	-- (This would require an ignore system to be implemented)
	
	-- Send trade request
	-- This would call TradeManager:RequestTrade(player, targetPlayer)
	sendMessageToPlayer(player, "Trade request sent to " .. targetPlayer.Name, "success")
	sendMessageToPlayer(targetPlayer, player.Name .. " wants to trade with you.", "system")
	
	ErrorHandler:LogInfo(ErrorHandler, "Trade command executed", {
		from = player.Name,
		to = targetPlayer.Name
	})
end

local function handlePartyCommand(player, args)
	if not PartyManager then
		sendMessageToPlayer(player, "Party system is currently unavailable.", "error")
		return
	end
	
	if #args &lt; 1 then
		sendMessageToPlayer(player, "Usage: /party &lt;invite|leave|kick|chat> [args]", "error")
		return
	end
	
	local subCommand = args[1]:lower()
	table.remove(args, 1)
	
	if subCommand == "invite" then
		if #args &lt; 1 then
			sendMessageToPlayer(player, "Usage: /party invite &lt;playerName>", "error")
			return
		end
		
		local targetName = args[1]
		local targetPlayer = getPlayerByName(targetName)
		
		if not targetPlayer then
			sendMessageToPlayer(player, "Player not found: " .. targetName, "error")
			return
		end
		
		if targetPlayer == player then
			sendMessageToPlayer(player, "You cannot invite yourself.", "error")
			return
		end
		
		-- Send party invite
		-- This would call PartyManager:InvitePlayer(player, targetPlayer)
		sendMessageToPlayer(player, "Party invite sent to " .. targetPlayer.Name, "success")
		sendMessageToPlayer(targetPlayer, player.Name .. " invited you to their party.", "system")
		
	elseif subCommand == "leave" then
		-- Leave party
		-- This would call PartyManager:LeaveParty(player)
		sendMessageToPlayer(player, "You left the party.", "success")
		
	elseif subCommand == "kick" then
		if #args &lt; 1 then
			sendMessageToPlayer(player, "Usage: /party kick &lt;playerName>", "error")
			return
		end
		
		local targetName = args[1]
		local targetPlayer = getPlayerByName(targetName)
		
		if not targetPlayer then
			sendMessageToPlayer(player, "Player not found: " .. targetName, "error")
			return
		end
		
		-- Kick player from party
		-- This would call PartyManager:KickPlayer(player, targetPlayer)
		sendMessageToPlayer(player, "Kicked " .. targetPlayer.Name .. " from the party.", "success")
		sendMessageToPlayer(targetPlayer, "You were kicked from the party.", "system")
		
	elseif subCommand == "chat" then
		if #args &lt; 1 then
			sendMessageToPlayer(player, "Usage: /party chat &lt;message>", "error")
			return
		end
		
		local message = table.concat(args, " ")
		
		-- Send party chat message
		if PartyMessageEvent then
			PartyMessageEvent:FireServer(player, message)
		end
		
		sendMessageToPlayer(player, "[Party] " .. player.Name .. ": " .. message, "party")
		
	else
		sendMessageToPlayer(player, "Unknown party command: " .. subCommand, "error")
		sendMessageToPlayer(player, "Available commands: invite, leave, kick, chat", "system")
	end
	
	ErrorHandler:LogInfo(ErrorHandler, "Party command executed", {
		player = player.Name,
		command = subCommand,
		args = args
	})
end

local function handleWhisperCommand(player, args)
	if #args &lt; 2 then
		sendMessageToPlayer(player, "Usage: /whisper &lt;playerName> &lt;message>", "error")
		return
	end
	
	local targetName = args[1]
	local targetPlayer = getPlayerByName(targetName)
	
	if not targetPlayer then
		sendMessageToPlayer(player, "Player not found: " .. targetName, "error")
		return
	end
	
	if targetPlayer == player then
		sendMessageToPlayer(player, "You cannot whisper to yourself.", "error")
		return
	end
	
	-- Check if target is ignoring player
	-- (This would require an ignore system to be implemented)
	
	local message = table.concat(args, " ", 2)
	
	-- Send whisper message
	if WhisperMessageEvent then
		WhisperMessageEvent:FireServer(player, targetPlayer, message)
	end
	
	-- Notify sender
	sendMessageToPlayer(player, "[To " .. targetPlayer.Name .. "] " .. message, "whisper")
	
	-- Notify receiver
	sendMessageToPlayer(targetPlayer, "[From " .. player.Name .. "] " .. message, "whisper")
	
	ErrorHandler:LogInfo(ErrorHandler, "Whisper command executed", {
		from = player.Name,
		to = targetPlayer.Name,
		message = message
	})
end

local function handleHelpCommand(player, args)
	if #args == 0 then
		-- Show all commands
		local helpText = "Available commands:\n"
		
		for cmdName, cmdInfo in pairs(COMMAND_CONFIG.COMMANDS) do
			helpText = helpText .. string.format("  %s%s - %s\n", 
				COMMAND_CONFIG.PREFIX, cmdName, cmdInfo.description)
		end
		
		helpText = helpText .. "\nUse /help &lt;command> for more information."
		sendMessageToPlayer(player, helpText, "system")
		
	else
		-- Show specific command help
		local cmdName = args[1]:lower()
		local cmdInfo = COMMAND_CONFIG.COMMANDS[cmdName]
		
		if cmdInfo then
			local helpText = string.format("Command: %s%s\n", COMMAND_CONFIG.PREFIX, cmdName)
			helpText = helpText .. "Description: " .. cmdInfo.description .. "\n"
			helpText = helpText .. "Usage: " .. cmdInfo.usage .. "\n"
			helpText = helpText .. "Minimum arguments: " .. tostring(cmdInfo.minArgs)
			
			sendMessageToPlayer(player, helpText, "system")
		else
			sendMessageToPlayer(player, "Unknown command: " .. cmdName, "error")
		end
	end
	
	ErrorHandler:LogDebug(ErrorHandler, "Help command executed", {
		player = player.Name,
		args = args
	})
end

local function handleStatsCommand(player, args)
	if not DataManager then
		sendMessageToPlayer(player, "Stats system is currently unavailable.", "error")
		return
	end
	
	-- Get player data
	local playerData = DataManager:GetData(player)
	
	if not playerData then
		sendMessageToPlayer(player, "Could not load your data.", "error")
		return
	end
	
	-- Format stats
	local statsText = "=== Your Statistics ===\n"
	
	-- Combat stats
	if playerData.combat then
		statsText = statsText .. string.format("Combat Level: %d\n", playerData.combat.level or 1)
		statsText = statsText .. string.format("Hitpoints: %d/%d\n", 
			playerData.combat.currentHP or 10, playerData.combat.maxHP or 10)
		statsText = statsText .. string.format("Prayer: %d/%d\n",
			playerData.combat.currentPrayer or 10, playerData.combat.maxPrayer or 10)
	end
	
	-- Skills
	if playerData.skills then
		statsText = statsText .. "\n=== Skills ===\n"
		
		local skillNames = {"attack", "strength", "defense", "ranged", "magic", "prayer", 
			"mining", "woodcutting", "fishing", "cooking", "crafting", "smithing", "fletching"}
		
		for _, skillName in ipairs(skillNames) do
			local skill = playerData.skills[skillName]
			if skill then
				statsText = statsText .. string.format("%s: Level %d (XP: %d)\n",
					skillName:gsub("^%l", string.upper), skill.level or 1, skill.xp or 0)
			end
		end
	end
	
	-- Equipment
	if playerData.equipment then
		statsText = statsText .. "\n=== Equipment ===\n"
		
		local slotNames = {"head", "cape", "neck", "ammo", "weapon", "body", "shield", "legs", "hands", "feet", "ring"}
		
		for _, slotName in ipairs(slotNames) do
			local item = playerData.equipment[slotName]
			if item and item.id then
				statsText = statsText .. string.format("%s: %s\n",
					slotName:gsub("^%l", string.upper), item.name or "Unknown")
			else
				statsText = statsText .. string.format("%s: Empty\n",
					slotName:gsub("^%l", string.upper))
			end
		end
	end
	
	-- Inventory
	if playerData.inventory then
		local itemCount = 0
		for _, item in pairs(playerData.inventory) do
			if item and item.id then
				itemCount = itemCount + 1
			end
		end
		
		statsText = statsText .. string.format("\n=== Inventory ===\nItems: %d/28\n", itemCount)
	end
	
	-- Bank
	if playerData.bank then
		local bankCount = 0
		for _, item in pairs(playerData.bank) do
			if item and item.id then
				bankCount = bankCount + 1
			end
		end
		
		statsText = statsText .. string.format("Bank items: %d\n", bankCount)
	end
	
	-- Gold
	statsText = statsText .. string.format("\n=== Wealth ===\nGold: %d\n", playerData.gold or 0)
	
	-- Quests
	if playerData.quests then
		local completed = 0
		local total = 0
		
		for _, quest in pairs(playerData.quests) do
			total = total + 1
			if quest.completed then
				completed = completed + 1
			end
		end
		
		statsText = statsText .. string.format("Quests: %d/%d completed\n", completed, total)
	end
	
	-- Playtime
	if playerData.playtime then
		local hours = math.floor(playerData.playtime / 3600)
		local minutes = math.floor((playerData.playtime % 3600) / 60)
		
		statsText = statsText .. string.format("Playtime: %d hours, %d minutes\n", hours, minutes)
	end
	
	sendMessageToPlayer(player, statsText, "system")
	
	ErrorHandler:LogDebug(ErrorHandler, "Stats command executed", {
		player = player.Name
	})
end

local function handleMeCommand(player, args)
	if #args &lt; 1 then
		sendMessageToPlayer(player, "Usage: /me &lt;action>", "error")
		return
	end
	
	local action = table.concat(args, " ")
	
	-- Broadcast roleplay action
	broadcastMessage("* " .. player.Name .. " " .. action, "system")
	
	ErrorHandler:LogDebug(ErrorHandler, "Me command executed", {
		player = player.Name,
		action = action
	})
end

local function handleRollCommand(player, args)
	local max = 100
	
	if #args >= 1 then
		local arg = args[1]
		if tonumber(arg) then
			max = math.floor(tonumber(arg))
			if max &lt; 2 then max = 2 end
			if max > 1000 then max = 1000 end
		end
	end
	
	local roll = math.random(1, max)
	
	-- Broadcast roll result
	broadcastMessage(player.Name .. " rolled " .. roll .. " (1-" .. max .. ")", "system")
	
	ErrorHandler:LogDebug(ErrorHandler, "Roll command executed", {
		player = player.Name,
		roll = roll,
		max = max
	})
end

local function handleTimeCommand(player, args)
	local currentTime = os.time()
	local timeString = os.date("%I:%M %p", currentTime)
	local dateString = os.date("%B %d, %Y", currentTime)
	
	sendMessageToPlayer(player, "Server time: " .. timeString .. "\nDate: " .. dateString, "system")
	
	ErrorHandler:LogDebug(ErrorHandler, "Time command executed", {
		player = player.Name
	})
end

local function handlePlayersCommand(player, args)
	local playerCount = #Players:GetPlayers()
	local playerNames = {}
	
	for _, p in ipairs(Players:GetPlayers()) do
		table.insert(playerNames, p.Name)
	end
	
	table.sort(playerNames)
	
	local playersText = "=== Online Players ===\n"
	playersText = playersText .. "Total: " .. playerCount .. "\n\n"
	
	for i, name in ipairs(playerNames) do
		playersText = playersText .. name .. "\n"
	end
	
	sendMessageToPlayer(player, playersText, "system")
	
	ErrorHandler:LogDebug(ErrorHandler, "Players command executed", {
		player = player.Name,
		count = playerCount
	})
end

local function handleIgnoreCommand(player, args)
	if #args &lt; 1 then
		sendMessageToPlayer(player, "Usage: /ignore &lt;playerName>", "error")
		return
	end
	
	local targetName = args[1]
	local targetPlayer = getPlayerByName(targetName)
	
	if not targetPlayer then
		sendMessageToPlayer(player, "Player not found: " .. targetName, "error")
		return
	end
	
	if targetPlayer == player then
		sendMessageToPlayer(player, "You cannot ignore yourself.", "error")
		return
	end
	
	-- Add to ignore list
	-- This would require an ignore system to be implemented
	sendMessageToPlayer(player, "Now ignoring " .. targetPlayer.Name, "success")
	
	ErrorHandler:LogInfo(ErrorHandler, "Ignore command executed", {
		player = player.Name,
		target = targetPlayer.Name
	})
end

local function handleUnignoreCommand(player, args)
	if #args &lt; 1 then
		sendMessageToPlayer(player, "Usage: /unignore &lt;playerName>", "error")
		return
	end
	
	local targetName = args[1]
	local targetPlayer = getPlayerByName(targetName)
	
	if not targetPlayer then
		sendMessageToPlayer(player, "Player not found: " .. targetName, "error")
		return
	end
	
	-- Remove from ignore list
	-- This would require an ignore system to be implemented
	sendMessageToPlayer(player, "No longer ignoring " .. targetPlayer.Name, "success")
	
	ErrorHandler:LogInfo(ErrorHandler, "Unignore command executed", {
		player = player.Name,
		target = targetPlayer.Name
	})
end

-- Main command handler
local function handleCommand(player, input)
	-- Parse command
	local command, args = parseCommand(input)
	
	if not command then
		-- Not a command, could be regular chat
		return false
	end
	
	-- Get command info
	local cmdInfo = COMMAND_CONFIG.COMMANDS[command]
	
	if not cmdInfo then
		sendMessageToPlayer(player, "Unknown command: " .. command, "error")
		sendMessageToPlayer(player, "Type /help for available commands.", "system")
		return true
	end
	
	-- Check minimum arguments
	if #args &lt; cmdInfo.minArgs then
		sendMessageToPlayer(player, "Usage: " .. cmdInfo.usage, "error")
		return true
	end
	
	-- Call command handler
	local handler = _G[cmdInfo.handler]
	if not handler then
		handler = _G["handle" .. command:gsub("^%l", string.upper) .. "Command"]
	end
	
	if handler then
		local success, result = pcall(handler, player, args)
		
		if not success then
			ErrorHandler:LogError(ErrorHandler, "Command handler error", {
				player = player.Name,
				command = command,
				error = result
			})
			
			sendMessageToPlayer(player, "An error occurred while processing the command.", "error")
		end
	else
		sendMessageToPlayer(player, "Command not implemented: " .. command, "error")
	end
	
	return true
end

-- Remote event handlers
ChatCommandEvent.OnServerEvent:Connect(function(player, message)
	-- Validate player
	if not player or not player:IsA("Player") then
		ErrorHandler:LogWarning(ErrorHandler, "Invalid player for chat command")
		return
	end
	
	-- Validate message
	if not message or type(message) ~= "string" then
		ErrorHandler:LogWarning(ErrorHandler, "Invalid message for chat command", {
			player = player.Name
		})
		return
	end
	
	-- Trim message
	message = message:gsub("^%s*(.-)%s*$", "%1")
	
	if message == "" then
		return
	end
	
	-- Handle command
	local isCommand = handleCommand(player, message)
	
	if not isCommand then
		-- Regular chat message (could be processed here if needed)
		ErrorHandler:LogDebug(ErrorHandler, "Regular chat message", {
			player = player.Name,
			message = message
		})
	end
end)

WhisperMessageEvent.OnServerEvent:Connect(function(sender, target, message)
	-- Validate players
	if not sender or not sender:IsA("Player") then
		ErrorHandler:LogWarning(ErrorHandler, "Invalid sender for whisper")
		return
	end
	
	if not target or not target:IsA("Player") then
		sendMessageToPlayer(sender, "Player not found or offline.", "error")
		return
	end
	
	-- Validate message
	if not message or type(message) ~= "string" then
		ErrorHandler:LogWarning(ErrorHandler, "Invalid message for whisper", {
			sender = sender.Name,
			target = target.Name
		})
		return
	end
	
	-- Trim message
	message = message:gsub("^%s*(.-)%s*$", "%1")
	
	if message == "" then
		return
	end
	
	-- Check if target is ignoring sender
	-- (This would require an ignore system to be implemented)
	
	-- Send whisper
	sendMessageToPlayer(sender, "[To " .. target.Name .. "] " .. message, "whisper")
	sendMessageToPlayer(target, "[From " .. sender.Name .. "] " .. message, "whisper")
	
	ErrorHandler:LogInfo(ErrorHandler, "Whisper sent", {
		from = sender.Name,
		to = target.Name,
		message = message
	})
end)

PartyMessageEvent.OnServerEvent:Connect(function(player, message)
	-- Validate player
	if not player or not player:IsA("Player") then
		ErrorHandler:LogWarning(ErrorHandler, "Invalid player for party message")
		return
	end
	
	-- Validate message
	if not message or type(message) ~= "string" then
		ErrorHandler:LogWarning(ErrorHandler, "Invalid message for party chat", {
			player = player.Name
		})
		return
	end
	
	-- Trim message
	message = message:gsub("^%s*(.-)%s*$", "%1")
	
	if message == "" then
		return
	end
	
	-- Check if player is in a party
	-- This would require PartyManager integration
	
	-- For now, just echo back to player
	sendMessageToPlayer(player, "[Party] " .. player.Name .. ": " .. message, "party")
	
	ErrorHandler:LogDebug(ErrorHandler, "Party message", {
		player = player.Name,
		message = message
	})
end)

-- Player join handler
Players.PlayerAdded:Connect(function(player)
	-- Send welcome message with command info
	task.wait(2) -- Wait a bit for player to load
	
	sendMessageToPlayer(player, "Welcome to Roscape Runeblocks!", "system")
	sendMessageToPlayer(player, "Type /help for available commands.", "system")
	
	ErrorHandler:LogInfo(ErrorHandler, "Player joined - command system initialized", {
		player = player.Name
	})
end)

-- Initialize
ErrorHandler:LogInfo(ErrorHandler, "ChatCommandHandler loaded successfully", {
	commandCount = #COMMAND_CONFIG.COMMANDS,
	prefix = COMMAND_CONFIG.PREFIX
})</string>
      </Properties>
    </Item>
    <Item class="Script" referent="128">
      <Properties>
        <string name="Name">CombatManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- CombatManager.server.lua
-- Server-authoritative combat system for PvP

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Config = require(ReplicatedStorage.Modules.Config)
local ItemDB = require(ReplicatedStorage.Modules.ItemDatabase)

local DataManager = require(ReplicatedStorage.Modules.DataManager)

-- Track attack cooldowns
local attackCooldowns = {}

-- Wilderness check
local WILDERNESS_Z = -100
local function isInWilderness(position)
	return position.Z < WILDERNESS_Z
end

local Remotes = ReplicatedStorage:WaitForChild("Remotes", 5)
local attackRemote = Remotes:WaitForChild("Attack", 5)
local damageRemote = Remotes:WaitForChild("DamageDealt", 5)

-- Get player's equipped weapon damage
local function getPlayerDamage(player)
	local data = DataManager:GetData(player)
	if not data then return 5 end

	-- Find best weapon in inventory
	local bestDamage = 5 -- fist damage
	for _, slot in ipairs(data.Inventory) do
		local item = ItemDB.GetItem(slot.name)
		if item and item.type == "weapon" then
			local strLevel = DataManager.GetSkillLevel(player, "Strength")
			if strLevel >= (item.combatReq or 1) then
				if item.damage > bestDamage then
					bestDamage = item.damage
				end
			end
		end
	end

	-- Add strength level bonus
	local strLevel = DataManager.GetSkillLevel(player, "Strength")
	bestDamage = bestDamage + math.floor(strLevel * 0.5)

	return bestDamage
end

-- Get player's max health based on defense level
local function getPlayerMaxHealth(player)
	local defLevel = DataManager.GetSkillLevel(player, "Defense")
	return Config.BaseHealth + (defLevel * Config.HealthPerCombatLevel)
end

-- Set up player health on spawn
local function setupPlayerHealth(player, character)
	local humanoid = character:WaitForChild("Humanoid", 5)
	local maxHP = getPlayerMaxHealth(player)
	humanoid.MaxHealth = maxHP
	humanoid.Health = maxHP
end

-- Handle attack request from client
attackRemote.OnServerEvent:Connect(function(attacker, targetPlayer)
	-- Validate target
	if not targetPlayer or not targetPlayer:IsA("Player") then return end
	if targetPlayer == attacker then return end

	-- Cooldown check
	local now = tick()
	if attackCooldowns[attacker.UserId] and (now - attackCooldowns[attacker.UserId]) < Config.AttackCooldown then
		return -- still on cooldown
	end
	attackCooldowns[attacker.UserId] = now

	-- Both players must have characters
	local attackerChar = attacker.Character
	local targetChar = targetPlayer.Character
	if not attackerChar or not targetChar then return end

	local attackerRoot = attackerChar:FindFirstChild("HumanoidRootPart")
	local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
	if not attackerRoot or not targetRoot then return end

	-- Range check (must be within 14 studs)
	local distance = (attackerRoot.Position - targetRoot.Position).Magnitude
	if distance > 14 then return end

	-- PvP zone check â€” both must be in wilderness
	if not isInWilderness(attackerRoot.Position) or not isInWilderness(targetRoot.Position) then
		return -- can't PvP in safe zone
	end

	-- Calculate damage
	local damage = getPlayerDamage(attacker)

	-- Apply some randomness (80%-120%)
	local multiplier = 0.8 + (math.random() * 0.4)
	damage = math.floor(damage * multiplier)

	-- Apply damage
	local targetHumanoid = targetChar:FindFirstChild("Humanoid")
	if not targetHumanoid or targetHumanoid.Health <= 0 then return end

	-- Tag the kill (so WildernessManager knows who killed them)
	local tag = targetHumanoid:FindFirstChild("creator")
	if not tag then
		tag = Instance.new("ObjectValue")
		tag.Name = "creator"
		tag.Parent = targetHumanoid
	end
	tag.Value = attacker

	-- Clear tag after 5 seconds
	task.delay(5, function()
		if tag and tag.Parent then
			tag:Destroy()
		end
	end)

	targetHumanoid:TakeDamage(damage)

	-- Award XP: Strength for attacking, Defense for taking hits
	local xpGain = math.floor(damage * 1.5)
	DataManager.AddSkillXP(attacker, "Strength", xpGain)
	DataManager.AddSkillXP(targetPlayer, "Defense", math.floor(damage * 0.8))

	-- Notify both players
	damageRemote:FireClient(attacker, "dealt", damage, targetPlayer.Name)
	damageRemote:FireClient(targetPlayer, "received", damage, attacker.Name)

	print("[Combat] " .. attacker.Name .. " hit " .. targetPlayer.Name .. " for " .. damage .. " damage")
end)

-- === EAT FOOD (healing) ===
local eatRemote = Remotes:WaitForChild("EatFood", 5)

eatRemote.OnServerEvent:Connect(function(player, itemName)
	local item = ItemDB.GetItem(itemName)
	if not item or item.type ~= "food" then return end

	-- Must have the food
	if not DataManager.HasItem(player, itemName, 1) then return end

	local character = player.Character
	if not character then return end
	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoid or humanoid.Health <= 0 then return end

	-- Already full health?
	if humanoid.Health >= humanoid.MaxHealth then return end

	-- Eat it!
	DataManager.RemoveFromInventory(player, itemName, 1)
	humanoid.Health = math.min(humanoid.Health + item.healAmount, humanoid.MaxHealth)

	-- Update inventory
	local invRemote = ReplicatedStorage.Remotes:FindFirstChild("InventoryUpdate")
	if invRemote then
		local data = DataManager:GetData(player)
		invRemote:FireClient(player, data.Inventory)
	end

	print("[Combat] " .. player.Name .. " ate " .. itemName .. " and healed " .. item.healAmount .. " HP")
end)

-- === PLAYER SETUP ===
Players.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function(character)
		task.wait(0.5) -- wait for DataManager to load
		setupPlayerHealth(player, character)
	end)
end)

Players.PlayerRemoving:Connect(function(player)
	attackCooldowns[player.UserId] = nil
end)

print("[CombatManager] PvP combat system active!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="129">
      <Properties>
        <string name="Name">CookingManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	CookingManager.server.lua
	Cook raw fish at fires/ranges. Burn chance based on level.
	Click once to start, auto-repeats (AFK-able).
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local DataManager = require(ReplicatedStorage.Modules.DataManager)
local Config = require(ReplicatedStorage.Modules.Config)

local Remotes = ReplicatedStorage:WaitForChild("Remotes", 5)

-- Get cooking remotes
local CookItemEvent = Remotes:WaitForChild("CookItem", 10)

------------------------------------------------------------
-- Recipes
------------------------------------------------------------
local CookingRecipes = {
	["Shrimp"] = {
		result = "Cooked Shrimp", burnResult = "Burnt Shrimp",
		baseTime = 3, baseXP = 30, levelRequired = 1,
		burnChanceAt1 = 0.4, burnChanceAt99 = 0.05,
	},
	["Trout"] = {
		result = "Cooked Trout", burnResult = "Burnt Trout",
		baseTime = 4, baseXP = 55, levelRequired = 15,
		burnChanceAt1 = 0.5, burnChanceAt99 = 0.08,
	},
	["Lobster"] = {
		result = "Cooked Lobster", burnResult = "Burnt Lobster",
		baseTime = 5, baseXP = 80, levelRequired = 40,
		burnChanceAt1 = 0.6, burnChanceAt99 = 0.12,
	},
	["Dark Crab"] = {
		result = "Cooked Dark Crab", burnResult = "Burnt Dark Crab",
		baseTime = 6, baseXP = 130, levelRequired = 70,
		burnChanceAt1 = 0.7, burnChanceAt99 = 0.18,
	},
}

------------------------------------------------------------
-- State
------------------------------------------------------------
local activeCookers = {} -- [UserId] = true

------------------------------------------------------------
-- Find nearby cooking fire
------------------------------------------------------------
local function findNearbyFire(player)
	local char = player.Character
	if not char then return nil end
	local root = char:FindFirstChild("HumanoidRootPart")
	if not root then return nil end

	local fires = workspace:FindFirstChild("CookingFires")
	if not fires then return nil end

	for _, fire in ipairs(fires:GetChildren()) do
		if fire:IsA("Part") then
			local d = (fire.Position - root.Position).Magnitude
			if d <= 10 then return fire end
		end
	end
	return nil
end

------------------------------------------------------------
-- Burn chance
------------------------------------------------------------
local function calculateBurnChance(recipe, cookingLevel)
	local minChance = recipe.burnChanceAt99
	local maxChance = recipe.burnChanceAt1
	local factor = math.max(0, math.min(1, (99 - cookingLevel) / 98))
	return minChance + (maxChance - minChance) * factor
end

------------------------------------------------------------
-- Cook one item, returns true to keep going
------------------------------------------------------------
local function cookOne(player, rawItemName, recipe, cookingSpot)
	local cookingLevel = DataManager.GetSkillLevel(player, "Cooking")

	-- Tell client cooking started
	CookItemEvent:FireClient(player, {
		action = "start",
		totalTime = recipe.baseTime,
		itemName = rawItemName,
	})

	-- Wait for cook time, checking distance
	local elapsed = 0
	while elapsed < recipe.baseTime do
		task.wait(0.25)
		elapsed = elapsed + 0.25

		if not activeCookers[player.UserId] then return false end

		local char = player.Character
		if not char then return false end
		local root = char:FindFirstChild("HumanoidRootPart")
		if not root then return false end
		local hum = char:FindFirstChildOfClass("Humanoid")
		if not hum or hum.Health <= 0 then return false end
		if (root.Position - cookingSpot.Position).Magnitude > 12 then return false end

		-- Send progress
		CookItemEvent:FireClient(player, {
			action = "progress",
			progress = elapsed / recipe.baseTime,
		})
	end

	-- Determine if burnt
	local burnChance = calculateBurnChance(recipe, cookingLevel)
	local isBurnt = math.random() < burnChance
	local resultItem = isBurnt and recipe.burnResult or recipe.result
	local xpGained = isBurnt and 0 or recipe.baseXP

	-- Add result
	local added = DataManager.AddToInventory(player, resultItem, 1)
	if not added then
		CookItemEvent:FireClient(player, {action = "full"})
		return false
	end

	-- Award XP
	if xpGained > 0 then
		DataManager.AddSkillXP(player, "Cooking", xpGained)
		local xpRemote = Remotes:FindFirstChild("XPUpdate")
		if xpRemote then xpRemote:FireClient(player) end
	end

	-- Update inventory
	local invRemote = Remotes:FindFirstChild("InventoryUpdate")
	if invRemote then invRemote:FireClient(player) end

	-- Notify completion
	CookItemEvent:FireClient(player, {
		result = resultItem,
		xpGained = xpGained,
		burnt = isBurnt,
	})

	return true
end

------------------------------------------------------------
-- Main cooking handler (auto-repeat)
------------------------------------------------------------
local function startCooking(player, rawItemName)
	if activeCookers[player.UserId] then return end

	local recipe = CookingRecipes[rawItemName]
	if not recipe then return end

	local cookingLevel = DataManager.GetSkillLevel(player, "Cooking")
	if cookingLevel < recipe.levelRequired then return end

	if not DataManager.HasItem(player, rawItemName, 1) then return end

	local cookingSpot = findNearbyFire(player)
	if not cookingSpot then return end

	activeCookers[player.UserId] = true

	task.spawn(function()
		while activeCookers[player.UserId] do
			-- Check still have the raw item
			if not DataManager.HasItem(player, rawItemName, 1) then break end

			-- Remove raw item
			if not DataManager.RemoveFromInventory(player, rawItemName, 1) then break end

			-- Cook it
			local keepGoing = cookOne(player, rawItemName, recipe, cookingSpot)
			if not keepGoing then break end

			task.wait(0.3)
		end

		activeCookers[player.UserId] = nil
		CookItemEvent:FireClient(player, {action = "stop"})
	end)
end

------------------------------------------------------------
-- Events
------------------------------------------------------------
CookItemEvent.OnServerEvent:Connect(function(player, rawItemName)
	if activeCookers[player.UserId] then
		-- Toggle off
		activeCookers[player.UserId] = nil
		return
	end
	startCooking(player, rawItemName)
end)

Players.PlayerRemoving:Connect(function(player)
	activeCookers[player.UserId] = nil
end)

------------------------------------------------------------
-- Add ClickDetectors to cooking fires
------------------------------------------------------------
task.defer(function()
	task.wait(3)
	local fires = workspace:FindFirstChild("CookingFires")
	if not fires then return end

	for _, fire in ipairs(fires:GetChildren()) do
		if fire:IsA("Part") then
			-- Add click detector
			if not fire:FindFirstChild("ClickDetector") then
				local cd = Instance.new("ClickDetector")
				cd.MaxActivationDistance = 10
				cd.Parent = fire
			end

			-- Add label
			if not fire:FindFirstChild("BillboardGui") then
				local bbg = Instance.new("BillboardGui")
				bbg.Size = UDim2.new(5, 0, 1, 0)
				bbg.StudsOffset = Vector3.new(0, 2.5, 0)
				bbg.Parent = fire

				local lbl = Instance.new("TextLabel")
				lbl.Size = UDim2.new(1, 0, 1, 0)
				lbl.BackgroundTransparency = 1
				lbl.Text = "ðŸ”¥ Cooking Fire"
				lbl.TextColor3 = Color3.fromRGB(255, 180, 80)
				lbl.TextScaled = true
				lbl.Font = Enum.Font.GothamBold
				lbl.TextStrokeTransparency = 0.5
				lbl.Parent = bbg
			end
		end
	end
	print("[CookingManager] Cooking fires ready")
end)

print("[CookingManager] Cooking system initialized")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="130">
      <Properties>
        <string name="Name">CraftingManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	CraftingManager.server.lua
	Handles Smithing & Cooking crafting stations for Haven town.
	Validates recipes, consumes ingredients, awards products & XP.
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Modules
local Modules = ReplicatedStorage:WaitForChild("Modules", 5)
local DataManager = require(Modules:WaitForChild("DataManager", 5))
local ItemDatabase = require(Modules:WaitForChild("ItemDatabase", 5))

----------------------------------------------------------------------
-- Remote Events
----------------------------------------------------------------------
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
local CraftRequest = Remotes:WaitForChild("CraftRequest", 10)
local CraftComplete = Remotes:WaitForChild("CraftComplete", 10)
local CraftUpdate = Remotes:WaitForChild("CraftUpdate", 10)

----------------------------------------------------------------------
-- Recipe Definitions
----------------------------------------------------------------------
export type Recipe = {
	id: string,
	skill: string,
	level: number,
	xp: number,
	ingredients: { [string]: number },
	product: string,
	productQty: number,
	station: string, -- "Anvil" | "Forge" | "CookingRange"
}

local Recipes: { Recipe } = {
	-- Smithing: smelting (Forge)
	{ id = "smelt_copper",  skill = "Smithing", level = 1,  xp = 25,  ingredients = { ["Copper Ore"] = 1 }, product = "Copper Bar", productQty = 1, station = "Forge" },
	{ id = "smelt_iron",    skill = "Smithing", level = 15, xp = 45,  ingredients = { ["Iron Ore"]   = 1 }, product = "Iron Bar",   productQty = 1, station = "Forge" },
	{ id = "smelt_gold",    skill = "Smithing", level = 40, xp = 75,  ingredients = { ["Gold Ore"]   = 1 }, product = "Gold Bar",   productQty = 1, station = "Forge" },

	-- Smithing: smithing (Anvil)
	{ id = "smith_copper_sword", skill = "Smithing", level = 1,  xp = 50,  ingredients = { ["Copper Bar"] = 2 }, product = "Copper Sword", productQty = 1, station = "Anvil" },
	{ id = "smith_iron_sword",   skill = "Smithing", level = 20, xp = 80,  ingredients = { ["Iron Bar"]   = 2 }, product = "Iron Sword",   productQty = 1, station = "Anvil" },
	{ id = "smith_gold_sword",   skill = "Smithing", level = 45, xp = 120, ingredients = { ["Gold Bar"]   = 3 }, product = "Gold Sword",   productQty = 1, station = "Anvil" },

	-- Cooking (CookingRange)
	{ id = "cook_shrimp",    skill = "Cooking", level = 1,  xp = 20,  ingredients = { ["Shrimp"]    = 1 }, product = "Cooked Shrimp",    productQty = 1, station = "CookingRange" },
	{ id = "cook_trout",     skill = "Cooking", level = 20, xp = 40,  ingredients = { ["Trout"]     = 1 }, product = "Cooked Trout",     productQty = 1, station = "CookingRange" },
	{ id = "cook_lobster",   skill = "Cooking", level = 40, xp = 65,  ingredients = { ["Lobster"]   = 1 }, product = "Cooked Lobster",   productQty = 1, station = "CookingRange" },
	{ id = "cook_dark_crab", skill = "Cooking", level = 70, xp = 140, ingredients = { ["Dark Crab"] = 1 }, product = "Cooked Dark Crab", productQty = 1, station = "CookingRange" },
}

-- Index by id for fast lookup
local RecipeById: { [string]: Recipe } = {}
for _, r in Recipes do
	RecipeById[r.id] = r
end

----------------------------------------------------------------------
-- Helpers
----------------------------------------------------------------------

--- Check if player has enough of each ingredient
local function hasIngredients(player: Player, ingredients: { [string]: number }): boolean
	for itemName, qty in ingredients do
		if DataManager:GetItemCount(player, itemName) < qty then
			return false
		end
	end
	return true
end

--- Get player skill level
local function getSkillLevel(player: Player, skill: string): number
	return DataManager:GetSkillLevel(player, skill) or 1
end

--- How many times can the player craft this recipe?
local function maxCraftCount(player: Player, recipe: Recipe): number
	local count = math.huge
	for itemName, qty in recipe.ingredients do
		local have = DataManager:GetItemCount(player, itemName)
		count = math.min(count, math.floor(have / qty))
	end
	if count == math.huge then count = 0 end
	return count
end

----------------------------------------------------------------------
-- Craft Handler
----------------------------------------------------------------------
local function handleCraftRequest(player, recipeId, quantity)
	-- Validate recipe exists
	local recipe = RecipeById[recipeId]
	if not recipe then
		warn("[CraftingManager] Unknown recipe:", recipeId)
		CraftComplete:FireClient(player, { success = false, message = "Unknown recipe." })
		return
	end

	-- Clamp quantity
	quantity = math.clamp(math.floor(quantity or 1), 1, 100)

	-- Check skill level
	local level = getSkillLevel(player, recipe.skill)
	if level < recipe.level then
		CraftComplete:FireClient(player, {
			success = false,
			message = string.format("You need %s level %d to craft this.", recipe.skill, recipe.level),
		})
		return
	end

	-- Determine how many we can actually craft
	local canCraft = math.min(quantity, maxCraftCount(player, recipe))
	if canCraft <= 0 then
		CraftComplete:FireClient(player, { success = false, message = "Not enough ingredients." })
		return
	end

	-- Process each craft one at a time (allows progress updates)
	local crafted = 0
	for i = 1, canCraft do
		-- Re-check ingredients each iteration (safety)
		if not hasIngredients(player, recipe.ingredients) then break end

		-- Consume ingredients
		for itemName, qty in recipe.ingredients do
			DataManager:RemoveItem(player, itemName, qty)
		end

		-- Grant product
		DataManager:AddItem(player, recipe.product, recipe.productQty)

		-- Award XP
		DataManager:AddSkillXP(player, recipe.skill, recipe.xp)

		crafted += 1

		-- Send progress update to client
		CraftUpdate:FireClient(player, {
			recipeId = recipeId,
			current = i,
			total = canCraft,
		})

		-- Wait between crafts (server pacing â€” client shows progress bar)
		if i < canCraft then
			task.wait(1.5)
		end
	end

	-- Done
	CraftComplete:FireClient(player, {
		success = true,
		recipeId = recipeId,
		crafted = crafted,
		product = recipe.product,
		message = string.format("Crafted %dx %s!", crafted, recipe.product),
	})
end

CraftRequest.OnServerEvent:Connect(handleCraftRequest)

----------------------------------------------------------------------
-- Station Setup (ClickDetectors)
----------------------------------------------------------------------
local STATION_NAMES = { "Anvil", "Forge", "CookingRange" }

local function setupStations()
	-- Wait for MapSetup to finish placing parts
	task.wait(2)

	for _, stationName in STATION_NAMES do
		local part = workspace:FindFirstChild(stationName, true)
		if not part then
			-- Station not placed on map yet, skip silently
			continue
		end

		-- Add ClickDetector if missing
		local cd = part:FindFirstChildOfClass("ClickDetector")
		if not cd then
			cd = Instance.new("ClickDetector")
			cd.MaxActivationDistance = 10
			cd.Parent = part
		end

		cd.MouseClick:Connect(function(player: Player)
			-- Tell client to open the crafting UI for this station
			CraftUpdate:FireClient(player, {
				action = "open",
				station = stationName,
				recipes = getRecipesForStation(stationName, player),
			})
		end)

		print(string.format("[CraftingManager] ClickDetector ready on %s", stationName))
	end
end

--- Build recipe list payload for a station, annotated with player info
function getRecipesForStation(stationName: string, player: Player): { any }
	local list = {}
	local playerSkills = {} -- cache

	for _, recipe in Recipes do
		if recipe.station ~= stationName then continue end

		-- Cache skill level
		if not playerSkills[recipe.skill] then
			playerSkills[recipe.skill] = getSkillLevel(player, recipe.skill)
		end
		local lvl = playerSkills[recipe.skill]

		-- Build ingredient info
		local ingredientInfo = {}
		for itemName, qty in recipe.ingredients do
			table.insert(ingredientInfo, {
				name = itemName,
				required = qty,
				have = DataManager:GetItemCount(player, itemName),
			})
		end

		table.insert(list, {
			id = recipe.id,
			product = recipe.product,
			productQty = recipe.productQty,
			skill = recipe.skill,
			level = recipe.level,
			xp = recipe.xp,
			ingredients = ingredientInfo,
			canCraft = lvl >= recipe.level,
			maxCraft = maxCraftCount(player, recipe),
		})
	end

	return list
end

----------------------------------------------------------------------
-- Init
----------------------------------------------------------------------
task.spawn(setupStations)
print("[CraftingManager] Crafting system active!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="131">
      <Properties>
        <string name="Name">DeathManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	DeathManager.server.lua
	Server-side death and respawn system for the Wilderness MMO.
	- Wilderness deaths: drop ALL inventory (full loot PvP), create grave
	- Safe zone deaths: keep items, respawn at Haven
	- Death screen overlay with timer and respawn button
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")

local DataManager = require(ReplicatedStorage.Modules.DataManager)

------------------------------------------------------------
-- Remote Events
------------------------------------------------------------
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
local PlayerDiedEvent = Remotes:WaitForChild("PlayerDied", 10)
local RespawnPlayerEvent = Remotes:WaitForChild("RespawnPlayer", 10)
local ShowDeathScreenEvent = Remotes:WaitForChild("ShowDeathScreen", 10)
local GraveInteractEvent = Remotes:WaitForChild("GraveInteract", 10)

------------------------------------------------------------
-- Constants
------------------------------------------------------------
local RESPAWN_POSITIONS = {
	Safe = Vector3.new(0, 15, 0), -- Haven City center (consistent with GameInit)
	Wilderness = Vector3.new(0, 15, 0), -- Still respawn at Haven
}

local GRAVE_LIFETIME = 120 -- 2 minutes in seconds
local DEATH_TIMER = 5 -- 5 seconds before can respawn

------------------------------------------------------------
-- Active Graves
------------------------------------------------------------
local activeGraves = {} -- [graveModel] = { owner, items, timestamp, position }

------------------------------------------------------------
-- Zone Detection
------------------------------------------------------------
local function getPlayerZone(player)
	local character = player.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") then
		return "Safe" -- Default to safe
	end

	local position = character.HumanoidRootPart.Position
	-- Simple zone detection - beyond 200 studs from Haven (50,15,50) is Wilderness
	local havenCenter = Vector3.new(50, 15, 50)
	local distance = (position - havenCenter).Magnitude

	if distance > 200 then
		return "Wilderness"
	else
		return "Safe"
	end
end

------------------------------------------------------------
-- Grave System
------------------------------------------------------------
local function createGrave(player, position, droppedItems)
	-- Create grave model
	local grave = Instance.new("Model")
	grave.Name = player.Name .. "'s Grave"
	grave.Parent = workspace

	-- Main gravestone
	local stone = Instance.new("Part")
	stone.Name = "Gravestone"
	stone.Size = Vector3.new(2, 3, 0.5)
	stone.Position = position + Vector3.new(0, 1.5, 0)
	stone.BrickColor = BrickColor.new("Dark stone grey")
	stone.Material = Enum.Material.Rock
	stone.Anchored = true
	stone.CanCollide = false
	stone.Parent = grave

	-- Make it slightly rounded
	local cornerRound = Instance.new("UICorner")
	cornerRound.CornerRadius = UDim.new(0, 8)

	-- Cross on top
	local cross = Instance.new("Part")
	cross.Name = "Cross"
	cross.Size = Vector3.new(0.8, 0.2, 0.2)
	cross.Position = stone.Position + Vector3.new(0, 1.7, 0)
	cross.BrickColor = BrickColor.new("Institutional white")
	cross.Material = Enum.Material.Marble
	cross.Anchored = true
	cross.CanCollide = false
	cross.Parent = grave

	local crossV = cross:Clone()
	crossV.Size = Vector3.new(0.2, 0.8, 0.2)
	crossV.Position = cross.Position
	crossV.Parent = grave

	-- Nameplate
	local nameGui = Instance.new("BillboardGui")
	nameGui.Size = UDim2.new(4, 0, 2, 0)
	nameGui.StudsOffset = Vector3.new(0, 1, 0)
	nameGui.Parent = stone

	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(1, 0, 0.6, 0)
	nameLabel.Position = UDim2.new(0, 0, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = "RIP " .. player.Name
	nameLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	nameLabel.TextScaled = true
	nameLabel.Font = Enum.Font.Antique
	nameLabel.Parent = nameGui

	local itemCountLabel = Instance.new("TextLabel")
	itemCountLabel.Size = UDim2.new(1, 0, 0.4, 0)
	itemCountLabel.Position = UDim2.new(0, 0, 0.6, 0)
	itemCountLabel.BackgroundTransparency = 1
	itemCountLabel.Text = #droppedItems .. " items"
	itemCountLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
	itemCountLabel.TextScaled = true
	itemCountLabel.Font = Enum.Font.Gotham
	itemCountLabel.Parent = nameGui

	-- Click detection
	local detector = Instance.new("ClickDetector")
	detector.MaxActivationDistance = 10
	detector.Parent = stone

	-- Store grave info
	activeGraves[grave] = {
		owner = player.UserId,
		ownerName = player.Name,
		items = droppedItems,
		timestamp = tick(),
		position = position
	}

	-- Handle clicks
	detector.MouseClick:Connect(function(clickingPlayer)
		if activeGraves[grave] then
			local items = activeGraves[grave].items
			local owner = activeGraves[grave].owner

			-- Anyone can loot graves in Wilderness (full PvP loot)
			GraveInteractEvent:FireClient(clickingPlayer, {
				graveName = grave.Name,
				items = items,
				isOwner = clickingPlayer.UserId == owner,
				ownerName = activeGraves[grave].ownerName
			})
		end
	end)

	-- Auto-cleanup after lifetime
	Debris:AddItem(grave, GRAVE_LIFETIME)
	task.spawn(function()
		task.wait(GRAVE_LIFETIME)
		activeGraves[grave] = nil
	end)

	print("[DeathManager] Created grave for", player.Name, "with", #droppedItems, "items")
	return grave
end

local function lootGrave(player, graveName)
	-- Find the grave
	local grave = workspace:FindFirstChild(graveName)
	if not grave or not activeGraves[grave] then
		return
	end

	local graveData = activeGraves[grave]
	local items = graveData.items

	-- Add items to player inventory
	local playerData = DataManager:GetData(player)
	if playerData then
		playerData.Inventory = playerData.Inventory or {}
		
		for _, item in ipairs(items) do
			table.insert(playerData.Inventory, item)
		end

		DataManager:SaveData(player)
		print("[DeathManager]", player.Name, "looted grave with", #items, "items")
		
		-- Update inventory UI
		local invUpdateEvent = ReplicatedStorage:FindFirstChild("InventoryUpdate")
		if invUpdateEvent and invUpdateEvent:IsA("RemoteEvent") then
			local data = DataManager:GetData(player)
			if data and data.Inventory then
				invUpdateEvent:FireClient(player, data.Inventory)
			end
		end
	end

	-- Remove grave
	activeGraves[grave] = nil
	if grave.Parent then
		grave:Destroy()
	end
end

------------------------------------------------------------
-- Death Handling
------------------------------------------------------------

-- Respawn function (must be defined before handlePlayerDeath uses it)
local function respawnPlayer(player)
	-- Respawn player at Haven City
	local respawnPosition = RESPAWN_POSITIONS.Safe
	
	-- Load character
	player:LoadCharacter()
	
	-- Wait for character to load and teleport
	local character = player.CharacterAdded:Wait()
	local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
	
	-- Teleport to respawn position
	task.wait(0.1) -- Small delay to ensure character is fully loaded
	humanoidRootPart.CFrame = CFrame.new(respawnPosition)
	
	print("[DeathManager]", player.Name, "respawned at Haven City")
end

local function handlePlayerDeath(player, killer)
	local character = player.Character
	if not character then return end

	local zone = getPlayerZone(player)
	local deathPosition = character:FindFirstChild("HumanoidRootPart") and 
		character.HumanoidRootPart.Position or Vector3.new(50, 15, 50)

	local playerData = DataManager:GetData(player)
	if not playerData then return end

	-- Update death stats
	playerData.TotalDeaths = (playerData.TotalDeaths or 0) + 1
	if killer then
		local killerData = DataManager:GetData(killer)
		if killerData then
			killerData.TotalKills = (killerData.TotalKills or 0) + 1
			DataManager:SaveData(killer)
		end
	end

	local droppedItems = {}

	if zone == "Wilderness" then
		-- WILDERNESS DEATH: Drop everything
		print("[DeathManager]", player.Name, "died in Wilderness - dropping all items")
		
		-- Copy inventory to dropped items
		if playerData.Inventory then
			for _, item in ipairs(playerData.Inventory) do
				table.insert(droppedItems, {
					name = item.name,
					quantity = item.quantity
				})
			end
		end

		-- Clear inventory
		playerData.Inventory = {}

		-- Create grave with dropped items
		if #droppedItems > 0 then
			createGrave(player, deathPosition, droppedItems)
		end
	else
		-- SAFE ZONE DEATH: Keep items
		print("[DeathManager]", player.Name, "died in Safe zone - keeping items")
		-- Items stay in inventory, no grave created
	end

	-- Save player data
	DataManager:SaveData(player)

	-- Show death screen
	ShowDeathScreenEvent:FireClient(player, {
		zone = zone,
		droppedItemCount = #droppedItems,
		killer = killer and killer.Name or nil,
		deathTimer = DEATH_TIMER
	})

	-- Force respawn after timer
	task.spawn(function()
		task.wait(DEATH_TIMER)
		respawnPlayer(player)
	end)

	print("[DeathManager]", player.Name, "died in", zone, "- dropped", #droppedItems, "items")
end

------------------------------------------------------------
-- Event Handlers
------------------------------------------------------------

-- Listen for player deaths
Players.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function(character)
		local humanoid = character:WaitForChild("Humanoid", 5)
		
		humanoid.Died:Connect(function()
			-- Try to find who killed the player (basic implementation)
			local killer = nil
			local lastDamager = character:FindFirstChild("LastDamager")
			if lastDamager and lastDamager.Value and lastDamager.Value.Parent then
				killer = Players:GetPlayerFromCharacter(lastDamager.Value.Parent)
			end
			
			handlePlayerDeath(player, killer)
		end)
	end)
end)

-- Handle respawn requests
RespawnPlayerEvent.OnServerEvent:Connect(function(player)
	respawnPlayer(player)
end)

-- Handle grave looting
GraveInteractEvent.OnServerEvent:Connect(function(player, graveName)
	lootGrave(player, graveName)
end)

------------------------------------------------------------
-- Cleanup
------------------------------------------------------------

-- Clean up graves periodically
task.spawn(function()
	while true do
		task.wait(30) -- Check every 30 seconds
		
		local currentTime = tick()
		for grave, data in pairs(activeGraves) do
			if currentTime - data.timestamp > GRAVE_LIFETIME then
				activeGraves[grave] = nil
				if grave.Parent then
					grave:Destroy()
				end
			end
		end
	end
end)

Players.PlayerRemoving:Connect(function(player)
	-- Clean up any data related to the leaving player
	-- Graves will persist for other players to loot
end)

print("[DeathManager] Death and respawn system initialized")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="132">
      <Properties>
        <string name="Name">DropHandler</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	DropHandler.server.lua
	Handles dropping items from inventory onto the ground.
	Shift+click in inventory fires DropItem remote.
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

task.wait(3)

local DataManager = require(ReplicatedStorage.Modules.DataManager)
local ItemDatabase = require(ReplicatedStorage.Modules.ItemDatabase)

local RARITY_COLORS = {
	common = Color3.fromRGB(157, 157, 157),
	uncommon = Color3.fromRGB(30, 255, 0),
	rare = Color3.fromRGB(0, 112, 221),
	epic = Color3.fromRGB(163, 53, 238),
	legendary = Color3.fromRGB(255, 128, 0),
}

local DESPAWN_TIME = 120 -- seconds before dropped items vanish

local Remotes = ReplicatedStorage:WaitForChild("Remotes", 5)
local DropItemRemote = Remotes:WaitForChild("DropItem", 5)
local UseItemRemote = Remotes:WaitForChild("UseItem", 5)

DropItemRemote.OnServerEvent:Connect(function(player, itemName, qty)
	if type(itemName) ~= "string" or type(qty) ~= "number" then return end
	qty = math.max(1, math.floor(qty))

	-- Validate player has the item
	local data = DataManager:GetData(player)
	if not data or not data.Inventory then return end

	-- Find item in inventory
	local found = false
	for i, slot in ipairs(data.Inventory) do
		if slot.name == itemName then
			if slot.quantity and slot.quantity > 1 then
				slot.quantity = slot.quantity - qty
				if slot.quantity <= 0 then
					table.remove(data.Inventory, i)
				end
			else
				table.remove(data.Inventory, i)
			end
			found = true
			break
		end
	end

	if not found then return end

	-- Notify client of inventory update
	local invRemote = Remotes:FindFirstChild("InventoryUpdate")
	if invRemote then
		local data = DataManager:GetData(player)
		if data and data.Inventory then
			invRemote:FireClient(player, data.Inventory)
		end
	end

	-- Spawn the item on the ground near the player
	local char = player.Character
	if not char then return end
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	-- Drop position: in front of player, on the ground
	local dropPos = hrp.Position + hrp.CFrame.LookVector * 3
	dropPos = Vector3.new(dropPos.X, 0.6, dropPos.Z)

	local itemDef = ItemDatabase.Items and ItemDatabase.Items[itemName]
	local rarity = (itemDef and itemDef.rarity) or "common"

	local itemPart = Instance.new("Part")
	itemPart.Name = "DroppedItem_" .. itemName
	itemPart.Size = Vector3.new(1.2, 1.2, 1.2)
	itemPart.Shape = Enum.PartType.Block
	itemPart.Anchored = true
	itemPart.CanCollide = false
	itemPart.Position = dropPos
	itemPart.Material = Enum.Material.Neon
	itemPart.Color = RARITY_COLORS[rarity] or RARITY_COLORS.common
	itemPart.Parent = workspace

	-- Label
	local bbg = Instance.new("BillboardGui")
	bbg.Size = UDim2.new(5, 0, 1, 0)
	bbg.StudsOffset = Vector3.new(0, 1.5, 0)
	bbg.AlwaysOnTop = true
	bbg.Adornee = itemPart
	bbg.Parent = itemPart

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	local displayText = itemName
	if qty > 1 then displayText = displayText .. " x" .. qty end
	label.Text = displayText
	label.TextColor3 = RARITY_COLORS[rarity] or RARITY_COLORS.common
	label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	label.TextStrokeTransparency = 0
	label.TextScaled = true
	label.Font = Enum.Font.GothamBold
	label.Parent = bbg

	-- Click to pick up (anyone can pick up dropped items)
	local click = Instance.new("ClickDetector")
	click.MaxActivationDistance = 14
	click.Parent = itemPart

	local picked = false
	click.MouseClick:Connect(function(picker)
		if picked then return end
		picked = true
		pcall(function()
			DataManager.AddToInventory(picker, itemName, qty)
		end)
		-- Notify client of inventory update
		local invRemote = Remotes:FindFirstChild("InventoryUpdate")
		if invRemote then
			invRemote:FireClient(picker)
		end
		TweenService:Create(itemPart, TweenInfo.new(0.3), {
			Size = Vector3.new(0.1, 0.1, 0.1),
			Transparency = 1,
		}):Play()
		task.delay(0.35, function()
			if itemPart and itemPart.Parent then itemPart:Destroy() end
		end)
	end)

	-- Bobbing (with race condition protection)
	task.spawn(function()
		if not itemPart or not itemPart.Parent then return end
		local startY = itemPart.Position.Y
		local t = math.random() * math.pi * 2
		while true do
			-- Double-check every iteration to prevent race condition
			if not itemPart or not itemPart.Parent then break end
			t = t + 0.05
			
			-- Protect the Position assignment
			local success, err = pcall(function()
				if itemPart and itemPart.Parent then
					itemPart.Position = Vector3.new(itemPart.Position.X, startY + math.sin(t) * 0.3, itemPart.Position.Z)
				end
			end)
			if not success then break end -- Exit loop if casting error occurs
			
			task.wait(0.03)
		end
	end)

	-- Auto-despawn
	task.delay(DESPAWN_TIME, function()
		if itemPart and itemPart.Parent then itemPart:Destroy() end
	end)

	print("[DropHandler] " .. player.Name .. " dropped " .. itemName .. " x" .. qty)
end)

print("[DropHandler] Ready!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="133">
      <Properties>
        <string name="Name">EquipmentManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- EquipmentManager.server.lua
-- Handles equipping/unequipping items for players

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local DataManager = require(ReplicatedStorage:WaitForChild("Modules", 5):WaitForChild("DataManager", 5))
local ItemDatabase = require(ReplicatedStorage:WaitForChild("Modules", 5):WaitForChild("ItemDatabase", 5))

-- Valid equipment slots
local VALID_SLOTS = {Head = true, Body = true, Legs = true, Weapon = true, Shield = true, Tool = true, Cape = true}

-- Get remotes from Remotes folder (created by Rojo project.json)
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 5)
local EquipItemRemote = Remotes:WaitForChild("EquipItem", 5)
local UnequipItemRemote = Remotes:WaitForChild("UnequipItem", 5)
local EquipmentUpdateRemote = Remotes:WaitForChild("EquipmentUpdate", 5)
local EquipmentInfoRemote = Remotes:WaitForChild("EquipmentInfo", 5)

local function getWeaponTypeFromName(weaponName)
	if not weaponName or weaponName == "" then return "fist" end
	local lower = weaponName:lower()
	if lower:find("crossbow") then return "crossbow"
	elseif lower:find("bow") then return "bow"
	elseif lower:find("axe") or lower:find("battleaxe") or lower:find("halberd") then return "sword" -- client sub-classifies by name
	elseif lower:find("dagger") or lower:find("knife") or lower:find("shiv") then return "sword" -- client sub-classifies by name
	elseif lower:find("sword") or lower:find("scimitar") then return "sword"
	else return "sword" end
end

local function sendEquipmentUpdate(player)
	local data = DataManager:GetData(player)
	if data then
		EquipmentUpdateRemote:FireClient(player, data.Equipment)

		-- Send weapon type info to client for animation system
		local weaponName = (data.Equipment and data.Equipment.Weapon) or ""
		local weaponType = getWeaponTypeFromName(weaponName)
		EquipmentInfoRemote:FireClient(player, {
			weaponType = weaponType,
			weaponName = weaponName,
			hasShield = (data.Equipment.Shield ~= nil and data.Equipment.Shield ~= ""),
		})
	end
	-- Fire BindableEvent so VisualEquipment updates character appearance
	local equipChanged = ReplicatedStorage:FindFirstChild("EquipmentChanged")
	if equipChanged then
		equipChanged:Fire(player)
	end
end

EquipItemRemote.OnServerEvent:Connect(function(player, slotName, itemName)
	if type(slotName) ~= "string" or type(itemName) ~= "string" then return end
	if not VALID_SLOTS[slotName] then return end

	local data = DataManager:GetData(player)
	if not data then return end

	-- Validate item exists in database and fits the slot
	local itemInfo = ItemDatabase.GetItem(itemName)
	if not itemInfo then return end
	if itemInfo.equipSlot ~= slotName then return end

	-- Validate player has the item
	if not DataManager.HasItem(player, itemName, 1) then return end

	-- Unequip current item in that slot (put back in inventory)
	local currentEquip = data.Equipment[slotName]
	if currentEquip and currentEquip ~= "" then
		DataManager.AddToInventory(player, currentEquip, 1)
	end

	-- Remove new item from inventory and equip it
	DataManager.RemoveFromInventory(player, itemName, 1)
	data.Equipment[slotName] = itemName

	sendEquipmentUpdate(player)
	-- Also notify inventory changed (item moved from inventory to equipment)
	local invRemote = Remotes:FindFirstChild("InventoryUpdate")
	if invRemote then invRemote:FireClient(player) end
	print("[Equipment] " .. player.Name .. " equipped " .. itemName .. " in " .. slotName)
end)

UnequipItemRemote.OnServerEvent:Connect(function(player, slotName)
	if type(slotName) ~= "string" then return end
	if not VALID_SLOTS[slotName] then return end

	local data = DataManager:GetData(player)
	if not data then return end

	local currentEquip = data.Equipment[slotName]
	if not currentEquip or currentEquip == "" then return end

	-- Move back to inventory
	local added = DataManager.AddToInventory(player, currentEquip, 1)
	if not added then return end -- inventory full

	data.Equipment[slotName] = ""
	sendEquipmentUpdate(player)
	-- Also notify inventory changed (item moved from equipment to inventory)
	local invRemote = Remotes:FindFirstChild("InventoryUpdate")
	if invRemote then invRemote:FireClient(player) end
	print("[Equipment] " .. player.Name .. " unequipped " .. currentEquip .. " from " .. slotName)
end)

-- Send equipment state when player joins
Players.PlayerAdded:Connect(function(player)
	-- Wait for data to load
	task.defer(function()
		task.wait(2)
		sendEquipmentUpdate(player)
	end)
end)

print("[EquipmentManager] Loaded!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="134">
      <Properties>
        <string name="Name">ErrorHandlingTest</string>
        <token name="RunContext">0</token>
        <string name="Source">-- ErrorHandlingTest.server.lua
-- Comprehensive test of error handling system

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local TestService = game:GetService("TestService")

print("=== Error Handling System Test ===")
print("Testing comprehensive error handling implementation...")

-- Test 1: Load ErrorHandler module
print("\n[Test 1] Loading ErrorHandler module...")
local ErrorHandler
local success, err = pcall(function()
	local Modules = ReplicatedStorage:WaitForChild("Modules", 5)
	ErrorHandler = require(Modules:WaitForChild("ErrorHandler", 5))
end)

if success and ErrorHandler then
	print("âœ“ ErrorHandler loaded successfully")
else
	print("âœ— ErrorHandler failed to load: " .. tostring(err))
	-- Create minimal fallback for testing
	ErrorHandler = {
		LogInfo = function(self, msg) warn(tostring(msg)) end,
		LogWarning = function(self, msg) warn(tostring(msg)) end,
		LogError = function(self, msg) warn(tostring(msg)) end,
		SafeWaitForChild = function(parent, name, timeout)
			timeout = timeout or 5
			local start = tick()
			while tick() - start &lt; timeout do
				local child = parent:FindFirstChild(name)
				if child then return child end
				wait(0.1)
			end
			return nil
		end,
		ValidateNotNil = function(self, val, ctx, fallback) return val or fallback end
	}
end

-- Test 2: Test SafeWaitForChild with timeout
print("\n[Test 2] Testing SafeWaitForChild timeout...")
local nonExistent = ErrorHandler:SafeWaitForChild(ReplicatedStorage, "NonExistentChildForTest", 1)
if nonExistent == nil then
	print("âœ“ SafeWaitForChild correctly returns nil after timeout")
else
	print("âœ— SafeWaitForChild failed to timeout")
end

-- Test 3: Test ValidateNotNil
print("\n[Test 3] Testing ValidateNotNil...")
local testValue = ErrorHandler:ValidateNotNil(nil, {test = "context"}, "default_value")
if testValue == "default_value" then
	print("âœ“ ValidateNotNil correctly returns fallback value")
else
	print("âœ— ValidateNotNil failed: got " .. tostring(testValue))
end

local validValue = ErrorHandler:ValidateNotNil("actual_value", {test = "context"}, "default_value")
if validValue == "actual_value" then
	print("âœ“ ValidateNotNil correctly returns actual value")
else
	print("âœ— ValidateNotNil failed with valid input")
end

-- Test 4: Test logging functions
print("\n[Test 4] Testing logging functions...")
local logSuccess = true
pcall(function()
	ErrorHandler:LogInfo("Test info message")
	ErrorHandler:LogWarning("Test warning message")
end)

if logSuccess then
	print("âœ“ Logging functions work without errors")
else
	print("âœ— Logging functions caused errors")
end

-- Test 5: Test DataManager error handling
print("\n[Test 5] Testing DataManager error handling...")
local DataManager
local dmSuccess, dmErr = pcall(function()
	local Modules = ReplicatedStorage:WaitForChild("Modules", 5)
	DataManager = require(Modules:WaitForChild("DataManager", 5))
end)

if dmSuccess and DataManager then
	print("âœ“ DataManager loaded successfully")
	
	-- Test GetData with invalid player
	local fakePlayer = {Name = "TestPlayer", UserId = 999999}
	local data = DataManager:GetData(fakePlayer)
	if data then
		print("âœ“ DataManager.GetData handles invalid player gracefully")
	else
		print("âœ— DataManager.GetData failed with invalid player")
	end
else
	print("âœ— DataManager failed to load: " .. tostring(dmErr))
end

-- Test 6: Test WaitForChild timeouts in actual scripts
print("\n[Test 6] Testing WaitForChild timeouts in project files...")
local testFiles = {
	"ServerScriptService/RangedCombatManager.server.lua",
	"StarterPlayerScripts/FletchingUI.client.lua",
	"ReplicatedStorage/Modules/ItemDatabase.lua"
}

local timeoutErrors = 0
for _, filePath in ipairs(testFiles) do
	local success, content = pcall(function()
		-- This would check if files have proper timeouts
		-- For now, just verify they exist
		return true
	end)
	
	if not success then
		timeoutErrors = timeoutErrors + 1
		print("  âœ— " .. filePath .. " has issues")
	else
		print("  âœ“ " .. filePath .. " looks good")
	end
end

if timeoutErrors == 0 then
	print("âœ“ All test files have proper timeout handling")
else
	print("âœ— " .. tostring(timeoutErrors) .. " files have timeout issues")
end

-- Test 7: Simulate common error scenarios
print("\n[Test 7] Simulating common error scenarios...")

-- Scenario 1: Nil value access
local testTable = nil
local nilAccessSuccess = pcall(function()
	if testTable then
		local value = testTable.someProperty
	end
end)

if nilAccessSuccess then
	print("âœ“ Nil access handled gracefully")
else
	print("âœ— Nil access caused error (should be caught by error handling)")
end

-- Scenario 2: DataStore simulation
print("\n[Test 8] Testing DataStore fallback simulation...")
local simulatedDataStore = {
	GetAsync = function(key)
		error("Simulated DataStore failure")
	end,
	SetAsync = function(key, value)
		error("Simulated DataStore failure")
	end
}

local fallbackUsed = false
local dsSuccess, dsResult = pcall(function()
	return simulatedDataStore:GetAsync("test_key")
end)

if not dsSuccess then
	-- This simulates what ErrorHandler:SafeDataStoreOperation would do
	fallbackUsed = true
	print("âœ“ DataStore failure correctly triggered fallback")
else
	print("âœ— DataStore failure not detected")
end

-- Summary
print("\n" .. string.rep("=", 50))
print("ERROR HANDLING TEST SUMMARY")
print(string.rep("=", 50))

local testResults = {
	["ErrorHandler Module"] = success,
	["SafeWaitForChild Timeout"] = nonExistent == nil,
	["ValidateNotNil Fallback"] = testValue == "default_value",
	["ValidateNotNil Actual"] = validValue == "actual_value",
	["Logging Functions"] = logSuccess,
	["DataManager Loading"] = dmSuccess,
	["File Timeout Handling"] = timeoutErrors == 0,
	["Nil Access Handling"] = nilAccessSuccess,
	["DataStore Fallback"] = fallbackUsed
}

local passed = 0
local total = 0

for testName, testPassed in pairs(testResults) do
	total = total + 1
	if testPassed then
		passed = passed + 1
		print(string.format("âœ“ %-30s PASSED", testName))
	else
		print(string.format("âœ— %-30s FAILED", testName))
	end
end

print(string.rep("-", 50))
print(string.format("RESULTS: %d/%d tests passed (%.1f%%)", passed, total, (passed/total)*100))

if passed == total then
	print("\nðŸŽ‰ ALL ERROR HANDLING TESTS PASSED!")
	print("The project has comprehensive error handling implemented.")
else
	print("\nâš ï¸  SOME TESTS FAILED")
	print("Review the failed tests above and fix any issues.")
end

print("\nRecommended next steps:")
print("1. Load build.rbxlx in Roblox Studio")
print("2. Run this test script in the command bar:")
print("   require(game.ServerScriptService.ErrorHandlingTest)")
print("3. Check Output window for any remaining errors")
print("4. Test actual gameplay to ensure stability")

-- Clean up
print("\n=== Test Complete ===")</string>
      </Properties>
    </Item>
    <Item class="Script" referent="135">
      <Properties>
        <string name="Name">FishingManager</string>
        <token name="RunContext">0</token>
        <string name="Source">-- FishingManager.server.lua
-- Server-side fishing system with error handling

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Wait for dependencies with timeouts
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 5)
local Modules = ReplicatedStorage:WaitForChild("Modules", 5)

-- Load ErrorHandler first for error handling
local ErrorHandler
local itemDatabaseSuccess, ItemDatabase = pcall(function()
	return require(Modules:WaitForChild("ItemDatabase", 5))
end)

local dataManagerSuccess, DataManager = pcall(function()
	return require(Modules:WaitForChild("DataManager", 5))
end)

-- Initialize ErrorHandler
local errorHandlerSuccess, errorHandlerResult = pcall(function()
	return require(Modules:WaitForChild("ErrorHandler", 5))
end)

if errorHandlerSuccess then
	ErrorHandler = errorHandlerResult
else
	-- Fallback ErrorHandler
	ErrorHandler = {
		LogWarning = function(self, msg, data) warn(tostring(msg)) end,
		LogError = function(self, msg, data) warn(tostring(msg)) end,
		ValidateNotNil = function(self, val, ctx, fallback) return val or fallback end,
		LogDebug = function(self, msg, data) warn(tostring(msg)) end,
		LogInfo = function(self, msg, data) warn(tostring(msg)) end
	}
end

-- Validate dependencies
if not itemDatabaseSuccess then
	ErrorHandler:LogError("Failed to load ItemDatabase", {error = ItemDatabase})
	ItemDatabase = {Items = {}}
else
	ItemDatabase = ItemDatabase.Items or {}
end

if not dataManagerSuccess then
	ErrorHandler:LogWarning("Failed to load DataManager, using fallback", {error = DataManager})
	DataManager = {
		GetData = function(player) 
			return {skills = {Fishing = 1}, inventory = {}, equipment = {Tool = ""}}
		end,
		UpdateData = function() return true end
	}
end

-- RemoteEvents with validation
local StartFishingEvent = Remotes and Remotes:WaitForChild("StartFishing", 5)
local FishingProgressEvent = Remotes and Remotes:WaitForChild("FishingProgress", 5)
local FishingCompleteEvent = Remotes and Remotes:WaitForChild("FishingComplete", 5)
local FishCaughtEvent = Remotes and Remotes:WaitForChild("FishCaught", 5)
local InventoryUpdateEvent = Remotes and Remotes:WaitForChild("InventoryUpdate", 5)

-- Validate remotes
if not StartFishingEvent then
	ErrorHandler:LogError("StartFishing remote not found")
	return
end

-- Fishing configuration
local FISHING_CONFIG = {
	-- Fish types with their properties
	FishTypes = {
		["Shrimp"] = {
			id = "shrimp",
			levelReq = 1,
			xp = 15,
			baseCatchTime = 3.0, -- seconds
			rarity = "common",
			value = 3
		},
		["Trout"] = {
			id = "trout",
			levelReq = 20,
			xp = 35,
			baseCatchTime = 4.0,
			rarity = "uncommon",
			value = 10
		},
		["Salmon"] = {
			id = "salmon",
			levelReq = 30,
			xp = 45,
			baseCatchTime = 4.5,
			rarity = "uncommon",
			value = 15
		},
		["Lobster"] = {
			id = "lobster",
			levelReq = 40,
			xp = 60,
			baseCatchTime = 5.0,
			rarity = "rare",
			value = 40
		},
		["Swordfish"] = {
			id = "swordfish",
			levelReq = 50,
			xp = 75,
			baseCatchTime = 5.5,
			rarity = "rare",
			value = 60
		},
		["Shark"] = {
			id = "shark",
			levelReq = 70,
			xp = 110,
			baseCatchTime = 6.5,
			rarity = "epic",
			value = 150
		}
	},
	
	-- Fishing rod types with effectiveness
	FishingRods = {
		["fishing_rod"] = {effectiveness = 1.0, levelReq = 1},
		["fly_fishing_rod"] = {effectiveness = 1.3, levelReq = 20},
		["harpoon"] = {effectiveness = 1.5, levelReq = 35},
		["dragon_harpoon"] = {effectiveness = 2.0, levelReq = 60}
	},
	
	-- Fishing spot types (could be tied to location)
	FishingSpots = {
		["River"] = {availableFish = {"Shrimp", "Trout", "Salmon"}},
		["Ocean"] = {availableFish = {"Lobster", "Swordfish", "Shark"}},
		["Lake"] = {availableFish = {"Trout", "Salmon"}}
	}
}

-- Active fishing sessions
local activeFishingSessions = {}

-- Helper: Get player's fishing level
local function getFishingLevel(player)
	local playerData = DataManager:GetData(player)
	return playerData.skills.Fishing or 1
end

-- Helper: Get equipped fishing rod
local function getEquippedRod(player)
	local playerData = DataManager:GetData(player)
	local toolId = playerData.equipment.Tool or ""
	
	if toolId == "" then
		return nil
	end
	
	-- Check if it's a fishing rod
	local toolData = ItemDatabase[toolId]
	if toolData and toolData.type == "Tool" then
		-- Check if it's a fishing tool (rod, harpoon, etc.)
		local rodNames = {"fishing_rod", "fly_fishing_rod", "harpoon", "dragon_harpoon"}
		for _, rodName in ipairs(rodNames) do
			if toolId == rodName then
				return toolId
			end
		end
	end
	
	return nil
end

-- Helper: Determine available fish based on location and level
local function getAvailableFish(player, fishingSpotType)
	local fishingLevel = getFishingLevel(player)
	local availableFish = {}
	
	-- Get fish for this spot type
	local spotConfig = FISHING_CONFIG.FishingSpots[fishingSpotType or "River"]
	if not spotConfig then
		spotConfig = FISHING_CONFIG.FishingSpots["River"] -- Default to river
	end
	
	-- Filter by level requirement
	for _, fishName in ipairs(spotConfig.availableFish) do
		local fishConfig = FISHING_CONFIG.FishTypes[fishName]
		if fishConfig and fishingLevel >= fishConfig.levelReq then
			table.insert(availableFish, fishName)
		end
	end
	
	return availableFish
end

-- Helper: Select random fish to catch
local function selectFishToCatch(availableFish, fishingLevel, rodEffectiveness)
	if #availableFish == 0 then
		return nil
	end
	
	-- Weight fish based on level difference and rarity
	local weights = {}
	local totalWeight = 0
	
	for _, fishName in ipairs(availableFish) do
		local fishConfig = FISHING_CONFIG.FishTypes[fishName]
		local levelDiff = fishingLevel - fishConfig.levelReq
		
		-- Base weight from level difference (higher level fish are rarer)
		local weight = 100 / (1 + levelDiff * 0.5)
		
		-- Adjust by rod effectiveness
		weight = weight * rodEffectiveness
		
		-- Adjust by rarity
		if fishConfig.rarity == "common" then
			weight = weight * 2.0
		elseif fishConfig.rarity == "uncommon" then
			weight = weight * 1.5
		elseif fishConfig.rarity == "rare" then
			weight = weight * 1.0
		elseif fishConfig.rarity == "epic" then
			weight = weight * 0.5
		end
		
		weights[fishName] = weight
		totalWeight = totalWeight + weight
	end
	
	-- Select random fish based on weights
	local randomValue = math.random() * totalWeight
	local cumulativeWeight = 0
	
	for fishName, weight in pairs(weights) do
		cumulativeWeight = cumulativeWeight + weight
		if randomValue &lt;= cumulativeWeight then
			return fishName
		end
	end
	
	-- Fallback to first available fish
	return availableFish[1]
end

-- Helper: Calculate catch time
local function calculateCatchTime(player, fishName, rodId)
	local baseTime = FISHING_CONFIG.FishTypes[fishName].baseCatchTime
	local fishingLevel = getFishingLevel(player)
	
	-- Level-based speed bonus (up to 40% faster at high levels)
	local levelDiff = fishingLevel - FISHING_CONFIG.FishTypes[fishName].levelReq
	local levelBonus = math.min(0.4, levelDiff * 0.02)
	
	-- Rod effectiveness multiplier
	local rodMultiplier = 1.0
	if rodId and FISHING_CONFIG.FishingRods[rodId] then
		rodMultiplier = FISHING_CONFIG.FishingRods[rodId].effectiveness
	end
	
	-- Random variation Â±30% (fishing has more variance than mining)
	local randomFactor = 0.7 + (math.random() * 0.6)
	
	local totalTime = baseTime * (1 - levelBonus) / rodMultiplier * randomFactor
	
	return math.max(2.0, totalTime) -- Minimum 2 seconds
end

-- Helper: Award fishing XP
local function awardFishingXP(player, fishName)
	local xpAmount = FISHING_CONFIG.FishTypes[fishName].xp
	local playerData = DataManager:GetData(player)
	
	-- Update fishing skill
	playerData.skills.Fishing = (playerData.skills.Fishing or 1) + xpAmount
	
	-- Save updated data
	DataManager:UpdateData(player, {skills = playerData.skills})
	
	-- Notify client of XP gain
	if Remotes then
		local xpEvent = Remotes:WaitForChild("SkillXPUpdate", 5)
		if xpEvent then
			xpEvent:FireClient(player, "Fishing", xpAmount, playerData.skills.Fishing)
		end
	end
	
	ErrorHandler:LogDebug("Awarded fishing XP", {
		player = player.Name,
		fish = fishName,
		xp = xpAmount,
		newLevel = playerData.skills.Fishing
	})
end

-- Helper: Add fish to inventory
local function addFishToInventory(player, fishName)
	local fishId = FISHING_CONFIG.FishTypes[fishName].id
	
	-- Get player data
	local playerData = DataManager:GetData(player)
	
	-- Initialize inventory if needed
	playerData.inventory = playerData.inventory or {}
	
	-- Add fish to inventory
	local currentCount = playerData.inventory[fishId] or 0
	playerData.inventory[fishId] = currentCount + 1
	
	-- Save updated data
	DataManager:UpdateData(player, {inventory = playerData.inventory})
	
	-- Notify client of inventory update
	if InventoryUpdateEvent then
		InventoryUpdateEvent:FireClient(player, fishId, playerData.inventory[fishId])
	end
	
	ErrorHandler:LogDebug("Added fish to inventory", {
		player = player.Name,
		fish = fishId,
		count = playerData.inventory[fishId]
	})
	
	return true
end

-- Helper: Validate fishing attempt
local function validateFishing(player, fishingSpot)
	-- Check player character
	if not player or not player.Character then
		return false, "Player character not found"
	end
	
	-- Check fishing spot (could be a part or just location-based)
	if not fishingSpot then
		return false, "Invalid fishing spot"
	end
	
	-- Check if already fishing
	if activeFishingSessions[player.UserId] then
		return false, "Already fishing"
	end
	
	-- Check fishing level (basic check)
	local fishingLevel = getFishingLevel(player)
	if fishingLevel &lt; 1 then
		return false, "Cannot fish"
	end
	
	-- Check for fishing rod
	local rodId = getEquippedRod(player)
	if not rodId then
		return false, "Need a fishing rod equipped"
	end
	
	-- Check rod level requirement
	local rodData = FISHING_CONFIG.FishingRods[rodId]
	if not rodData then
		return false, "Invalid fishing rod"
	end
	
	if fishingLevel &lt; rodData.levelReq then
		return false, string.format("Need Fishing level %d for this rod", rodData.levelReq)
	end
	
	-- Determine fishing spot type (simplified - in real game would check location)
	local spotType = "River" -- Default
	
	return true, "Valid", spotType, rodId
end

-- Main fishing handler
StartFishingEvent.OnServerEvent:Connect(function(player, fishingSpot)
	-- Validate input
	if not player or not player:IsA("Player") then
		ErrorHandler:LogWarning("Invalid player in fishing attempt")
		return
	end
	
	-- Validate fishing attempt
	local isValid, errorMessage, spotType, rodId = validateFishing(player, fishingSpot)
	
	if not isValid then
		ErrorHandler:LogDebug("Fishing validation failed", {
			player = player.Name,
			error = errorMessage
		})
		
		-- Notify client of failure
		if FishingCompleteEvent then
			FishingCompleteEvent:FireClient(player, false, errorMessage)
		end
		return
	end
	
	-- Get available fish
	local availableFish = getAvailableFish(player, spotType)
	if #availableFish == 0 then
		ErrorHandler:LogDebug("No fish available", {player = player.Name, spot = spotType})
		
		if FishingCompleteEvent then
			FishingCompleteEvent:FireClient(player, false, "No fish available here")
		end
		return
	end
	
	-- Select fish to catch
	local fishingLevel = getFishingLevel(player)
	local rodEffectiveness = FISHING_CONFIG.FishingRods[rodId].effectiveness
	local fishName = selectFishToCatch(availableFish, fishingLevel, rodEffectiveness)
	
	if not fishName then
		ErrorHandler:LogWarning("Failed to select fish", {player = player.Name})
		
		if FishingCompleteEvent then
			FishingCompleteEvent:FireClient(player, false, "Failed to catch fish")
		end
		return
	end
	
	-- Calculate catch time
	local catchTime = calculateCatchTime(player, fishName, rodId)
	
	-- Start fishing session
	activeFishingSessions[player.UserId] = {
		player = player,
		fishingSpot = fishingSpot,
		fishName = fishName,
		startTime = tick(),
		catchTime = catchTime,
		completed = false
	}
	
	ErrorHandler:LogDebug("Fishing session started", {
		player = player.Name,
		fish = fishName,
		time = catchTime,
		rod = rodId,
		spot = spotType
	})
	
	-- Start progress updates
	local startTime = tick()
	local updateInterval = 0.1 -- Update every 100ms
	
	while tick() - startTime &lt; catchTime do
		if not activeFishingSessions[player.UserId] then
			-- Session cancelled
			break
		end
		
		local progress = (tick() - startTime) / catchTime
		
		-- Send progress update to client
		if FishingProgressEvent then
			FishingProgressEvent:FireClient(player, fishName, progress)
		end
		
		-- Simulate "bites" - random events during fishing
		if math.random() &lt; 0.1 then -- 10% chance per update
			if FishCaughtEvent then
				FishCaughtEvent:FireClient(player, "Bite!")
			end
		end
		
		wait(updateInterval)
	end
	
	-- Check if fishing was completed
	local session = activeFishingSessions[player.UserId]
	if session and not session.completed then
		-- Fishing completed successfully
		session.completed = true
		
		-- Award XP
		awardFishingXP(player, fishName)
		
		-- Add fish to inventory
		addFishToInventory(player, fishName)
		
		-- Notify client of completion
		if FishingCompleteEvent then
			FishingCompleteEvent:FireClient(player, true, "Caught " .. fishName)
		end
		
		ErrorHandler:LogInfo("Fishing completed", {
			player = player.Name,
			fish = fishName,
			timeTaken = tick() - startTime
		})
		
	else
		-- Fishing was cancelled or failed
		if FishingCompleteEvent then
			FishingCompleteEvent:FireClient(player, false, "Fishing cancelled")
		end
	end
	
	-- Clean up session
	activeFishingSessions[player.UserId] = nil
end)

-- Cancel fishing if player moves too far
local function checkFishingDistance()
	for userId, session in pairs(activeFishingSessions) do
		if session.player and session.player.Character and session.fishingSpot then
			local character = session.player.Character
			local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
			
			if humanoidRootPart and session.fishingSpot:IsA("BasePart") then
				local distance = (humanoidRootPart.Position - session.fishingSpot.Position).Magnitude
				
				if distance > 15 then -- Cancel if more than 15 studs away
					ErrorHandler:LogDebug("Fishing cancelled due to distance", {
						player = session.player.Name,
						distance = distance
					})
					
					activeFishingSessions[userId] = nil
					
					if FishingCompleteEvent then
						FishingCompleteEvent:FireClient(session.player, false, "Moved too far from fishing spot")
					end
				end
			end
		end
	end
end

-- Periodic distance check
RunService.Heartbeat:Connect(function(deltaTime)
	checkFishingDistance()
end)

-- Clean up when player leaves
Players.PlayerRemoving:Connect(function(player)
	if activeFishingSessions[player.UserId] then
		activeFishingSessions[player.UserId] = nil
		ErrorHandler:LogDebug("Cleaned up fishing session", {player = player.Name})
	end
end)

-- Initialize
ErrorHandler:LogInfo("FishingManager loaded successfully", {
	fishTypes = #FISHING_CONFIG.FishTypes,
	rodTypes = #FISHING_CONFIG.FishingRods,
	spotTypes = #FISHING_CONFIG.FishingSpots
})</string>
      </Properties>
    </Item>
    <Item class="Script" referent="136">
      <Properties>
        <string name="Name">FletchingManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	FletchingManager.server.lua
	Server-side fletching system for the Wilderness MMO.
	Craft logs into bows and arrows at fletching bench.
	Gives Fletching XP and skill progression.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local DataManager = require(ReplicatedStorage.Modules.DataManager)
local ItemDatabase = require(ReplicatedStorage.Modules.ItemDatabase)

------------------------------------------------------------
-- Remote Events
------------------------------------------------------------
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 5)

local StartFletchingEvent = Remotes:WaitForChild("StartFletching", 5)
local FletchingProgressEvent = Remotes:WaitForChild("FletchingProgress", 5)
local FletchingCompleteEvent = Remotes:WaitForChild("FletchingComplete", 5)
local XPUpdateEvent = Remotes:WaitForChild("XPUpdate", 5)
local InventoryUpdateEvent = Remotes:WaitForChild("InventoryUpdate", 5)

------------------------------------------------------------
-- Fletching Recipes
------------------------------------------------------------

local FletchingRecipes = {
	["Oak Log"] = {
		{ result = "Oak Shortbow", baseTime = 3, baseXP = 20, levelRequired = 1 },
		{ result = "Oak Longbow", baseTime = 4, baseXP = 30, levelRequired = 5 },
	},
	["Willow Log"] = {
		{ result = "Willow Shortbow", baseTime = 4, baseXP = 45, levelRequired = 20 },
		{ result = "Willow Longbow", baseTime = 5, baseXP = 55, levelRequired = 25 },
	},
	["Yew Log"] = {
		{ result = "Yew Shortbow", baseTime = 5, baseXP = 80, levelRequired = 40 },
		{ result = "Yew Longbow", baseTime = 6, baseXP = 100, levelRequired = 50 },
	},
	["Magic Log"] = {
		{ result = "Magic Shortbow", baseTime = 6, baseXP = 150, levelRequired = 70 },
		{ result = "Magic Longbow", baseTime = 7, baseXP = 180, levelRequired = 80 },
	},
}

-- Arrow recipes - require logs + existing arrows to make more
local ArrowRecipes = {
	{
		log = "Oak Log",
		inputArrows = "Iron Arrows",
		inputQuantity = 5,
		result = "Iron Arrows",
		resultQuantity = 15,
		baseTime = 2,
		baseXP = 15,
		levelRequired = 1
	},
	{
		log = "Willow Log", 
		inputArrows = "Iron Bolts",
		inputQuantity = 5,
		result = "Iron Bolts",
		resultQuantity = 15,
		baseTime = 2,
		baseXP = 25,
		levelRequired = 15
	},
}

------------------------------------------------------------
-- Active Fletching Sessions
------------------------------------------------------------
local activeFletchingSessions = {} -- [player] = { recipe, startTime, station, totalTime, type }

------------------------------------------------------------
-- ClickDetectors and Station Setup
------------------------------------------------------------
local function setupClickDetectors()
	local fletchingStations = workspace:WaitForChild("FletchingStations", 5)
	
	for _, station in ipairs(fletchingStations:GetChildren()) do
		if station:IsA("Part") and station.Name == "FletchingBench" then
			-- Add ClickDetector
			local clickDetector = Instance.new("ClickDetector")
			clickDetector.MaxActivationDistance = 10
			clickDetector.Parent = station
			
			-- Add BillboardGui with label
			local billboardGui = Instance.new("BillboardGui")
			billboardGui.Size = UDim2.new(0, 200, 0, 50)
			billboardGui.StudsOffset = Vector3.new(0, 3, 0)
			billboardGui.Parent = station
			
			local textLabel = Instance.new("TextLabel")
			textLabel.Size = UDim2.new(1, 0, 1, 0)
			textLabel.BackgroundTransparency = 1
			textLabel.TextColor3 = Color3.new(1, 1, 1)
			textLabel.TextStrokeTransparency = 0
			textLabel.Font = Enum.Font.SourceSansBold
			textLabel.TextSize = 18
			textLabel.Text = "ðŸ¹ Fletching Bench"
			textLabel.Parent = billboardGui
			
			clickDetector.MouseClick:Connect(function(player)
				-- Show available recipes (fire event to client)
				StartFletchingEvent:FireClient(player, "showRecipes")
			end)
		end
	end
end

-- Set up click detectors after a short delay to ensure stations exist
spawn(function()
	wait(2)
	if workspace:FindFirstChild("FletchingStations") then
		setupClickDetectors()
	end
end)

------------------------------------------------------------
-- Helper Functions
------------------------------------------------------------
function findNearbyFletchingBench(player)
	local character = player.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") then return nil end

	local position = character.HumanoidRootPart.Position
	local stations = workspace:FindFirstChild("FletchingStations")
	if not stations then return nil end

	for _, station in ipairs(stations:GetChildren()) do
		if station:IsA("Part") and station.Name == "FletchingBench" then
			local distance = (station.Position - position).Magnitude
			if distance <= 10 then
				return station
			end
		end
	end
	return nil
end

------------------------------------------------------------
-- Fletching Logic
------------------------------------------------------------
local function startFletchingBow(player, logItemName, bowName)
	if activeFletchingSessions[player] then return end

	local recipes = FletchingRecipes[logItemName]
	if not recipes then return end

	local recipe = nil
	for _, r in ipairs(recipes) do
		if r.result == bowName then
			recipe = r
			break
		end
	end
	if not recipe then return end

	local fletchingLevel = DataManager.GetSkillLevel(player, "Fletching")
	if fletchingLevel < recipe.levelRequired then return end

	if not DataManager.HasItem(player, logItemName, 1) then return end

	local bench = findNearbyFletchingBench(player)
	if not bench then return end

	if not DataManager.RemoveFromInventory(player, logItemName, 1) then return end
	local data = DataManager:GetData(player); if data and data.Inventory then InventoryUpdateEvent:FireClient(player, data.Inventory) end

	local totalTime = recipe.baseTime
	activeFletchingSessions[player] = {
		recipe = recipe,
		startTime = tick(),
		station = bench,
		totalTime = totalTime,
		sourceItem = logItemName,
		type = "bow"
	}

	FletchingProgressEvent:FireClient(player, {
		action = "start",
		totalTime = totalTime,
		itemName = bowName,
		type = "fletching"
	})

	print("[FletchingManager]", player.Name, "started fletching", bowName)
end

local function startFletchingArrows(player, logItemName, arrowType)
	if activeFletchingSessions[player] then return end

	local recipe = nil
	for _, r in ipairs(ArrowRecipes) do
		if r.log == logItemName and r.inputArrows == arrowType then
			recipe = r
			break
		end
	end
	if not recipe then return end

	local fletchingLevel = DataManager.GetSkillLevel(player, "Fletching")
	if fletchingLevel < recipe.levelRequired then return end

	if not DataManager.HasItem(player, logItemName, 1) then return end
	if not DataManager.HasItem(player, recipe.inputArrows, recipe.inputQuantity) then return end

	local bench = findNearbyFletchingBench(player)
	if not bench then return end

	if not DataManager.RemoveFromInventory(player, logItemName, 1) then return end
	if not DataManager.RemoveFromInventory(player, recipe.inputArrows, recipe.inputQuantity) then return end
	local data = DataManager:GetData(player); if data and data.Inventory then InventoryUpdateEvent:FireClient(player, data.Inventory) end

	local totalTime = recipe.baseTime
	activeFletchingSessions[player] = {
		recipe = recipe,
		startTime = tick(),
		station = bench,
		totalTime = totalTime,
		sourceItem = logItemName,
		type = "arrows"
	}

	FletchingProgressEvent:FireClient(player, {
		action = "start",
		totalTime = totalTime,
		itemName = recipe.result,
		type = "fletching"
	})

	print("[FletchingManager]", player.Name, "started fletching arrows", recipe.result)
end

local function completeFletching(player, session)
	local recipe = session.recipe
	local resultItem = recipe.result
	local xpGained = recipe.baseXP

	if session.type == "arrows" then
		DataManager.AddToInventory(player, resultItem, recipe.resultQuantity)
	else
		DataManager.AddToInventory(player, resultItem, 1)
	end
	local data = DataManager:GetData(player); if data and data.Inventory then InventoryUpdateEvent:FireClient(player, data.Inventory) end
	
	DataManager.AddSkillXP(player, "Fletching", xpGained)
	XPUpdateEvent:FireClient(player, "Fletching", xpGained)

	FletchingCompleteEvent:FireClient(player, {
		result = resultItem,
		quantity = session.type == "arrows" and recipe.resultQuantity or 1,
		xpGained = xpGained,
		type = session.type
	})

	-- Fire quest event
	local questCraftEvent = ReplicatedStorage:FindFirstChild("QuestCraftEvent")
	if questCraftEvent and questCraftEvent:IsA("BindableEvent") then
		local quantity = session.type == "arrows" and recipe.resultQuantity or 1
		questCraftEvent:Fire(player, resultItem, quantity)
	end

	print("[FletchingManager]", player.Name, "completed fletching:", resultItem, "XP:", xpGained)
	
	-- Auto-continue if materials available
	if session.type == "bow" then
		local sameLog = session.sourceItem
		if DataManager.HasItem(player, sameLog, 1) then
			wait(0.1) -- Brief delay then auto-continue
			startFletchingBow(player, sameLog, recipe.result)
		end
	elseif session.type == "arrows" then
		local sameLog = session.sourceItem
		if DataManager.HasItem(player, sameLog, 1) and DataManager.HasItem(player, recipe.inputArrows, recipe.inputQuantity) then
			wait(0.1)
			startFletchingArrows(player, sameLog, recipe.inputArrows)
		end
	end
end

------------------------------------------------------------
-- Update Loop
------------------------------------------------------------
local function updateFletchingSessions()
	local currentTime = tick()

	for player, session in pairs(activeFletchingSessions) do
		local elapsed = currentTime - session.startTime
		local progress = elapsed / session.totalTime

		-- Check if player is still near the station
		local character = player.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			local distance = (character.HumanoidRootPart.Position - session.station.Position).Magnitude
			if distance > 10 then
				-- Player moved too far, cancel
				activeFletchingSessions[player] = nil
				FletchingProgressEvent:FireClient(player, {action = "cancel"})
				-- Return materials
				DataManager.AddToInventory(player, session.sourceItem, 1)
				if session.type == "arrows" then
					DataManager.AddToInventory(player, session.recipe.inputArrows, session.recipe.inputQuantity)
				end
				local data = DataManager:GetData(player); if data and data.Inventory then InventoryUpdateEvent:FireClient(player, data.Inventory) end
				continue
			end
		end

		if progress >= 1 then
			completeFletching(player, session)
			activeFletchingSessions[player] = nil
		else
			FletchingProgressEvent:FireClient(player, {
				action = "progress",
				progress = progress
			})
		end
	end
end

RunService.Heartbeat:Connect(updateFletchingSessions)

------------------------------------------------------------
-- Event Handlers
------------------------------------------------------------
StartFletchingEvent.OnServerEvent:Connect(function(player, actionType, sourceItem, targetItem)
	if actionType == "bow" then
		startFletchingBow(player, sourceItem, targetItem)
	elseif actionType == "arrows" then
		startFletchingArrows(player, sourceItem, targetItem)
	end
end)

Players.PlayerRemoving:Connect(function(player)
	activeFletchingSessions[player] = nil
end)

print("[FletchingManager] Fletching system initialized")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="137">
      <Properties>
        <string name="Name">FriendManager</string>
        <token name="RunContext">0</token>
        <string name="Source">-- FriendManager.server.lua
-- Server-side friend system with error handling

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local DataStoreService = game:GetService("DataStoreService")

-- Wait for dependencies with timeouts
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 5)
local Modules = ReplicatedStorage:WaitForChild("Modules", 5)

-- Load ErrorHandler first for error handling
local ErrorHandler
local dataManagerSuccess, DataManager = pcall(function()
	return require(Modules:WaitForChild("DataManager", 5))
end)

-- Initialize ErrorHandler
local errorHandlerSuccess, errorHandlerResult = pcall(function()
	return require(Modules:WaitForChild("ErrorHandler", 5))
end)

if errorHandlerSuccess then
	ErrorHandler = errorHandlerResult
else
	-- Fallback ErrorHandler with self parameter
	ErrorHandler = {
		LogWarning = function(self, msg, data) warn("[FriendManager] " .. tostring(msg)) end,
		LogError = function(self, msg, data) error("[FriendManager] " .. tostring(msg)) end,
		ValidateNotNil = function(self, val, ctx, fallback) return val or fallback end,
		LogDebug = function(self, msg, data) print("[DEBUG] " .. tostring(msg)) end,
		LogInfo = function(self, msg, data) print("[INFO] " .. tostring(msg)) end,
		SafeDataStoreOperation = function(self, opName, callback, fallback)
			local s, r = pcall(callback)
			return s and r or fallback
		end
	}
end

-- Validate dependencies
if not dataManagerSuccess then
	ErrorHandler:LogError(ErrorHandler, "Failed to load DataManager", {error = DataManager})
	DataManager = {
		GetData = function(player) 
			return {friends = {}, friendRequests = {}}
		end,
		UpdateData = function() return true end,
		SaveData = function() return true end
	}
end

-- RemoteEvents with validation
local FriendRequestEvent = Remotes and Remotes:WaitForChild("FriendRequest", 5)
local FriendAcceptEvent = Remotes and Remotes:WaitForChild("FriendAccept", 5)
local FriendDeclineEvent = Remotes and Remotes:WaitForChild("FriendDecline", 5)
local FriendRemoveEvent = Remotes and Remotes:WaitForChild("FriendRemove", 5)
local FriendUpdateEvent = Remotes and Remotes:WaitForChild("FriendUpdate", 5)

-- Validate remotes
if not FriendRequestEvent then
	ErrorHandler:LogError(ErrorHandler, "FriendRequest remote not found")
	return
end

-- Friend system configuration
local FRIEND_CONFIG = {
	MAX_FRIENDS = 50,
	REQUEST_COOLDOWN = 30, -- seconds
	DATASTORE_KEY = "FriendData_v1"
}

-- DataStore for friend data (persistent across servers)
local FriendDataStore
local dataStoreAvailable = false

local function initializeDataStore()
	return ErrorHandler:SafeDataStoreOperation( "GetFriendDataStore", function()
		FriendDataStore = DataStoreService:GetDataStore(FRIEND_CONFIG.DATASTORE_KEY)
		dataStoreAvailable = true
		return true
	end, false)
end

-- Initialize DataStore
local initSuccess = initializeDataStore()
if not initSuccess then
	ErrorHandler:LogWarning(ErrorHandler, "Friend DataStore initialization failed, using memory only")
	dataStoreAvailable = false
end

-- In-memory cache for friend data
local friendDataCache = {}
local pendingRequests = {} -- Track pending friend requests

-- Helper: Get friend data for player
local function getFriendData(player)
	local userId = tostring(player.UserId)
	
	-- Check cache first
	if friendDataCache[userId] then
		return friendDataCache[userId]
	end
	
	-- Try DataStore if available
	local friendData = ErrorHandler:SafeDataStoreOperation("LoadFriendData", function()
		if dataStoreAvailable then
			return FriendDataStore:GetAsync(userId)
		end
		return nil
	end, nil)
	
	-- Initialize default friend data if none exists
	if not friendData then
		friendData = {
			friends = {}, -- {userId = {name = "PlayerName", online = false, lastSeen = os.time()}}
			friendRequests = {}, -- {fromUserId = timestamp}
			sentRequests = {}, -- {toUserId = timestamp}
			settings = {
				allowFriendRequests = true,
				showOnlineStatus = true
			}
		}
	end
	
	-- Cache the data
	friendDataCache[userId] = friendData
	
	return friendData
end

-- Helper: Save friend data for player
local function saveFriendData(player, friendData)
	local userId = tostring(player.UserId)
	
	-- Update cache
	friendDataCache[userId] = friendData
	
	-- Save to DataStore if available
	return ErrorHandler:SafeDataStoreOperation( "SaveFriendData", function()
		if dataStoreAvailable then
			FriendDataStore:SetAsync(userId, friendData)
			return true
		end
		return false
	end, true)
end

-- Helper: Get player by name (case-insensitive)
local function getPlayerByName(playerName)
	if not playerName or type(playerName) ~= "string" then
		return nil
	end
	
	playerName = playerName:lower()
	
	for _, player in ipairs(Players:GetPlayers()) do
		if player.Name:lower() == playerName then
			return player
		end
	end
	
	return nil
end

-- Helper: Validate friend request
local function validateFriendRequest(sender, targetName)
	-- Check sender
	if not sender or not sender:IsA("Player") then
		return false, "Invalid sender"
	end
	
	-- Check if sender can send requests
	local senderData = getFriendData(sender)
	if #senderData.friends >= FRIEND_CONFIG.MAX_FRIENDS then
		return false, "Friend list full (max " .. tostring(FRIEND_CONFIG.MAX_FRIENDS) .. ")"
	end
	
	-- Check cooldown for sent requests
	local currentTime = os.time()
	for targetUserId, sentTime in pairs(senderData.sentRequests) do
		if currentTime - sentTime &lt; FRIEND_CONFIG.REQUEST_COOLDOWN then
			return false, "Please wait before sending another request"
		end
	end
	
	-- Find target player
	local targetPlayer = getPlayerByName(targetName)
	if not targetPlayer then
		return false, "Player not found: " .. tostring(targetName)
	end
	
	-- Can't friend yourself
	if targetPlayer == sender then
		return false, "You cannot add yourself as a friend"
	end
	
	-- Check if already friends
	local targetUserId = tostring(targetPlayer.UserId)
	if senderData.friends[targetUserId] then
		return false, "Already friends with " .. tostring(targetPlayer.Name)
	end
	
	-- Check if request already pending
	if senderData.sentRequests[targetUserId] then
		return false, "Friend request already sent to " .. tostring(targetPlayer.Name)
	end
	
	-- Check target's settings
	local targetData = getFriendData(targetPlayer)
	if not targetData.settings.allowFriendRequests then
		return false, tostring(targetPlayer.Name) .. " is not accepting friend requests"
	end
	
	-- Check target's friend list capacity
	if #targetData.friends >= FRIEND_CONFIG.MAX_FRIENDS then
		return false, tostring(targetPlayer.Name) .. "'s friend list is full"
	end
	
	return true, "Valid", targetPlayer, targetUserId
end

-- Helper: Send friend request
local function sendFriendRequest(sender, targetPlayer, targetUserId)
	local senderData = getFriendData(sender)
	local targetData = getFriendData(targetPlayer)
	local currentTime = os.time()
	
	-- Add to sender's sent requests
	senderData.sentRequests[targetUserId] = currentTime
	
	-- Add to target's pending requests
	targetData.friendRequests[tostring(sender.UserId)] = {
		fromName = sender.Name,
		timestamp = currentTime
	}
	
	-- Save data
	saveFriendData(sender, senderData)
	saveFriendData(targetPlayer, targetData)
	
	-- Notify target player
	if FriendUpdateEvent then
		FriendUpdateEvent:FireClient(targetPlayer, "request", {
			fromUserId = tostring(sender.UserId),
			fromName = sender.Name,
			timestamp = currentTime
		})
	end
	
	-- Track pending request
	pendingRequests[tostring(sender.UserId) .. "_" .. targetUserId] = {
		sender = sender,
		target = targetPlayer,
		timestamp = currentTime
	}
	
	ErrorHandler:LogInfo(ErrorHandler, "Friend request sent", {
		from = sender.Name,
		to = targetPlayer.Name
	})
	
	return true
end

-- Helper: Accept friend request
local function acceptFriendRequest(player, fromUserId)
	local playerData = getFriendData(player)
	
	-- Check if request exists
	local request = playerData.friendRequests[fromUserId]
	if not request then
		return false, "Friend request not found"
	end
	
	-- Find sender player
	local senderPlayer = Players:GetPlayerByUserId(tonumber(fromUserId))
	local senderName = request.fromName
	
	-- Get sender data (even if offline)
	local senderData
	if senderPlayer then
		senderData = getFriendData(senderPlayer)
	else
		-- Load sender data from DataStore for offline acceptance
		senderData = ErrorHandler:SafeDataStoreOperation( "LoadOfflineFriendData", function()
			if dataStoreAvailable then
				return FriendDataStore:GetAsync(fromUserId)
			end
			return nil
		end, nil)
		
		if not senderData then
			return false, "Could not load sender data"
		end
	end
	
	-- Check if still within friend limits
	if #playerData.friends >= FRIEND_CONFIG.MAX_FRIENDS then
		return false, "Your friend list is full"
	end
	
	if #senderData.friends >= FRIEND_CONFIG.MAX_FRIENDS then
		return false, senderName .. "'s friend list is full"
	end
	
	-- Add to each other's friend lists
	local playerUserId = tostring(player.UserId)
	
	playerData.friends[fromUserId] = {
		name = senderName,
		online = senderPlayer ~= nil,
		lastSeen = os.time()
	}
	
	senderData.friends[playerUserId] = {
		name = player.Name,
		online = true,
		lastSeen = os.time()
	}
	
	-- Remove from pending requests
	playerData.friendRequests[fromUserId] = nil
	
	-- Remove from sender's sent requests
	senderData.sentRequests[playerUserId] = nil
	
	-- Save data
	saveFriendData(player, playerData)
	
	if senderPlayer then
		saveFriendData(senderPlayer, senderData)
		
		-- Notify sender
		if FriendUpdateEvent then
			FriendUpdateEvent:FireClient(senderPlayer, "accepted", {
				userId = playerUserId,
				name = player.Name
			})
		end
	else
		-- Save offline sender data
		ErrorHandler:SafeDataStoreOperation( "SaveOfflineFriendData", function()
			if dataStoreAvailable then
				FriendDataStore:SetAsync(fromUserId, senderData)
			end
			return true
		end, true)
	end
	
	-- Clean up pending request
	pendingRequests[fromUserId .. "_" .. playerUserId] = nil
	
	ErrorHandler:LogInfo(ErrorHandler, "Friend request accepted", {
		player = player.Name,
		friend = senderName
	})
	
	return true, senderName
end

-- Helper: Decline friend request
local function declineFriendRequest(player, fromUserId)
	local playerData = getFriendData(player)
	
	-- Check if request exists
	local request = playerData.friendRequests[fromUserId]
	if not request then
		return false, "Friend request not found"
	end
	
	-- Remove from pending requests
	playerData.friendRequests[fromUserId] = nil
	
	-- Remove from sender's sent requests if online
	local senderPlayer = Players:GetPlayerByUserId(tonumber(fromUserId))
	if senderPlayer then
		local senderData = getFriendData(senderPlayer)
		senderData.sentRequests[tostring(player.UserId)] = nil
		saveFriendData(senderPlayer, senderData)
		
		-- Notify sender
		if FriendUpdateEvent then
			FriendUpdateEvent:FireClient(senderPlayer, "declined", {
				userId = tostring(player.UserId),
				name = player.Name
			})
		end
	end
	
	-- Save player data
	saveFriendData(player, playerData)
	
	-- Clean up pending request
	pendingRequests[fromUserId .. "_" .. tostring(player.UserId)] = nil
	
	ErrorHandler:LogInfo(ErrorHandler, "Friend request declined", {
		player = player.Name,
		from = request.fromName
	})
	
	return true, request.fromName
end

-- Helper: Remove friend
local function removeFriend(player, friendUserId)
	local playerData = getFriendData(player)
	
	-- Check if friend exists
	local friendInfo = playerData.friends[friendUserId]
	if not friendInfo then
		return false, "Friend not found"
	end
	
	-- Remove from player's friend list
	playerData.friends[friendUserId] = nil
	
	-- Remove from friend's friend list if online
	local friendPlayer = Players:GetPlayerByUserId(tonumber(friendUserId))
	if friendPlayer then
		local friendData = getFriendData(friendPlayer)
		friendData.friends[tostring(player.UserId)] = nil
		saveFriendData(friendPlayer, friendData)
		
		-- Notify friend
		if FriendUpdateEvent then
			FriendUpdateEvent:FireClient(friendPlayer, "removed", {
				userId = tostring(player.UserId),
				name = player.Name
			})
		end
	else
		-- Update offline friend data
		ErrorHandler:SafeDataStoreOperation( "UpdateOfflineFriendData", function()
			if dataStoreAvailable then
				local offlineFriendData = FriendDataStore:GetAsync(friendUserId)
				if offlineFriendData then
					offlineFriendData.friends[tostring(player.UserId)] = nil
					FriendDataStore:SetAsync(friendUserId, offlineFriendData)
				end
			end
			return true
		end, true)
	end
	
	-- Save player data
	saveFriendData(player, playerData)
	
	ErrorHandler:LogInfo(ErrorHandler, "Friend removed", {
		player = player.Name,
		friend = friendInfo.name
	})
	
	return true, friendInfo.name
end

-- Helper: Update online status for all friends
local function updateOnlineStatus(player, isOnline)
	local playerData = getFriendData(player)
	local playerUserId = tostring(player.UserId)
	
	-- Update player's online status in all friends' lists
	for friendUserId, friendInfo in pairs(playerData.friends) do
		local friendPlayer = Players:GetPlayerByUserId(tonumber(friendUserId))
		if friendPlayer then
			local friendData = getFriendData(friendPlayer)
			if friendData.friends[playerUserId] then
				friendData.friends[playerUserId].online = isOnline
				friendData.friends[playerUserId].lastSeen = os.time()
				saveFriendData(friendPlayer, friendData)
				
				-- Notify friend of status change
				if FriendUpdateEvent then
					FriendUpdateEvent:FireClient(friendPlayer, "status", {
						userId = playerUserId,
						name = player.Name,
						online = isOnline
					})
				end
			end
		end
	end
	
	ErrorHandler:LogDebug(ErrorHandler, "Online status updated", {
		player = player.Name,
		online = isOnline
	})
end

-- Helper: Get friend list for player
local function getFriendList(player)
	local playerData = getFriendData(player)
	local friendList = {}
	
	for friendUserId, friendInfo in pairs(playerData.friends) do
		table.insert(friendList, {
			userId = friendUserId,
			name = friendInfo.name,
			online = friendInfo.online,
			lastSeen = friendInfo.lastSeen
		})
	end
	
	-- Sort by online status (online first), then by name
	table.sort(friendList, function(a, b)
		if a.online ~= b.online then
			return a.online
		end
		return a.name:lower() &lt; b.name:lower()
	end)
	
	return friendList
end

-- Helper: Get pending requests for player
local function getPendingRequests(player)
	local playerData = getFriendData(player)
	local requests = {}
	
	for fromUserId, requestData in pairs(playerData.friendRequests) do
		table.insert(requests, {
			fromUserId = fromUserId,
			fromName = requestData.fromName,
			timestamp = requestData.timestamp
		})
	end
	
	-- Sort by timestamp (newest first)
	table.sort(requests, function(a, b)
		return a.timestamp > b.timestamp
	end)
	
	return requests
end

-- Remote event handlers
FriendRequestEvent.OnServerEvent:Connect(function(player, targetName)
	-- Validate and send friend request
	local isValid, errorMessage, targetPlayer, targetUserId = validateFriendRequest(player, targetName)
	
	if not isValid then
		ErrorHandler:LogDebug(ErrorHandler, "Friend request validation failed", {
			player = player.Name,
			target = targetName,
			error = errorMessage
		})
		
		-- Notify player of failure
		if FriendUpdateEvent then
			FriendUpdateEvent:FireClient(player, "error", errorMessage)
		end
		return
	end
	
	-- Send friend request
	local success = sendFriendRequest(player, targetPlayer, targetUserId)
	
	if success then
		-- Notify player of success
		if FriendUpdateEvent then
			FriendUpdateEvent:FireClient(player, "sent", {
				toName = targetPlayer.Name
			})
		end
	else
		-- Notify player of failure
		if FriendUpdateEvent then
			FriendUpdateEvent:FireClient(player, "error", "Failed to send friend request")
		end
	end
end)

FriendAcceptEvent.OnServerEvent:Connect(function(player, fromUserId)
	-- Accept friend request
	local success, resultMessage = acceptFriendRequest(player, fromUserId)
	
	if success then
		-- Send updated friend list to player
		local friendList = getFriendList(player)
		local pendingRequests = getPendingRequests(player)
		
		if FriendUpdateEvent then
			FriendUpdateEvent:FireClient(player, "list", {
				friends = friendList,
				requests = pendingRequests
			})
		end
		
		ErrorHandler:LogInfo(ErrorHandler, "Friend request accepted", {
			player = player.Name,
			friend = resultMessage
		})
	else
		-- Notify player of failure
		if FriendUpdateEvent then
			FriendUpdateEvent:FireClient(player, "error", resultMessage or "Failed to accept friend request")
		end
	end
end)

FriendDeclineEvent.OnServerEvent:Connect(function(player, fromUserId)
	-- Decline friend request
	local success, resultMessage = declineFriendRequest(player, fromUserId)
	
	if success then
		-- Send updated pending requests to player
		local pendingRequests = getPendingRequests(player)
		
		if FriendUpdateEvent then
			FriendUpdateEvent:FireClient(player, "requests", pendingRequests)
		end
		
		ErrorHandler:LogInfo(ErrorHandler, "Friend request declined", {
			player = player.Name,
			from = resultMessage
		})
	else
		-- Notify player of failure
		if FriendUpdateEvent then
			FriendUpdateEvent:FireClient(player, "error", resultMessage or "Failed to decline friend request")
		end
	end
end)

FriendRemoveEvent.OnServerEvent:Connect(function(player, friendUserId)
	-- Remove friend
	local success, resultMessage = removeFriend(player, friendUserId)
	
	if success then
		-- Send updated friend list to player
		local friendList = getFriendList(player)
		
		if FriendUpdateEvent then
			FriendUpdateEvent:FireClient(player, "list", {
				friends = friendList,
				requests = getPendingRequests(player)
			})
		end
		
		ErrorHandler:LogInfo(ErrorHandler, "Friend removed", {
			player = player.Name,
			friend = resultMessage
		})
	else
		-- Notify player of failure
		if FriendUpdateEvent then
			FriendUpdateEvent:FireClient(player, "error", resultMessage or "Failed to remove friend")
		end
	end
end)

-- Player join/leave handlers
Players.PlayerAdded:Connect(function(player)
	-- Load friend data
	getFriendData(player)
	
	-- Update online status for all friends
	updateOnlineStatus(player, true)
	
	-- Send initial friend data to player
	local friendList = getFriendList(player)
	local pendingRequests = getPendingRequests(player)
	
	if FriendUpdateEvent then
		FriendUpdateEvent:FireClient(player, "init", {
			friends = friendList,
			requests = pendingRequests,
			maxFriends = FRIEND_CONFIG.MAX_FRIENDS
		})
	end
	
	ErrorHandler:LogInfo(ErrorHandler, "Player joined - friend system initialized", {
		player = player.Name,
		friendCount = #friendList,
		requestCount = #pendingRequests
	})
end)

Players.PlayerRemoving:Connect(function(player)
	-- Update online status for all friends
	updateOnlineStatus(player, false)
	
	-- Save friend data
	local playerData = getFriendData(player)
	saveFriendData(player, playerData)
	
	-- Clean up cache
	friendDataCache[tostring(player.UserId)] = nil
	
	ErrorHandler:LogInfo(ErrorHandler, "Player left - friend system cleaned up", {
		player = player.Name
	})
end)

-- Clean up old pending requests periodically
local function cleanupOldRequests()
	local currentTime = os.time()
	local removedCount = 0
	
	for requestKey, requestData in pairs(pendingRequests) do
		if currentTime - requestData.timestamp > FRIEND_CONFIG.REQUEST_COOLDOWN * 2 then
			-- Request is too old, clean it up
			pendingRequests[requestKey] = nil
			removedCount = removedCount + 1
		end
	end
	
	if removedCount > 0 then
		ErrorHandler:LogDebug(ErrorHandler, "Cleaned up old pending requests", {
			count = removedCount
		})
	end
end

-- Periodic cleanup
RunService.Heartbeat:Connect(function(deltaTime)
	cleanupOldRequests()
end)

-- Initialize
ErrorHandler:LogInfo(ErrorHandler, "FriendManager loaded successfully", {
	maxFriends = FRIEND_CONFIG.MAX_FRIENDS,
	requestCooldown = FRIEND_CONFIG.REQUEST_COOLDOWN,
	dataStoreAvailable = dataStoreAvailable
})</string>
      </Properties>
    </Item>
    <Item class="Script" referent="138">
      <Properties>
        <string name="Name">HotbarHandler</string>
        <token name="RunContext">0</token>
        <string name="Source">--[[
	HotbarHandler.server.lua
	Server-side handler for hotbar item usage
	Handles food consumption, healing, and other consumable items
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

print("[HotbarHandler] Starting...")

-- Modules
local Modules = ReplicatedStorage:WaitForChild("Modules", 5)
local DataManager = require(Modules:WaitForChild("DataManager", 5))
local ItemDatabase = require(Modules:WaitForChild("ItemDatabase", 5))

-- Get UseItem RemoteEvent
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 5)
local UseItemRemote = Remotes:WaitForChild("UseItem", 10)

-- Also get other remotes for notifications
local XPPopupEvent = Remotes:FindFirstChild("XPPopup")
local InventoryUpdateEvent = Remotes:FindFirstChild("InventoryUpdate")

-----------------------------------------------------------------------
-- ITEM USAGE HANDLERS
-----------------------------------------------------------------------

local function handleFoodConsumption(player, itemName)
	local itemDef = ItemDatabase.GetItem(itemName)
	if not itemDef then
		warn("[HotbarHandler] Unknown item:", itemName)
		return false
	end
	
	-- Verify it's actually food
	if itemDef.type ~= "food" then
		warn("[HotbarHandler] Item is not food:", itemName)
		return false
	end
	
	-- Check if player has the item
	local playerData = DataManager:GetData(player)
	if not playerData then
		warn("[HotbarHandler] No player data for:", player.Name)
		return false
	end
	
	-- Find item in inventory
	local foundSlot = nil
	for i, slot in ipairs(playerData.inventory) do
		if slot and slot.name == itemName and slot.count > 0 then
			foundSlot = i
			break
		end
	end
	
	if not foundSlot then
		warn("[HotbarHandler] Player doesn't have item:", itemName)
		return false
	end
	
	-- Get heal amount (with fallback based on tier)
	local healAmount = itemDef.healAmount
	if not healAmount then
		-- Default heal amounts based on item tier/value
		local value = itemDef.value or 0
		if value >= 200 then
			healAmount = 50 -- High tier food
		elseif value >= 50 then
			healAmount = 25 -- Mid tier food
		elseif value >= 10 then
			healAmount = 15 -- Low tier food
		else
			healAmount = 8 -- Basic food
		end
	end
	
	-- Get player's current health
	local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
	if not humanoid then
		warn("[HotbarHandler] Player has no humanoid")
		return false
	end
	
	local currentHealth = humanoid.Health
	local maxHealth = humanoid.MaxHealth
	
	-- Don't eat if already at full health
	if currentHealth >= maxHealth then
		print("[HotbarHandler] Player already at full health")
		return false
	end
	
	-- Consume the item
	local consumed = DataManager.RemoveItem(player, itemName, 1)
	if not consumed then
		warn("[HotbarHandler] Failed to remove item:", itemName)
		return false
	end
	
	-- Heal the player
	local newHealth = math.min(currentHealth + healAmount, maxHealth)
	humanoid.Health = newHealth
	
	print("[HotbarHandler] " .. player.Name .. " ate " .. itemName .. " and healed " .. healAmount .. " HP")
	
	-- Notify client of inventory update
	if InventoryUpdateEvent then
		local data = DataManager:GetData(player)
		if data and data.Inventory then
			InventoryUpdateEvent:FireClient(player, data.Inventory)
		end
	end
	
	-- Show heal effect (you could add a visual effect here)
	-- For now, just print to the player
	if XPPopupEvent then
		XPPopupEvent:FireClient(player, "+" .. healAmount .. " HP", Color3.fromRGB(0, 255, 0), player.Character.HumanoidRootPart.Position + Vector3.new(0, 5, 0))
	end
	
	return true
end

local function handlePotionConsumption(player, itemName)
	-- Future: Handle potions (stat boosts, temporary effects, etc.)
	print("[HotbarHandler] Potion consumption not yet implemented:", itemName)
	return false
end

local function handleOtherConsumables(player, itemName)
	-- Future: Handle other consumable items
	print("[HotbarHandler] Other consumable usage not yet implemented:", itemName)
	return false
end

-----------------------------------------------------------------------
-- MAIN HANDLER
-----------------------------------------------------------------------

UseItemRemote.OnServerEvent:Connect(function(player, itemName)
	if not player or not itemName then
		warn("[HotbarHandler] Invalid parameters")
		return
	end
	
	print("[HotbarHandler] " .. player.Name .. " attempting to use:", itemName)
	
	local itemDef = ItemDatabase.GetItem(itemName)
	if not itemDef then
		warn("[HotbarHandler] Unknown item:", itemName)
		return
	end
	
	-- Route to appropriate handler based on item type
	local success = false
	
	if itemDef.type == "food" then
		success = handleFoodConsumption(player, itemName)
	elseif itemDef.type == "potion" then
		success = handlePotionConsumption(player, itemName)
	else
		-- Try as other consumable
		success = handleOtherConsumables(player, itemName)
	end
	
	if not success then
		warn("[HotbarHandler] Failed to use item:", itemName)
	end
end)

print("[HotbarHandler] Ready!")</string>
      </Properties>
    </Item>
    <Item class="Script" referent="139">
      <Properties>
        <string name="Name">LeaderboardManager</string>
        <token name="RunContext">0</token>
        <string name="Source">-- LeaderboardManager.server.lua
-- Leaderboard system for Wilderness MMO

print("[LeaderboardManager] Starting...")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Wait for dependencies with timeouts
local Modules = ReplicatedStorage:WaitForChild("Modules", 10)
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)

-- Load required modules
local DataManager = require(Modules:WaitForChild("DataManager", 10))

-- Get remotes
local GetLeaderboard = Remotes:WaitForChild("GetLeaderboard", 5)
local LeaderboardUpdate = Remotes:WaitForChild("LeaderboardUpdate", 5)

-- Validate remotes
if not GetLeaderboard or not LeaderboardUpdate then
	warn("[LeaderboardManager] Missing remotes!")
	return
end

-- Leaderboard categories
local CATEGORIES = {
	"Total Level",
	"Monsters Killed", 
	"Gold",
	"Combat Level",
	"Mining",
	"Woodcutting",
	"Fishing",
	"Crafting",
	"Smithing",
	"Fletching",
	"Cooking"
}

-- Cache for leaderboard data
local leaderboardCache = {}
local lastUpdateTime = 0
local UPDATE_INTERVAL = 60 -- seconds

-- Helper function to calculate total level
local function calculateTotalLevel(playerData)
	local total = 0
	for skill, level in pairs(playerData.skillLevels or {}) do
		total = total + level
	end
	return total
end

-- Helper function to get player stats for leaderboard
local function getPlayerStats(player)
	if not player then return nil end
	
	local data = DataManager:GetData(player)
	if not data then return nil end
	
	return {
		userId = player.UserId,
		name = player.Name,
		totalLevel = calculateTotalLevel(data),
		monstersKilled = data.monstersKilled or 0,
		gold = data.gold or 0,
		combatLevel = data.combatLevel or 0,
		mining = data.skillLevels and data.skillLevels.Mining or 0,
		woodcutting = data.skillLevels and data.skillLevels.Woodcutting or 0,
		fishing = data.skillLevels and data.skillLevels.Fishing or 0,
		crafting = data.skillLevels and data.skillLevels.Crafting or 0,
		smithing = data.skillLevels and data.skillLevels.Smithing or 0,
		fletching = data.skillLevels and data.skillLevels.Fletching or 0,
		cooking = data.skillLevels and data.skillLevels.Cooking or 0
	}
end

-- Function to update leaderboard cache
local function updateLeaderboardCache()
	local allStats = {}
	
	-- Get stats for all players
	for _, player in ipairs(Players:GetPlayers()) do
		local stats = getPlayerStats(player)
		if stats then
			table.insert(allStats, stats)
		end
	end
	
	-- Sort by each category
	for _, category in ipairs(CATEGORIES) do
		local sorted = {}
		
		for _, stats in ipairs(allStats) do
			table.insert(sorted, stats)
		end
		
		-- Sort based on category
		if category == "Total Level" then
			table.sort(sorted, function(a, b)
				return a.totalLevel > b.totalLevel
			end)
		elseif category == "Monsters Killed" then
			table.sort(sorted, function(a, b)
				return a.monstersKilled > b.monstersKilled
			end)
		elseif category == "Gold" then
			table.sort(sorted, function(a, b)
				return a.gold > b.gold
			end)
		elseif category == "Combat Level" then
			table.sort(sorted, function(a, b)
				return a.combatLevel > b.combatLevel
			end)
		elseif category == "Mining" then
			table.sort(sorted, function(a, b)
				return a.mining > b.mining
			end)
		elseif category == "Woodcutting" then
			table.sort(sorted, function(a, b)
				return a.woodcutting > b.woodcutting
			end)
		elseif category == "Fishing" then
			table.sort(sorted, function(a, b)
				return a.fishing > b.fishing
			end)
		elseif category == "Crafting" then
			table.sort(sorted, function(a, b)
				return a.crafting > b.crafting
			end)
		elseif category == "Smithing" then
			table.sort(sorted, function(a, b)
				return a.smithing > b.smithing
			end)
		elseif category == "Fletching" then
			table.sort(sorted, function(a, b)
				return a.fletching > b.fletching
			end)
		elseif category == "Cooking" then
			table.sort(sorted, function(a, b)
				return a.cooking > b.cooking
			end)
		end
		
		-- Limit to top 100
		local limited = {}
		for i = 1, math.min(100, #sorted) do
			table.insert(limited, sorted[i])
		end
		
		leaderboardCache[category] = limited
	end
	
	lastUpdateTime = os.time()
	print("[LeaderboardManager] Cache updated at " .. tostring(lastUpdateTime))
end

-- Function to get leaderboard data
local function getLeaderboardData(category, limit)
	-- Check if cache needs update
	if os.time() - lastUpdateTime > UPDATE_INTERVAL then
		updateLeaderboardCache()
	end
	
	local data = leaderboardCache[category] or {}
	
	-- Apply limit
	if limit and limit > 0 then
		local limited = {}
		for i = 1, math.min(limit, #data) do
			table.insert(limited, data[i])
		end
		return limited
	end
	
	return data
end

-- Handle GetLeaderboard remote function
GetLeaderboard.OnServerInvoke = function(player, category, limit)
	if not category or not table.find(CATEGORIES, category) then
		category = "Total Level"
	end
	
	limit = limit or 100
	if limit > 100 then limit = 100 end
	
	local data = getLeaderboardData(category, limit)
	
	-- Add player's rank if they're not in top list
	local playerStats = getPlayerStats(player)
	if playerStats then
		local allData = getLeaderboardData(category, 0) -- Get all for ranking
		local playerRank = nil
		
		for i, stats in ipairs(allData) do
			if stats.userId == player.UserId then
				playerRank = i
				break
			end
		end
		
		-- If player not in top 100, find their rank
		if not playerRank then
			playerRank = #allData + 1
			for i, stats in ipairs(allData) do
				local playerValue = playerStats[category:gsub(" ", ""):lower()] or 0
				local otherValue = stats[category:gsub(" ", ""):lower()] or 0
				
				if category == "Total Level" then
					playerValue = playerStats.totalLevel
					otherValue = stats.totalLevel
				elseif category == "Monsters Killed" then
					playerValue = playerStats.monstersKilled
					otherValue = stats.monstersKilled
				elseif category == "Gold" then
					playerValue = playerStats.gold
					otherValue = stats.gold
				elseif category == "Combat Level" then
					playerValue = playerStats.combatLevel
					otherValue = stats.combatLevel
				end
				
				if playerValue > otherValue then
					playerRank = i
					break
				end
			end
		end
		
		return {
			category = category,
			data = data,
			playerRank = playerRank,
			playerStats = playerStats,
			totalPlayers = #allData,
			lastUpdate = lastUpdateTime
		}
	end
	
	return {
		category = category,
		data = data,
		playerRank = nil,
		playerStats = nil,
		totalPlayers = #data,
		lastUpdate = lastUpdateTime
	}
end

-- Function to force update (for other systems)
local function forceUpdate()
	updateLeaderboardCache()
	
	-- Notify all players
	for _, player in ipairs(Players:GetPlayers()) do
		LeaderboardUpdate:FireClient(player, {
			timestamp = lastUpdateTime
		})
	end
end

-- Periodic updates
task.spawn(function()
	while true do
		task.wait(UPDATE_INTERVAL)
		forceUpdate()
	end
end)

-- Update when player joins/leaves
Players.PlayerAdded:Connect(function(player)
	-- Small delay to let player data load
	task.wait(2)
	forceUpdate()
end)

Players.PlayerRemoving:Connect(function(player)
	forceUpdate()
end)

-- Initial update
task.wait(5) -- Wait for players to load
updateLeaderboardCache()

print("[LeaderboardManager] Ready with " .. tostring(#CATEGORIES) .. " categories!")

-- Public API
return {
	ForceUpdate = forceUpdate,
	GetLeaderboardData = getLeaderboardData,
	GetCategories = function() return CATEGORIES end
}</string>
      </Properties>
    </Item>
    <Item class="Script" referent="140">
      <Properties>
        <string name="Name">LootManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	LootManager.server.lua
	Handles full-loot PvP death drops in the wilderness.
	When a player dies at Z < -100, all inventory items drop as a loot bag
	that any player can loot within 60 seconds.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")

-- Modules
local DataManager = require(ReplicatedStorage:WaitForChild("Modules", 5):WaitForChild("DataManager", 5))

-- Config
local Config = {
	WildernessZ = -100,          -- Z threshold for wilderness
	LootDropDuration = 60,       -- seconds before bag despawns
	BagSize = Vector3.new(2, 2, 2),
	BagColor = Color3.fromRGB(139, 90, 43), -- brown sack
	GlowColor = Color3.fromRGB(240, 192, 64),
	MaxLootDistance = 10,
	CleanupInterval = 5,         -- seconds between cleanup sweeps
}

-- RemoteEvents
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
local LootBagOpen = Remotes:WaitForChild("LootBagOpen", 10)
local LootBagTake = Remotes:WaitForChild("LootBagTake", 10)
local LootBagUpdate = Remotes:WaitForChild("LootBagUpdate", 10)

-- Active loot bags: bagId -> { model, contents, position, timestamp, owner }
local activeBags = {}

local nextBagId = 1

--------------------------------------------------------------------------------
-- Loot Bag Creation
--------------------------------------------------------------------------------

--- Build the 3D loot bag model at the given position
local function createBagModel(position, ownerName, bagId)
	local model = Instance.new("Model")
	model.Name = "LootBag_" .. bagId

	-- Primary part: the brown sack
	local part = Instance.new("Part")
	part.Name = "Sack"
	part.Size = Config.BagSize
	part.Position = position + Vector3.new(0, 1, 0) -- slightly above ground
	part.Anchored = true
	part.CanCollide = false
	part.Shape = Enum.PartType.Ball
	part.Color = Config.BagColor
	part.Material = Enum.Material.Fabric
	part.Parent = model

	model.PrimaryPart = part

	-- Glow effect
	local light = Instance.new("PointLight")
	light.Color = Config.GlowColor
	light.Brightness = 0.8
	light.Range = 6
	light.Parent = part

	-- BillboardGui label
	local billboard = Instance.new("BillboardGui")
	billboard.Name = "Label"
	billboard.Size = UDim2.new(0, 200, 0, 60)
	billboard.StudsOffset = Vector3.new(0, 2.5, 0)
	billboard.AlwaysOnTop = true
	billboard.Parent = part

	local title = Instance.new("TextLabel")
	title.Size = UDim2.new(1, 0, 0.5, 0)
	title.BackgroundTransparency = 1
	title.Text = "ðŸ’€ Loot Bag"
	title.TextColor3 = Config.GlowColor
	title.TextScaled = true
	title.Font = Enum.Font.GothamBold
	title.Parent = billboard

	local subtitle = Instance.new("TextLabel")
	subtitle.Size = UDim2.new(1, 0, 0.5, 0)
	subtitle.Position = UDim2.new(0, 0, 0.5, 0)
	subtitle.BackgroundTransparency = 1
	subtitle.Text = ownerName
	subtitle.TextColor3 = Color3.new(1, 1, 1)
	subtitle.TextScaled = true
	subtitle.Font = Enum.Font.Gotham
	subtitle.Parent = billboard

	-- ClickDetector for interaction
	local click = Instance.new("ClickDetector")
	click.MaxActivationDistance = Config.MaxLootDistance
	click.Parent = part

	-- Store bagId as attribute for identification
	model:SetAttribute("BagId", bagId)

	-- Parent to workspace
	model.Parent = workspace

	return model
end

--- Drop all of a player's inventory as a loot bag at their death position
local function dropLootBag(player, deathPosition)
	-- Get player inventory from DataManager
	local inventory = DataManager:GetInventory(player)
	if not inventory or #inventory == 0 then
		return -- nothing to drop
	end

	local bagId = tostring(nextBagId)
	nextBagId += 1

	-- Deep copy inventory contents
	local contents = {}
	for _, item in inventory do
		table.insert(contents, table.clone(item))
	end

	-- Clear player's inventory
	DataManager:ClearInventory(player)

	-- Create bag
	local model = createBagModel(deathPosition, player.Name, bagId)

	activeBags[bagId] = {
		model = model,
		contents = contents,
		position = deathPosition,
		timestamp = os.clock(),
		ownerName = player.Name,
	}

	-- Wire up click detector
	local sack = model.PrimaryPart
	local clickDetector = sack:FindFirstChildOfClass("ClickDetector")
	clickDetector.MouseClick:Connect(function(looter)
		local bag = activeBags[bagId]
		if not bag then return end

		-- Send bag contents to the clicking player
		LootBagOpen:FireClient(looter, bagId, bag.contents, bag.ownerName)
	end)

	-- Auto-despawn via Debris as a safety net
	Debris:AddItem(model, Config.LootDropDuration + 1)

	print(string.format("[LootManager] %s dropped loot bag #%s (%d items) at %s",
		player.Name, bagId, #contents, tostring(deathPosition)))
end

--------------------------------------------------------------------------------
-- Loot Taking
--------------------------------------------------------------------------------

--- Handle a player requesting to take a single item from a bag
LootBagTake.OnServerEvent:Connect(function(player, bagId, itemIndex)
	local bag = activeBags[bagId]
	if not bag then return end

	-- Validate index
	if itemIndex < 1 or itemIndex > #bag.contents then return end

	-- Distance check
	local character = player.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") then return end
	local dist = (character.HumanoidRootPart.Position - bag.position).Magnitude
	if dist > Config.MaxLootDistance + 2 then return end -- small grace

	-- Remove item from bag and give to player
	local item = table.remove(bag.contents, itemIndex)
	if not item then return end

	DataManager:AddItem(player, item)

	print(string.format("[LootManager] %s looted %s from bag #%s", player.Name, item.name or item.itemId, bagId))

	-- Notify all clients who might have this bag open
	if #bag.contents == 0 then
		-- Bag is empty, destroy it
		LootBagUpdate:FireAllClients(bagId, nil) -- nil = bag gone
		if bag.model then bag.model:Destroy() end
		activeBags[bagId] = nil
	else
		-- Update remaining contents
		LootBagUpdate:FireAllClients(bagId, bag.contents)
	end
end)

--------------------------------------------------------------------------------
-- Death Handling
--------------------------------------------------------------------------------

local function onCharacterAdded(player, character)
	local humanoid = character:WaitForChild("Humanoid", 5)

	humanoid.Died:Connect(function()
		local rootPart = character:FindFirstChild("HumanoidRootPart")
		if not rootPart then return end

		local pos = rootPart.Position

		-- Only drop loot in wilderness (Z < -100)
		if pos.Z < Config.WildernessZ then
			dropLootBag(player, pos)
		end
	end)
end

local function onPlayerAdded(player)
	player.CharacterAdded:Connect(function(character)
		onCharacterAdded(player, character)
	end)

	-- Handle already-spawned character
	if player.Character then
		onCharacterAdded(player, player.Character)
	end
end

Players.PlayerAdded:Connect(onPlayerAdded)
for _, player in Players:GetPlayers() do
	onPlayerAdded(player)
end

--------------------------------------------------------------------------------
-- Cleanup Loop: remove expired bags
--------------------------------------------------------------------------------

task.spawn(function()
	while true do
		task.wait(Config.CleanupInterval)
		local now = os.clock()

		for bagId, bag in activeBags do
			if now - bag.timestamp >= Config.LootDropDuration then
				print(string.format("[LootManager] Bag #%s expired, destroying", bagId))
				LootBagUpdate:FireAllClients(bagId, nil)
				if bag.model then bag.model:Destroy() end
				activeBags[bagId] = nil
			end
		end
	end
end)

print("[LootManager] Loot system active!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="141">
      <Properties>
        <string name="Name">MapSetup</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- MapSetup.server.lua
-- Creates the entire game world: terrain, city, wilderness, ponds, mine, forests

print("[MapSetup] Starting world generation...")
local WS = game:GetService("Workspace")

-- === HELPER FUNCTIONS ===
local function makePart(name, size, position, color, material, parent, props)
	local p = Instance.new("Part")
	p.Name = name
	p.Size = size
	p.Position = position
	p.Anchored = true
	if typeof(color) == "Color3" then
		p.Color = color
	else
		p.BrickColor = BrickColor.new(color)
	end
	p.Material = material or Enum.Material.SmoothPlastic
	p.Parent = parent
	if props then
		for k, v in pairs(props) do
			p[k] = v
		end
	end
	return p
end

local function makeWedge(name, size, position, color, material, parent, props)
	local w = Instance.new("WedgePart")
	w.Name = name
	w.Size = size
	w.Position = position
	w.Anchored = true
	w.BrickColor = BrickColor.new(color)
	w.Material = material or Enum.Material.SmoothPlastic
	w.Parent = parent
	if props then
		for k, v in pairs(props) do
			w[k] = v
		end
	end
	return w
end

local function makeSign(parent, text, offset, size)
	local bg = Instance.new("BillboardGui")
	bg.Size = size or UDim2.new(8, 0, 2, 0)
	bg.StudsOffset = offset or Vector3.new(0, 5, 0)
	bg.Parent = parent
	local tl = Instance.new("TextLabel")
	tl.Size = UDim2.new(1, 0, 1, 0)
	tl.BackgroundTransparency = 1
	tl.Text = text
	tl.TextColor3 = Color3.fromRGB(255, 255, 255)
	tl.TextScaled = true
	tl.Font = Enum.Font.GothamBold
	tl.TextStrokeTransparency = 0.3
	tl.Parent = bg
	return bg
end

local function makeTorch(position, parent)
	local pole = makePart("TorchPole", Vector3.new(0.5, 6, 0.5), position, "Reddish brown", Enum.Material.Wood, parent)
	local flame = makePart("TorchFlame", Vector3.new(0.8, 1.2, 0.8), position + Vector3.new(0, 3.5, 0), "Bright orange", Enum.Material.Neon, parent, {Transparency = 0.4})
	local light = Instance.new("PointLight")
	light.Color = Color3.fromRGB(255, 150, 50)
	light.Brightness = 0.5
	light.Range = 10
	light.Parent = flame
	return pole
end

local function makeLantern(position, parent)
	local post = makePart("LanternPost", Vector3.new(0.4, 5, 0.4), position, "Dark stone grey", Enum.Material.Metal, parent)
	local lamp = makePart("Lantern", Vector3.new(1.2, 1.5, 1.2), position + Vector3.new(0, 3.2, 0), "Bright yellow", Enum.Material.Neon, parent, {Transparency = 0.5})
	local light = Instance.new("PointLight")
	light.Color = Color3.fromRGB(255, 220, 120)
	light.Brightness = 0.4
	light.Range = 12
	light.Parent = lamp
	return post
end

-- === FOLDERS ===
local function getOrMake(parent, name)
	local f = parent:FindFirstChild(name)
	if not f then f = Instance.new("Folder") f.Name = name f.Parent = parent end
	return f
end

local safeZone = getOrMake(WS, "SafeZone")
local wilderness = getOrMake(WS, "Wilderness")
local resourceNodes = getOrMake(WS, "ResourceNodes")

-- ============================================================
-- === GROUND / TERRAIN ===
-- ============================================================

-- Main baseplate (safe zone - green grass) â€” HUGE
if not WS:FindFirstChild("Baseplate") then
	local bp = Instance.new("Part")
	bp.Name = "Baseplate"
	bp.Size = Vector3.new(800, 1, 800)
	bp.Position = Vector3.new(0, -0.5, 0)
	bp.Anchored = true
	bp.BrickColor = BrickColor.new("Bright green")
	bp.Material = Enum.Material.Grass
	bp.Parent = WS
end

-- Wilderness ground (darker, dead â€” extends north)
if not WS:FindFirstChild("WildernessGround") then
	local wg = Instance.new("Part")
	wg.Name = "WildernessGround"
	wg.Size = Vector3.new(800, 1.01, 600)
	wg.Position = Vector3.new(0, -0.5, -400)
	wg.Anchored = true
	wg.BrickColor = BrickColor.new("Dark stone grey")
	wg.Material = Enum.Material.Ground
	wg.Parent = WS
end

-- === SPAWN POINT ===
if not WS:FindFirstChild("SpawnLocation") then
	local sp = Instance.new("SpawnLocation")
	sp.Size = Vector3.new(12, 1, 12)
	sp.Position = Vector3.new(0, 0.5, 60)
	sp.Anchored = true
	sp.BrickColor = BrickColor.new("White")
	sp.Material = Enum.Material.Marble
	sp.Parent = WS
end

-- === WILDERNESS BORDER ===
if not WS:FindFirstChild("WildernessBorder") then
	local b = makePart("WildernessBorder", Vector3.new(800, 30, 2), Vector3.new(0, 15, -100), Color3.fromRGB(100, 15, 15), Enum.Material.ForceField, WS, {Transparency = 0.4, CanCollide = false})
	local borderGlow = Instance.new("PointLight")
	borderGlow.Color = Color3.fromRGB(180, 20, 20)
	borderGlow.Brightness = 0.8
	borderGlow.Range = 20
	borderGlow.Parent = b
	makeSign(b, "âš ï¸ WILDERNESS â€” FULL LOOT PVP âš ï¸\nCross at your own risk!", Vector3.new(0, 8, 0))
end

-- ============================================================
-- === THE CITY OF HAVEN ===
-- ============================================================

local cityFolder = getOrMake(safeZone, "City")

-- ---- CITY WALLS (enhanced medieval perimeter with crenellations) ----
-- Back wall (north side) â€” split for North Gate with proper crenellations
makePart("WallBackL", Vector3.new(50, 14, 6), Vector3.new(-37, 7, -10), "Medium stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("WallBackR", Vector3.new(50, 14, 6), Vector3.new(37, 7, -10), "Medium stone grey", Enum.Material.Cobblestone, cityFolder)
-- Crenellations (battlements) on north walls
for i = 0, 8 do
	makePart("CreneL" .. i, Vector3.new(4, 4, 4), Vector3.new(-60 + i * 6, 16, -10), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
end
for i = 0, 8 do
	makePart("CreneR" .. i, Vector3.new(4, 4, 4), Vector3.new(12 + i * 6, 16, -10), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
end

-- North Gate (enhanced archway and architecture)
makePart("NorthGateLeft", Vector3.new(8, 20, 8), Vector3.new(-12, 10, -10), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("NorthGateRight", Vector3.new(8, 20, 8), Vector3.new(12, 10, -10), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("NorthGateArch", Vector3.new(28, 6, 8), Vector3.new(0, 20, -10), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
-- Decorative arch details
makePart("NorthArchTrim", Vector3.new(30, 1, 6), Vector3.new(0, 17, -10), "Bright yellow", Enum.Material.Metal, cityFolder)
-- Iron portcullis
makePart("NorthPortcullis", Vector3.new(16, 16, 1), Vector3.new(0, 10, -10), "Black", Enum.Material.DiamondPlate, cityFolder, {Transparency = 0.3, CanCollide = false})
-- Gate towers with peaked roofs
makeWedge("NorthGateRoofL", Vector3.new(8, 6, 8), Vector3.new(-12, 26, -10), "Dark red", Enum.Material.Slate, cityFolder)
makeWedge("NorthGateRoofR", Vector3.new(8, 6, 8), Vector3.new(12, 26, -10), "Dark red", Enum.Material.Slate, cityFolder)
-- Enhanced signage
local northGateSign = makePart("NorthGateSign", Vector3.new(1, 1, 1), Vector3.new(0, 24, -10), "Dark stone grey", Enum.Material.Cobblestone, cityFolder, {Transparency = 1})
makeSign(northGateSign, "âš ï¸ WILDERNESS BEYOND", Vector3.new(0, 0, 0), UDim2.new(12, 0, 4, 0))
-- Enhanced torches with brazier style
makePart("NorthBrazierL", Vector3.new(2, 1, 2), Vector3.new(-10, 24, -14), "Dark stone grey", Enum.Material.Metal, cityFolder)
makePart("NorthFlameL", Vector3.new(2, 3, 2), Vector3.new(-10, 26, -14), "Really red", Enum.Material.Neon, cityFolder, {Transparency = 0.5})
local nlLight = Instance.new("PointLight") nlLight.Color = Color3.fromRGB(255, 40, 40) nlLight.Brightness = 0.6 nlLight.Range = 10 nlLight.Parent = cityFolder:FindFirstChild("NorthFlameL")
makePart("NorthBrazierR", Vector3.new(2, 1, 2), Vector3.new(10, 24, -14), "Dark stone grey", Enum.Material.Metal, cityFolder)
makePart("NorthFlameR", Vector3.new(2, 3, 2), Vector3.new(10, 26, -14), "Really red", Enum.Material.Neon, cityFolder, {Transparency = 0.5})
local nrLight = Instance.new("PointLight") nrLight.Color = Color3.fromRGB(255, 40, 40) nrLight.Brightness = 0.6 nrLight.Range = 10 nrLight.Parent = cityFolder:FindFirstChild("NorthFlameR")

-- Left wall (west) â€” enhanced with crenellations
makePart("WallLeftN", Vector3.new(6, 14, 50), Vector3.new(-62, 7, 15), "Medium stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("WallLeftS", Vector3.new(6, 14, 50), Vector3.new(-62, 7, 85), "Medium stone grey", Enum.Material.Cobblestone, cityFolder)
-- West wall crenellations
for i = 0, 7 do
	makePart("WestCreneN" .. i, Vector3.new(4, 4, 4), Vector3.new(-62, 16, -8 + i * 6), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
end
for i = 0, 7 do
	makePart("WestCreneS" .. i, Vector3.new(4, 4, 4), Vector3.new(-62, 16, 62 + i * 6), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
end

-- West Gate (enhanced architecture)
makePart("WestGateTop", Vector3.new(8, 20, 8), Vector3.new(-62, 10, 38), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("WestGateBot", Vector3.new(8, 20, 8), Vector3.new(-62, 10, 62), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("WestGateArch", Vector3.new(8, 6, 28), Vector3.new(-62, 20, 50), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("WestArchTrim", Vector3.new(6, 1, 30), Vector3.new(-62, 17, 50), "Bright yellow", Enum.Material.Metal, cityFolder)
makePart("WestPortcullis", Vector3.new(1, 16, 16), Vector3.new(-62, 10, 50), "Black", Enum.Material.DiamondPlate, cityFolder, {Transparency = 0.3, CanCollide = false})
-- Gate towers with peaked roofs
makeWedge("WestGateRoofTop", Vector3.new(8, 6, 8), Vector3.new(-62, 26, 38), "Dark red", Enum.Material.Slate, cityFolder)
makeWedge("WestGateRoofBot", Vector3.new(8, 6, 8), Vector3.new(-62, 26, 62), "Dark red", Enum.Material.Slate, cityFolder)
local westGateSign = makePart("WestGateSign", Vector3.new(1, 1, 1), Vector3.new(-62, 24, 50), "Dark stone grey", Enum.Material.Cobblestone, cityFolder, {Transparency = 1})
makeSign(westGateSign, "â›ï¸ TO HAVEN MINE", Vector3.new(0, 0, 0), UDim2.new(10, 0, 3, 0))
-- Enhanced gate lighting
makeLantern(Vector3.new(-66, 0, 43), cityFolder)
makeLantern(Vector3.new(-66, 0, 57), cityFolder)

-- Right wall (east) â€” enhanced with crenellations
makePart("WallRightN", Vector3.new(6, 14, 50), Vector3.new(62, 7, 15), "Medium stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("WallRightS", Vector3.new(6, 14, 50), Vector3.new(62, 7, 85), "Medium stone grey", Enum.Material.Cobblestone, cityFolder)
-- East wall crenellations
for i = 0, 7 do
	makePart("EastCreneN" .. i, Vector3.new(4, 4, 4), Vector3.new(62, 16, -8 + i * 6), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
end
for i = 0, 7 do
	makePart("EastCreneS" .. i, Vector3.new(4, 4, 4), Vector3.new(62, 16, 62 + i * 6), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
end

-- East Gate (enhanced architecture)
makePart("EastGateTop", Vector3.new(8, 20, 8), Vector3.new(62, 10, 38), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("EastGateBot", Vector3.new(8, 20, 8), Vector3.new(62, 10, 62), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("EastGateArch", Vector3.new(8, 6, 28), Vector3.new(62, 20, 50), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("EastArchTrim", Vector3.new(6, 1, 30), Vector3.new(62, 17, 50), "Bright yellow", Enum.Material.Metal, cityFolder)
makePart("EastPortcullis", Vector3.new(1, 16, 16), Vector3.new(62, 10, 50), "Black", Enum.Material.DiamondPlate, cityFolder, {Transparency = 0.3, CanCollide = false})
-- Gate towers with peaked roofs
makeWedge("EastGateRoofTop", Vector3.new(8, 6, 8), Vector3.new(62, 26, 38), "Dark red", Enum.Material.Slate, cityFolder)
makeWedge("EastGateRoofBot", Vector3.new(8, 6, 8), Vector3.new(62, 26, 62), "Dark red", Enum.Material.Slate, cityFolder)
local eastGateSign = makePart("EastGateSign", Vector3.new(1, 1, 1), Vector3.new(62, 24, 50), "Dark stone grey", Enum.Material.Cobblestone, cityFolder, {Transparency = 1})
makeSign(eastGateSign, "ðŸŒ² TO HAVEN FOREST", Vector3.new(0, 0, 0), UDim2.new(10, 0, 3, 0))
-- Enhanced gate lighting
makeLantern(Vector3.new(66, 0, 43), cityFolder)
makeLantern(Vector3.new(66, 0, 57), cityFolder)

-- Front walls with crenellations
makePart("WallFrontL", Vector3.new(48, 14, 6), Vector3.new(-36, 7, 108), "Medium stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("WallFrontR", Vector3.new(48, 14, 6), Vector3.new(36, 7, 108), "Medium stone grey", Enum.Material.Cobblestone, cityFolder)
-- South wall crenellations
for i = 0, 7 do
	makePart("SouthCreneL" .. i, Vector3.new(4, 4, 4), Vector3.new(-58 + i * 6, 16, 108), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
end
for i = 0, 7 do
	makePart("SouthCreneR" .. i, Vector3.new(4, 4, 4), Vector3.new(12 + i * 6, 16, 108), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
end

-- Enhanced Corner Towers with detailed architecture
makePart("TowerNW", Vector3.new(10, 20, 10), Vector3.new(-62, 10, -10), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("TowerNE", Vector3.new(10, 20, 10), Vector3.new(62, 10, -10), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("TowerSW", Vector3.new(10, 20, 10), Vector3.new(-62, 10, 108), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("TowerSE", Vector3.new(10, 20, 10), Vector3.new(62, 10, 108), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)

-- Tower crenellations (proper battlements)
local towerPositions = {
	{-62, -10, "NW"}, {62, -10, "NE"}, {-62, 108, "SW"}, {62, 108, "SE"}
}
for _, pos in ipairs(towerPositions) do
	local x, z, name = pos[1], pos[2], pos[3]
	-- 8 crenellations per tower
	for i = 0, 7 do
		local angle = math.rad(i * 45) -- 8 sides
		local creneX = x + 6 * math.sin(angle)
		local creneZ = z + 6 * math.cos(angle)
		makePart("TowerCrene" .. name .. i, Vector3.new(3, 5, 3), Vector3.new(creneX, 22, creneZ), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
	end
	-- Conical tower roofs
	makePart("TowerRoof" .. name, Vector3.new(12, 8, 12), Vector3.new(x, 25, z), "Dark red", Enum.Material.Slate, cityFolder)
	-- Tower flags
	makePart("FlagPole" .. name, Vector3.new(0.3, 8, 0.3), Vector3.new(x, 33, z), "Reddish brown", Enum.Material.Wood, cityFolder)
	makePart("Flag" .. name, Vector3.new(4, 2, 0.1), Vector3.new(x + 2, 35, z), "Bright red", Enum.Material.Fabric, cityFolder)
end

-- ---- MAIN GATE (GRANDEST ENTRANCE) ----
makePart("GateLeft", Vector3.new(8, 22, 8), Vector3.new(-12, 11, 108), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("GateRight", Vector3.new(8, 22, 8), Vector3.new(12, 11, 108), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("GateArch", Vector3.new(28, 8, 8), Vector3.new(0, 22, 108), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
-- Ornate archway decorations
makePart("GateArchTrim", Vector3.new(30, 2, 6), Vector3.new(0, 18, 108), "Bright yellow", Enum.Material.Metal, cityFolder)
makePart("GateKeystone", Vector3.new(3, 3, 2), Vector3.new(0, 22, 110), "Bright yellow", Enum.Material.Metal, cityFolder)
-- Heavy iron portcullis (open - decorative only)
makePart("Portcullis", Vector3.new(16, 18, 2), Vector3.new(0, 11, 108), "Black", Enum.Material.DiamondPlate, cityFolder, {Transparency = 0.3, CanCollide = false})
-- Gate towers with peaked roofs
makeWedge("GateRoofL", Vector3.new(8, 8, 8), Vector3.new(-12, 30, 108), "Dark red", Enum.Material.Slate, cityFolder)
makeWedge("GateRoofR", Vector3.new(8, 8, 8), Vector3.new(12, 30, 108), "Dark red", Enum.Material.Slate, cityFolder)
-- Magnificent gate sign
local gateSign = makePart("GateSignPost", Vector3.new(1, 1, 1), Vector3.new(0, 28, 108), "Dark stone grey", Enum.Material.Cobblestone, cityFolder, {Transparency = 1})
makeSign(gateSign, "ðŸ° CITY OF HAVEN", Vector3.new(0, 0, 0), UDim2.new(12, 0, 4, 0))
-- Grand braziers
makePart("MainBrazierL", Vector3.new(3, 2, 3), Vector3.new(-10, 26, 112), "Dark stone grey", Enum.Material.Metal, cityFolder)
makePart("MainFlameL", Vector3.new(3, 4, 3), Vector3.new(-10, 29, 112), "Bright yellow", Enum.Material.Neon, cityFolder, {Transparency = 0.5})
local mlLight = Instance.new("PointLight") mlLight.Color = Color3.fromRGB(255, 200, 50) mlLight.Brightness = 0.8 mlLight.Range = 14 mlLight.Parent = cityFolder:FindFirstChild("MainFlameL")
makePart("MainBrazierR", Vector3.new(3, 2, 3), Vector3.new(10, 26, 112), "Dark stone grey", Enum.Material.Metal, cityFolder)
makePart("MainFlameR", Vector3.new(3, 4, 3), Vector3.new(10, 29, 112), "Bright yellow", Enum.Material.Neon, cityFolder, {Transparency = 0.5})
local mrLight = Instance.new("PointLight") mrLight.Color = Color3.fromRGB(255, 200, 50) mrLight.Brightness = 0.8 mrLight.Range = 14 mrLight.Parent = cityFolder:FindFirstChild("MainFlameR")

-- ---- ENHANCED CITY GROUND WITH PROPER COBBLESTONE ----
-- CityFloor is the base layer â€” sits just above baseplate so roads can layer on top without z-fighting
makePart("CityFloor", Vector3.new(120, 0.3, 116), Vector3.new(0, 0.15, 49), "Medium stone grey", Enum.Material.Cobblestone, cityFolder)

-- ---- ENHANCED STREET SYSTEM ----
-- Roads sit clearly above city floor (0.3 gap to prevent z-fighting)
-- Main road (grand boulevard from gate to square)
makePart("MainRoad", Vector3.new(12, 0.15, 60), Vector3.new(0, 0.38, 78), "Institutional white", Enum.Material.Cobblestone, cityFolder)
-- Road borders (darker stone, slightly raised)
makePart("MainRoadBorderL", Vector3.new(1, 0.2, 60), Vector3.new(-6.5, 0.4, 78), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("MainRoadBorderR", Vector3.new(1, 0.2, 60), Vector3.new(6.5, 0.4, 78), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)

-- East-west main crossroad
makePart("CrossRoad", Vector3.new(100, 0.15, 10), Vector3.new(0, 0.38, 50), "Institutional white", Enum.Material.Cobblestone, cityFolder)
makePart("CrossRoadBorderN", Vector3.new(100, 0.2, 1), Vector3.new(0, 0.4, 45), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("CrossRoadBorderS", Vector3.new(100, 0.2, 1), Vector3.new(0, 0.4, 55), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)

-- Secondary roads to different quarters
-- Road to smithy (northwest)
makePart("SmithyRoad", Vector3.new(8, 0.15, 20), Vector3.new(-25, 0.38, 35), "Institutional white", Enum.Material.Cobblestone, cityFolder)
-- Road to church (northeast)  
makePart("ChurchRoad", Vector3.new(8, 0.15, 20), Vector3.new(25, 0.38, 35), "Institutional white", Enum.Material.Cobblestone, cityFolder)
-- Road to market (southwest)
makePart("MarketRoad", Vector3.new(20, 0.15, 8), Vector3.new(-35, 0.38, 75), "Institutional white", Enum.Material.Cobblestone, cityFolder)
-- Road to guard tower (southeast)
makePart("GuardRoad", Vector3.new(12, 0.15, 8), Vector3.new(15, 0.38, 75), "Institutional white", Enum.Material.Cobblestone, cityFolder)

-- Street lamps along main roads
local streetLampPositions = {
	-- Main road lamps
	{-8, 0, 65}, {8, 0, 65}, {-8, 0, 85}, {8, 0, 85}, {-8, 0, 95}, {8, 0, 95},
	-- Cross road lamps
	{-25, 0, 48}, {25, 0, 48}, {-35, 0, 52}, {35, 0, 52},
	-- Quarter roads
	{-25, 0, 25}, {25, 0, 25}, {-45, 0, 75}, {15, 0, 67}
}
for _, pos in ipairs(streetLampPositions) do
	makeLantern(Vector3.new(pos[1], pos[2], pos[3]), cityFolder)
end

-- ============================================================
-- === GRAND TOWN SQUARE (center) ===
-- ============================================================

-- Magnificent Grand Fountain (multi-tiered)
-- Base platform
makePart("FountainPlatform", Vector3.new(20, 1, 20), Vector3.new(0, 0.5, 50), "Medium stone grey", Enum.Material.Marble, cityFolder)
-- Lower tier
makePart("FountainBaseLower", Vector3.new(16, 3, 16), Vector3.new(0, 2.5, 50), "Medium stone grey", Enum.Material.Marble, cityFolder)
makePart("FountainWaterLower", Vector3.new(14, 0.5, 14), Vector3.new(0, 3.75, 50), Color3.fromRGB(65, 130, 175), Enum.Material.Water, cityFolder, {Transparency = 0.3})
-- Middle tier
makePart("FountainBaseMiddle", Vector3.new(10, 3, 10), Vector3.new(0, 5.5, 50), "Medium stone grey", Enum.Material.Marble, cityFolder)
makePart("FountainWaterMiddle", Vector3.new(8, 0.5, 8), Vector3.new(0, 6.75, 50), Color3.fromRGB(65, 130, 175), Enum.Material.Water, cityFolder, {Transparency = 0.3})
-- Central pillar and top
makePart("FountainPillar", Vector3.new(3, 6, 3), Vector3.new(0, 10, 50), "Medium stone grey", Enum.Material.Marble, cityFolder)
makePart("FountainTop", Vector3.new(6, 1.5, 6), Vector3.new(0, 13.75, 50), "Medium stone grey", Enum.Material.Marble, cityFolder)
makePart("FountainTopWater", Vector3.new(4, 0.4, 4), Vector3.new(0, 14.4, 50), Color3.fromRGB(65, 130, 175), Enum.Material.Water, cityFolder, {Transparency = 0.3})

-- Decorative lion heads (water spouts)
for i = 0, 3 do
	local angle = math.rad(i * 90)
	local x = 6 * math.sin(angle)
	local z = 6 * math.cos(angle)
	makePart("LionHead" .. i, Vector3.new(2, 1.5, 1), Vector3.new(x, 5.5, 50 + z), "Dark stone grey", Enum.Material.Marble, cityFolder)
end

-- Ornate fountain sign
local squareSign = makePart("SquareSign", Vector3.new(1, 1, 1), Vector3.new(0, 16, 50), "White", nil, cityFolder, {Transparency = 1})
makeSign(squareSign, "â›² HAVEN TOWN SQUARE", Vector3.new(0, 0, 0), UDim2.new(12, 0, 3, 0))

-- Enhanced seating area with decorative benches
local benchPositions = {
	{-14, 0.75, 50, 90}, {14, 0.75, 50, 90}, {0, 0.75, 36, 0}, {0, 0.75, 64, 0},
	{-10, 0.75, 40, 45}, {10, 0.75, 40, -45}, {-10, 0.75, 60, -45}, {10, 0.75, 60, 45}
}
for i, pos in ipairs(benchPositions) do
	local bench = makePart("Bench" .. i, Vector3.new(5, 1.5, 1.8), Vector3.new(pos[1], pos[2], pos[3]), "Reddish brown", Enum.Material.Wood, cityFolder)
	if pos[4] then
		bench.Orientation = Vector3.new(0, pos[4], 0)
	end
	-- Bench backs
	makePart("BenchBack" .. i, Vector3.new(5, 2, 0.3), Vector3.new(pos[1], pos[2] + 1.65, pos[3] + (pos[4] == 0 and 0.9 or 0)), "Reddish brown", Enum.Material.Wood, cityFolder)
end

-- Decorative planters with flowers
local planterPositions = {
	{-18, 35}, {18, 35}, {-18, 65}, {18, 65}
}
for i, pos in ipairs(planterPositions) do
	makePart("Planter" .. i, Vector3.new(3, 2, 3), Vector3.new(pos[1], 1, pos[2]), "Brown", Enum.Material.Wood, cityFolder)
	makePart("Soil" .. i, Vector3.new(2.8, 0.3, 2.8), Vector3.new(pos[1], 2.1, pos[2]), "Brown", Enum.Material.Ground, cityFolder)
	-- Flowers in planters
	for j = 1, 4 do
		local fx = pos[1] + math.random(-1, 1)
		local fz = pos[2] + math.random(-1, 1)
		local colors = {"Bright red", "Bright yellow", "Bright violet", "Hot pink"}
		makePart("PlanterFlower" .. i .. j, Vector3.new(0.4, 1, 0.4), Vector3.new(fx, 2.8, fz), colors[j], Enum.Material.SmoothPlastic, cityFolder, {CanCollide = false})
	end
end

-- Grand square lighting
local squareLanterns = {
	{-15, 0, 42}, {15, 0, 42}, {-15, 0, 58}, {15, 0, 58},
	{-20, 0, 50}, {20, 0, 50}, {0, 0, 32}, {0, 0, 68}
}
for _, pos in ipairs(squareLanterns) do
	makeLantern(Vector3.new(pos[1], pos[2], pos[3]), cityFolder)
end

-- Decorative statues around the square
makePart("StatueNorth", Vector3.new(2, 6, 2), Vector3.new(0, 3, 35), "Medium stone grey", Enum.Material.Marble, cityFolder)
makePart("StatueNorthBase", Vector3.new(3, 1, 3), Vector3.new(0, 0.5, 35), "Medium stone grey", Enum.Material.Marble, cityFolder)
makeSign(makePart("StatueNorthSign", Vector3.new(1, 1, 1), Vector3.new(0, 7, 35), "White", nil, cityFolder, {Transparency = 1}), "âš”ï¸ HERO'S MEMORIAL", Vector3.new(0, 0, 0))

-- Town square decorative barrels and crates (medieval atmosphere)
local decorPositions = {
	{-25, 25}, {25, 25}, {-25, 75}, {25, 75}
}
for i, pos in ipairs(decorPositions) do
	-- Barrel clusters
	makePart("DecorBarrel" .. i .. "A", Vector3.new(2, 3, 2), Vector3.new(pos[1], 1.5, pos[2]), "Reddish brown", Enum.Material.Wood, cityFolder)
	makePart("DecorBarrel" .. i .. "B", Vector3.new(2, 3, 2), Vector3.new(pos[1] + 2, 1.5, pos[2] + 1), "Reddish brown", Enum.Material.Wood, cityFolder)
	-- Wooden crates
	makePart("DecorCrate" .. i, Vector3.new(2.5, 2.5, 2.5), Vector3.new(pos[1] - 2, 1.25, pos[2] - 1), "Brown", Enum.Material.Wood, cityFolder)
end

-- ============================================================
-- === BANK OF HAVEN (GRAND FINANCIAL INSTITUTION) ===
-- ============================================================
local bankBuilding = getOrMake(cityFolder, "BankBuilding")
-- Enhanced foundation with steps
makePart("BankFoundation", Vector3.new(24, 1.5, 20), Vector3.new(35, 0.75, 50), "Dark stone grey", Enum.Material.Cobblestone, bankBuilding)
makePart("BankSteps", Vector3.new(8, 0.5, 3), Vector3.new(35, 1.25, 59), "Medium stone grey", Enum.Material.Marble, bankBuilding)
-- Quality floor
makePart("BankFloor", Vector3.new(22, 0.5, 18), Vector3.new(35, 1.75, 50), "Reddish brown", Enum.Material.WoodPlanks, bankBuilding)

-- Enhanced walls with architectural details
makePart("BankWallBack", Vector3.new(22, 14, 2), Vector3.new(35, 8.5, 41), "Brick yellow", Enum.Material.Brick, bankBuilding)
makePart("BankWallLeft", Vector3.new(2, 14, 18), Vector3.new(24, 8.5, 50), "Brick yellow", Enum.Material.Brick, bankBuilding)
makePart("BankWallRight", Vector3.new(2, 14, 18), Vector3.new(46, 8.5, 50), "Brick yellow", Enum.Material.Brick, bankBuilding)
-- Front wall with grand entrance
makePart("BankFrontL", Vector3.new(8, 14, 2), Vector3.new(27, 8.5, 59), "Brick yellow", Enum.Material.Brick, bankBuilding)
makePart("BankFrontR", Vector3.new(8, 14, 2), Vector3.new(43, 8.5, 59), "Brick yellow", Enum.Material.Brick, bankBuilding)
makePart("BankEntryArch", Vector3.new(8, 6, 2), Vector3.new(35, 13, 59), "Brick yellow", Enum.Material.Brick, bankBuilding, {CanCollide = false})

-- Bank entrance â€” open doorway, no door

-- Windows with frames
local bankWindowPos = {
	{30, 7, 41}, {40, 7, 41}, -- Back wall windows
	{24, 7, 45}, {24, 7, 55}, -- Left wall windows  
	{46, 7, 45}, {46, 7, 55}, -- Right wall windows
	{30, 11, 59}, {40, 11, 59} -- Upper front windows
}
for i, pos in ipairs(bankWindowPos) do
	makePart("BankWindow" .. i, Vector3.new(2.5, 3, 0.3), Vector3.new(pos[1], pos[2], pos[3]), "Light blue", Enum.Material.Glass, bankBuilding, {Transparency = 0.3})
	makePart("BankWindowFrame" .. i, Vector3.new(3, 3.5, 0.5), Vector3.new(pos[1], pos[2], pos[3]), "Dark stone grey", Enum.Material.Marble, bankBuilding)
end

-- Peaked roof system
makeWedge("BankRoofNorth", Vector3.new(22, 8, 12), Vector3.new(35, 19, 45), "Dark red", Enum.Material.Slate, bankBuilding)
makeWedge("BankRoofSouth", Vector3.new(22, 8, 12), Vector3.new(35, 19, 55), "Dark red", Enum.Material.Slate, bankBuilding, {Orientation = Vector3.new(0, 180, 0)})
-- Ridge line
makePart("BankRoofRidge", Vector3.new(24, 0.5, 1), Vector3.new(35, 23, 50), "Dark stone grey", Enum.Material.Slate, bankBuilding)
-- Chimney
makePart("BankChimney", Vector3.new(2, 6, 2), Vector3.new(32, 26, 47), "Dark stone grey", Enum.Material.Cobblestone, bankBuilding)

-- Gold trim and decorative elements
makePart("BankGoldTrimFront", Vector3.new(24, 1, 1), Vector3.new(35, 15, 60), "Bright yellow", Enum.Material.Metal, bankBuilding)
makePart("BankGoldTrimSides", Vector3.new(1, 1, 20), Vector3.new(24, 15, 50), "Bright yellow", Enum.Material.Metal, bankBuilding)
makePart("BankGoldTrimSides2", Vector3.new(1, 1, 20), Vector3.new(46, 15, 50), "Bright yellow", Enum.Material.Metal, bankBuilding)

-- Interior furnishings
makePart("BankCounter", Vector3.new(14, 4, 3), Vector3.new(35, 3.5, 47), "Reddish brown", Enum.Material.WoodPlanks, bankBuilding)
makePart("CounterTop", Vector3.new(14, 0.5, 3), Vector3.new(35, 5.5, 47), "Dark stone grey", Enum.Material.Marble, bankBuilding)
-- Teller windows
makePart("TellerWindow1", Vector3.new(3, 2, 0.2), Vector3.new(31, 4.5, 49), "Light blue", Enum.Material.Glass, bankBuilding, {Transparency = 0.2})
makePart("TellerWindow2", Vector3.new(3, 2, 0.2), Vector3.new(35, 4.5, 49), "Light blue", Enum.Material.Glass, bankBuilding, {Transparency = 0.2})
makePart("TellerWindow3", Vector3.new(3, 2, 0.2), Vector3.new(39, 4.5, 49), "Light blue", Enum.Material.Glass, bankBuilding, {Transparency = 0.2})

-- Gold vault door (decorative)
makePart("VaultDoor", Vector3.new(4, 8, 1), Vector3.new(35, 5.5, 42), "Bright yellow", Enum.Material.Metal, bankBuilding)
makePart("VaultHandle", Vector3.new(1.5, 1.5, 0.5), Vector3.new(37, 5.5, 42.5), "Dark stone grey", Enum.Material.Metal, bankBuilding)

-- Display gold (secure behind glass)
makePart("GoldDisplay", Vector3.new(8, 0.3, 2), Vector3.new(35, 3.8, 48), "Bright yellow", Enum.Material.Metal, bankBuilding)
for i = 1, 6 do
	makePart("GoldBar" .. i, Vector3.new(1.2, 0.6, 0.8), Vector3.new(32 + i, 4.2, 48), "Bright yellow", Enum.Material.Metal, bankBuilding)
end

-- Grand bank signage
local bankSign = makePart("BankSign", Vector3.new(1, 1, 1), Vector3.new(35, 18, 60), "White", nil, bankBuilding, {Transparency = 1})
makeSign(bankSign, "ðŸ¦ FIRST BANK OF HAVEN", Vector3.new(0, 0, 0), UDim2.new(12, 0, 3, 0))

-- Enhanced lighting
makeLantern(Vector3.new(26, 0, 58), bankBuilding)
makeLantern(Vector3.new(44, 0, 58), bankBuilding)
makeLantern(Vector3.new(35, 0, 62), bankBuilding)

-- ============================================================
-- === GENERAL STORE (MERCHANT ESTABLISHMENT) ===
-- ============================================================
local shopBuilding = getOrMake(cityFolder, "ShopBuilding")
-- Enhanced foundation and steps
makePart("ShopFoundation", Vector3.new(20, 1.5, 16), Vector3.new(-35, 0.75, 50), "Dark stone grey", Enum.Material.Cobblestone, shopBuilding)
makePart("ShopSteps", Vector3.new(6, 0.4, 2), Vector3.new(-35, 1.4, 57), "Medium stone grey", Enum.Material.Cobblestone, shopBuilding)
makePart("ShopFloor", Vector3.new(18, 0.5, 14), Vector3.new(-35, 1.75, 50), "Reddish brown", Enum.Material.WoodPlanks, shopBuilding)

-- Tudor-style walls (half-timbered look)
makePart("ShopWallBack", Vector3.new(18, 12, 2), Vector3.new(-35, 7.5, 43), "Brick yellow", Enum.Material.Brick, shopBuilding)
makePart("ShopWallLeft", Vector3.new(2, 12, 14), Vector3.new(-44, 7.5, 50), "Brick yellow", Enum.Material.Brick, shopBuilding)
makePart("ShopWallRight", Vector3.new(2, 12, 14), Vector3.new(-26, 7.5, 50), "Brick yellow", Enum.Material.Brick, shopBuilding)
-- Front wall with shop window
makePart("ShopFrontL", Vector3.new(6, 12, 2), Vector3.new(-41, 7.5, 57), "Brick yellow", Enum.Material.Brick, shopBuilding)
makePart("ShopFrontR", Vector3.new(6, 12, 2), Vector3.new(-29, 7.5, 57), "Brick yellow", Enum.Material.Brick, shopBuilding)
makePart("ShopFrontTop", Vector3.new(8, 4, 2), Vector3.new(-35, 11.5, 57), "Brick yellow", Enum.Material.Brick, shopBuilding)

-- Tudor timber framing (dark wooden beams)
makePart("TimberFrameV1", Vector3.new(0.5, 12, 0.8), Vector3.new(-38, 7.5, 57.6), "Dark stone grey", Enum.Material.Wood, shopBuilding)
makePart("TimberFrameV2", Vector3.new(0.5, 12, 0.8), Vector3.new(-32, 7.5, 57.6), "Dark stone grey", Enum.Material.Wood, shopBuilding)
makePart("TimberFrameH1", Vector3.new(8, 0.5, 0.8), Vector3.new(-35, 9, 57.6), "Dark stone grey", Enum.Material.Wood, shopBuilding)
makePart("TimberFrameH2", Vector3.new(8, 0.5, 0.8), Vector3.new(-35, 6, 57.6), "Dark stone grey", Enum.Material.Wood, shopBuilding)

-- Shop entrance door (CanCollide false for entry)
makePart("ShopDoor", Vector3.new(4, 8, 0.5), Vector3.new(-35, 5.5, 57.5), "Brown", Enum.Material.Wood, shopBuilding, {CanCollide = false, Transparency = 0.15})
makePart("DoorHandle", Vector3.new(0.3, 0.8, 0.3), Vector3.new(-33, 5.5, 57.8), "Black", Enum.Material.Metal, shopBuilding, {CanCollide = false})

-- Large shop windows
makePart("ShopWindow", Vector3.new(6, 4, 0.3), Vector3.new(-35, 10, 57.3), "Light blue", Enum.Material.Glass, shopBuilding, {Transparency = 0.2})
makePart("WindowFrame", Vector3.new(6.5, 4.5, 0.5), Vector3.new(-35, 10, 57.2), "Dark stone grey", Enum.Material.Wood, shopBuilding)
-- Window cross-frames
makePart("WindowCrossH", Vector3.new(6, 0.3, 0.2), Vector3.new(-35, 10, 57.4), "Dark stone grey", Enum.Material.Wood, shopBuilding)
makePart("WindowCrossV", Vector3.new(0.3, 4, 0.2), Vector3.new(-35, 10, 57.4), "Dark stone grey", Enum.Material.Wood, shopBuilding)

-- Side windows
makePart("SideWindow1", Vector3.new(0.3, 3, 2.5), Vector3.new(-44.2, 8, 48), "Light blue", Enum.Material.Glass, shopBuilding, {Transparency = 0.2})
makePart("SideWindow2", Vector3.new(0.3, 3, 2.5), Vector3.new(-25.8, 8, 52), "Light blue", Enum.Material.Glass, shopBuilding, {Transparency = 0.2})

-- Steep peaked roof (medieval style)
makeWedge("ShopRoofNorth", Vector3.new(18, 6, 8), Vector3.new(-35, 16, 47), "Dark red", Enum.Material.Slate, shopBuilding)
makeWedge("ShopRoofSouth", Vector3.new(18, 6, 8), Vector3.new(-35, 16, 53), "Dark red", Enum.Material.Slate, shopBuilding, {Orientation = Vector3.new(0, 180, 0)})
makePart("ShopRoofRidge", Vector3.new(20, 0.5, 0.8), Vector3.new(-35, 19, 50), "Dark stone grey", Enum.Material.Slate, shopBuilding)

-- Enhanced storefront awning
makePart("ShopAwning", Vector3.new(12, 0.5, 5), Vector3.new(-35, 9.5, 59), "Bright red", Enum.Material.Fabric, shopBuilding)
makePart("AwningSupport1", Vector3.new(0.5, 2, 0.5), Vector3.new(-41, 8, 61), "Reddish brown", Enum.Material.Wood, shopBuilding)
makePart("AwningSupport2", Vector3.new(0.5, 2, 0.5), Vector3.new(-29, 8, 61), "Reddish brown", Enum.Material.Wood, shopBuilding)

-- Outdoor market display
makePart("DisplayShelf1", Vector3.new(4, 4, 1.5), Vector3.new(-30, 2.5, 59), "Reddish brown", Enum.Material.Wood, shopBuilding)
makePart("DisplayShelf2", Vector3.new(4, 4, 1.5), Vector3.new(-40, 2.5, 59), "Reddish brown", Enum.Material.Wood, shopBuilding)
-- Goods on display
makePart("DisplayBread1", Vector3.new(1, 0.5, 0.8), Vector3.new(-29, 4.5, 59), "Nougat", Enum.Material.SmoothPlastic, shopBuilding)
makePart("DisplayBread2", Vector3.new(1, 0.5, 0.8), Vector3.new(-31, 4.5, 59), "Nougat", Enum.Material.SmoothPlastic, shopBuilding)
makePart("DisplayApples", Vector3.new(1.5, 1, 1), Vector3.new(-39, 4.8, 59), "Bright red", Enum.Material.SmoothPlastic, shopBuilding)
makePart("DisplayCarrots", Vector3.new(0.8, 1.2, 0.8), Vector3.new(-41, 4.8, 59), "Bright orange", Enum.Material.SmoothPlastic, shopBuilding)

-- Storage barrels and crates (more extensive)
local storageItems = {
	{-45, 1.5, 52, "Barrel", Vector3.new(2, 3, 2), "Reddish brown"},
	{-45, 1.5, 54, "Barrel", Vector3.new(2, 3, 2), "Reddish brown"}, 
	{-45, 4.3, 53, "Barrel", Vector3.new(2, 3, 2), "Reddish brown"},
	{-45, 1.25, 49, "Crate", Vector3.new(2.5, 2.5, 2.5), "Brown"},
	{-45, 1.25, 46, "Crate", Vector3.new(2.5, 2.5, 2.5), "Brown"},
	{-25, 1.5, 55, "Sack", Vector3.new(1.5, 2.5, 1.5), "Dusty Rose"},
	{-25, 1.5, 53, "Sack", Vector3.new(1.5, 2.5, 1.5), "Dusty Rose"},
}
for i, item in ipairs(storageItems) do
	makePart("Storage" .. i, item[5], Vector3.new(item[1], item[2], item[3]), item[6], Enum.Material.Wood, shopBuilding)
end

-- Shop sign (hanging style)
makePart("SignPost", Vector3.new(0.5, 4, 0.5), Vector3.new(-32, 11, 60), "Reddish brown", Enum.Material.Wood, shopBuilding)
makePart("SignBoard", Vector3.new(6, 3, 0.3), Vector3.new(-28, 12, 60), "Brown", Enum.Material.Wood, shopBuilding)
local shopSign = makePart("ShopSign", Vector3.new(1, 1, 1), Vector3.new(-28, 12, 60), "White", nil, shopBuilding, {Transparency = 1})
makeSign(shopSign, "ðŸª HAVEN GENERAL STORE", Vector3.new(0, 0, 0), UDim2.new(10, 0, 3, 0))

-- Enhanced lighting
makeLantern(Vector3.new(-27, 0, 60), shopBuilding)
makeLantern(Vector3.new(-43, 0, 60), shopBuilding)

-- ============================================================
-- === SMITHY & KITCHEN (northwest area) ===
-- ============================================================
local smithy = getOrMake(cityFolder, "Smithy")
makePart("SmithyFoundation", Vector3.new(20, 1, 16), Vector3.new(-35, 0.5, 20), "Dark stone grey", Enum.Material.Cobblestone, smithy)
makePart("SmithyFloor", Vector3.new(18, 0.3, 14), Vector3.new(-35, 1.15, 20), "Dark stone grey", Enum.Material.Slate, smithy)
-- Walls (open front for smoke/heat)
makePart("SmithyWallBack", Vector3.new(18, 10, 1), Vector3.new(-35, 6, 13), "Dark stone grey", Enum.Material.Cobblestone, smithy)
makePart("SmithyWallLeft", Vector3.new(1, 10, 14), Vector3.new(-44, 6, 20), "Dark stone grey", Enum.Material.Cobblestone, smithy)
makePart("SmithyWallRight", Vector3.new(1, 10, 8), Vector3.new(-26, 6, 17), "Dark stone grey", Enum.Material.Cobblestone, smithy)
makePart("SmithyRoof", Vector3.new(22, 1, 18), Vector3.new(-35, 11.5, 20), "Dark stone grey", Enum.Material.Slate, smithy)
-- Chimney
makePart("Chimney", Vector3.new(4, 8, 4), Vector3.new(-40, 16, 15), "Dark stone grey", Enum.Material.Cobblestone, smithy)
makePart("ChimneySmoke", Vector3.new(2, 2, 2), Vector3.new(-40, 21, 15), "Medium stone grey", Enum.Material.SmoothPlastic, smithy, {Transparency = 0.6})
-- Forge (big glowing furnace)
makePart("ForgeBase", Vector3.new(5, 3, 4), Vector3.new(-40, 2.5, 15), "Dark stone grey", Enum.Material.Cobblestone, smithy)
makePart("ForgeFire", Vector3.new(3, 2, 2), Vector3.new(-40, 2, 15), "Bright red", Enum.Material.Neon, smithy, {Transparency = 0.2})
local forgeLight = Instance.new("PointLight")
forgeLight.Color = Color3.fromRGB(255, 100, 30)
forgeLight.Brightness = 0.8
forgeLight.Range = 20
forgeLight.Parent = smithy:FindFirstChild("ForgeFire")
-- Anvil
makePart("Anvil", Vector3.new(2, 1.5, 3), Vector3.new(-35, 1.75, 18), "Black", Enum.Material.Metal, smithy)
makePart("AnvilHorn", Vector3.new(1, 0.5, 1), Vector3.new(-35, 2.75, 16.5), "Black", Enum.Material.Metal, smithy)
-- Weapon rack
makePart("WeaponRack", Vector3.new(0.5, 6, 4), Vector3.new(-43.5, 4, 18), "Reddish brown", Enum.Material.Wood, smithy)
makePart("RackSword1", Vector3.new(0.3, 4, 0.3), Vector3.new(-43.5, 4.5, 19.5), "Medium stone grey", Enum.Material.Metal, smithy)
makePart("RackSword2", Vector3.new(0.3, 3.5, 0.3), Vector3.new(-43.5, 4.5, 17.5), "Medium stone grey", Enum.Material.Metal, smithy)
-- Cooking range (next to smithy)
makePart("CookingRange", Vector3.new(4, 2, 4), Vector3.new(-30, 2, 18), "Bright orange", Enum.Material.Neon, smithy, {Transparency = 0.3})
makePart("CookingPot", Vector3.new(2, 1.5, 2), Vector3.new(-30, 3.5, 18), "Dark stone grey", Enum.Material.Metal, smithy)
local smithySign = makePart("SmithySign", Vector3.new(1, 1, 1), Vector3.new(-35, 13, 27), "White", nil, smithy, {Transparency = 1})
makeSign(smithySign, "ðŸ”¨ Smithy & Kitchen", Vector3.new(0, 0, 0))

-- === INTERACTIVE STATIONS FOR COOKING & SMITHING ===
-- Create stations folders for the cooking and smithing systems
local stationsFolder = Instance.new("Folder")
stationsFolder.Name = "SmithingStations"
stationsFolder.Parent = workspace

local cookingFolder = Instance.new("Folder")
cookingFolder.Name = "CookingFires"
cookingFolder.Parent = workspace

-- Smithing Furnace (interactive - reuse existing forge position)
local furnace = makePart("SmithingFurnace", Vector3.new(5, 3, 4), Vector3.new(-40, 2.5, 15), "Dark stone grey", Enum.Material.Cobblestone, stationsFolder)
furnace.Name = "SmithingFurnace"

-- Smithing Anvil (interactive - reuse existing anvil position) 
local anvil = makePart("SmithingAnvil", Vector3.new(2, 1.5, 3), Vector3.new(-35, 1.75, 18), "Black", Enum.Material.Metal, stationsFolder)
anvil.Name = "SmithingAnvil"

-- Cooking Fire (interactive - reuse existing cooking range position)
local cookingFire = makePart("CookingFire", Vector3.new(4, 2, 4), Vector3.new(-30, 2, 18), "Bright orange", Enum.Material.Neon, cookingFolder, {Transparency = 0.3})
cookingFire.Name = "CookingFire"

-- Additional cooking fire near Old Bess (tavern area)
local tavernFire = makePart("TavernCookingFire", Vector3.new(3, 1.5, 3), Vector3.new(10, 1.75, 35), "Bright orange", Enum.Material.Neon, cookingFolder, {Transparency = 0.3})
tavernFire.Name = "TavernCookingFire"

-- Cooking fire near the marketplace for easy access
local marketFire = makePart("MarketCookingFire", Vector3.new(2.5, 1.5, 2.5), Vector3.new(25, 1.75, 10), "Bright orange", Enum.Material.Neon, cookingFolder, {Transparency = 0.3})
marketFire.Name = "MarketCookingFire"

-- === FLETCHING STATION ===
local fletchFolder = Instance.new("Folder")
fletchFolder.Name = "FletchingStations"
fletchFolder.Parent = workspace

local fletchBench = makePart("FletchingBench", Vector3.new(4, 2, 3), Vector3.new(-25, 2, 18), "Reddish brown", Enum.Material.Wood, fletchFolder)
fletchBench.Name = "FletchingBench"

-- ============================================================
-- === CATHEDRAL OF LIGHT (GRAND PRAYER TEMPLE) ===
-- ============================================================
local church = getOrMake(cityFolder, "Church")
-- Grand foundation with steps
makePart("ChurchFoundation", Vector3.new(20, 2, 26), Vector3.new(35, 1, 25), "White", Enum.Material.Marble, church)
makePart("ChurchSteps", Vector3.new(12, 0.8, 4), Vector3.new(35, 1.9, 37), "White", Enum.Material.Marble, church)
makePart("ChurchUpperSteps", Vector3.new(8, 0.6, 2), Vector3.new(35, 2.8, 38.5), "White", Enum.Material.Marble, church)
makePart("ChurchFloor", Vector3.new(18, 0.5, 24), Vector3.new(35, 2.75, 25), "White", Enum.Material.Marble, church)

-- Gothic architecture walls
makePart("ChurchWallBack", Vector3.new(18, 16, 2), Vector3.new(35, 10, 13), "White", Enum.Material.Brick, church)
makePart("ChurchWallLeft", Vector3.new(2, 16, 24), Vector3.new(26, 10, 25), "White", Enum.Material.Brick, church)
makePart("ChurchWallRight", Vector3.new(2, 16, 24), Vector3.new(44, 10, 25), "White", Enum.Material.Brick, church)
-- Front wall with grand entrance
makePart("ChurchFrontL", Vector3.new(6, 16, 2), Vector3.new(29, 10, 37), "White", Enum.Material.Brick, church)
makePart("ChurchFrontR", Vector3.new(6, 16, 2), Vector3.new(41, 10, 37), "White", Enum.Material.Brick, church)
makePart("ChurchEntryArch", Vector3.new(8, 8, 2), Vector3.new(35, 15, 37), "White", Enum.Material.Brick, church)

-- Grand entrance doors (CanCollide false for entry)
makePart("ChurchDoors", Vector3.new(6, 12, 0.5), Vector3.new(35, 8, 37.5), "Reddish brown", Enum.Material.Wood, church, {CanCollide = false, Transparency = 0.15})
makePart("DoorFrameArch", Vector3.new(8, 14, 1), Vector3.new(35, 9, 37.3), "Dark stone grey", Enum.Material.Marble, church, {CanCollide = false})
-- Door handles
makePart("DoorHandleL", Vector3.new(0.3, 1.2, 0.3), Vector3.new(32, 8, 37.8), "Bright yellow", Enum.Material.Metal, church, {CanCollide = false})
makePart("DoorHandleR", Vector3.new(0.3, 1.2, 0.3), Vector3.new(38, 8, 37.8), "Bright yellow", Enum.Material.Metal, church, {CanCollide = false})

-- Magnificent stained glass windows (larger and more elaborate)
local stainedGlassData = {
	{26, 11, 18, "Bright blue", "âœï¸"}, {44, 11, 18, "Bright violet", "ðŸ•Šï¸"},
	{26, 11, 22, "Bright green", "ðŸŒŸ"}, {44, 11, 22, "Bright red", "â¤ï¸"},
	{26, 11, 28, "Bright yellow", "â­"}, {44, 11, 28, "Hot pink", "ðŸŒ¸"},
	{26, 11, 32, "Bright orange", "ðŸ”¥"}, {44, 11, 32, "Bright cyan", "ðŸ’§"}
}
for i, glass in ipairs(stainedGlassData) do
	-- Window frame
	makePart("WindowFrame" .. i, Vector3.new(0.8, 7, 4), Vector3.new(glass[1], glass[2], glass[3]), "Dark stone grey", Enum.Material.Marble, church)
	-- Colored glass
	makePart("StainedGlass" .. i, Vector3.new(0.4, 6, 3), Vector3.new(glass[1], glass[2], glass[3]), glass[4], Enum.Material.Neon, church, {Transparency = 0.3})
	-- Symbol on glass
	local glassSign = makePart("GlassSymbol" .. i, Vector3.new(1, 1, 1), Vector3.new(glass[1], glass[2], glass[3]), "White", nil, church, {Transparency = 1})
	makeSign(glassSign, glass[5], Vector3.new(0, 0, 0), UDim2.new(4, 0, 4, 0))
end

-- Rose window (circular stained glass above entrance)
makePart("RoseWindowFrame", Vector3.new(0.8, 6, 6), Vector3.new(35, 16, 37), "Dark stone grey", Enum.Material.Marble, church)
makePart("RoseWindow", Vector3.new(0.4, 5, 5), Vector3.new(35, 16, 37), "Bright violet", Enum.Material.Neon, church, {Transparency = 0.2})

-- Flying buttresses (Gothic support structures)
makePart("Buttress1", Vector3.new(2, 12, 4), Vector3.new(23, 12, 18), "White", Enum.Material.Marble, church)
makePart("Buttress2", Vector3.new(2, 12, 4), Vector3.new(47, 12, 18), "White", Enum.Material.Marble, church)
makePart("Buttress3", Vector3.new(2, 12, 4), Vector3.new(23, 12, 32), "White", Enum.Material.Marble, church)
makePart("Buttress4", Vector3.new(2, 12, 4), Vector3.new(47, 12, 32), "White", Enum.Material.Marble, church)

-- Vaulted roof system
makeWedge("ChurchRoofNorth", Vector3.new(18, 8, 12), Vector3.new(35, 21, 19), "Dark stone grey", Enum.Material.Slate, church)
makeWedge("ChurchRoofSouth", Vector3.new(18, 8, 12), Vector3.new(35, 21, 31), "Dark stone grey", Enum.Material.Slate, church, {Orientation = Vector3.new(0, 180, 0)})
makePart("ChurchRoofRidge", Vector3.new(20, 1, 1), Vector3.new(35, 25, 25), "Dark stone grey", Enum.Material.Slate, church)

-- Twin bell towers (Gothic cathedral style)
makePart("BellTowerL", Vector3.new(6, 20, 6), Vector3.new(29, 20, 37), "White", Enum.Material.Brick, church)
makePart("BellTowerR", Vector3.new(6, 20, 6), Vector3.new(41, 20, 37), "White", Enum.Material.Brick, church)
-- Tower spires
makeWedge("SpireL", Vector3.new(6, 8, 6), Vector3.new(29, 34, 37), "Dark stone grey", Enum.Material.Slate, church)
makeWedge("SpireR", Vector3.new(6, 8, 6), Vector3.new(41, 34, 37), "Dark stone grey", Enum.Material.Slate, church)

-- Bell tower bells
makePart("BellL", Vector3.new(2, 3, 2), Vector3.new(29, 28, 37), "Dark stone grey", Enum.Material.Metal, church)
makePart("BellR", Vector3.new(2, 3, 2), Vector3.new(41, 28, 37), "Dark stone grey", Enum.Material.Metal, church)

-- Central steeple (tallest)
makePart("MainSteeple", Vector3.new(8, 16, 8), Vector3.new(35, 26, 13), "White", Enum.Material.Brick, church)
makeWedge("MainSpire", Vector3.new(8, 10, 8), Vector3.new(35, 39, 13), "Dark stone grey", Enum.Material.Slate, church)
-- Golden cross on main spire
makePart("CrossV", Vector3.new(0.8, 6, 0.8), Vector3.new(35, 47, 13), "Bright yellow", Enum.Material.Metal, church)
makePart("CrossH", Vector3.new(4, 0.8, 0.8), Vector3.new(35, 48, 13), "Bright yellow", Enum.Material.Metal, church)

-- Enhanced interior (prayer area)
-- Grand altar
makePart("AltarBase", Vector3.new(8, 2, 4), Vector3.new(35, 4, 14), "White", Enum.Material.Marble, church)
makePart("AltarTop", Vector3.new(8, 0.5, 4), Vector3.new(35, 5.25, 14), "Bright yellow", Enum.Material.Metal, church)
makePart("AltarCloth", Vector3.new(8.2, 0.1, 4.2), Vector3.new(35, 5.6, 14), "Bright violet", Enum.Material.Fabric, church)

-- Altar decorations
makePart("Chalice", Vector3.new(1, 1.5, 1), Vector3.new(35, 6.25, 14), "Bright yellow", Enum.Material.Metal, church)
makePart("Candle1", Vector3.new(0.3, 2, 0.3), Vector3.new(33, 6.5, 14), "White", Enum.Material.SmoothPlastic, church)
makePart("Candle2", Vector3.new(0.3, 2, 0.3), Vector3.new(37, 6.5, 14), "White", Enum.Material.SmoothPlastic, church)
makePart("Flame1", Vector3.new(0.5, 0.8, 0.5), Vector3.new(33, 7.9, 14), "Bright orange", Enum.Material.Neon, church, {Transparency = 0.5})
makePart("Flame2", Vector3.new(0.5, 0.8, 0.5), Vector3.new(37, 7.9, 14), "Bright orange", Enum.Material.Neon, church, {Transparency = 0.5})

-- Prayer pews (wooden benches in rows)
for row = 1, 6 do
	local z = 18 + row * 2.5
	-- Left side pews
	makePart("PewL" .. row, Vector3.new(6, 2.5, 2), Vector3.new(30, 4.25, z), "Reddish brown", Enum.Material.Wood, church)
	makePart("PewBackL" .. row, Vector3.new(6, 3, 0.3), Vector3.new(30, 5, z + 1), "Reddish brown", Enum.Material.Wood, church)
	-- Right side pews
	makePart("PewR" .. row, Vector3.new(6, 2.5, 2), Vector3.new(40, 4.25, z), "Reddish brown", Enum.Material.Wood, church)
	makePart("PewBackR" .. row, Vector3.new(6, 3, 0.3), Vector3.new(40, 5, z + 1), "Reddish brown", Enum.Material.Wood, church)
end

-- Prayer kneeling cushions
for i = 1, 12 do
	local x = 30 + (i % 2) * 10
	local z = 18 + math.floor((i-1) / 2) * 2.5 - 0.8
	makePart("Cushion" .. i, Vector3.new(5, 0.5, 1), Vector3.new(x, 3.25, z), "Bright violet", Enum.Material.Fabric, church)
end

-- Pulpit
makePart("PulpitBase", Vector3.new(3, 4, 3), Vector3.new(35, 5, 20), "White", Enum.Material.Marble, church)
makePart("PulpitTop", Vector3.new(4, 0.5, 4), Vector3.new(35, 7.25, 20), "Reddish brown", Enum.Material.Wood, church)
makePart("PulpitStairs", Vector3.new(2, 2, 1), Vector3.new(35, 4, 22), "White", Enum.Material.Marble, church)

-- Holy water fonts
makePart("FontL", Vector3.new(2, 3, 2), Vector3.new(28, 4.5, 35), "White", Enum.Material.Marble, church)
makePart("FontR", Vector3.new(2, 3, 2), Vector3.new(42, 4.5, 35), "White", Enum.Material.Marble, church)
makePart("HolyWaterL", Vector3.new(1.5, 0.3, 1.5), Vector3.new(28, 5.9, 35), Color3.fromRGB(65, 130, 175), Enum.Material.Water, church, {Transparency = 0.3})
makePart("HolyWaterR", Vector3.new(1.5, 0.3, 1.5), Vector3.new(42, 5.9, 35), Color3.fromRGB(65, 130, 175), Enum.Material.Water, church, {Transparency = 0.3})

-- Cathedral lighting (holy ambiance)
local churchLights = {
	{29, 0, 40}, {41, 0, 40}, {26, 0, 25}, {44, 0, 25}, {35, 0, 35}, {35, 0, 15}
}
for _, pos in ipairs(churchLights) do
	-- Holy braziers instead of lanterns
	makePart("HolyBrazier" .. _, Vector3.new(1.5, 3, 1.5), Vector3.new(pos[1], pos[2] + 3, pos[3]), "Dark stone grey", Enum.Material.Metal, church)
	makePart("HolyFlame" .. _, Vector3.new(2, 4, 2), Vector3.new(pos[1], pos[2] + 6, pos[3]), "Bright yellow", Enum.Material.Neon, church, {Transparency = 0.5})
	local holyLight = Instance.new("PointLight")
	holyLight.Color = Color3.fromRGB(255, 240, 200)
	holyLight.Brightness = 0.5
	holyLight.Range = 12
	holyLight.Parent = church:FindFirstChild("HolyFlame" .. _)
end

-- Grand cathedral sign
local churchSign = makePart("ChurchSign", Vector3.new(1, 1, 1), Vector3.new(35, 20, 40), "White", nil, church, {Transparency = 1})
makeSign(churchSign, "â›ª CATHEDRAL OF LIGHT\nðŸ™ HOUSE OF PRAYER", Vector3.new(0, 0, 0), UDim2.new(14, 0, 4, 0))

-- ============================================================
-- === TOWN DECORATIONS AND LANDSCAPING ===
-- ============================================================
local townDecor = getOrMake(cityFolder, "TownDecorations")

-- Trees and bushes around town perimeter (inside walls)
local function makeDecorativeTree(position, scale, leafColor)
	scale = scale or 1
	leafColor = leafColor or "Forest green"
	-- Tree trunk
	makePart("DecorTree", Vector3.new(2*scale, 8*scale, 2*scale), position + Vector3.new(0, 4*scale, 0), "Reddish brown", Enum.Material.Wood, townDecor)
	-- Tree foliage (fuller canopy)
	makePart("DecorLeaves", Vector3.new(8*scale, 8*scale, 8*scale), position + Vector3.new(0, 9*scale, 0), leafColor, Enum.Material.Grass, townDecor)
	-- Additional leaf layers for fullness
	makePart("DecorLeavesLower", Vector3.new(6*scale, 4*scale, 6*scale), position + Vector3.new(0, 6*scale, 0), leafColor, Enum.Material.Grass, townDecor)
	makePart("DecorLeavesUpper", Vector3.new(4*scale, 3*scale, 4*scale), position + Vector3.new(0, 12*scale, 0), leafColor, Enum.Material.Grass, townDecor)
end

-- Decorative trees OUTSIDE the city walls (walls at x=Â±62, z=-10 to z=108)
local perimeterTrees = {
	-- Outside north wall (z < -10)
	{-50, 0, -20}, {-30, 0, -22}, {30, 0, -20}, {50, 0, -22},
	-- Outside west wall (x < -62)
	{-72, 0, 10}, {-74, 0, 30}, {-70, 0, 50}, {-73, 0, 70}, {-71, 0, 90},
	-- Outside east wall (x > 62)
	{72, 0, 10}, {74, 0, 30}, {70, 0, 50}, {73, 0, 70}, {71, 0, 90},
	-- Outside south wall (z > 108)
	{-50, 0, 118}, {-25, 0, 120}, {25, 0, 118}, {50, 0, 120},
}

for i, pos in ipairs(perimeterTrees) do
	local scale = 0.8 + math.random() * 0.4
	local leafColors = {"Forest green", "Earth green", "Dark green"}
	makeDecorativeTree(Vector3.new(pos[1], pos[2], pos[3]), scale, leafColors[math.random(#leafColors)])
end

-- Small decorative bushes â€” only in open areas away from buildings
local bushPositions = {
	{-50, 0, 50}, {50, 0, 50}, -- along inner walls
}

for i, pos in ipairs(bushPositions) do
	makePart("Bush" .. i, Vector3.new(2, 1.5, 2), Vector3.new(pos[1], pos[2] + 0.75, pos[3]), "Forest green", Enum.Material.Grass, townDecor, {CanCollide = false})
end

-- (Gardens removed â€” too much visual clutter inside town)

-- Street decorations and furniture
local streetDecor = {
	-- Water troughs for horses
	{{-15, 1, 95}, "WaterTrough", Vector3.new(4, 2, 2), "Medium stone grey"},
	{{15, 1, 95}, "WaterTrough2", Vector3.new(4, 2, 2), "Medium stone grey"},
	-- Hitching posts
	{{-20, 2.5, 95}, "HitchPost", Vector3.new(0.5, 5, 0.5), "Reddish brown"},
	{{20, 2.5, 95}, "HitchPost2", Vector3.new(0.5, 5, 0.5), "Reddish brown"},
	-- Notice boards
	{{-5, 3, 95}, "NoticeBoard", Vector3.new(0.3, 4, 3), "Brown"},
	{{5, 3, 95}, "NoticeBoard2", Vector3.new(0.3, 4, 3), "Brown"},
	-- Town stocks (medieval punishment device)
	{{-40, 2, 90}, "Stocks", Vector3.new(4, 2, 1), "Reddish brown"},
	-- Wells in quarters
	{{-40, 2, 30}, "NorthWell", Vector3.new(3, 4, 3), "Medium stone grey"},
	{{40, 2, 30}, "NorthWellE", Vector3.new(3, 4, 3), "Medium stone grey"},
}

for i, item in ipairs(streetDecor) do
	makePart(item[2], item[3], Vector3.new(item[1][1], item[1][2], item[1][3]), item[4], Enum.Material.Wood, townDecor)
	-- Add water to troughs and wells
	if string.find(item[2], "Trough") or string.find(item[2], "Well") then
		makePart(item[2] .. "Water", Vector3.new(item[3].X - 0.2, 0.3, item[3].Z - 0.2), Vector3.new(item[1][1], item[1][2] + item[3].Y/2 - 0.2, item[1][3]), Color3.fromRGB(65, 130, 175), Enum.Material.Water, townDecor, {Transparency = 0.3})
	end
end

-- Decorative signposts throughout town
local signposts = {
	{-30, "ðŸ¦ BANK â†’", {30, 6, 50}},
	{30, "â† ðŸª SHOP", {-30, 6, 50}},
	{0, "â›ª CATHEDRAL â†‘", {35, 6, 40}},
	{-90, "ðŸ”¨ SMITHY â†–", {-25, 6, 30}},
	{45, "ðŸº TAVERN â†—", {-10, 6, 80}},
	{135, "ðŸª MARKET â†™", {-25, 6, 70}},
}

for i, sign in ipairs(signposts) do
	local post = makePart("Signpost" .. i, Vector3.new(0.5, 4, 0.5), Vector3.new(sign[3][1], sign[3][2] - 2, sign[3][3]), "Reddish brown", Enum.Material.Wood, townDecor)
	local board = makePart("SignBoard" .. i, Vector3.new(6, 1.5, 0.3), Vector3.new(sign[3][1], sign[3][2], sign[3][3]), "Brown", Enum.Material.Wood, townDecor)
	board.Orientation = Vector3.new(0, sign[1], 0)
	local signText = makePart("SignText" .. i, Vector3.new(1, 1, 1), Vector3.new(sign[3][1], sign[3][2], sign[3][3]), "White", nil, townDecor, {Transparency = 1})
	makeSign(signText, sign[2], Vector3.new(0, 0, 0), UDim2.new(8, 0, 2, 0))
end

-- Decorative crates, barrels, and clutter around town
local clutter = {
	-- Near shops
	{-50, 1.5, 45, "Barrel", Vector3.new(2, 3, 2), "Reddish brown"},
	{-52, 1.5, 47, "Barrel", Vector3.new(2, 3, 2), "Reddish brown"},
	{48, 1.25, 45, "Crate", Vector3.new(2.5, 2.5, 2.5), "Brown"},
	{50, 1.25, 47, "Crate", Vector3.new(2.5, 2.5, 2.5), "Brown"},
	-- Near tavern
	{-8, 1.5, 88, "AleBarel", Vector3.new(2, 3, 2), "Reddish brown"},
	{-6, 1.5, 88, "AleBarel2", Vector3.new(2, 3, 2), "Reddish brown"},
	-- Near smithy
	{-40, 1, 25, "CoalPile", Vector3.new(3, 1.5, 3), "Black"},
	{-38, 1, 27, "IronOre", Vector3.new(2, 2, 2), "Dark stone grey"},
	-- Random town clutter
	{10, 1, 90, "WoodenBox", Vector3.new(2, 2, 2), "Brown"},
	{-25, 1, 60, "Sack", Vector3.new(1.5, 2.5, 1.5), "Dusty Rose"},
	{25, 1, 40, "Chest", Vector3.new(3, 2, 2), "Reddish brown"},
}

for i, item in ipairs(clutter) do
	makePart("TownClutter" .. i, item[5], Vector3.new(item[1], item[2], item[3]), item[6], Enum.Material.Wood, townDecor)
end

-- (Flower patches removed â€” too much visual clutter)

-- Decorative stone paths connecting major areas
local pathSegments = {
	-- Path from fountain to bank
	{{10, 0.35, 50}, {15, 0.35, 50}, {20, 0.35, 50}, {25, 0.35, 50}},
	-- Path from fountain to shop  
	{{-10, 0.35, 50}, {-15, 0.35, 50}, {-20, 0.35, 50}, {-25, 0.35, 50}},
	-- Path from square to cathedral
	{{0, 0.35, 45}, {5, 0.35, 40}, {15, 0.35, 35}, {25, 0.35, 30}},
	-- Path from square to smithy
	{{0, 0.35, 45}, {-5, 0.35, 40}, {-15, 0.35, 35}, {-25, 0.35, 30}},
}

for i, path in ipairs(pathSegments) do
	for j, segment in ipairs(path) do
		makePart("DecorPath" .. i .. j, Vector3.new(4, 0.1, 4), Vector3.new(segment[1], 0.36, segment[3]), "Light stone grey", Enum.Material.Cobblestone, townDecor)
	end
end

-- ============================================================
-- === TAVERN (south-central, near gate) ===
-- ============================================================
local tavern = getOrMake(cityFolder, "Tavern")
makePart("TavernFoundation", Vector3.new(18, 1, 14), Vector3.new(-15, 0.5, 85), "Dark stone grey", Enum.Material.Cobblestone, tavern)
makePart("TavernFloor", Vector3.new(16, 0.3, 12), Vector3.new(-15, 1.15, 85), "Reddish brown", Enum.Material.WoodPlanks, tavern)
makePart("TavernWallBack", Vector3.new(16, 10, 1), Vector3.new(-15, 6, 79), "Brown", Enum.Material.Wood, tavern)
makePart("TavernWallLeft", Vector3.new(1, 10, 12), Vector3.new(-23, 6, 85), "Brown", Enum.Material.Wood, tavern)
makePart("TavernWallRight", Vector3.new(1, 10, 12), Vector3.new(-7, 6, 85), "Brown", Enum.Material.Wood, tavern)
makePart("TavernRoof", Vector3.new(20, 1, 16), Vector3.new(-15, 11.5, 85), "Reddish brown", Enum.Material.Wood, tavern)
-- Second floor
makePart("TavernFloor2", Vector3.new(16, 0.5, 12), Vector3.new(-15, 6, 85), "Reddish brown", Enum.Material.WoodPlanks, tavern, {Transparency = 0.1})
-- Bar counter
makePart("BarCounter", Vector3.new(10, 3, 2), Vector3.new(-15, 2.5, 81), "Reddish brown", Enum.Material.WoodPlanks, tavern)
-- Tables
makePart("Table1", Vector3.new(3, 2, 3), Vector3.new(-19, 2, 86), "Reddish brown", Enum.Material.Wood, tavern)
makePart("Table2", Vector3.new(3, 2, 3), Vector3.new(-11, 2, 86), "Reddish brown", Enum.Material.Wood, tavern)
-- Kegs behind bar
makePart("Keg1", Vector3.new(2, 3, 2), Vector3.new(-19, 1.5, 80), "Reddish brown", Enum.Material.Wood, tavern)
makePart("Keg2", Vector3.new(2, 3, 2), Vector3.new(-17, 1.5, 80), "Reddish brown", Enum.Material.Wood, tavern)
local tavernSign = makePart("TavernSign", Vector3.new(1, 1, 1), Vector3.new(-15, 13, 91), "White", nil, tavern, {Transparency = 1})
makeSign(tavernSign, "ðŸº The Rusty Blade Tavern", Vector3.new(0, 0, 0))
makeTorch(Vector3.new(-7, 3, 91), tavern)
makeTorch(Vector3.new(-23, 3, 91), tavern)

-- ============================================================
-- === GUARD TOWER (near gate, east side) ===
-- ============================================================
local guardTower = getOrMake(cityFolder, "GuardTower")
makePart("GTBase", Vector3.new(8, 20, 8), Vector3.new(15, 10, 85), "Medium stone grey", Enum.Material.Cobblestone, guardTower)
makePart("GTTop", Vector3.new(10, 1, 10), Vector3.new(15, 20.5, 85), "Dark stone grey", Enum.Material.Cobblestone, guardTower)
makePart("GTRail1", Vector3.new(10, 3, 0.5), Vector3.new(15, 22.5, 80), "Dark stone grey", Enum.Material.Cobblestone, guardTower)
makePart("GTRail2", Vector3.new(10, 3, 0.5), Vector3.new(15, 22.5, 90), "Dark stone grey", Enum.Material.Cobblestone, guardTower)
makePart("GTRail3", Vector3.new(0.5, 3, 10), Vector3.new(10, 22.5, 85), "Dark stone grey", Enum.Material.Cobblestone, guardTower)
makePart("GTRail4", Vector3.new(0.5, 3, 10), Vector3.new(20, 22.5, 85), "Dark stone grey", Enum.Material.Cobblestone, guardTower)
-- Ladder
makePart("Ladder", Vector3.new(0.5, 20, 2), Vector3.new(19, 10, 85), "Reddish brown", Enum.Material.Wood, guardTower)
local gtSign = makePart("GTSign", Vector3.new(1, 1, 1), Vector3.new(15, 25, 85), "White", nil, guardTower, {Transparency = 1})
makeSign(gtSign, "ðŸ›¡ï¸ Guard Tower", Vector3.new(0, 0, 0))

-- ============================================================
-- === HAVEN MARKETPLACE (BUSTLING MEDIEVAL MARKET) ===
-- ============================================================
local market = getOrMake(cityFolder, "Market")

-- Market square cobblestone foundation (slightly above city floor to avoid z-fighting)
makePart("MarketFloor", Vector3.new(60, 0.12, 40), Vector3.new(-35, 0.37, 75), "Medium stone grey", Enum.Material.Cobblestone, market)

-- Enhanced market stalls with detailed architecture
local stallData = {
	{-50, "Bright red", "ðŸž BAKER"}, {-40, "Bright blue", "ðŸŸ FISHMONGER"},
	{-30, "Bright green", "ðŸ¥• GROCER"}, {-20, "Bright yellow", "ðŸ§µ TAILOR"}
}
for i, stall in ipairs(stallData) do
	local xOff = stall[1]
	local color = stall[2]
	local sign = stall[3]
	
	-- Stall frame (more robust)
	makePart("Stall" .. i .. "PostFL", Vector3.new(0.8, 8, 0.8), Vector3.new(xOff - 4, 4, 72), "Reddish brown", Enum.Material.Wood, market)
	makePart("Stall" .. i .. "PostFR", Vector3.new(0.8, 8, 0.8), Vector3.new(xOff + 4, 4, 72), "Reddish brown", Enum.Material.Wood, market)
	makePart("Stall" .. i .. "PostBL", Vector3.new(0.8, 8, 0.8), Vector3.new(xOff - 4, 4, 78), "Reddish brown", Enum.Material.Wood, market)
	makePart("Stall" .. i .. "PostBR", Vector3.new(0.8, 8, 0.8), Vector3.new(xOff + 4, 4, 78), "Reddish brown", Enum.Material.Wood, market)
	
	-- Cross beams for structure
	makePart("Stall" .. i .. "BeamF", Vector3.new(8.5, 0.5, 0.5), Vector3.new(xOff, 7.5, 72), "Reddish brown", Enum.Material.Wood, market)
	makePart("Stall" .. i .. "BeamB", Vector3.new(8.5, 0.5, 0.5), Vector3.new(xOff, 7.5, 78), "Reddish brown", Enum.Material.Wood, market)
	makePart("Stall" .. i .. "BeamL", Vector3.new(0.5, 0.5, 6.5), Vector3.new(xOff - 4, 7.5, 75), "Reddish brown", Enum.Material.Wood, market)
	makePart("Stall" .. i .. "BeamR", Vector3.new(0.5, 0.5, 6.5), Vector3.new(xOff + 4, 7.5, 75), "Reddish brown", Enum.Material.Wood, market)
	
	-- Sloped roof awning
	makeWedge("Stall" .. i .. "RoofF", Vector3.new(9, 1.5, 3), Vector3.new(xOff, 8.75, 73.5), color, Enum.Material.Fabric, market)
	makeWedge("Stall" .. i .. "RoofB", Vector3.new(9, 1.5, 3), Vector3.new(xOff, 8.75, 76.5), color, Enum.Material.Fabric, market, {Orientation = Vector3.new(0, 180, 0)})
	
	-- Counter and shelving
	makePart("Stall" .. i .. "Counter", Vector3.new(8, 3.5, 2.5), Vector3.new(xOff, 2.25, 73), "Reddish brown", Enum.Material.WoodPlanks, market)
	makePart("Stall" .. i .. "BackShelf", Vector3.new(8, 4, 1), Vector3.new(xOff, 2.5, 77.5), "Reddish brown", Enum.Material.Wood, market)
	makePart("Stall" .. i .. "SideShelfL", Vector3.new(1, 4, 4), Vector3.new(xOff - 3.5, 2.5, 75), "Reddish brown", Enum.Material.Wood, market)
	makePart("Stall" .. i .. "SideShelfR", Vector3.new(1, 4, 4), Vector3.new(xOff + 3.5, 2.5, 75), "Reddish brown", Enum.Material.Wood, market)
	
	-- Stall-specific goods
	if i == 1 then -- Baker
		makePart("Bread1", Vector3.new(1.2, 0.6, 1), Vector3.new(xOff - 2, 4.3, 73), "Nougat", Enum.Material.SmoothPlastic, market)
		makePart("Bread2", Vector3.new(1, 0.5, 0.8), Vector3.new(xOff + 1, 4.3, 73), "Nougat", Enum.Material.SmoothPlastic, market)
		makePart("BreadBasket", Vector3.new(2, 1, 1.5), Vector3.new(xOff, 4.5, 77.5), "Brown", Enum.Material.Wood, market)
	elseif i == 2 then -- Fishmonger
		makePart("Fish1", Vector3.new(1.5, 0.3, 0.8), Vector3.new(xOff - 1, 4.3, 73), "Medium blue", Enum.Material.SmoothPlastic, market)
		makePart("Fish2", Vector3.new(1.2, 0.3, 0.6), Vector3.new(xOff + 2, 4.3, 73), "Medium blue", Enum.Material.SmoothPlastic, market)
		makePart("IceBox", Vector3.new(3, 2, 2), Vector3.new(xOff, 3, 77), "Light blue", Enum.Material.Ice, market)
	elseif i == 3 then -- Grocer
		makePart("Apples", Vector3.new(1.5, 1, 1.5), Vector3.new(xOff - 2, 4.8, 73), "Bright red", Enum.Material.SmoothPlastic, market)
		makePart("Carrots", Vector3.new(1, 1.5, 1), Vector3.new(xOff + 1, 4.8, 73), "Bright orange", Enum.Material.SmoothPlastic, market)
		makePart("Cabbage", Vector3.new(1.2, 1.2, 1.2), Vector3.new(xOff + 2, 4.8, 77.5), "Earth green", Enum.Material.SmoothPlastic, market)
	elseif i == 4 then -- Tailor
		makePart("Fabric1", Vector3.new(2, 0.3, 1.5), Vector3.new(xOff - 1.5, 4.3, 73), "Bright red", Enum.Material.Fabric, market)
		makePart("Fabric2", Vector3.new(2, 0.3, 1.5), Vector3.new(xOff + 1.5, 4.3, 73), "Bright blue", Enum.Material.Fabric, market)
		makePart("Thread", Vector3.new(0.8, 0.8, 0.8), Vector3.new(xOff, 4.6, 77.5), "Bright yellow", Enum.Material.SmoothPlastic, market)
	end
	
	-- Stall sign
	local stallSign = makePart("StallSign" .. i, Vector3.new(1, 1, 1), Vector3.new(xOff, 9.5, 75), "White", nil, market, {Transparency = 1})
	makeSign(stallSign, sign, Vector3.new(0, 0, 0), UDim2.new(8, 0, 2, 0))
end

-- Central market well
makePart("MarketWellBase", Vector3.new(6, 3, 6), Vector3.new(-35, 1.5, 85), "Medium stone grey", Enum.Material.Cobblestone, market)
makePart("MarketWellRim", Vector3.new(6.5, 0.5, 6.5), Vector3.new(-35, 3.25, 85), "Medium stone grey", Enum.Material.Marble, market)
makePart("MarketWellWater", Vector3.new(5, 0.3, 5), Vector3.new(-35, 2.9, 85), Color3.fromRGB(65, 130, 175), Enum.Material.Water, market, {Transparency = 0.3})
-- Well post and bucket system
makePart("WellPost", Vector3.new(0.8, 6, 0.8), Vector3.new(-35, 6, 85), "Reddish brown", Enum.Material.Wood, market)
makePart("WellCrossbeam", Vector3.new(4, 0.6, 0.6), Vector3.new(-35, 9, 85), "Reddish brown", Enum.Material.Wood, market)
makePart("WellRoof", Vector3.new(5, 0.4, 5), Vector3.new(-35, 9.8, 85), "Dark red", Enum.Material.Wood, market)
makePart("WellBucket", Vector3.new(1.5, 2, 1.5), Vector3.new(-33, 7, 85), "Dark stone grey", Enum.Material.Metal, market)

-- Market decorations and atmosphere
local decorItems = {
	-- Flower carts
	{-15, 1, 70, "FlowerCart", Vector3.new(3, 2, 1.5), "Reddish brown"},
	{-55, 1, 80, "FlowerCart2", Vector3.new(3, 2, 1.5), "Reddish brown"},
	-- Spare barrels and crates
	{-58, 1.5, 72, "MarketBarrel1", Vector3.new(2, 3, 2), "Reddish brown"},
	{-58, 1.5, 74, "MarketBarrel2", Vector3.new(2, 3, 2), "Reddish brown"},
	{-12, 1.25, 82, "MarketCrate1", Vector3.new(2.5, 2.5, 2.5), "Brown"},
	{-10, 1.25, 82, "MarketCrate2", Vector3.new(2.5, 2.5, 2.5), "Brown"},
}
for i, item in ipairs(decorItems) do
	makePart(item[4], item[5], Vector3.new(item[1], item[2], item[3]), item[6], Enum.Material.Wood, market)
end

-- Flowers in flower carts
local flowers = {"Bright red", "Bright yellow", "Bright violet", "Hot pink"}
for i, pos in ipairs({{-15, 70}, {-55, 80}}) do
	for j = 1, 4 do
		makePart("CartFlower" .. i .. j, Vector3.new(0.4, 1, 0.4), Vector3.new(pos[1] + math.random(-1, 1), 2.8, pos[2] + math.random(-1, 1)), flowers[j], Enum.Material.SmoothPlastic, market, {CanCollide = false})
	end
end

-- Market entrance arch
makePart("MarketArchL", Vector3.new(4, 12, 4), Vector3.new(-65, 6, 75), "Medium stone grey", Enum.Material.Cobblestone, market)
makePart("MarketArchR", Vector3.new(4, 12, 4), Vector3.new(-5, 6, 75), "Medium stone grey", Enum.Material.Cobblestone, market)
makePart("MarketArchTop", Vector3.new(64, 4, 4), Vector3.new(-35, 12, 75), "Medium stone grey", Enum.Material.Cobblestone, market)

-- Grand market sign
local marketSign = makePart("MarketSign", Vector3.new(1, 1, 1), Vector3.new(-35, 16, 75), "White", nil, market, {Transparency = 1})
makeSign(marketSign, "ðŸª HAVEN MARKETPLACE", Vector3.new(0, 0, 0), UDim2.new(14, 0, 4, 0))

-- Market lighting
local marketLanterns = {
	{-25, 0, 70}, {-45, 0, 70}, {-25, 0, 80}, {-45, 0, 80}, {-35, 0, 65}, {-35, 0, 90}
}
for _, pos in ipairs(marketLanterns) do
	makeLantern(Vector3.new(pos[1], pos[2], pos[3]), market)
end

-- ============================================================
-- === FISHING POND (south-east, inside walls) ===
-- ============================================================
local pond = getOrMake(safeZone, "FishingPond")
-- Pond water
makePart("PondWater", Vector3.new(30, 0.5, 20), Vector3.new(80, -0.25, 80), Color3.fromRGB(65, 130, 175), Enum.Material.Water, pond, {Transparency = 0.3})
-- Pond banks (dirt edges)
makePart("PondBankN", Vector3.new(34, 1, 3), Vector3.new(80, 0, 69), "Brown", Enum.Material.Ground, pond)
makePart("PondBankS", Vector3.new(34, 1, 3), Vector3.new(80, 0, 91), "Brown", Enum.Material.Ground, pond)
makePart("PondBankW", Vector3.new(3, 1, 20), Vector3.new(64, 0, 80), "Brown", Enum.Material.Ground, pond)
makePart("PondBankE", Vector3.new(3, 1, 20), Vector3.new(96, 0, 80), "Brown", Enum.Material.Ground, pond)
-- Reeds / cattails
for i = 1, 6 do
	local rx = 64 + math.random(0, 30)
	local rz = 70 + math.random(0, 18)
	makePart("Reed" .. i, Vector3.new(0.3, 3 + math.random(), 0.3), Vector3.new(rx, 1.5, rz), "Earth green", Enum.Material.Grass, pond)
end
-- Dock / pier
makePart("Dock", Vector3.new(4, 0.5, 12), Vector3.new(80, 0.5, 86), "Reddish brown", Enum.Material.WoodPlanks, pond)
makePart("DockPost1", Vector3.new(0.5, 3, 0.5), Vector3.new(78, 0.5, 92), "Reddish brown", Enum.Material.Wood, pond)
makePart("DockPost2", Vector3.new(0.5, 3, 0.5), Vector3.new(82, 0.5, 92), "Reddish brown", Enum.Material.Wood, pond)
local pondSign = makePart("PondSign", Vector3.new(1, 1, 1), Vector3.new(80, 3, 68), "White", nil, pond, {Transparency = 1})
makeSign(pondSign, "ðŸŽ£ Haven Pond", Vector3.new(0, 0, 0))

-- Second smaller pond (lily pond)
makePart("LilyPond", Vector3.new(14, 0.5, 10), Vector3.new(110, -0.25, 60), Color3.fromRGB(65, 130, 175), Enum.Material.Water, pond, {Transparency = 0.3})
makePart("LilyPondBank", Vector3.new(18, 0.8, 14), Vector3.new(110, -0.1, 60), "Brown", Enum.Material.Ground, pond)
-- Lily pads
for i = 1, 4 do
	makePart("LilyPad" .. i, Vector3.new(2, 0.1, 2), Vector3.new(106 + i * 2, 0.1, 58 + math.random(-3, 3)), "Earth green", Enum.Material.Grass, pond)
end

-- ============================================================
-- === MINING CAVE (west side, outside walls) ===
-- ============================================================
local mine = getOrMake(safeZone, "MiningCave")
-- Cave entrance (big rocky arch)
makePart("CaveWallL", Vector3.new(6, 16, 8), Vector3.new(-100, 8, 30), "Dark stone grey", Enum.Material.Slate, mine)
makePart("CaveWallR", Vector3.new(6, 16, 8), Vector3.new(-86, 8, 30), "Dark stone grey", Enum.Material.Slate, mine)
makePart("CaveArch", Vector3.new(20, 5, 8), Vector3.new(-93, 18.5, 30), "Dark stone grey", Enum.Material.Slate, mine)
-- Cave interior (hollowed out area)
makePart("CaveFloor", Vector3.new(30, 0.3, 30), Vector3.new(-93, 0.15, 15), "Dark stone grey", Enum.Material.Slate, mine)
makePart("CaveRoof", Vector3.new(34, 2, 34), Vector3.new(-93, 14, 15), "Dark stone grey", Enum.Material.Slate, mine)
makePart("CaveWallBack", Vector3.new(34, 14, 2), Vector3.new(-93, 7, -1), "Dark stone grey", Enum.Material.Slate, mine)
makePart("CaveWallSideL", Vector3.new(2, 14, 34), Vector3.new(-110, 7, 15), "Dark stone grey", Enum.Material.Slate, mine)
makePart("CaveWallSideR", Vector3.new(2, 14, 34), Vector3.new(-76, 7, 15), "Dark stone grey", Enum.Material.Slate, mine)
-- Cave supports (wooden beams)
makePart("Support1", Vector3.new(1, 12, 1), Vector3.new(-100, 6, 20), "Reddish brown", Enum.Material.Wood, mine)
makePart("Support2", Vector3.new(1, 12, 1), Vector3.new(-86, 6, 20), "Reddish brown", Enum.Material.Wood, mine)
makePart("SupportBeam", Vector3.new(16, 1, 1), Vector3.new(-93, 12, 20), "Reddish brown", Enum.Material.Wood, mine)
makePart("Support3", Vector3.new(1, 12, 1), Vector3.new(-100, 6, 8), "Reddish brown", Enum.Material.Wood, mine)
makePart("Support4", Vector3.new(1, 12, 1), Vector3.new(-86, 6, 8), "Reddish brown", Enum.Material.Wood, mine)
makePart("SupportBeam2", Vector3.new(16, 1, 1), Vector3.new(-93, 12, 8), "Reddish brown", Enum.Material.Wood, mine)
-- Mine cart tracks
makePart("Track1", Vector3.new(0.3, 0.2, 30), Vector3.new(-91.5, 0.3, 15), "Dark stone grey", Enum.Material.Metal, mine)
makePart("Track2", Vector3.new(0.3, 0.2, 30), Vector3.new(-94.5, 0.3, 15), "Dark stone grey", Enum.Material.Metal, mine)
-- Mine cart
makePart("CartBody", Vector3.new(3, 2, 4), Vector3.new(-93, 1.5, 22), "Dark stone grey", Enum.Material.Metal, mine)
makePart("CartWheel1", Vector3.new(1.5, 1.5, 0.3), Vector3.new(-91.5, 0.8, 24), "Black", Enum.Material.Metal, mine)
makePart("CartWheel2", Vector3.new(1.5, 1.5, 0.3), Vector3.new(-94.5, 0.8, 24), "Black", Enum.Material.Metal, mine)
-- Torch lighting inside cave
makeTorch(Vector3.new(-100, 3, 15), mine)
makeTorch(Vector3.new(-86, 3, 15), mine)
makeTorch(Vector3.new(-100, 3, 5), mine)
makeTorch(Vector3.new(-86, 3, 5), mine)
-- Ore veins (visual, the actual clickable nodes are from SkillManager)
makePart("OreVeinCopper", Vector3.new(3, 3, 1), Vector3.new(-109, 3, 10), "Nougat", Enum.Material.Slate, mine)
makePart("OreVeinIron", Vector3.new(2, 4, 1), Vector3.new(-109, 4, 18), "Dark stone grey", Enum.Material.Slate, mine)
local mineSign = makePart("MineSign", Vector3.new(1, 1, 1), Vector3.new(-93, 22, 34), "White", nil, mine, {Transparency = 1})
makeSign(mineSign, "â›ï¸ Haven Mine", Vector3.new(0, 0, 0), UDim2.new(10, 0, 2, 0))

-- ============================================================
-- === FOREST (east side, outside walls) ===
-- ============================================================
local forest = getOrMake(safeZone, "Forest")
-- Grass clearing floor
makePart("ForestFloor", Vector3.new(80, 0.15, 80), Vector3.new(130, 0.08, 30), "Earth green", Enum.Material.Grass, forest)
-- Scattered decorative trees (non-clickable, just scenery)
local function makeSceneryTree(pos, scale, leafColor)
	scale = scale or 1
	leafColor = leafColor or "Forest green"
	makePart("STree", Vector3.new(2*scale, 10*scale, 2*scale), pos + Vector3.new(0, 5*scale, 0), "Reddish brown", Enum.Material.Wood, forest)
	makePart("SLeaf", Vector3.new(10*scale, 10*scale, 10*scale), pos + Vector3.new(0, 11*scale, 0), leafColor, Enum.Material.Grass, forest)
end
-- Dense forest â€” many trees
local treePositions = {
	{100, 0, 10}, {110, 0, 15}, {120, 0, 5}, {105, 0, 25}, {115, 0, 30},
	{130, 0, 10}, {140, 0, 20}, {150, 0, 15}, {135, 0, 35}, {145, 0, 40},
	{100, 0, 45}, {110, 0, 50}, {125, 0, 55}, {155, 0, 30}, {160, 0, 45},
	{115, 0, 60}, {130, 0, 65}, {145, 0, 55}, {150, 0, 65}, {105, 0, 70},
}
for _, tp in ipairs(treePositions) do
	local scale = 0.7 + math.random() * 0.6
	local colors = {"Forest green", "Earth green", "Dark green", "Bright green"}
	makeSceneryTree(Vector3.new(tp[1], tp[2], tp[3]), scale, colors[math.random(#colors)])
end
-- Path into forest
makePart("ForestPath", Vector3.new(4, 0.12, 40), Vector3.new(90, 0.06, 30), "Brown", Enum.Material.Ground, forest)
local forestSign = makePart("ForestSign", Vector3.new(1, 1, 1), Vector3.new(90, 4, 50), "White", nil, forest, {Transparency = 1})
makeSign(forestSign, "ðŸŒ² Haven Forest", Vector3.new(0, 0, 0))

-- ============================================================
-- === WILDERNESS â€” THEMED ZONES ===
-- ============================================================

-- Helper: dead tree (reusable)
local function makeDeadTree(position, parent)
	parent = parent or wilderness
	makePart("DeadTrunk", Vector3.new(1.5, 7, 1.5), position + Vector3.new(0, 3.5, 0), "Dark stone grey", Enum.Material.Wood, parent)
	makePart("DeadBranch1", Vector3.new(0.5, 3, 0.5), position + Vector3.new(1.5, 6, 0), "Dark stone grey", Enum.Material.Wood, parent, {Orientation = Vector3.new(0, 0, 30)})
	makePart("DeadBranch2", Vector3.new(0.5, 2.5, 0.5), position + Vector3.new(-1, 5, 0.5), "Dark stone grey", Enum.Material.Wood, parent, {Orientation = Vector3.new(0, 0, -25)})
end

-- Helper: warning sign
local function makeWarningSign(position, text)
	text = text or "DANGER"
	makePart("SignPost", Vector3.new(0.5, 4, 0.5), position + Vector3.new(0, 2, 0), "Reddish brown", Enum.Material.Wood, wilderness)
	local board = makePart("SignBoard", Vector3.new(3, 2, 0.3), position + Vector3.new(0, 4.5, 0), "Brown", Enum.Material.Wood, wilderness)
	makeSign(board, text, Vector3.new(0, 1, 0))
end

-- Helper: rock cluster
local function makeRockCluster(center, count, spread, parent)
	parent = parent or wilderness
	for i = 1, count do
		local ox = (math.random() - 0.5) * spread
		local oz = (math.random() - 0.5) * spread
		local s = 2 + math.random() * 3
		makePart("Rock"..i, Vector3.new(s, s * 0.7, s * 0.9), center + Vector3.new(ox, s * 0.35, oz), "Dark stone grey", Enum.Material.Slate, parent)
	end
end

-- ---- WILDERNESS BORDER (z = -100 to -110) ----
-- Warning signs at the border
makeWarningSign(Vector3.new(0, 0, -105), "WILDERNESS")
makeWarningSign(Vector3.new(-40, 0, -105), "DANGER")
makeWarningSign(Vector3.new(40, 0, -105), "DANGER")

-- === WILDERNESS BARRIER â€” low red wall you can jump over ===
local wildBorder = getOrMake(safeZone, "WildernessBorder")
-- Main wall segments (left and right of path gap)
makePart("RedWallLeft", Vector3.new(90, 3, 2), Vector3.new(-49, 1.5, -100), Color3.fromRGB(140, 20, 20), Enum.Material.Brick, wildBorder)
makePart("RedWallRight", Vector3.new(90, 3, 2), Vector3.new(49, 1.5, -100), Color3.fromRGB(140, 20, 20), Enum.Material.Brick, wildBorder)
-- Gap posts (frame the path opening, 8 stud gap)
makePart("RedPostL", Vector3.new(2, 5, 2), Vector3.new(-4, 2.5, -100), Color3.fromRGB(100, 10, 10), Enum.Material.Brick, wildBorder)
makePart("RedPostR", Vector3.new(2, 5, 2), Vector3.new(4, 2.5, -100), Color3.fromRGB(100, 10, 10), Enum.Material.Brick, wildBorder)
-- Top trim (darker red accent line)
makePart("RedTrimL", Vector3.new(90, 0.4, 2.2), Vector3.new(-49, 3.2, -100), Color3.fromRGB(80, 5, 5), Enum.Material.Metal, wildBorder)
makePart("RedTrimR", Vector3.new(90, 0.4, 2.2), Vector3.new(49, 3.2, -100), Color3.fromRGB(80, 5, 5), Enum.Material.Metal, wildBorder)
-- Warning sign above gap
local wildWallSign = makePart("WildWallSign", Vector3.new(1, 1, 1), Vector3.new(0, 6, -100), "White", nil, wildBorder, {Transparency = 1})
makeSign(wildWallSign, "WILDERNESS", Vector3.new(0, 0, 0), UDim2.new(8, 0, 2, 0))

-- Dirt path from Haven north gate into wilderness
makePart("NorthPath", Vector3.new(8, 0.12, 80), Vector3.new(0, 0.06, -50), "Brown", Enum.Material.Ground, safeZone)
makePart("WildMainPath", Vector3.new(6, 0.12, 400), Vector3.new(0, 0.06, -300), "Dark stone grey", Enum.Material.Ground, wilderness)

-- Wilderness ground â€” darker terrain floor
makePart("WildFloorNear", Vector3.new(200, 0.15, 100), Vector3.new(0, 0.05, -155), Color3.fromRGB(60, 55, 45), Enum.Material.Ground, wilderness)
makePart("WildFloorMid", Vector3.new(200, 0.15, 150), Vector3.new(0, 0.05, -280), Color3.fromRGB(50, 45, 38), Enum.Material.Ground, wilderness)
makePart("WildFloorDeep", Vector3.new(200, 0.15, 200), Vector3.new(0, 0.05, -430), Color3.fromRGB(35, 30, 28), Enum.Material.Ground, wilderness)

-- ============================================================
-- ZONE 1: SKELETON GRAVEYARD (z: -120 to -165)
-- ============================================================
local graveyard = getOrMake(wilderness, "Graveyard")
-- Ground: dark earth
makePart("GraveFloor", Vector3.new(80, 0.18, 50), Vector3.new(-30, 0.07, -145), Color3.fromRGB(45, 40, 35), Enum.Material.Ground, graveyard)
-- Iron fence perimeter
makePart("GraveFenceN", Vector3.new(80, 3, 0.3), Vector3.new(-30, 1.5, -120), "Black", Enum.Material.Metal, graveyard)
makePart("GraveFenceS", Vector3.new(80, 3, 0.3), Vector3.new(-30, 1.5, -170), "Black", Enum.Material.Metal, graveyard)
makePart("GraveFenceW", Vector3.new(0.3, 3, 50), Vector3.new(-70, 1.5, -145), "Black", Enum.Material.Metal, graveyard)
makePart("GraveFenceE", Vector3.new(0.3, 3, 50), Vector3.new(10, 1.5, -145), "Black", Enum.Material.Metal, graveyard)
-- Gate opening on east side
makePart("GatePostL", Vector3.new(1, 5, 1), Vector3.new(10, 2.5, -140), "Dark stone grey", Enum.Material.Cobblestone, graveyard)
makePart("GatePostR", Vector3.new(1, 5, 1), Vector3.new(10, 2.5, -150), "Dark stone grey", Enum.Material.Cobblestone, graveyard)
-- Gravestones in rows
for row = 0, 2 do
	for col = 0, 5 do
		local gx = -60 + col * 10
		local gz = -130 - row * 14
		makePart("Grave"..row..col, Vector3.new(2, 3, 0.5), Vector3.new(gx, 1.5, gz), "Medium stone grey", Enum.Material.Cobblestone, graveyard)
		makePart("Mound"..row..col, Vector3.new(3, 0.5, 4), Vector3.new(gx, 0.25, gz + 2.5), Color3.fromRGB(50, 42, 35), Enum.Material.Ground, graveyard)
	end
end
-- Dead trees in graveyard
makeDeadTree(Vector3.new(-55, 0, -135), graveyard)
makeDeadTree(Vector3.new(-10, 0, -155), graveyard)
makeDeadTree(Vector3.new(-35, 0, -165), graveyard)
-- Eerie fog
makePart("GraveFog1", Vector3.new(30, 2, 20), Vector3.new(-40, 1, -140), Color3.fromRGB(80, 80, 90), Enum.Material.SmoothPlastic, graveyard, {Transparency = 0.9, CanCollide = false})
makePart("GraveFog2", Vector3.new(25, 2, 15), Vector3.new(-20, 1, -155), Color3.fromRGB(80, 80, 90), Enum.Material.SmoothPlastic, graveyard, {Transparency = 0.9, CanCollide = false})
local graveSign = makePart("GraveSign", Vector3.new(1, 1, 1), Vector3.new(10, 6, -145), "White", nil, graveyard, {Transparency = 1})
makeSign(graveSign, "Forgotten Graveyard", Vector3.new(0, 0, 0))

-- ============================================================
-- ZONE 2: DARK WIZARD RUINS (z: -165 to -195)
-- ============================================================
local ruins = getOrMake(wilderness, "AncientRuins")
-- Stone platform
makePart("RuinFloor", Vector3.new(50, 0.5, 40), Vector3.new(60, 0.25, -178), "Medium stone grey", Enum.Material.Cobblestone, ruins)
-- Crumbling walls
makePart("RuinWallN", Vector3.new(40, 10, 2), Vector3.new(60, 5, -160), "Medium stone grey", Enum.Material.Cobblestone, ruins)
makePart("RuinWallW", Vector3.new(2, 8, 30), Vector3.new(37, 4, -175), "Medium stone grey", Enum.Material.Cobblestone, ruins)
makePart("RuinWallBroken", Vector3.new(15, 5, 2), Vector3.new(52, 2.5, -195), "Medium stone grey", Enum.Material.Cobblestone, ruins)
-- Intact pillars
for i = 0, 3 do
	local px = 45 + i * 10
	local pHeight = (i == 1 or i == 3) and 10 or 6
	makePart("Pillar"..i, Vector3.new(2, pHeight, 2), Vector3.new(px, pHeight/2, -165), "Medium stone grey", Enum.Material.Marble, ruins)
end
-- Fallen pillar on ground
makePart("FallenPillar", Vector3.new(2, 2, 8), Vector3.new(55, 1, -180), "Medium stone grey", Enum.Material.Marble, ruins, {Orientation = Vector3.new(0, 25, 90)})
-- Dark magic circle on floor
makePart("MagicCircle", Vector3.new(12, 0.08, 12), Vector3.new(60, 0.55, -178), "Really black", Enum.Material.Neon, ruins, {Transparency = 0.4})
-- Candles around circle
for a = 0, 5 do
	local angle = a * (math.pi * 2 / 6)
	local cx = 60 + math.cos(angle) * 7
	local cz = -178 + math.sin(angle) * 7
	makePart("Candle"..a, Vector3.new(0.3, 1, 0.3), Vector3.new(cx, 1, cz), "Institutional white", Enum.Material.SmoothPlastic, ruins)
	local candleLight = Instance.new("PointLight")
	candleLight.Color = Color3.fromRGB(255, 180, 80)
	candleLight.Brightness = 0.5
	candleLight.Range = 6
	candleLight.Parent = ruins:FindFirstChild("Candle"..a)
end
local ruinSign = makePart("RuinSign", Vector3.new(1, 1, 1), Vector3.new(60, 12, -160), "White", nil, ruins, {Transparency = 1})
makeSign(ruinSign, "Ancient Ruins", Vector3.new(0, 0, 0))

-- ============================================================
-- ZONE 3: DEMON WASTELAND (z: -260 to -330)
-- ============================================================
local demonZone = getOrMake(wilderness, "DemonWaste")
-- Scorched ground
makePart("ScorchedFloor", Vector3.new(100, 0.2, 80), Vector3.new(0, 0.08, -295), Color3.fromRGB(30, 20, 15), Enum.Material.Ground, demonZone)
-- Lava cracks in the ground
for i = 1, 8 do
	local cx = -35 + math.random(0, 70)
	local cz = -270 - math.random(0, 50)
	local cw = 8 + math.random(0, 12)
	makePart("LavaCrack"..i, Vector3.new(cw, 0.15, 0.5 + math.random() * 0.5), Vector3.new(cx, 0.2, cz), "Bright orange", Enum.Material.Neon, demonZone, {Transparency = 0.2, Orientation = Vector3.new(0, math.random(-30, 30), 0)})
end
-- Lava pit (center of demon area)
makePart("LavaRim", Vector3.new(24, 1.5, 24), Vector3.new(0, 0.75, -295), "Dark stone grey", Enum.Material.Slate, demonZone)
makePart("LavaPool", Vector3.new(18, 0.5, 18), Vector3.new(0, 0.15, -295), "Bright red", Enum.Material.Neon, demonZone, {Transparency = 0.15})
local lavaLight = Instance.new("PointLight")
lavaLight.Color = Color3.fromRGB(255, 60, 20)
lavaLight.Brightness = 1.2
lavaLight.Range = 50
local lavaPoolPart = demonZone:FindFirstChild("LavaPool")
if lavaPoolPart then lavaLight.Parent = lavaPoolPart end
-- Dark obsidian spires
makePart("Spire1", Vector3.new(3, 18, 3), Vector3.new(-30, 9, -280), "Really black", Enum.Material.Slate, demonZone)
makePart("Spire2", Vector3.new(4, 22, 4), Vector3.new(35, 11, -310), "Really black", Enum.Material.Slate, demonZone)
makePart("Spire3", Vector3.new(2.5, 14, 2.5), Vector3.new(-20, 7, -315), "Really black", Enum.Material.Slate, demonZone)
makePart("Spire4", Vector3.new(3, 16, 3), Vector3.new(25, 8, -275), "Really black", Enum.Material.Slate, demonZone)
-- Lava rocks
makePart("LavaRock1", Vector3.new(5, 3, 4), Vector3.new(15, 1.5, -285), "Black", Enum.Material.Slate, demonZone)
makePart("LavaRock2", Vector3.new(4, 4, 5), Vector3.new(-12, 2, -305), "Black", Enum.Material.Slate, demonZone)
makePart("LavaRock3", Vector3.new(6, 2.5, 4), Vector3.new(8, 1.25, -320), "Black", Enum.Material.Slate, demonZone)
-- Smoke/ash
for i = 1, 4 do
	local sx = -20 + math.random(0, 40)
	local sz = -280 - math.random(0, 40)
	makePart("Smoke"..i, Vector3.new(15, 6, 15), Vector3.new(sx, 3, sz), Color3.fromRGB(40, 30, 25), Enum.Material.SmoothPlastic, demonZone, {Transparency = 0.85, CanCollide = false})
end
local demonSign = makePart("DemonSign", Vector3.new(1, 1, 1), Vector3.new(0, 6, -260), "White", nil, demonZone, {Transparency = 1})
makeSign(demonSign, "Demon Wasteland", Vector3.new(0, 0, 0))

-- ============================================================
-- ZONE 4: DARK WATERS (z: -200 to -240)
-- ============================================================
local darkPond = getOrMake(wilderness, "DarkPond")
makePart("DPBank", Vector3.new(30, 0.8, 22), Vector3.new(-60, -0.1, -220), Color3.fromRGB(40, 35, 30), Enum.Material.Ground, darkPond)
makePart("DPWater", Vector3.new(24, 0.5, 16), Vector3.new(-60, -0.25, -220), Color3.fromRGB(20, 60, 90), Enum.Material.Water, darkPond, {Transparency = 0.25})
-- Glowing mushrooms along shore
for i = 1, 6 do
	local angle = i * (math.pi * 2 / 6)
	local mx = -60 + math.cos(angle) * 14
	local mz = -220 + math.sin(angle) * 10
	local shroom = makePart("Mushroom"..i, Vector3.new(0.8, 1.2, 0.8), Vector3.new(mx, 0.6, mz), "Bright violet", Enum.Material.Neon, darkPond, {Transparency = 0.3})
	local shroomLight = Instance.new("PointLight")
	shroomLight.Color = Color3.fromRGB(140, 40, 200)
	shroomLight.Brightness = 0.6
	shroomLight.Range = 6
	shroomLight.Parent = shroom
end
-- Dead reeds
for i = 1, 8 do
	local rx = -72 + math.random(0, 24)
	local rz = -228 + math.random(0, 16)
	makePart("Reed"..i, Vector3.new(0.15, 2 + math.random(), 0.15), Vector3.new(rx, 1, rz), "Brown", Enum.Material.Grass, darkPond, {CanCollide = false})
end
local dpSign = makePart("DPSign", Vector3.new(1, 1, 1), Vector3.new(-60, 3, -207), "White", nil, darkPond, {Transparency = 1})
makeSign(dpSign, "Dark Waters", Vector3.new(0, 0, 0))

-- ============================================================
-- ZONE 5: DRAGON'S NEST (z: -430 to -500)
-- ============================================================
local dragonNest = getOrMake(wilderness, "DragonNest")
-- Massive scorched crater
makePart("NestFloor", Vector3.new(120, 0.3, 80), Vector3.new(50, -0.5, -465), Color3.fromRGB(25, 18, 15), Enum.Material.Slate, dragonNest)
makePart("NestRim", Vector3.new(130, 3, 90), Vector3.new(50, 1.5, -465), Color3.fromRGB(35, 25, 20), Enum.Material.Slate, dragonNest)
-- Rim is hollow (floor sits inside)
-- Jagged rock walls surrounding the nest
makePart("NestWallN", Vector3.new(100, 15, 5), Vector3.new(50, 7.5, -425), "Really black", Enum.Material.Slate, dragonNest)
makePart("NestWallS", Vector3.new(100, 12, 5), Vector3.new(50, 6, -505), "Really black", Enum.Material.Slate, dragonNest)
makePart("NestWallW", Vector3.new(5, 14, 80), Vector3.new(-12, 7, -465), "Really black", Enum.Material.Slate, dragonNest)
makePart("NestWallE", Vector3.new(5, 14, 80), Vector3.new(112, 7, -465), "Really black", Enum.Material.Slate, dragonNest)
-- Opening/entrance on north side
makePart("NestGateL", Vector3.new(5, 18, 8), Vector3.new(38, 9, -425), "Really black", Enum.Material.Slate, dragonNest)
makePart("NestGateR", Vector3.new(5, 18, 8), Vector3.new(62, 9, -425), "Really black", Enum.Material.Slate, dragonNest)
-- Lava veins running through the nest floor
for i = 1, 10 do
	local lx = 10 + math.random(0, 80)
	local lz = -490 + math.random(0, 50)
	local lw = 10 + math.random(0, 15)
	makePart("NestLava"..i, Vector3.new(lw, 0.12, 0.8), Vector3.new(lx, -0.3, lz), "Bright orange", Enum.Material.Neon, dragonNest, {Transparency = 0.15, Orientation = Vector3.new(0, math.random(-40, 40), 0)})
end
-- Charred bone piles (trophies)
for i = 1, 5 do
	local bx = 20 + math.random(0, 60)
	local bz = -450 - math.random(0, 35)
	makePart("BonePile"..i, Vector3.new(3 + math.random() * 2, 1, 3 + math.random() * 2), Vector3.new(bx, 0.2, bz), "Institutional white", Enum.Material.SmoothPlastic, dragonNest)
end
-- Giant skull decoration
makePart("GiantSkull", Vector3.new(5, 4, 4), Vector3.new(50, 2, -480), "Institutional white", Enum.Material.SmoothPlastic, dragonNest)
makePart("SkullJaw", Vector3.new(4, 1.5, 3), Vector3.new(50, 0.5, -479), "Institutional white", Enum.Material.SmoothPlastic, dragonNest)
-- Embers floating (neon particles)
for i = 1, 8 do
	local ex = 20 + math.random(0, 60)
	local ez = -445 - math.random(0, 45)
	makePart("Ember"..i, Vector3.new(0.3, 0.3, 0.3), Vector3.new(ex, 1 + math.random() * 3, ez), "Bright orange", Enum.Material.Neon, dragonNest, {CanCollide = false})
end
-- Nest lighting (orange glow)
local nestGlow = Instance.new("PointLight")
nestGlow.Color = Color3.fromRGB(255, 100, 30)
nestGlow.Brightness = 1
nestGlow.Range = 80
local nestFloor = dragonNest:FindFirstChild("NestFloor")
if nestFloor then nestGlow.Parent = nestFloor end
local nestSign = makePart("NestSign", Vector3.new(1, 1, 1), Vector3.new(50, 20, -425), "White", nil, dragonNest, {Transparency = 1})
makeSign(nestSign, "Dragon's Nest", Vector3.new(0, 0, 0), UDim2.new(10, 0, 3, 0))

-- ============================================================
-- ZONE 6: LICH KING'S DOMAIN (z: -370 to -420)
-- ============================================================
local lichDomain = getOrMake(wilderness, "LichDomain")
makePart("LichFloor", Vector3.new(60, 0.3, 60), Vector3.new(-50, 0.1, -395), Color3.fromRGB(20, 15, 25), Enum.Material.Slate, lichDomain)
-- Corrupted stone pillars in a circle
for i = 0, 7 do
	local angle = i * (math.pi * 2 / 8)
	local px = -50 + math.cos(angle) * 25
	local pz = -395 + math.sin(angle) * 25
	local height = 12 + math.random(0, 6)
	makePart("LichPillar"..i, Vector3.new(2.5, height, 2.5), Vector3.new(px, height/2, pz), "Really black", Enum.Material.Cobblestone, lichDomain)
end
-- Central altar
makePart("Altar", Vector3.new(6, 2, 6), Vector3.new(-50, 1, -395), "Really black", Enum.Material.Marble, lichDomain)
makePart("AltarGlow", Vector3.new(4, 0.1, 4), Vector3.new(-50, 2.1, -395), "Royal purple", Enum.Material.Neon, lichDomain, {Transparency = 0.3})
local altarLight = Instance.new("PointLight")
altarLight.Color = Color3.fromRGB(120, 40, 200)
altarLight.Brightness = 1.5
altarLight.Range = 40
local altarPart = lichDomain:FindFirstChild("AltarGlow")
if altarPart then altarLight.Parent = altarPart end
-- Floating dark energy wisps
for i = 1, 6 do
	local wx = -50 + (math.random() - 0.5) * 40
	local wz = -395 + (math.random() - 0.5) * 40
	makePart("Wisp"..i, Vector3.new(0.6, 0.6, 0.6), Vector3.new(wx, 2 + math.random() * 4, wz), "Royal purple", Enum.Material.Neon, lichDomain, {CanCollide = false, Transparency = 0.3})
end
local lichSign = makePart("LichSign", Vector3.new(1, 1, 1), Vector3.new(-50, 8, -370), "White", nil, lichDomain, {Transparency = 1})
makeSign(lichSign, "Lich King's Domain", Vector3.new(0, 0, 0))

-- ============================================================
-- SCATTERED WILDERNESS DECORATIONS (intentional, sparse)
-- ============================================================
-- Dead trees along the main path
local wildDeadTrees = {
	{15, 0, -130}, {-25, 0, -170}, {30, 0, -210}, {-15, 0, -250},
	{20, 0, -340}, {-30, 0, -360}, {45, 0, -190}, {-50, 0, -300},
}
for _, dt in ipairs(wildDeadTrees) do
	makeDeadTree(Vector3.new(dt[1], dt[2], dt[3]))
end

-- Rock formations along path edges (not random, placed)
makeRockCluster(Vector3.new(25, 0, -150), 3, 8)
makeRockCluster(Vector3.new(-30, 0, -200), 3, 10)
makeRockCluster(Vector3.new(35, 0, -270), 4, 12)
makeRockCluster(Vector3.new(-40, 0, -340), 3, 8)

-- Dead bushes (sparse, along path)
local deadBushPositions = {
	{-12, -135}, {18, -160}, {-20, -195}, {25, -230}, {-15, -265},
	{10, -310}, {-25, -350}, {20, -385},
}
for i, db in ipairs(deadBushPositions) do
	makePart("DeadBush"..i, Vector3.new(1.5, 1, 1.5), Vector3.new(db[1], 0.5, db[2]), "Brown", Enum.Material.Grass, wilderness, {CanCollide = false})
end

-- Sparse fog patches (only 3, subtle)
makePart("WildFog1", Vector3.new(40, 3, 30), Vector3.new(0, 1.5, -180), Color3.fromRGB(60, 55, 50), Enum.Material.SmoothPlastic, wilderness, {Transparency = 0.92, CanCollide = false})
makePart("WildFog2", Vector3.new(35, 3, 25), Vector3.new(-30, 1.5, -270), Color3.fromRGB(50, 45, 40), Enum.Material.SmoothPlastic, wilderness, {Transparency = 0.92, CanCollide = false})
makePart("WildFog3", Vector3.new(45, 4, 35), Vector3.new(20, 2, -400), Color3.fromRGB(40, 35, 35), Enum.Material.SmoothPlastic, wilderness, {Transparency = 0.9, CanCollide = false})

-- ============================================================
-- === SAFE ZONE TERRAIN ===
-- ============================================================

-- Gentle hills around Haven
local havenHillData = {
	{-30, 2, 140, 20, 15}, {30, 1.5, 150, 18, 14}, {-50, 2.5, 160, 25, 20},
	{50, 2, 170, 22, 16}, {0, 1.8, 180, 30, 20}, {-80, 2, 130, 15, 12},
	{80, 1.5, 145, 16, 14},
}
for i, h in ipairs(havenHillData) do
	makePart("HavenHill"..i, Vector3.new(h[4], h[2], h[5]), Vector3.new(h[1], h[2]/2, h[3]), "Bright green", Enum.Material.Grass, safeZone)
end

-- Farmland rolling hills
local hillData = {
	{170, 3, 130, 30, 6, 25}, {220, 4, 180, 25, 8, 20}, {280, 2.5, 160, 35, 5, 30},
	{310, 3.5, 200, 20, 7, 22}, {190, 2, 220, 28, 4, 24}, {250, 3, 240, 22, 6, 18},
}
for i, h in ipairs(hillData) do
	makePart("FarmHill"..i, Vector3.new(h[4], h[2], h[6]), Vector3.new(h[1], h[2]/2, h[3]), "Bright green", Enum.Material.Grass, safeZone)
end

-- River (east-west)
makePart("RiverWater", Vector3.new(200, 0.5, 8), Vector3.new(0, -0.3, 0), Color3.fromRGB(65, 130, 175), Enum.Material.Water, safeZone, {Transparency = 0.3, CanCollide = false})
makePart("RiverBankN", Vector3.new(200, 0.6, 3), Vector3.new(0, 0, -5), "Brown", Enum.Material.Ground, safeZone)
makePart("RiverBankS", Vector3.new(200, 0.6, 3), Vector3.new(0, 0, 5), "Brown", Enum.Material.Ground, safeZone)
-- Bridge
makePart("BridgeDeck", Vector3.new(10, 1, 12), Vector3.new(0, 1, 0), "Medium stone grey", Enum.Material.Cobblestone, safeZone)
makePart("BridgeRailL", Vector3.new(1, 3, 12), Vector3.new(-5, 2.5, 0), "Medium stone grey", Enum.Material.Cobblestone, safeZone)
makePart("BridgeRailR", Vector3.new(1, 3, 12), Vector3.new(5, 2.5, 0), "Medium stone grey", Enum.Material.Cobblestone, safeZone)

-- Paths from gates
makePart("WestPath", Vector3.new(30, 0.12, 6), Vector3.new(-78, 0.06, 50), "Brown", Enum.Material.Ground, safeZone)
makePart("EastPath", Vector3.new(30, 0.12, 6), Vector3.new(78, 0.06, 50), "Brown", Enum.Material.Ground, safeZone)
makePart("SouthPath", Vector3.new(8, 0.12, 40), Vector3.new(0, 0.06, 128), "Brown", Enum.Material.Ground, safeZone)

-- Bushes (safe zone, sparse)
for i = 1, 12 do
	local bx = -60 + math.random(0, 220)
	local bz = 115 + math.random(0, 100)
	local bs = 1.5 + math.random() * 1.5
	makePart("Bush"..i, Vector3.new(bs, bs * 0.7, bs), Vector3.new(bx, bs * 0.35, bz), "Forest green", Enum.Material.Grass, safeZone, {CanCollide = false})
end

-- Flowers near Haven
local flowerColors = {"Bright red", "Bright yellow", "Bright violet", "Hot pink"}
for i = 1, 12 do
	local fx = -40 + math.random(0, 80)
	local fz = 115 + math.random(0, 40)
	makePart("Flower"..i, Vector3.new(0.5, 0.8, 0.5), Vector3.new(fx, 0.4, fz), flowerColors[math.random(#flowerColors)], Enum.Material.SmoothPlastic, safeZone, {CanCollide = false})
end

-- Rock formations near mine
for i = 1, 4 do
	local rx = -112 + i * 8
	local rs = 3 + math.random() * 3
	makePart("MineRock"..i, Vector3.new(rs, rs * 1.2, rs * 0.8), Vector3.new(rx, rs * 0.6, 25 + math.random(0, 10)), "Dark stone grey", Enum.Material.Slate, safeZone)
end

-- ============================================================
-- === LIGHTING ===
-- ============================================================
local Lighting = game:GetService("Lighting")
Lighting.Ambient = Color3.fromRGB(80, 80, 100)
Lighting.OutdoorAmbient = Color3.fromRGB(100, 100, 120)
Lighting.Brightness = 1.5
Lighting.ClockTime = 10
Lighting.FogEnd = 1200
Lighting.FogColor = Color3.fromRGB(180, 200, 220)

-- ============================================================
-- CRIMSON WARLORD BATTLE ARENA (0, 0, 250)
-- Grand circular arena south of Haven â€” the centerpiece boss fight
-- ============================================================
local arenaFolder = getOrMake(safeZone, "BattleArena")

-- Arena floor â€” large circular stone platform
makePart("ArenaFloor", Vector3.new(40, 0.5, 40), Vector3.new(0, 0.25, 250), "Medium stone grey", Enum.Material.Cobblestone, arenaFolder)
-- Inner ring (darker)
makePart("ArenaInner", Vector3.new(28, 0.52, 28), Vector3.new(0, 0.27, 250), "Dark stone grey", Enum.Material.Slate, arenaFolder)
-- Center crimson circle (boss spawn point)
makePart("ArenaCenterRing", Vector3.new(10, 0.54, 10), Vector3.new(0, 0.28, 250), Color3.fromRGB(120, 20, 20), Enum.Material.Marble, arenaFolder)
makePart("ArenaCenterCore", Vector3.new(5, 0.56, 5), Vector3.new(0, 0.29, 250), Color3.fromRGB(180, 30, 30), Enum.Material.Neon, arenaFolder, {Transparency = 0.3})

-- Arena walls (stone pillars around perimeter)
local pillarAngles = 12
for i = 1, pillarAngles do
	local angle = (i / pillarAngles) * math.pi * 2
	local px = math.cos(angle) * 22
	local pz = math.sin(angle) * 22 + 250

	-- Stone pillar
	makePart("ArenaPillar" .. i, Vector3.new(2, 10, 2), Vector3.new(px, 5, pz), "Dark stone grey", Enum.Material.Cobblestone, arenaFolder)
	-- Pillar cap
	makePart("PillarCap" .. i, Vector3.new(2.5, 0.5, 2.5), Vector3.new(px, 10.25, pz), "Dark stone grey", Enum.Material.Slate, arenaFolder)

	-- Every 3rd pillar gets a torch
	if i % 3 == 0 then
		makePart("Torch" .. i, Vector3.new(0.3, 1.5, 0.3), Vector3.new(px, 8.5, pz), "Brown", Enum.Material.Wood, arenaFolder)
		local flame = makePart("TorchFlame" .. i, Vector3.new(0.6, 0.8, 0.6), Vector3.new(px, 9.5, pz), Color3.fromRGB(255, 100, 0), Enum.Material.Neon, arenaFolder, {Transparency = 0.3, CanCollide = false})
	end
end

-- Iron chain fences between pillars (low walls)
for i = 1, pillarAngles do
	local a1 = (i / pillarAngles) * math.pi * 2
	local a2 = ((i % pillarAngles + 1) / pillarAngles) * math.pi * 2
	local mx = (math.cos(a1) + math.cos(a2)) / 2 * 22
	local mz = (math.sin(a1) + math.sin(a2)) / 2 * 22 + 250
	local dx = math.cos(a2) * 22 - math.cos(a1) * 22
	local dz = (math.sin(a2) - math.sin(a1)) * 22
	local fenceLen = math.sqrt(dx * dx + dz * dz)
	local fenceAngle = math.deg(math.atan2(dx, dz))
	makePart("ArenaFence" .. i, Vector3.new(fenceLen, 3, 0.5), Vector3.new(mx, 1.5, mz), "Dark stone grey", Enum.Material.Metal, arenaFolder, {CanCollide = true, Orientation = Vector3.new(0, fenceAngle, 0)})
end

-- Entrance path from Haven (north side of arena)
makePart("ArenaPath", Vector3.new(6, 0.3, 30), Vector3.new(0, 0.15, 220), "Brown", Enum.Material.Ground, arenaFolder)
makePart("ArenaPathStone", Vector3.new(8, 0.4, 4), Vector3.new(0, 0.2, 230), "Medium stone grey", Enum.Material.Cobblestone, arenaFolder)

-- Grand entrance arch
makePart("ArchLeft", Vector3.new(2, 12, 2), Vector3.new(-4, 6, 228), "Dark stone grey", Enum.Material.Cobblestone, arenaFolder)
makePart("ArchRight", Vector3.new(2, 12, 2), Vector3.new(4, 6, 228), "Dark stone grey", Enum.Material.Cobblestone, arenaFolder)
makePart("ArchTop", Vector3.new(10, 2, 2), Vector3.new(0, 12, 228), "Dark stone grey", Enum.Material.Cobblestone, arenaFolder)
-- Crimson banner on arch
makePart("BannerL", Vector3.new(0.1, 4, 1.5), Vector3.new(-3, 8, 227.5), Color3.fromRGB(120, 15, 15), Enum.Material.Fabric, arenaFolder)
makePart("BannerR", Vector3.new(0.1, 4, 1.5), Vector3.new(3, 8, 227.5), Color3.fromRGB(120, 15, 15), Enum.Material.Fabric, arenaFolder)

-- Arena sign
local arenaSign = makePart("ArenaSign", Vector3.new(1, 1, 1), Vector3.new(0, 14, 228), "White", nil, arenaFolder, {Transparency = 1})
makeSign(arenaSign, "CRIMSON ARENA", Vector3.new(0, 0, 0), UDim2.new(10, 0, 2, 0))

-- Skull decorations on ground near entrance
makePart("Skull1", Vector3.new(0.8, 0.8, 0.8), Vector3.new(-6, 0.4, 232), "White", Enum.Material.SmoothPlastic, arenaFolder)
makePart("Skull2", Vector3.new(0.8, 0.8, 0.8), Vector3.new(7, 0.4, 235), "White", Enum.Material.SmoothPlastic, arenaFolder)

-- Weapon racks (decoration on sides)
makePart("WeaponRack1", Vector3.new(3, 4, 0.5), Vector3.new(-18, 2, 245), "Brown", Enum.Material.Wood, arenaFolder)
makePart("RackSword1", Vector3.new(0.2, 3, 0.1), Vector3.new(-18, 3, 244.5), Color3.fromRGB(180, 180, 190), Enum.Material.Metal, arenaFolder)
makePart("WeaponRack2", Vector3.new(3, 4, 0.5), Vector3.new(18, 2, 245), "Brown", Enum.Material.Wood, arenaFolder)
makePart("RackSword2", Vector3.new(0.2, 3, 0.1), Vector3.new(18, 3, 244.5), Color3.fromRGB(180, 180, 190), Enum.Material.Metal, arenaFolder)

print("[MapSetup] Battle Arena built at (0, 0, 250)")

-- ============================================================
-- WILDERNESS CASTLE â€” "The Dark Fortress" (0, 0, -350)
-- Deep wilderness PvP castle. Multi-level, towers, moat, throne room.
-- Center of PvP warfare. High-risk, high-reward territory.
-- ============================================================
local castleFolder = getOrMake(wilderness, "DarkFortress")
local CX, CZ = 0, -350 -- Castle center

-- === MOAT (lava ring around castle) ===
-- Outer lava moat ring (4 segments)
makePart("MoatN", Vector3.new(80, 2, 8), Vector3.new(CX, -1, CZ - 44), Color3.fromRGB(200, 60, 0), Enum.Material.Neon, castleFolder, {Transparency = 0.2, CanCollide = false})
makePart("MoatS", Vector3.new(80, 2, 8), Vector3.new(CX, -1, CZ + 44), Color3.fromRGB(200, 60, 0), Enum.Material.Neon, castleFolder, {Transparency = 0.2, CanCollide = false})
makePart("MoatE", Vector3.new(8, 2, 80), Vector3.new(CX + 44, -1, CZ), Color3.fromRGB(200, 60, 0), Enum.Material.Neon, castleFolder, {Transparency = 0.2, CanCollide = false})
makePart("MoatW", Vector3.new(8, 2, 80), Vector3.new(CX - 44, -1, CZ), Color3.fromRGB(200, 60, 0), Enum.Material.Neon, castleFolder, {Transparency = 0.2, CanCollide = false})

-- Drawbridge (south entrance â€” from Haven direction)
makePart("Drawbridge", Vector3.new(12, 1, 10), Vector3.new(CX, 0.5, CZ + 44), "Brown", Enum.Material.WoodPlanks, castleFolder)

-- === OUTER WALLS (40x40 perimeter, 20 studs high) ===
local WH = 20 -- wall height
local WS2 = 40 -- half-size of castle square
makePart("OuterWallN", Vector3.new(80, WH, 4), Vector3.new(CX, WH/2, CZ - WS2), "Dark stone grey", Enum.Material.Cobblestone, castleFolder)
makePart("OuterWallS_L", Vector3.new(30, WH, 4), Vector3.new(CX - 25, WH/2, CZ + WS2), "Dark stone grey", Enum.Material.Cobblestone, castleFolder)
makePart("OuterWallS_R", Vector3.new(30, WH, 4), Vector3.new(CX + 25, WH/2, CZ + WS2), "Dark stone grey", Enum.Material.Cobblestone, castleFolder)
makePart("OuterWallS_Top", Vector3.new(20, 8, 4), Vector3.new(CX, WH - 4 + WH/2 - 6, CZ + WS2), "Dark stone grey", Enum.Material.Cobblestone, castleFolder)
makePart("OuterWallE", Vector3.new(4, WH, 80), Vector3.new(CX + WS2, WH/2, CZ), "Dark stone grey", Enum.Material.Cobblestone, castleFolder)
makePart("OuterWallW", Vector3.new(4, WH, 80), Vector3.new(CX - WS2, WH/2, CZ), "Dark stone grey", Enum.Material.Cobblestone, castleFolder)

-- Gate arch (south wall gap)
makePart("GateArchTop", Vector3.new(20, 6, 4), Vector3.new(CX, WH - 3, CZ + WS2), "Dark stone grey", Enum.Material.Cobblestone, castleFolder)
-- Portcullis (iron gate)
makePart("Portcullis", Vector3.new(12, 14, 0.5), Vector3.new(CX, 7, CZ + WS2), Color3.fromRGB(60, 60, 70), Enum.Material.Metal, castleFolder, {Transparency = 0.3, CanCollide = false})

-- === WALL CRENELLATIONS (battlements along top) ===
for i = -36, 36, 4 do
	-- North wall merlons
	makePart("MerlonN" .. i, Vector3.new(2, 3, 1), Vector3.new(CX + i, WH + 1.5, CZ - WS2 + 2), "Dark stone grey", Enum.Material.Cobblestone, castleFolder)
	-- South wall merlons (skip gate area)
	if math.abs(i) > 8 then
		makePart("MerlonS" .. i, Vector3.new(2, 3, 1), Vector3.new(CX + i, WH + 1.5, CZ + WS2 - 2), "Dark stone grey", Enum.Material.Cobblestone, castleFolder)
	end
end
for i = -36, 36, 4 do
	makePart("MerlonE" .. i, Vector3.new(1, 3, 2), Vector3.new(CX + WS2 - 2, WH + 1.5, CZ + i), "Dark stone grey", Enum.Material.Cobblestone, castleFolder)
	makePart("MerlonW" .. i, Vector3.new(1, 3, 2), Vector3.new(CX - WS2 + 2, WH + 1.5, CZ + i), "Dark stone grey", Enum.Material.Cobblestone, castleFolder)
end

-- Wall walkway (along top of walls)
makePart("WalkwayN", Vector3.new(76, 1, 4), Vector3.new(CX, WH + 0.5, CZ - WS2), "Medium stone grey", Enum.Material.Slate, castleFolder)
makePart("WalkwayS", Vector3.new(76, 1, 4), Vector3.new(CX, WH + 0.5, CZ + WS2), "Medium stone grey", Enum.Material.Slate, castleFolder)
makePart("WalkwayE", Vector3.new(4, 1, 76), Vector3.new(CX + WS2, WH + 0.5, CZ), "Medium stone grey", Enum.Material.Slate, castleFolder)
makePart("WalkwayW", Vector3.new(4, 1, 76), Vector3.new(CX - WS2, WH + 0.5, CZ), "Medium stone grey", Enum.Material.Slate, castleFolder)

-- === CORNER TOWERS (4 towers, 30 studs tall) ===
local TH = 30
local corners = {
	{CX - WS2, CZ - WS2, "NW"},
	{CX + WS2, CZ - WS2, "NE"},
	{CX - WS2, CZ + WS2, "SW"},
	{CX + WS2, CZ + WS2, "SE"},
}
for _, c in ipairs(corners) do
	local tx, tz, tag = c[1], c[2], c[3]
	-- Tower body (cylindrical look â€” octagonal with 2 parts)
	makePart("Tower" .. tag, Vector3.new(8, TH, 8), Vector3.new(tx, TH/2, tz), "Dark stone grey", Enum.Material.Cobblestone, castleFolder)
	-- Tower cap (wider top)
	makePart("TowerCap" .. tag, Vector3.new(10, 2, 10), Vector3.new(tx, TH + 1, tz), "Dark stone grey", Enum.Material.Slate, castleFolder)
	-- Tower roof (pointed)
	makeWedge("TowerRoof" .. tag .. "A", Vector3.new(10, 8, 6), Vector3.new(tx, TH + 6, tz - 2), "Dark red", Enum.Material.Slate, castleFolder)
	makeWedge("TowerRoof" .. tag .. "B", Vector3.new(10, 8, 6), Vector3.new(tx, TH + 6, tz + 2), "Dark red", Enum.Material.Slate, castleFolder, {Orientation = Vector3.new(0, 180, 0)})
	-- Tower merlons (4 per tower)
	makePart("TowerMerlon" .. tag .. "1", Vector3.new(2, 3, 1), Vector3.new(tx - 3, TH + 3.5, tz - 4), "Dark stone grey", Enum.Material.Cobblestone, castleFolder)
	makePart("TowerMerlon" .. tag .. "2", Vector3.new(2, 3, 1), Vector3.new(tx + 3, TH + 3.5, tz - 4), "Dark stone grey", Enum.Material.Cobblestone, castleFolder)
	makePart("TowerMerlon" .. tag .. "3", Vector3.new(2, 3, 1), Vector3.new(tx - 3, TH + 3.5, tz + 4), "Dark stone grey", Enum.Material.Cobblestone, castleFolder)
	makePart("TowerMerlon" .. tag .. "4", Vector3.new(2, 3, 1), Vector3.new(tx + 3, TH + 3.5, tz + 4), "Dark stone grey", Enum.Material.Cobblestone, castleFolder)
	-- Torch on each tower
	makePart("TowerTorch" .. tag, Vector3.new(0.4, 2, 0.4), Vector3.new(tx, TH - 4, tz + 4.5), "Brown", Enum.Material.Wood, castleFolder)
	makePart("TowerFlame" .. tag, Vector3.new(0.8, 1, 0.8), Vector3.new(tx, TH - 2.5, tz + 4.5), Color3.fromRGB(255, 120, 0), Enum.Material.Neon, castleFolder, {CanCollide = false, Transparency = 0.2})
end

-- === COURTYARD (ground floor) ===
makePart("CourtyardFloor", Vector3.new(72, 0.5, 72), Vector3.new(CX, 0.25, CZ), "Medium stone grey", Enum.Material.Cobblestone, castleFolder)
-- Darker inner pattern
makePart("CourtyardInner", Vector3.new(40, 0.52, 40), Vector3.new(CX, 0.27, CZ), "Dark stone grey", Enum.Material.Slate, castleFolder)

-- === THE KEEP (central tower â€” throne room) ===
local KH = 25 -- keep height
-- Keep walls
makePart("KeepWallN", Vector3.new(24, KH, 3), Vector3.new(CX, KH/2, CZ - 12), Color3.fromRGB(50, 45, 55), Enum.Material.Cobblestone, castleFolder)
makePart("KeepWallS_L", Vector3.new(8, KH, 3), Vector3.new(CX - 8, KH/2, CZ + 12), Color3.fromRGB(50, 45, 55), Enum.Material.Cobblestone, castleFolder)
makePart("KeepWallS_R", Vector3.new(8, KH, 3), Vector3.new(CX + 8, KH/2, CZ + 12), Color3.fromRGB(50, 45, 55), Enum.Material.Cobblestone, castleFolder)
makePart("KeepArch", Vector3.new(8, 8, 3), Vector3.new(CX, KH - 4, CZ + 12), Color3.fromRGB(50, 45, 55), Enum.Material.Cobblestone, castleFolder)
makePart("KeepWallE", Vector3.new(3, KH, 24), Vector3.new(CX + 12, KH/2, CZ), Color3.fromRGB(50, 45, 55), Enum.Material.Cobblestone, castleFolder)
makePart("KeepWallW", Vector3.new(3, KH, 24), Vector3.new(CX - 12, KH/2, CZ), Color3.fromRGB(50, 45, 55), Enum.Material.Cobblestone, castleFolder)
-- Keep floor
makePart("KeepFloor", Vector3.new(21, 0.6, 21), Vector3.new(CX, 0.3, CZ), Color3.fromRGB(40, 35, 45), Enum.Material.Marble, castleFolder)
-- Keep roof / upper floor
makePart("KeepUpperFloor", Vector3.new(21, 1, 21), Vector3.new(CX, KH - 5, CZ), Color3.fromRGB(50, 45, 55), Enum.Material.Slate, castleFolder)
-- Keep roof
makeWedge("KeepRoofN", Vector3.new(24, 10, 14), Vector3.new(CX, KH + 5, CZ - 5), "Dark red", Enum.Material.Slate, castleFolder)
makeWedge("KeepRoofS", Vector3.new(24, 10, 14), Vector3.new(CX, KH + 5, CZ + 5), "Dark red", Enum.Material.Slate, castleFolder, {Orientation = Vector3.new(0, 180, 0)})

-- === THRONE (capture point) ===
-- Throne platform
makePart("ThronePlatform", Vector3.new(8, 1, 6), Vector3.new(CX, 1, CZ - 6), Color3.fromRGB(80, 20, 20), Enum.Material.Marble, castleFolder)
-- Throne back
makePart("ThroneBack", Vector3.new(4, 8, 1), Vector3.new(CX, 5, CZ - 8.5), Color3.fromRGB(60, 15, 15), Enum.Material.Metal, castleFolder)
-- Throne seat
makePart("ThroneSeat", Vector3.new(4, 1, 3), Vector3.new(CX, 2, CZ - 7), Color3.fromRGB(80, 20, 20), Enum.Material.Marble, castleFolder)
-- Throne armrests
makePart("ThroneArmL", Vector3.new(0.5, 3, 3), Vector3.new(CX - 2.2, 3, CZ - 7), Color3.fromRGB(60, 15, 15), Enum.Material.Metal, castleFolder)
makePart("ThroneArmR", Vector3.new(0.5, 3, 3), Vector3.new(CX + 2.2, 3, CZ - 7), Color3.fromRGB(60, 15, 15), Enum.Material.Metal, castleFolder)
-- Skull ornaments on throne
makePart("ThroneSkull1", Vector3.new(1, 1, 1), Vector3.new(CX - 1, 8.5, CZ - 8.5), "White", Enum.Material.SmoothPlastic, castleFolder)
makePart("ThroneSkull2", Vector3.new(1, 1, 1), Vector3.new(CX + 1, 8.5, CZ - 8.5), "White", Enum.Material.SmoothPlastic, castleFolder)
-- Crown above throne (glowing)
makePart("ThroneCrown", Vector3.new(2, 1, 2), Vector3.new(CX, 9.5, CZ - 8.5), Color3.fromRGB(255, 200, 50), Enum.Material.Neon, castleFolder, {Transparency = 0.2})

-- Capture point indicator (glowing floor ring)
makePart("CaptureRing", Vector3.new(10, 0.1, 8), Vector3.new(CX, 1.6, CZ - 6), Color3.fromRGB(200, 150, 0), Enum.Material.Neon, castleFolder, {Transparency = 0.5})

-- === STAIRCASES (access to wall walkways) ===
-- SW staircase (from courtyard to south wall)
for step = 0, 9 do
	local sy = step * 2 + 0.5
	local sz = CZ + 30 - step * 1.5
	makePart("StairSW" .. step, Vector3.new(4, 1, 2), Vector3.new(CX - 30, sy, sz), "Medium stone grey", Enum.Material.Slate, castleFolder)
end
-- NE staircase
for step = 0, 9 do
	local sy = step * 2 + 0.5
	local sz = CZ - 30 + step * 1.5
	makePart("StairNE" .. step, Vector3.new(4, 1, 2), Vector3.new(CX + 30, sy, sz), "Medium stone grey", Enum.Material.Slate, castleFolder)
end

-- === BANNERS & DECORATIONS ===
-- Dark purple/red banners on walls
local bannerPositions = {
	{CX - 15, 12, CZ - WS2 + 2.5}, {CX, 12, CZ - WS2 + 2.5}, {CX + 15, 12, CZ - WS2 + 2.5},
	{CX - 15, 12, CZ + WS2 - 2.5}, {CX + 15, 12, CZ + WS2 - 2.5},
}
for bi, bp in ipairs(bannerPositions) do
	makePart("Banner" .. bi, Vector3.new(0.1, 6, 3), Vector3.new(bp[1], bp[2], bp[3]), Color3.fromRGB(60, 10, 40), Enum.Material.Fabric, castleFolder)
	makePart("BannerPole" .. bi, Vector3.new(0.2, 0.2, 3.5), Vector3.new(bp[1], bp[2] + 3.2, bp[3]), Color3.fromRGB(80, 70, 60), Enum.Material.Metal, castleFolder)
end

-- Courtyard torches (8 around the courtyard)
for ti = 1, 8 do
	local angle = (ti / 8) * math.pi * 2
	local ttx = CX + math.cos(angle) * 25
	local ttz = CZ + math.sin(angle) * 25
	makePart("CTorch" .. ti, Vector3.new(0.5, 3, 0.5), Vector3.new(ttx, 2.5, ttz), "Brown", Enum.Material.Wood, castleFolder)
	makePart("CFlame" .. ti, Vector3.new(0.8, 1.2, 0.8), Vector3.new(ttx, 4.5, ttz), Color3.fromRGB(255, 100, 0), Enum.Material.Neon, castleFolder, {CanCollide = false, Transparency = 0.2})
end

-- Weapon racks in courtyard
makePart("CWRack1", Vector3.new(4, 5, 0.5), Vector3.new(CX - 18, 2.5, CZ + 15), "Brown", Enum.Material.Wood, castleFolder)
makePart("CWSword1", Vector3.new(0.2, 4, 0.1), Vector3.new(CX - 18, 3, CZ + 14.5), Color3.fromRGB(180, 180, 190), Enum.Material.Metal, castleFolder)
makePart("CWRack2", Vector3.new(4, 5, 0.5), Vector3.new(CX + 18, 2.5, CZ + 15), "Brown", Enum.Material.Wood, castleFolder)
makePart("CWSword2", Vector3.new(0.2, 4, 0.1), Vector3.new(CX + 18, 3, CZ + 14.5), Color3.fromRGB(180, 180, 190), Enum.Material.Metal, castleFolder)

-- Training dummies in courtyard
makePart("CDummy1Post", Vector3.new(0.5, 4, 0.5), Vector3.new(CX - 12, 2, CZ + 20), "Brown", Enum.Material.Wood, castleFolder)
makePart("CDummy1Body", Vector3.new(2, 2, 1), Vector3.new(CX - 12, 4, CZ + 20), "Bright orange", Enum.Material.Fabric, castleFolder)
makePart("CDummy1Arm", Vector3.new(3, 0.5, 0.5), Vector3.new(CX - 12, 4.5, CZ + 20), "Brown", Enum.Material.Wood, castleFolder)

-- Castle floor (dark wilderness ground around it)
makePart("CastleGround", Vector3.new(120, 0.15, 120), Vector3.new(CX, 0.05, CZ), Color3.fromRGB(30, 25, 22), Enum.Material.Ground, castleFolder)

-- Castle sign
local castleSign = makePart("CastleSign", Vector3.new(1, 1, 1), Vector3.new(CX, 24, CZ + WS2 + 2), "White", nil, castleFolder, {Transparency = 1})
makeSign(castleSign, "THE DARK FORTRESS", Vector3.new(0, 0, 0), UDim2.new(14, 0, 3, 0))

-- Warning sign outside
local castleWarn = makePart("CastleWarn", Vector3.new(1, 1, 1), Vector3.new(CX, 4, CZ + 55), "White", nil, castleFolder, {Transparency = 1})
makeSign(castleWarn, "PVP ZONE - ENTER AT YOUR OWN RISK", Vector3.new(0, 0, 0), UDim2.new(16, 0, 2, 0))

print("[MapSetup] Dark Fortress built at (0, 0, -350)")

-- ============================================================
print("[MapSetup] World generation complete!")
print("[MapSetup] Haven + 6 wilderness zones + terrain features + Crimson Arena + Dark Fortress")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="142">
      <Properties>
        <string name="Name">MapSetup2</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- MapSetup2.server.lua
-- WORLD EXPANSION: Areas outside Haven, safe zone content, and deep wilderness
-- Runs AFTER MapSetup.server.lua

task.wait(1) -- let MapSetup finish first
print("[MapSetup2] Starting world expansion...")

local WS = game:GetService("Workspace")

local function makePart(name, size, position, color, material, parent, props)
	local p = Instance.new("Part")
	p.Name = name
	p.Size = size
	p.Position = position
	p.Anchored = true
	if typeof(color) == "Color3" then
		p.Color = color
	else
		p.BrickColor = BrickColor.new(color)
	end
	p.Material = material or Enum.Material.SmoothPlastic
	p.Parent = parent
	if props then for k, v in pairs(props) do p[k] = v end end
	return p
end

local function makeSign(parent, text, offset, size)
	local bg = Instance.new("BillboardGui")
	bg.Size = size or UDim2.new(10, 0, 2.5, 0)
	bg.StudsOffset = offset or Vector3.new(0, 5, 0)
	bg.Parent = parent
	local tl = Instance.new("TextLabel")
	tl.Size = UDim2.new(1, 0, 1, 0)
	tl.BackgroundTransparency = 1
	tl.Text = text
	tl.TextColor3 = Color3.fromRGB(255, 255, 255)
	tl.TextScaled = true
	tl.Font = Enum.Font.GothamBold
	tl.TextStrokeTransparency = 0.3
	tl.Parent = bg
	return bg
end

local function makeTorch(position, parent)
	local pole = makePart("TorchPole", Vector3.new(0.5, 6, 0.5), position, "Reddish brown", Enum.Material.Wood, parent)
	local flame = makePart("TorchFlame", Vector3.new(1, 1.5, 1), position + Vector3.new(0, 3.5, 0), "Bright orange", Enum.Material.Neon, parent, {Transparency = 0.2})
	local light = Instance.new("PointLight")
	light.Color = Color3.fromRGB(255, 150, 50)
	light.Brightness = 2
	light.Range = 20
	light.Parent = flame
end

local function makeLantern(position, parent)
	makePart("LPost", Vector3.new(0.4, 5, 0.4), position, "Dark stone grey", Enum.Material.Metal, parent)
	local lamp = makePart("Lamp", Vector3.new(1.2, 1.5, 1.2), position + Vector3.new(0, 3.2, 0), "Bright yellow", Enum.Material.Neon, parent, {Transparency = 0.3})
	local light = Instance.new("PointLight")
	light.Color = Color3.fromRGB(255, 220, 120)
	light.Brightness = 1.5
	light.Range = 25
	light.Parent = lamp
end

local function makeTree(position, parent, scale, leafColor)
	scale = scale or 1
	leafColor = leafColor or "Forest green"
	makePart("Trunk", Vector3.new(2*scale, 10*scale, 2*scale), position + Vector3.new(0, 5*scale, 0), "Reddish brown", Enum.Material.Wood, parent)
	makePart("Leaves", Vector3.new(10*scale, 10*scale, 10*scale), position + Vector3.new(0, 11*scale, 0), leafColor, Enum.Material.Grass, parent)
end

local function makeHouse(position, parent, width, depth, height, wallColor, roofColor, name)
	local f = Instance.new("Folder") f.Name = name or "House" f.Parent = parent
	makePart("Floor", Vector3.new(width, 0.3, depth), position + Vector3.new(0, 0.15, 0), "Reddish brown", Enum.Material.WoodPlanks, f)
	makePart("WallBack", Vector3.new(width, height, 1), position + Vector3.new(0, height/2, -depth/2), wallColor, Enum.Material.Brick, f)
	makePart("WallLeft", Vector3.new(1, height, depth), position + Vector3.new(-width/2, height/2, 0), wallColor, Enum.Material.Brick, f)
	makePart("WallRight", Vector3.new(1, height, depth), position + Vector3.new(width/2, height/2, 0), wallColor, Enum.Material.Brick, f)
	makePart("Roof", Vector3.new(width+2, 1, depth+2), position + Vector3.new(0, height+0.5, 0), roofColor, Enum.Material.Slate, f)
	return f
end

local function getOrMake(parent, name)
	local f = parent:FindFirstChild(name)
	if not f then f = Instance.new("Folder") f.Name = name f.Parent = parent end
	return f
end

local safeZone = getOrMake(WS, "SafeZone")
local wilderness = getOrMake(WS, "Wilderness")

-- ============================================================
-- 1. FARMLANDS (east, x=100-250, z=120-220)
-- ============================================================
print("[MapSetup2] Building Farmlands...")
local farm = getOrMake(safeZone, "Farmlands")

-- Dirt ground
makePart("FarmGround", Vector3.new(160, 0.15, 110), Vector3.new(175, 0.08, 170), "Brown", Enum.Material.Ground, farm)

-- Wheat fields (rows of yellow)
for row = 0, 5 do
	for col = 0, 8 do
		makePart("Wheat", Vector3.new(3, 2, 12), Vector3.new(110 + col * 7, 1, 130 + row * 14), "Bright yellow", Enum.Material.Grass, farm, {CanCollide = false})
	end
end

-- Farmhouse 1
local fh1 = makeHouse(Vector3.new(200, 0, 140), farm, 14, 10, 8, "Brick yellow", "Reddish brown", "Farmhouse1")
local fh1Sign = makePart("Sign", Vector3.new(1,1,1), Vector3.new(200, 10, 145), "White", nil, farm, {Transparency = 1})
makeSign(fh1Sign, "ðŸ¡ Old MacDonald's Farm", Vector3.new(0,0,0))

-- Farmhouse 2
makeHouse(Vector3.new(230, 0, 180), farm, 12, 8, 7, "Brown", "Dark stone grey", "Farmhouse2")

-- Fences around pasture
for i = 0, 15 do
	makePart("FencePost", Vector3.new(0.5, 3, 0.5), Vector3.new(155 + i * 6, 1.5, 155), "Reddish brown", Enum.Material.Wood, farm)
	makePart("FenceRail", Vector3.new(6, 0.3, 0.3), Vector3.new(158 + i * 6, 2.2, 155), "Reddish brown", Enum.Material.Wood, farm)
	makePart("FenceRail2", Vector3.new(6, 0.3, 0.3), Vector3.new(158 + i * 6, 1.2, 155), "Reddish brown", Enum.Material.Wood, farm)
end
for i = 0, 8 do
	makePart("FencePost", Vector3.new(0.5, 3, 0.5), Vector3.new(155, 1.5, 155 + i * 6), "Reddish brown", Enum.Material.Wood, farm)
	makePart("FencePost", Vector3.new(0.5, 3, 0.5), Vector3.new(245, 1.5, 155 + i * 6), "Reddish brown", Enum.Material.Wood, farm)
end

-- Scarecrow
makePart("ScarecrowPole", Vector3.new(0.5, 6, 0.5), Vector3.new(140, 3, 145), "Reddish brown", Enum.Material.Wood, farm)
makePart("ScarecrowArms", Vector3.new(4, 0.5, 0.5), Vector3.new(140, 5, 145), "Reddish brown", Enum.Material.Wood, farm)
makePart("ScarecrowHead", Vector3.new(1.5, 1.5, 1.5), Vector3.new(140, 6.5, 145), "Bright orange", Enum.Material.SmoothPlastic, farm)

-- Hay bales
for i = 1, 6 do
	makePart("HayBale"..i, Vector3.new(3, 2, 3), Vector3.new(210 + math.random(-5,5), 1, 165 + math.random(-5,5)), "Bright yellow", Enum.Material.Grass, farm)
end

-- Windmill
makePart("WindmillBase", Vector3.new(8, 20, 8), Vector3.new(240, 10, 145), "Brick yellow", Enum.Material.Brick, farm)
makePart("WindmillRoof", Vector3.new(10, 2, 10), Vector3.new(240, 21, 145), "Reddish brown", Enum.Material.Wood, farm)
-- Sails (simplified as crossed planks)
makePart("Sail1", Vector3.new(1, 18, 1), Vector3.new(240, 18, 141), "White", Enum.Material.Fabric, farm, {CanCollide = false})
makePart("Sail2", Vector3.new(18, 1, 1), Vector3.new(240, 18, 141), "White", Enum.Material.Fabric, farm, {CanCollide = false})

-- Chicken coop
makePart("CoopBase", Vector3.new(6, 3, 5), Vector3.new(170, 1.5, 170), "Reddish brown", Enum.Material.Wood, farm)
makePart("CoopRoof", Vector3.new(7, 0.5, 6), Vector3.new(170, 3.5, 170), "Reddish brown", Enum.Material.Wood, farm)
makePart("CoopFence", Vector3.new(12, 2, 0.3), Vector3.new(170, 1, 175), "Reddish brown", Enum.Material.Wood, farm)

task.wait()

-- ============================================================
-- 2. HAVEN LAKE (west, x=-200 to -100, z=100-200)
-- ============================================================
print("[MapSetup2] Building Haven Lake...")
local lake = getOrMake(safeZone, "HavenLake")

-- Lake water
makePart("LakeWater", Vector3.new(80, 1, 60), Vector3.new(-150, -0.5, 150), Color3.fromRGB(65, 130, 175), Enum.Material.Water, lake, {Transparency = 0.3, CanCollide = false})
-- Sandy beach (south side)
makePart("Beach", Vector3.new(90, 0.3, 15), Vector3.new(-150, 0.15, 185), "Brick yellow", Enum.Material.Sand, lake)
-- Dirt banks
makePart("BankNorth", Vector3.new(90, 0.8, 5), Vector3.new(-150, 0.1, 118), "Brown", Enum.Material.Ground, lake)
makePart("BankWest", Vector3.new(5, 0.8, 70), Vector3.new(-195, 0.1, 150), "Brown", Enum.Material.Ground, lake)
makePart("BankEast", Vector3.new(5, 0.8, 70), Vector3.new(-105, 0.1, 150), "Brown", Enum.Material.Ground, lake)

-- Fishing dock
makePart("Dock", Vector3.new(5, 0.6, 20), Vector3.new(-130, 0.5, 170), "Reddish brown", Enum.Material.WoodPlanks, lake)
makePart("DockPost1", Vector3.new(0.5, 3, 0.5), Vector3.new(-128, 0.5, 180), "Reddish brown", Enum.Material.Wood, lake)
makePart("DockPost2", Vector3.new(0.5, 3, 0.5), Vector3.new(-132, 0.5, 180), "Reddish brown", Enum.Material.Wood, lake)

-- Rowboat
makePart("BoatHull", Vector3.new(3, 1, 6), Vector3.new(-140, 0.2, 165), "Reddish brown", Enum.Material.Wood, lake)
makePart("BoatSeat", Vector3.new(2, 0.3, 1), Vector3.new(-140, 1, 165), "Reddish brown", Enum.Material.Wood, lake)

-- Small island in lake
makePart("Island", Vector3.new(12, 1, 10), Vector3.new(-155, 0.2, 148), "Bright green", Enum.Material.Grass, lake)
makeTree(Vector3.new(-155, 0.7, 148), lake, 0.8, "Forest green")

-- Lighthouse
makePart("LighthouseBase", Vector3.new(6, 25, 6), Vector3.new(-192, 12.5, 135), "White", Enum.Material.Brick, lake)
makePart("LighthouseTop", Vector3.new(8, 3, 8), Vector3.new(-192, 26.5, 135), "Bright red", Enum.Material.Brick, lake)
local lhLight = makePart("LighthouseLight", Vector3.new(2, 2, 2), Vector3.new(-192, 29, 135), "Bright yellow", Enum.Material.Neon, lake, {Transparency = 0.2})
local pl = Instance.new("PointLight") pl.Color = Color3.fromRGB(255, 255, 200) pl.Brightness = 5 pl.Range = 60 pl.Parent = lhLight

-- Cattails/reeds
for i = 1, 12 do
	local rx = -190 + math.random(0, 80)
	local rz = 120 + math.random(0, 60)
	makePart("Reed"..i, Vector3.new(0.3, 2 + math.random(), 0.3), Vector3.new(rx, 1, rz), "Earth green", Enum.Material.Grass, lake)
end

local lakeSign = makePart("LakeSign", Vector3.new(1,1,1), Vector3.new(-150, 4, 190), "White", nil, lake, {Transparency = 1})
makeSign(lakeSign, "ðŸžï¸ Haven Lake", Vector3.new(0,0,0))

task.wait()

-- ============================================================
-- 3. COMBAT TRAINING GROUNDS (east, x=150-250, z=-30 to 70)
-- ============================================================
print("[MapSetup2] Building Training Grounds...")
local training = getOrMake(safeZone, "TrainingGrounds")

-- Arena floor
makePart("ArenaFloor", Vector3.new(80, 0.2, 80), Vector3.new(195, 0.1, 20), "Brown", Enum.Material.Ground, training)
-- Arena walls (stone)
makePart("ArenaWallN", Vector3.new(84, 8, 3), Vector3.new(195, 4, -22), "Medium stone grey", Enum.Material.Cobblestone, training)
makePart("ArenaWallS", Vector3.new(84, 8, 3), Vector3.new(195, 4, 62), "Medium stone grey", Enum.Material.Cobblestone, training)
makePart("ArenaWallW", Vector3.new(3, 8, 80), Vector3.new(152, 4, 20), "Medium stone grey", Enum.Material.Cobblestone, training)
makePart("ArenaWallE", Vector3.new(3, 8, 80), Vector3.new(238, 4, 20), "Medium stone grey", Enum.Material.Cobblestone, training)

-- Training dummies (T-shapes)
for i = 0, 2 do
	local dx = 170 + i * 20
	makePart("DummyPole"..i, Vector3.new(1, 6, 1), Vector3.new(dx, 3, 10), "Reddish brown", Enum.Material.Wood, training)
	makePart("DummyArms"..i, Vector3.new(4, 1, 1), Vector3.new(dx, 5, 10), "Reddish brown", Enum.Material.Wood, training)
	makePart("DummyHead"..i, Vector3.new(1.5, 1.5, 1.5), Vector3.new(dx, 7, 10), "Bright yellow", Enum.Material.SmoothPlastic, training)
end

-- Archery targets
for i = 0, 3 do
	makePart("Target"..i, Vector3.new(0.5, 4, 4), Vector3.new(230, 2.5, 0 + i * 12), "White", Enum.Material.SmoothPlastic, training)
	makePart("TargetRing"..i, Vector3.new(0.6, 2, 2), Vector3.new(230, 2.5, 0 + i * 12), "Bright red", Enum.Material.SmoothPlastic, training)
	makePart("TargetBull"..i, Vector3.new(0.7, 0.8, 0.8), Vector3.new(230, 2.5, 0 + i * 12), "Bright yellow", Enum.Material.SmoothPlastic, training)
end

-- Weapon racks
makePart("WeaponRack1", Vector3.new(0.5, 5, 4), Vector3.new(158, 2.5, 30), "Reddish brown", Enum.Material.Wood, training)
makePart("WeaponRack2", Vector3.new(0.5, 5, 4), Vector3.new(158, 2.5, 40), "Reddish brown", Enum.Material.Wood, training)

-- Spectator benches
for i = 0, 3 do
	makePart("Bench"..i, Vector3.new(8, 1.5, 1.5), Vector3.new(195, 0.75 + i * 1.5, 58 - i * 2), "Reddish brown", Enum.Material.Wood, training)
end

-- Armory building
makeHouse(Vector3.new(170, 0, 50), training, 12, 10, 8, "Dark stone grey", "Dark stone grey", "Armory")
local armSign = makePart("ArmSign", Vector3.new(1,1,1), Vector3.new(170, 10, 55), "White", nil, training, {Transparency = 1})
makeSign(armSign, "âš”ï¸ Combat Training Grounds", Vector3.new(0,0,0))

task.wait()

-- ============================================================
-- 4. ANCIENT GROVE (west, x=-250 to -100, z=-60 to 60)
-- ============================================================
print("[MapSetup2] Building Ancient Grove...")
local grove = getOrMake(safeZone, "AncientGrove")

-- Mystic ground
makePart("GroveGround", Vector3.new(140, 0.15, 120), Vector3.new(-175, 0.08, 0), "Earth green", Enum.Material.Grass, grove)

-- HUGE ancient trees (5 studs wide trunks, 25 tall)
local ancientPos = {
	{-200, 0, -30}, {-160, 0, -40}, {-130, 0, -20}, {-220, 0, 10},
	{-180, 0, 30}, {-140, 0, 40}, {-210, 0, 50}, {-160, 0, 20},
}
for i, tp in ipairs(ancientPos) do
	makePart("AncientTrunk"..i, Vector3.new(5, 25, 5), Vector3.new(tp[1], 12.5, tp[3]), "Reddish brown", Enum.Material.Wood, grove)
	makePart("AncientCanopy"..i, Vector3.new(20, 15, 20), Vector3.new(tp[1], 27, tp[3]), "Dark green", Enum.Material.Grass, grove, {CanCollide = false})
	-- Roots
	makePart("Root"..i.."a", Vector3.new(1, 1, 6), Vector3.new(tp[1]+3, 0.5, tp[3]+2), "Reddish brown", Enum.Material.Wood, grove)
	makePart("Root"..i.."b", Vector3.new(6, 1, 1), Vector3.new(tp[1]-2, 0.5, tp[3]-3), "Reddish brown", Enum.Material.Wood, grove)
end

-- Glowing blue mushrooms
for i = 1, 15 do
	local mx = -240 + math.random(0, 130)
	local mz = -55 + math.random(0, 110)
	local shroom = makePart("BlueMushroom"..i, Vector3.new(0.8, 1.2, 0.8), Vector3.new(mx, 0.6, mz), "Bright blue", Enum.Material.Neon, grove, {Transparency = 0.3, CanCollide = false})
	local sl = Instance.new("PointLight") sl.Color = Color3.fromRGB(50, 120, 255) sl.Brightness = 1 sl.Range = 6 sl.Parent = shroom
end

-- Stone circle (8 standing stones in a ring)
local circleCenter = Vector3.new(-180, 0, 0)
for i = 0, 7 do
	local angle = (i / 8) * math.pi * 2
	local sx = circleCenter.X + math.cos(angle) * 15
	local sz = circleCenter.Z + math.sin(angle) * 15
	local height = 6 + math.random(0, 4)
	makePart("DruidStone"..i, Vector3.new(2, height, 1.5), Vector3.new(sx, height/2, sz), "Medium stone grey", Enum.Material.Slate, grove)
end
-- Center altar
makePart("DruidAltar", Vector3.new(4, 1.5, 4), Vector3.new(-180, 0.75, 0), "Medium stone grey", Enum.Material.Marble, grove)
local altarGlow = makePart("AltarGlow", Vector3.new(2, 0.5, 2), Vector3.new(-180, 1.75, 0), "Bright green", Enum.Material.Neon, grove, {Transparency = 0.4})
local agl = Instance.new("PointLight") agl.Color = Color3.fromRGB(50, 255, 100) agl.Brightness = 2 agl.Range = 15 agl.Parent = altarGlow

-- Moss-covered ruins
makePart("MossRuin1", Vector3.new(5, 4, 1.5), Vector3.new(-220, 2, -40), "Earth green", Enum.Material.Cobblestone, grove)
makePart("MossRuin2", Vector3.new(1.5, 3, 5), Vector3.new(-217, 1.5, -37), "Earth green", Enum.Material.Cobblestone, grove)

-- Waterfall cave entrance
makePart("CaveRockL", Vector3.new(5, 12, 5), Vector3.new(-245, 6, 20), "Dark stone grey", Enum.Material.Slate, grove)
makePart("CaveRockR", Vector3.new(5, 12, 5), Vector3.new(-235, 6, 20), "Dark stone grey", Enum.Material.Slate, grove)
makePart("CaveArch", Vector3.new(15, 4, 5), Vector3.new(-240, 14, 20), "Dark stone grey", Enum.Material.Slate, grove)
makePart("Waterfall", Vector3.new(6, 12, 0.5), Vector3.new(-240, 6, 20), Color3.fromRGB(65, 130, 175), Enum.Material.Water, grove, {Transparency = 0.3, CanCollide = false})

local groveSign = makePart("GroveSign", Vector3.new(1,1,1), Vector3.new(-175, 5, 60), "White", nil, grove, {Transparency = 1})
makeSign(groveSign, "ðŸŒ¿ Ancient Grove", Vector3.new(0,0,0))

task.wait()

-- ============================================================
-- 5. OUTSKIRTS VILLAGE (south, x=-60 to 60, z=150-230)
-- ============================================================
print("[MapSetup2] Building Outskirts Village...")
local village = getOrMake(safeZone, "OutskirtsVillage")

-- Village ground
makePart("VillageGround", Vector3.new(120, 0.15, 80), Vector3.new(0, 0.08, 190), "Brown", Enum.Material.Ground, village)

-- Houses
makeHouse(Vector3.new(-30, 0, 175), village, 10, 8, 7, "Brick yellow", "Reddish brown", "VHouse1")
makeHouse(Vector3.new(-10, 0, 200), village, 10, 8, 7, "Brown", "Dark stone grey", "VHouse2")
makeHouse(Vector3.new(15, 0, 175), village, 12, 8, 7, "Brick yellow", "Reddish brown", "VHouse3")
makeHouse(Vector3.new(35, 0, 200), village, 10, 8, 7, "Brown", "Dark stone grey", "VHouse4")
makeHouse(Vector3.new(-35, 0, 210), village, 10, 8, 7, "Brick yellow", "Reddish brown", "VHouse5")

-- Well in center
makePart("WellBase", Vector3.new(4, 3, 4), Vector3.new(0, 1.5, 190), "Medium stone grey", Enum.Material.Cobblestone, village)
makePart("WellWater", Vector3.new(2, 0.3, 2), Vector3.new(0, 0.5, 190), Color3.fromRGB(65, 130, 175), Enum.Material.Water, village, {Transparency = 0.3})
makePart("WellRoof", Vector3.new(5, 0.5, 5), Vector3.new(0, 5, 190), "Reddish brown", Enum.Material.Wood, village)
makePart("WellPost1", Vector3.new(0.3, 5, 0.3), Vector3.new(-2, 2.5, 188), "Reddish brown", Enum.Material.Wood, village)
makePart("WellPost2", Vector3.new(0.3, 5, 0.3), Vector3.new(2, 2.5, 192), "Reddish brown", Enum.Material.Wood, village)

-- Market cart
makePart("CartBody", Vector3.new(4, 2, 6), Vector3.new(25, 1.5, 190), "Reddish brown", Enum.Material.Wood, village)
makePart("CartGoods", Vector3.new(3, 1, 5), Vector3.new(25, 3, 190), "Bright green", Enum.Material.Fabric, village)

-- Small chapel
local chapel = makeHouse(Vector3.new(45, 0, 185), village, 8, 10, 8, "White", "Dark stone grey", "VChapel")
makePart("ChapelSteeple", Vector3.new(3, 6, 3), Vector3.new(45, 14, 182), "Dark stone grey", Enum.Material.Slate, village)

-- Clotheslines
makePart("ClothPost1", Vector3.new(0.3, 4, 0.3), Vector3.new(-20, 2, 188), "Reddish brown", Enum.Material.Wood, village)
makePart("ClothPost2", Vector3.new(0.3, 4, 0.3), Vector3.new(-5, 2, 188), "Reddish brown", Enum.Material.Wood, village)
makePart("ClothLine", Vector3.new(15, 0.1, 0.1), Vector3.new(-12.5, 3.8, 188), "White", Enum.Material.Fabric, village)
makePart("Cloth1", Vector3.new(2, 2, 0.1), Vector3.new(-15, 2.8, 188), "Bright blue", Enum.Material.Fabric, village, {CanCollide = false})
makePart("Cloth2", Vector3.new(2, 2, 0.1), Vector3.new(-10, 2.8, 188), "Bright red", Enum.Material.Fabric, village, {CanCollide = false})

local villSign = makePart("VillSign", Vector3.new(1,1,1), Vector3.new(0, 7, 230), "White", nil, village, {Transparency = 1})
makeSign(villSign, "ðŸ˜ï¸ Outskirts Village", Vector3.new(0,0,0))

task.wait()

-- ============================================================
-- 6. WATCHTOWER HILL (northeast, x=200-240, z=-80 to -50)
-- ============================================================
print("[MapSetup2] Building Watchtower Hill...")
local hill = getOrMake(safeZone, "WatchtowerHill")

-- Raised hill platform
makePart("HillBase", Vector3.new(50, 8, 40), Vector3.new(220, 4, -65), "Earth green", Enum.Material.Grass, hill)
makePart("HillRamp", Vector3.new(12, 1, 20), Vector3.new(200, 4, -55), "Earth green", Enum.Material.Grass, hill, {Orientation = Vector3.new(20, 0, 0)})

-- Watchtower (tall!)
makePart("TowerBase", Vector3.new(8, 30, 8), Vector3.new(220, 23, -65), "Medium stone grey", Enum.Material.Cobblestone, hill)
makePart("TowerTop", Vector3.new(12, 2, 12), Vector3.new(220, 39, -65), "Dark stone grey", Enum.Material.Cobblestone, hill)
-- Railings
makePart("Rail1", Vector3.new(12, 3, 0.5), Vector3.new(220, 41.5, -71), "Dark stone grey", Enum.Material.Cobblestone, hill)
makePart("Rail2", Vector3.new(12, 3, 0.5), Vector3.new(220, 41.5, -59), "Dark stone grey", Enum.Material.Cobblestone, hill)
makePart("Rail3", Vector3.new(0.5, 3, 12), Vector3.new(214, 41.5, -65), "Dark stone grey", Enum.Material.Cobblestone, hill)
makePart("Rail4", Vector3.new(0.5, 3, 12), Vector3.new(226, 41.5, -65), "Dark stone grey", Enum.Material.Cobblestone, hill)

-- Warning flags
makePart("FlagPole1", Vector3.new(0.3, 8, 0.3), Vector3.new(214, 47, -71), "Dark stone grey", Enum.Material.Metal, hill)
makePart("Flag1", Vector3.new(3, 2, 0.1), Vector3.new(216, 49, -71), "Really red", Enum.Material.Fabric, hill, {CanCollide = false})

-- Guard campfire
makePart("FireLogs1", Vector3.new(2, 0.5, 0.5), Vector3.new(210, 8.5, -60), "Reddish brown", Enum.Material.Wood, hill)
makePart("FireLogs2", Vector3.new(0.5, 0.5, 2), Vector3.new(210, 8.5, -60), "Reddish brown", Enum.Material.Wood, hill)
local campfire = makePart("Campfire", Vector3.new(1.5, 2, 1.5), Vector3.new(210, 9.5, -60), "Bright orange", Enum.Material.Neon, hill, {Transparency = 0.3})
local cfl = Instance.new("PointLight") cfl.Color = Color3.fromRGB(255, 140, 40) cfl.Brightness = 3 cfl.Range = 20 cfl.Parent = campfire

local hillSign = makePart("HillSign", Vector3.new(1,1,1), Vector3.new(220, 44, -65), "White", nil, hill, {Transparency = 1})
makeSign(hillSign, "ðŸ° Watchtower Hill", Vector3.new(0,0,0))

task.wait()

-- ============================================================
-- 7. MERCHANT ROADS (connecting all areas)
-- ============================================================
print("[MapSetup2] Building roads...")
local roads = getOrMake(safeZone, "Roads")

-- Haven gate to south (Outskirts Village)
makePart("RoadSouth", Vector3.new(6, 0.12, 120), Vector3.new(0, 0.06, 168), "Medium stone grey", Enum.Material.Cobblestone, roads)
-- Haven to east (Farmlands/Training)
makePart("RoadEast", Vector3.new(120, 0.12, 6), Vector3.new(120, 0.06, 108), "Medium stone grey", Enum.Material.Cobblestone, roads)
-- Haven to west (Lake/Grove)
makePart("RoadWest", Vector3.new(130, 0.12, 6), Vector3.new(-120, 0.06, 108), "Medium stone grey", Enum.Material.Cobblestone, roads)
-- Road to lake
makePart("RoadToLake", Vector3.new(6, 0.12, 80), Vector3.new(-150, 0.06, 148), "Medium stone grey", Enum.Material.Cobblestone, roads)
-- Road to grove
makePart("RoadToGrove", Vector3.new(6, 0.12, 60), Vector3.new(-120, 0.06, 70), "Medium stone grey", Enum.Material.Cobblestone, roads)
-- Road to training
makePart("RoadToTraining", Vector3.new(6, 0.12, 40), Vector3.new(195, 0.06, 80), "Medium stone grey", Enum.Material.Cobblestone, roads)
-- Road to wilderness (north from Haven)
makePart("RoadNorth", Vector3.new(6, 0.12, 100), Vector3.new(0, 0.06, -55), "Medium stone grey", Enum.Material.Cobblestone, roads)

-- Signposts at intersections
local function makeSignpost(position, texts)
	makePart("Signpost", Vector3.new(0.5, 5, 0.5), position, "Reddish brown", Enum.Material.Wood, roads)
	for i, t in ipairs(texts) do
		local board = makePart("SignBoard"..i, Vector3.new(4, 1, 0.3), position + Vector3.new(2, 4.5 - i * 1.2, 0), "Brown", Enum.Material.Wood, roads)
		makeSign(board, t, Vector3.new(0, 0.5, 0), UDim2.new(6, 0, 1.5, 0))
	end
end

makeSignpost(Vector3.new(5, 0, 115), {"â†’ Farmlands", "â† Haven Lake", "â†‘ Haven"})
makeSignpost(Vector3.new(0, 0, 155), {"â†‘ Haven", "â†“ Outskirts Village"})
makeSignpost(Vector3.new(0, 0, -50), {"â†‘ âš ï¸ WILDERNESS", "â†“ Haven"})

-- Lanterns along roads
for i = 0, 8 do
	makeLantern(Vector3.new(5, 0, 120 + i * 12), roads)
	makeLantern(Vector3.new(-5, 0, -10 - i * 10), roads)
end

task.wait()

-- ============================================================
-- 8. BANDIT CAMP (wilderness, x=-80 to -30, z=-180 to -130)
-- ============================================================
print("[MapSetup2] Building Bandit Camp...")
local bandits = getOrMake(wilderness, "BanditCamp")

-- Palisade walls (crude wooden fence)
makePart("PalisadeN", Vector3.new(55, 6, 1), Vector3.new(-55, 3, -130), "Reddish brown", Enum.Material.Wood, bandits)
makePart("PalisadeS", Vector3.new(55, 6, 1), Vector3.new(-55, 3, -180), "Reddish brown", Enum.Material.Wood, bandits)
makePart("PalisadeW", Vector3.new(1, 6, 50), Vector3.new(-82, 3, -155), "Reddish brown", Enum.Material.Wood, bandits)
makePart("PalisadeE", Vector3.new(1, 6, 50), Vector3.new(-28, 3, -155), "Reddish brown", Enum.Material.Wood, bandits)

-- Tents
for i, pos in ipairs({{-65, 0, -145}, {-50, 0, -160}, {-40, 0, -145}, {-70, 0, -170}}) do
	makePart("TentBase"..i, Vector3.new(6, 0.1, 6), Vector3.new(pos[1], 0.05, pos[3]), "Brown", Enum.Material.Fabric, bandits)
	makePart("TentPole"..i, Vector3.new(0.3, 5, 0.3), Vector3.new(pos[1], 2.5, pos[3]), "Reddish brown", Enum.Material.Wood, bandits)
	makePart("TentCover"..i, Vector3.new(7, 0.2, 7), Vector3.new(pos[1], 4.5, pos[3]), "Brown", Enum.Material.Fabric, bandits, {Orientation = Vector3.new(10, math.random(-20,20), 0)})
end

-- Campfire
makePart("BanditFireLogs", Vector3.new(2, 0.5, 2), Vector3.new(-55, 0.25, -155), "Reddish brown", Enum.Material.Wood, bandits)
local bf = makePart("BanditFire", Vector3.new(1.5, 2, 1.5), Vector3.new(-55, 1.5, -155), "Bright orange", Enum.Material.Neon, bandits, {Transparency = 0.3})
local bfl = Instance.new("PointLight") bfl.Color = Color3.fromRGB(255, 120, 30) bfl.Brightness = 3 bfl.Range = 20 bfl.Parent = bf

-- Weapon crates
makePart("WeaponCrate1", Vector3.new(3, 2, 2), Vector3.new(-45, 1, -150), "Brown", Enum.Material.Wood, bandits)
makePart("WeaponCrate2", Vector3.new(3, 2, 2), Vector3.new(-45, 3, -150), "Brown", Enum.Material.Wood, bandits)

-- Skull flag
makePart("SkullPole", Vector3.new(0.4, 8, 0.4), Vector3.new(-55, 4, -132), "Reddish brown", Enum.Material.Wood, bandits)
makePart("SkullFlag", Vector3.new(4, 3, 0.1), Vector3.new(-53, 7, -132), "Black", Enum.Material.Fabric, bandits)

local banditSign = makePart("BSign", Vector3.new(1,1,1), Vector3.new(-55, 8, -130), "White", nil, bandits, {Transparency = 1})
makeSign(banditSign, "âš”ï¸ Bandit Camp", Vector3.new(0,0,0))

task.wait()

-- ============================================================
-- 9. DARK FOREST (wilderness, x=60 to 200, z=-220 to -120)
-- ============================================================
print("[MapSetup2] Building Dark Forest...")
local darkForest = getOrMake(wilderness, "DarkForest")

-- Dark ground
makePart("DarkForestGround", Vector3.new(140, 0.15, 100), Vector3.new(130, 0.08, -170), "Really black", Enum.Material.Ground, darkForest)

-- Dense dead/twisted trees
for i = 1, 25 do
	local tx = 70 + math.random(0, 120)
	local tz = -210 + math.random(0, 80)
	local th = 6 + math.random(0, 8)
	makePart("DarkTrunk"..i, Vector3.new(1.5, th, 1.5), Vector3.new(tx, th/2, tz), "Really black", Enum.Material.Wood, darkForest)
	if math.random() > 0.4 then
		makePart("DarkBranch"..i, Vector3.new(0.5, 3, 0.5), Vector3.new(tx+1.5, th-1, tz), "Really black", Enum.Material.Wood, darkForest, {Orientation = Vector3.new(0,0,30)})
	end
end

-- Spider webs between trees
for i = 1, 8 do
	local wx = 80 + math.random(0, 100)
	local wz = -200 + math.random(0, 70)
	makePart("Web"..i, Vector3.new(5, 5, 0.1), Vector3.new(wx, 4, wz), "White", Enum.Material.Neon, darkForest, {Transparency = 0.7, CanCollide = false})
end

-- Fog (low transparent grey)
for i = 1, 6 do
	local fx = 80 + math.random(0, 110)
	local fz = -205 + math.random(0, 75)
	makePart("Fog"..i, Vector3.new(25, 3, 25), Vector3.new(fx, 1.5, fz), "Medium stone grey", Enum.Material.SmoothPlastic, darkForest, {Transparency = 0.85, CanCollide = false})
end

-- Abandoned cabin
local cabin = getOrMake(darkForest, "AbandonedCabin")
makePart("CabinFloor", Vector3.new(10, 0.3, 8), Vector3.new(140, 0.15, -180), "Reddish brown", Enum.Material.WoodPlanks, cabin)
makePart("CabinWall1", Vector3.new(10, 6, 1), Vector3.new(140, 3, -184), "Reddish brown", Enum.Material.Wood, cabin)
makePart("CabinWall2", Vector3.new(1, 6, 8), Vector3.new(135, 3, -180), "Reddish brown", Enum.Material.Wood, cabin)
-- Missing wall (broken)
makePart("CabinWall3Broken", Vector3.new(1, 3, 5), Vector3.new(145, 1.5, -178), "Reddish brown", Enum.Material.Wood, cabin)
-- Partial roof
makePart("CabinRoof", Vector3.new(8, 0.5, 6), Vector3.new(138, 6.5, -181), "Reddish brown", Enum.Material.Wood, cabin)

-- Creepy totem poles
for i = 0, 2 do
	makePart("Totem"..i, Vector3.new(1.5, 8, 1.5), Vector3.new(100 + i * 25, 4, -140), "Reddish brown", Enum.Material.Wood, darkForest)
	makePart("TotemFace"..i, Vector3.new(2, 2, 0.5), Vector3.new(100 + i * 25, 6, -139.5), "Bright red", Enum.Material.Neon, darkForest, {Transparency = 0.4})
end

local dfSign = makePart("DFSign", Vector3.new(1,1,1), Vector3.new(130, 5, -120), "White", nil, darkForest, {Transparency = 1})
makeSign(dfSign, "ðŸŒ‘ Dark Forest", Vector3.new(0,0,0))

task.wait()

-- ============================================================
-- 10. DRAGON'S SPINE MOUNTAINS (deep wilderness, x=-180 to -60, z=-380 to -260)
-- ============================================================
print("[MapSetup2] Building Dragon's Spine Mountains...")
local mountains = getOrMake(wilderness, "DragonSpine")

-- Mountain base
makePart("MtnBase", Vector3.new(130, 2, 130), Vector3.new(-120, 1, -320), "Dark stone grey", Enum.Material.Slate, mountains)

-- Rock spires/peaks
local peakData = {
	{-160, 0, -290, 50}, {-130, 0, -310, 40}, {-100, 0, -280, 45},
	{-80, 0, -330, 55}, {-140, 0, -350, 35}, {-110, 0, -360, 42},
	{-170, 0, -340, 38}, {-90, 0, -300, 48},
}
for i, pd in ipairs(peakData) do
	local h = pd[4]
	makePart("Peak"..i, Vector3.new(12, h, 12), Vector3.new(pd[1], h/2 + 2, pd[3]), "Dark stone grey", Enum.Material.Slate, mountains)
	-- Snow cap
	makePart("Snow"..i, Vector3.new(10, 3, 10), Vector3.new(pd[1], h + 1, pd[3]), "White", Enum.Material.SmoothPlastic, mountains)
end

-- Cave entrance in mountain
makePart("MtnCaveL", Vector3.new(6, 14, 6), Vector3.new(-130, 9, -270), "Dark stone grey", Enum.Material.Slate, mountains)
makePart("MtnCaveR", Vector3.new(6, 14, 6), Vector3.new(-118, 9, -270), "Dark stone grey", Enum.Material.Slate, mountains)
makePart("MtnCaveTop", Vector3.new(18, 4, 6), Vector3.new(-124, 18, -270), "Dark stone grey", Enum.Material.Slate, mountains)

-- Rope bridge between peaks
makePart("RopeBridge", Vector3.new(3, 0.3, 30), Vector3.new(-115, 25, -305), "Reddish brown", Enum.Material.Wood, mountains)
makePart("BridgeRope1", Vector3.new(0.2, 2, 30), Vector3.new(-113.5, 26, -305), "Brown", Enum.Material.Fabric, mountains)
makePart("BridgeRope2", Vector3.new(0.2, 2, 30), Vector3.new(-116.5, 26, -305), "Brown", Enum.Material.Fabric, mountains)

-- Dragon bones
makePart("DragonSkull", Vector3.new(6, 4, 8), Vector3.new(-140, 4, -370), "White", Enum.Material.SmoothPlastic, mountains)
makePart("DragonSpine1", Vector3.new(2, 3, 2), Vector3.new(-140, 3, -362), "White", Enum.Material.SmoothPlastic, mountains)
makePart("DragonSpine2", Vector3.new(2, 2.5, 2), Vector3.new(-140, 2.5, -356), "White", Enum.Material.SmoothPlastic, mountains)
makePart("DragonRib1", Vector3.new(0.5, 5, 3), Vector3.new(-138, 3, -365), "White", Enum.Material.SmoothPlastic, mountains)
makePart("DragonRib2", Vector3.new(0.5, 5, 3), Vector3.new(-142, 3, -365), "White", Enum.Material.SmoothPlastic, mountains)

local mtnSign = makePart("MtnSign", Vector3.new(1,1,1), Vector3.new(-120, 30, -275), "White", nil, mountains, {Transparency = 1})
makeSign(mtnSign, "ðŸ”ï¸ Dragon's Spine", Vector3.new(0,0,0))

task.wait()

-- ============================================================
-- 11. CURSED SWAMP (deep wilderness, x=40 to 200, z=-380 to -270)
-- ============================================================
print("[MapSetup2] Building Cursed Swamp...")
local swamp = getOrMake(wilderness, "CursedSwamp")

-- Murky water
makePart("SwampWater", Vector3.new(160, 0.5, 110), Vector3.new(120, -0.25, -325), Color3.fromRGB(30, 80, 120), Enum.Material.Water, swamp, {Transparency = 0.3, CanCollide = false})
-- Muddy ground
makePart("SwampMud", Vector3.new(170, 0.3, 120), Vector3.new(120, -0.1, -325), "Brown", Enum.Material.Ground, swamp)

-- Dead trees emerging from water
for i = 1, 12 do
	local sx = 50 + math.random(0, 140)
	local sz = -370 + math.random(0, 90)
	makePart("SwampTree"..i, Vector3.new(1, 6 + math.random(0,4), 1), Vector3.new(sx, 3, sz), "Dark stone grey", Enum.Material.Wood, swamp)
end

-- Bubbling pits
for i = 1, 5 do
	local bx = 60 + math.random(0, 120)
	local bz = -360 + math.random(0, 70)
	local pit = makePart("BubblePit"..i, Vector3.new(4, 0.5, 4), Vector3.new(bx, 0.1, bz), "Bright green", Enum.Material.Neon, swamp, {Transparency = 0.4})
	local pgl = Instance.new("PointLight") pgl.Color = Color3.fromRGB(50, 200, 50) pgl.Brightness = 1.5 pgl.Range = 10 pgl.Parent = pit
end

-- Rickety walkways
makePart("Walkway1", Vector3.new(3, 0.3, 40), Vector3.new(100, 0.4, -315), "Reddish brown", Enum.Material.WoodPlanks, swamp)
makePart("Walkway2", Vector3.new(30, 0.3, 3), Vector3.new(120, 0.4, -335), "Reddish brown", Enum.Material.WoodPlanks, swamp)
makePart("Walkway3", Vector3.new(3, 0.3, 30), Vector3.new(140, 0.4, -345), "Reddish brown", Enum.Material.WoodPlanks, swamp)

-- Witch's hut on stilts
makePart("HutStilt1", Vector3.new(0.5, 6, 0.5), Vector3.new(155, 3, -350), "Reddish brown", Enum.Material.Wood, swamp)
makePart("HutStilt2", Vector3.new(0.5, 6, 0.5), Vector3.new(165, 3, -350), "Reddish brown", Enum.Material.Wood, swamp)
makePart("HutStilt3", Vector3.new(0.5, 6, 0.5), Vector3.new(155, 3, -356), "Reddish brown", Enum.Material.Wood, swamp)
makePart("HutStilt4", Vector3.new(0.5, 6, 0.5), Vector3.new(165, 3, -356), "Reddish brown", Enum.Material.Wood, swamp)
makePart("HutFloor", Vector3.new(12, 0.3, 8), Vector3.new(160, 6, -353), "Reddish brown", Enum.Material.WoodPlanks, swamp)
makePart("HutWall1", Vector3.new(12, 6, 0.5), Vector3.new(160, 9, -357), "Reddish brown", Enum.Material.Wood, swamp)
makePart("HutWall2", Vector3.new(0.5, 6, 8), Vector3.new(154, 9, -353), "Reddish brown", Enum.Material.Wood, swamp)
makePart("HutRoof", Vector3.new(14, 0.5, 10), Vector3.new(160, 12, -353), "Really black", Enum.Material.Slate, swamp)

-- Poisonous mushrooms (red with white)
for i = 1, 8 do
	local mx = 60 + math.random(0, 130)
	local mz = -370 + math.random(0, 80)
	makePart("PoisonShroom"..i, Vector3.new(1.2, 1.5, 1.2), Vector3.new(mx, 0.75, mz), "Bright red", Enum.Material.SmoothPlastic, swamp, {CanCollide = false})
	makePart("ShroomSpot"..i, Vector3.new(0.4, 0.4, 0.1), Vector3.new(mx + 0.3, 1.2, mz), "White", Enum.Material.SmoothPlastic, swamp, {CanCollide = false})
end

local swampSign = makePart("SwampSign", Vector3.new(1,1,1), Vector3.new(120, 4, -272), "White", nil, swamp, {Transparency = 1})
makeSign(swampSign, "ðŸ§ª Cursed Swamp", Vector3.new(0,0,0))

task.wait()

-- ============================================================
-- 12. THE ABYSS (deepest wilderness, x=-80 to 80, z=-520 to -420)
-- ============================================================
print("[MapSetup2] Building The Abyss...")
local abyss = getOrMake(wilderness, "TheAbyss")

-- Obsidian ground
makePart("AbyssGround", Vector3.new(180, 0.3, 120), Vector3.new(0, 0.15, -470), "Really black", Enum.Material.Slate, abyss)

-- Lava rivers (red neon strips)
makePart("LavaRiver1", Vector3.new(4, 0.5, 100), Vector3.new(-30, 0.25, -470), "Bright red", Enum.Material.Neon, abyss, {Transparency = 0.2, CanCollide = false})
makePart("LavaRiver2", Vector3.new(80, 0.5, 4), Vector3.new(10, 0.25, -450), "Bright red", Enum.Material.Neon, abyss, {Transparency = 0.2, CanCollide = false})
makePart("LavaRiver3", Vector3.new(4, 0.5, 60), Vector3.new(40, 0.25, -490), "Bright red", Enum.Material.Neon, abyss, {Transparency = 0.2, CanCollide = false})

-- Floating crystal formations
for i = 1, 10 do
	local cx = -60 + math.random(0, 120)
	local cy = 5 + math.random(0, 15)
	local cz = -510 + math.random(0, 80)
	local crystal = makePart("Crystal"..i, Vector3.new(2, 5 + math.random(0, 4), 2), Vector3.new(cx, cy, cz), "Bright violet", Enum.Material.Neon, abyss, {Transparency = 0.3, CanCollide = false, Orientation = Vector3.new(math.random(-15,15), math.random(0,360), math.random(-15,15))})
	local crl = Instance.new("PointLight") crl.Color = Color3.fromRGB(150, 50, 255) crl.Brightness = 2 crl.Range = 15 crl.Parent = crystal
end

-- Ruined altar/temple
local temple = getOrMake(abyss, "DarkTemple")
makePart("TempleFloor", Vector3.new(30, 1, 24), Vector3.new(0, 0.5, -480), "Really black", Enum.Material.Marble, temple)
-- Pillars
for i = 0, 3 do
	makePart("TPillarL"..i, Vector3.new(3, 16, 3), Vector3.new(-12, 8, -472 - i * 5), "Dark stone grey", Enum.Material.Marble, temple)
	makePart("TPillarR"..i, Vector3.new(3, 16, 3), Vector3.new(12, 8, -472 - i * 5), "Dark stone grey", Enum.Material.Marble, temple)
end
-- Temple roof fragments
makePart("TempleRoof1", Vector3.new(15, 2, 10), Vector3.new(-3, 17, -475), "Dark stone grey", Enum.Material.Marble, temple)
makePart("TempleRoof2", Vector3.new(10, 2, 8), Vector3.new(5, 17, -488), "Dark stone grey", Enum.Material.Marble, temple)
-- Dark altar
makePart("DarkAltar", Vector3.new(6, 3, 4), Vector3.new(0, 2, -490), "Really black", Enum.Material.Marble, temple)
local altarOrb = makePart("AltarOrb", Vector3.new(2, 2, 2), Vector3.new(0, 4.5, -490), "Bright violet", Enum.Material.Neon, temple, {Transparency = 0.2})
local aol = Instance.new("PointLight") aol.Color = Color3.fromRGB(200, 50, 255) aol.Brightness = 5 aol.Range = 30 aol.Parent = altarOrb

-- Demonic statues
for i, pos in ipairs({{-20, 0, -465}, {20, 0, -465}, {-15, 0, -495}, {15, 0, -495}}) do
	makePart("DemonBase"..i, Vector3.new(3, 1, 3), Vector3.new(pos[1], 0.5, pos[3]), "Really black", Enum.Material.Marble, abyss)
	makePart("DemonBody"..i, Vector3.new(2, 6, 2), Vector3.new(pos[1], 4, pos[3]), "Really black", Enum.Material.Slate, abyss)
	makePart("DemonHead"..i, Vector3.new(1.5, 1.5, 1.5), Vector3.new(pos[1], 7.75, pos[3]), "Really black", Enum.Material.Slate, abyss)
	makePart("DemonEyes"..i, Vector3.new(0.8, 0.3, 0.1), Vector3.new(pos[1], 8, pos[3] + 0.8), "Bright red", Enum.Material.Neon, abyss)
end

local abyssSign = makePart("AbyssSign", Vector3.new(1,1,1), Vector3.new(0, 20, -425), "White", nil, abyss, {Transparency = 1})
makeSign(abyssSign, "ðŸ‘ï¸ THE ABYSS â€” Turn Back", Vector3.new(0,0,0), UDim2.new(14, 0, 3, 0))

-- ============================================================
-- 13. ADDITIONAL TERRAIN FEATURES
-- ============================================================
print("[MapSetup2] Adding terrain details...")

-- Cliff edges near Dragon's Spine
local cliffs = getOrMake(wilderness, "DragonSpine")
for i = 1, 6 do
	local cx = -180 + i * 20
	makePart("Cliff"..i, Vector3.new(15, 12 + math.random(0, 8), 4), Vector3.new(cx, 6, -265), "Dark stone grey", Enum.Material.Slate, cliffs)
end

-- Extra boulders around training grounds
for i = 1, 6 do
	local bx = 155 + math.random(0, 80)
	local bz = -25 + math.random(0, 90)
	local bs = 2 + math.random() * 3
	makePart("TrainBoulder"..i, Vector3.new(bs, bs * 0.7, bs), Vector3.new(bx, bs * 0.35, bz), "Medium stone grey", Enum.Material.Slate, safeZone)
end

-- Flower meadow near lake
for i = 1, 15 do
	local fx = -190 + math.random(0, 80)
	local fz = 190 + math.random(0, 20)
	local colors = {"Bright red", "Bright yellow", "Hot pink", "Bright violet", "Bright blue"}
	makePart("LakeFlower"..i, Vector3.new(0.5, 0.7, 0.5), Vector3.new(fx, 0.35, fz), colors[math.random(#colors)], Enum.Material.SmoothPlastic, safeZone, {CanCollide = false})
end

-- Bushes around village
for i = 1, 12 do
	local bx = -50 + math.random(0, 100)
	local bz = 160 + math.random(0, 60)
	local bs = 1.5 + math.random() * 1.5
	makePart("VillageBush"..i, Vector3.new(bs, bs * 0.6, bs), Vector3.new(bx, bs * 0.3, bz), "Forest green", Enum.Material.Grass, safeZone, {CanCollide = false})
end

-- Swamp fog patches
for i = 1, 5 do
	local fx = 60 + math.random(0, 120)
	local fz = -370 + math.random(0, 80)
	makePart("SwampFog"..i, Vector3.new(25 + math.random(0, 15), 4, 25 + math.random(0, 15)), Vector3.new(fx, 2, fz), "Dark green", Enum.Material.SmoothPlastic, wilderness, {Transparency = 0.88, CanCollide = false})
end

-- Grove moss patches
for i = 1, 10 do
	local mx = -240 + math.random(0, 120)
	local mz = -50 + math.random(0, 100)
	makePart("MossPatch"..i, Vector3.new(3 + math.random() * 4, 0.15, 3 + math.random() * 4), Vector3.new(mx, 0.1, mz), "Earth green", Enum.Material.Grass, safeZone, {CanCollide = false})
end

-- ============================================================
-- EXPAND BASEPLATE for all new areas
-- ============================================================
local bp = WS:FindFirstChild("Baseplate")
if bp then
	bp.Size = Vector3.new(800, 1, 800)
	bp.Position = Vector3.new(0, -0.5, 50)
end
local wg = WS:FindFirstChild("WildernessGround")
if wg then
	wg.Size = Vector3.new(800, 1.01, 800)
	wg.Position = Vector3.new(0, -0.5, -400)
end

print("[MapSetup2] World expansion complete!")
print("[MapSetup2] Areas: Farmlands, Haven Lake, Training Grounds, Ancient Grove, Outskirts Village, Watchtower Hill")
print("[MapSetup2] Wilderness: Bandit Camp, Dark Forest, Dragon's Spine, Cursed Swamp, The Abyss")
print("[MapSetup2] Roads connecting all areas with signposts and lanterns")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="143">
      <Properties>
        <string name="Name">MapSetup3</string>
        <token name="RunContext">0</token>
        <string name="Source">--[[
	MapSetup3.server.lua
	ServerScriptService

	Fills the ENTIRE 800x800 map with terrain features, removing all empty space.
	Adds procedurally generated hills, boulders, trees, decorations, and border walls.
]]

-- Wait for MapSetup2 to finish
task.wait(3)

print("[MapSetup3] Starting comprehensive map filling...")

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------
local function getOrMake(parent, name)
	local existing = parent:FindFirstChild(name)
	if existing then return existing end
	local folder = Instance.new("Folder")
	folder.Name = name
	folder.Parent = parent
	return folder
end

local function makePart(name, size, position, color, material, parent, props)
	local part = Instance.new("Part")
	part.Name = name
	part.Size = size
	part.Position = position
	part.Anchored = true
	part.CanCollide = true
	part.Color = typeof(color) == "string" and BrickColor.new(color).Color or color
	part.Material = material or Enum.Material.SmoothPlastic
	
	if props then
		for key, value in pairs(props) do
			if key == "Orientation" then
				part.Orientation = value
			else
				part[key] = value
			end
		end
	end
	
	part.Parent = parent
	return part
end

local function makeTree(position, parent, scale)
	scale = scale or 1
	-- Trunk
	local trunk = makePart(
		"TreeTrunk",
		Vector3.new(1.5 * scale, 6 * scale, 1.5 * scale),
		position + Vector3.new(0, 3 * scale, 0),
		Color3.fromRGB(101, 67, 33),
		Enum.Material.Wood,
		parent
	)
	
	-- Canopy
	local canopy = makePart(
		"TreeCanopy",
		Vector3.new(6 * scale, 4 * scale, 6 * scale),
		position + Vector3.new(0, 7 * scale, 0),
		Color3.fromRGB(34, 139, 34),
		Enum.Material.Grass,
		parent,
		{ Shape = Enum.PartType.Ball }
	)
	
	return trunk, canopy
end

local function makeBush(position, parent, color, scale)
	scale = scale or 1
	color = color or Color3.fromRGB(34, 100, 34)
	return makePart(
		"Bush",
		Vector3.new(2 * scale, 1.5 * scale, 2 * scale),
		position + Vector3.new(0, 0.75 * scale, 0),
		color,
		Enum.Material.Grass,
		parent,
		{ Shape = Enum.PartType.Ball }
	)
end

local function makeBoulder(position, parent, scale, color)
	scale = scale or 1
	color = color or Color3.fromRGB(105, 105, 105)
	local size = Vector3.new(
		2 + math.random() * 3,
		1.5 + math.random() * 2,
		2 + math.random() * 3
	) * scale
	
	return makePart(
		"Boulder",
		size,
		position + Vector3.new(0, size.Y / 2, 0),
		color,
		Enum.Material.Rock,
		parent,
		{ Shape = Enum.PartType.Ball }
	)
end

local function makeHill(position, parent, scale, height)
	scale = scale or 1
	height = height or (2 + math.random() * 6)
	local size = Vector3.new(
		8 + math.random() * 12,
		height,
		8 + math.random() * 12
	) * scale
	
	return makePart(
		"Hill",
		size,
		position + Vector3.new(0, height / 2, 0),
		Color3.fromRGB(34, 139, 34),
		Enum.Material.Grass,
		parent,
		{ Shape = Enum.PartType.Ball }
	)
end

local function makeFlowerPatch(position, parent)
	local colors = {
		Color3.fromRGB(255, 192, 203), -- Pink
		Color3.fromRGB(255, 255, 0),   -- Yellow
		Color3.fromRGB(138, 43, 226),  -- Purple
		Color3.fromRGB(255, 165, 0),   -- Orange
		Color3.fromRGB(255, 20, 147),  -- Deep Pink
	}
	
	for i = 1, 3 + math.random(4) do
		local offset = Vector3.new(
			(math.random() - 0.5) * 4,
			0,
			(math.random() - 0.5) * 4
		)
		makePart(
			"Flower",
			Vector3.new(0.3, 1.2, 0.3),
			position + offset + Vector3.new(0, 0.6, 0),
			colors[math.random(#colors)],
			Enum.Material.Neon,
			parent,
			{ CanCollide = false }
		)
	end
end

local function makePond(position, parent, scale)
	scale = scale or 1
	-- Pond base
	local pond = makePart(
		"Pond",
		Vector3.new(8 * scale, 0.3, 8 * scale),
		position + Vector3.new(0, 0.15, 0),
		Color3.fromRGB(65, 130, 175),
		Enum.Material.Water,
		parent,
		{ Shape = Enum.PartType.Ball, Transparency = 0.3, CanCollide = false }
	)
	
	-- Lily pads
	for i = 1, 2 + math.random(3) do
		local padPos = position + Vector3.new(
			(math.random() - 0.5) * 6 * scale,
			0.4,
			(math.random() - 0.5) * 6 * scale
		)
		makePart(
			"LilyPad",
			Vector3.new(1.2, 0.1, 1.2),
			padPos,
			Color3.fromRGB(34, 139, 34),
			Enum.Material.Grass,
			parent,
			{ Shape = Enum.PartType.Cylinder, CanCollide = false }
		)
	end
	
	return pond
end

local function makeFence(startPos, endPos, parent)
	local direction = (endPos - startPos).Unit
	local distance = (endPos - startPos).Magnitude
	local posts = math.floor(distance / 4) + 1
	
	for i = 0, posts - 1 do
		local postPos = startPos + direction * (i * distance / (posts - 1))
		makePart(
			"FencePost",
			Vector3.new(0.3, 2, 0.3),
			postPos + Vector3.new(0, 1, 0),
			Color3.fromRGB(101, 67, 33),
			Enum.Material.Wood,
			parent
		)
		
		if i &lt; posts - 1 then
			local railPos = postPos + direction * (distance / (posts - 1) / 2)
			makePart(
				"FenceRail",
				Vector3.new(0.2, 0.3, distance / (posts - 1)),
				railPos + Vector3.new(0, 1, 0),
				Color3.fromRGB(101, 67, 33),
				Enum.Material.Wood,
				parent
			)
		end
	end
end

--------------------------------------------------------------------------------
-- MAIN GENERATION
--------------------------------------------------------------------------------
local terrain = getOrMake(workspace, "TerrainFeatures")
local RNG = Random.new(12345) -- Seeded for consistent generation

-- BORDER WALLS - Define the edge of the map
print("[MapSetup3] Creating border walls...")
local borderWalls = getOrMake(terrain, "BorderWalls")

-- North wall (Z = 395)
for x = -395, 395, 20 do
	makePart(
		"NorthWall",
		Vector3.new(20, 15, 5),
		Vector3.new(x, 7.5, 395),
		Color3.fromRGB(40, 40, 40),
		Enum.Material.Concrete,
		borderWalls
	)
end

-- South wall (Z = -795) â€” pushed far south so Dragon's Nest, Underground Ruins etc are accessible
for x = -395, 395, 20 do
	makePart(
		"SouthWall",
		Vector3.new(20, 15, 5),
		Vector3.new(x, 7.5, -795),
		Color3.fromRGB(40, 40, 40),
		Enum.Material.Concrete,
		borderWalls
	)
end

-- East wall (X = 395)
for z = -395, 395, 20 do
	makePart(
		"EastWall",
		Vector3.new(5, 15, 20),
		Vector3.new(395, 7.5, z),
		Color3.fromRGB(40, 40, 40),
		Enum.Material.Concrete,
		borderWalls
	)
end

-- West wall (X = -395)
for z = -395, 395, 20 do
	makePart(
		"WestWall",
		Vector3.new(5, 15, 20),
		Vector3.new(-395, 7.5, z),
		Color3.fromRGB(40, 40, 40),
		Enum.Material.Concrete,
		borderWalls
	)
end

-- NE QUADRANT (X: 100-400, Z: 100-400) â€” Rolling farmland
print("[MapSetup3] Filling NE quadrant - Rolling farmland...")
local neFarmland = getOrMake(terrain, "NEFarmland")

for i = 1, 20 do
	local pos = Vector3.new(
		100 + RNG:NextNumber() * 300,
		0,
		100 + RNG:NextNumber() * 300
	)
	makeHill(pos, neFarmland, 1, 2 + RNG:NextNumber() * 4)
end

-- Farmland fences
for i = 1, 8 do
	local startX = 120 + RNG:NextNumber() * 260
	local startZ = 120 + RNG:NextNumber() * 260
	local endX = startX + 20 + RNG:NextNumber() * 40
	local endZ = startZ + (-10 + RNG:NextNumber() * 20)
	makeFence(
		Vector3.new(startX, 0, startZ),
		Vector3.new(endX, 0, endZ),
		neFarmland
	)
end

-- Haystacks
for i = 1, 12 do
	local pos = Vector3.new(
		120 + RNG:NextNumber() * 260,
		0,
		120 + RNG:NextNumber() * 260
	)
	makePart(
		"Haystack",
		Vector3.new(3, 2.5, 3),
		pos + Vector3.new(0, 1.25, 0),
		Color3.fromRGB(218, 165, 32),
		Enum.Material.Fabric,
		neFarmland,
		{ Shape = Enum.PartType.Ball }
	)
end

-- Scarecrows
for i = 1, 6 do
	local pos = Vector3.new(
		130 + RNG:NextNumber() * 240,
		0,
		130 + RNG:NextNumber() * 240
	)
	-- Scarecrow post
	makePart(
		"ScarecrowPost",
		Vector3.new(0.3, 4, 0.3),
		pos + Vector3.new(0, 2, 0),
		Color3.fromRGB(101, 67, 33),
		Enum.Material.Wood,
		neFarmland
	)
	-- Scarecrow head
	makePart(
		"ScarecrowHead",
		Vector3.new(0.8, 0.8, 0.8),
		pos + Vector3.new(0, 3.8, 0),
		Color3.fromRGB(255, 165, 0),
		Enum.Material.SmoothPlastic,
		neFarmland,
		{ Shape = Enum.PartType.Ball }
	)
	-- Arms
	makePart(
		"ScarecrowArms",
		Vector3.new(3, 0.2, 0.2),
		pos + Vector3.new(0, 3, 0),
		Color3.fromRGB(101, 67, 33),
		Enum.Material.Wood,
		neFarmland
	)
end

-- NW QUADRANT (X: -400 to -100, Z: 100-400) â€” Rocky highlands
print("[MapSetup3] Filling NW quadrant - Rocky highlands...")
local nwHighlands = getOrMake(terrain, "NWHighlands")

for i = 1, 25 do
	local pos = Vector3.new(
		-400 + RNG:NextNumber() * 300,
		0,
		100 + RNG:NextNumber() * 300
	)
	makeBoulder(pos, nwHighlands, 1 + RNG:NextNumber(), Color3.fromRGB(70, 70, 80))
end

-- Highland cliffs (raised terrain)
for i = 1, 15 do
	local pos = Vector3.new(
		-380 + RNG:NextNumber() * 260,
		0,
		120 + RNG:NextNumber() * 260
	)
	makeHill(pos, nwHighlands, 1.5, 6 + RNG:NextNumber() * 8)
end

-- Mountain flowers
for i = 1, 8 do
	local pos = Vector3.new(
		-380 + RNG:NextNumber() * 260,
		0,
		120 + RNG:NextNumber() * 260
	)
	makeFlowerPatch(pos, nwHighlands)
end

-- SE QUADRANT (X: 100-400, Z: -100 to -400) â€” Marshland
print("[MapSetup3] Filling SE quadrant - Marshland...")
local seMarshland = getOrMake(terrain, "SEMarshland")

-- Marshland puddles
for i = 1, 15 do
	local pos = Vector3.new(
		120 + RNG:NextNumber() * 260,
		0,
		-380 + RNG:NextNumber() * 260
	)
	makePond(pos, seMarshland, 0.7)
end

-- Dead trees
for i = 1, 20 do
	local pos = Vector3.new(
		120 + RNG:NextNumber() * 260,
		0,
		-380 + RNG:NextNumber() * 260
	)
	-- Dead tree trunk (taller, thinner)
	makePart(
		"DeadTreeTrunk",
		Vector3.new(1, 8, 1),
		pos + Vector3.new(0, 4, 0),
		Color3.fromRGB(50, 40, 30),
		Enum.Material.Wood,
		seMarshland
	)
	-- A few dead branches
	for j = 1, 2 + math.random(2) do
		local branchHeight = 4 + RNG:NextNumber() * 3
		local branchAngle = RNG:NextNumber() * 360
		local branchOffset = Vector3.new(
			math.sin(math.rad(branchAngle)) * 1.5,
			0,
			math.cos(math.rad(branchAngle)) * 1.5
		)
		makePart(
			"DeadBranch",
			Vector3.new(0.2, 1.5, 0.2),
			pos + Vector3.new(0, branchHeight, 0) + branchOffset,
			Color3.fromRGB(40, 30, 20),
			Enum.Material.Wood,
			seMarshland
		)
	end
end

-- Fog-colored ground patches
for i = 1, 12 do
	local pos = Vector3.new(
		130 + RNG:NextNumber() * 240,
		0,
		-370 + RNG:NextNumber() * 240
	)
	makePart(
		"FogPatch",
		Vector3.new(8, 0.5, 8),
		pos + Vector3.new(0, 0.25, 0),
		Color3.fromRGB(200, 200, 200),
		Enum.Material.Neon,
		seMarshland,
		{ Transparency = 0.7, CanCollide = false, Shape = Enum.PartType.Ball }
	)
end

-- SW QUADRANT (X: -400 to -100, Z: -100 to -400) â€” Dark forest
print("[MapSetup3] Filling SW quadrant - Dark forest...")
local swDarkForest = getOrMake(terrain, "SWDarkForest")

-- Dense tree clusters
for i = 1, 25 do
	local pos = Vector3.new(
		-380 + RNG:NextNumber() * 260,
		0,
		-380 + RNG:NextNumber() * 260
	)
	makeTree(pos, swDarkForest, 1 + RNG:NextNumber() * 0.5)
end

-- Mushroom circles
for i = 1, 8 do
	local centerPos = Vector3.new(
		-360 + RNG:NextNumber() * 220,
		0,
		-360 + RNG:NextNumber() * 220
	)
	for j = 1, 6 + math.random(6) do
		local angle = (j / (6 + math.random(6))) * math.pi * 2
		local radius = 3 + RNG:NextNumber() * 4
		local mushroomPos = centerPos + Vector3.new(
			math.sin(angle) * radius,
			0,
			math.cos(angle) * radius
		)
		makePart(
			"Mushroom",
			Vector3.new(0.8, 1.2, 0.8),
			mushroomPos + Vector3.new(0, 0.6, 0),
			Color3.fromRGB(128, 0, 128),
			Enum.Material.Neon,
			swDarkForest,
			{ Shape = Enum.PartType.Ball }
		)
	end
end

-- Spider webs (thin transparent parts)
for i = 1, 15 do
	local pos = Vector3.new(
		-370 + RNG:NextNumber() * 240,
		2 + RNG:NextNumber() * 4,
		-370 + RNG:NextNumber() * 240
	)
	makePart(
		"SpiderWeb",
		Vector3.new(3, 0.05, 3),
		pos,
		Color3.fromRGB(220, 220, 220),
		Enum.Material.ForceField,
		swDarkForest,
		{ Transparency = 0.8, CanCollide = false }
	)
end

-- CENTRAL WILDERNESS (X: -100 to 100, Z: -200 to -400) â€” More ruins and atmosphere
print("[MapSetup3] Filling central wilderness...")
local centralWilderness = getOrMake(terrain, "CentralWilderness")

-- More ruins
for i = 1, 20 do
	local pos = Vector3.new(
		-80 + RNG:NextNumber() * 160,
		0,
		-380 + RNG:NextNumber() * 180
	)
	local ruinHeight = 1 + RNG:NextNumber() * 4
	makePart(
		"RuinWall",
		Vector3.new(2 + RNG:NextNumber() * 3, ruinHeight, 0.5),
		pos + Vector3.new(0, ruinHeight / 2, 0),
		Color3.fromRGB(100, 100, 100),
		Enum.Material.Concrete,
		centralWilderness
	)
end

-- Gravestones
for i = 1, 15 do
	local pos = Vector3.new(
		-90 + RNG:NextNumber() * 180,
		0,
		-370 + RNG:NextNumber() * 160
	)
	makePart(
		"Gravestone",
		Vector3.new(0.8, 2, 0.3),
		pos + Vector3.new(0, 1, 0),
		Color3.fromRGB(80, 80, 80),
		Enum.Material.Concrete,
		centralWilderness
	)
end

-- Cracked earth
for i = 1, 10 do
	local pos = Vector3.new(
		-70 + RNG:NextNumber() * 140,
		0,
		-360 + RNG:NextNumber() * 140
	)
	makePart(
		"CrackedEarth",
		Vector3.new(6, 0.2, 6),
		pos + Vector3.new(0, 0.1, 0),
		Color3.fromRGB(60, 40, 30),
		Enum.Material.Concrete,
		centralWilderness,
		{ Shape = Enum.PartType.Ball }
	)
end

-- ROLLING HILLS across all areas
print("[MapSetup3] Adding rolling hills across all empty areas...")
local globalHills = getOrMake(terrain, "GlobalHills")

for i = 1, 60 do -- 80 total hills
	local pos = Vector3.new(
		-390 + RNG:NextNumber() * 780,
		0,
		-390 + RNG:NextNumber() * 780
	)
	
	-- Skip areas that are already built up
	local skipArea = false
	-- Skip Haven City area
	if pos.X > -62 and pos.X &lt; 62 and pos.Z > -10 and pos.Z &lt; 108 then
		skipArea = true
	end
	-- Skip core wilderness spawn
	if pos.X > -50 and pos.X &lt; 50 and pos.Z > -450 and pos.Z &lt; -200 then
		skipArea = true
	end
	
	if not skipArea then
		makeHill(pos, globalHills, 0.8 + RNG:NextNumber() * 0.7, 2 + RNG:NextNumber() * 6)
	end
end

-- ADDITIONAL BOULDERS everywhere
print("[MapSetup3] Scattering boulders...")
local globalBoulders = getOrMake(terrain, "GlobalBoulders")

for i = 1, 75 do -- 100 total boulders
	local pos = Vector3.new(
		-380 + RNG:NextNumber() * 760,
		0,
		-380 + RNG:NextNumber() * 760
	)
	
	-- Skip main areas
	local skipArea = false
	if pos.X > -70 and pos.X &lt; 70 and pos.Z > -20 and pos.Z &lt; 120 then
		skipArea = true
	end
	
	if not skipArea then
		makeBoulder(pos, globalBoulders, 0.5 + RNG:NextNumber() * 1.5)
	end
end

-- ADDITIONAL TREES everywhere
print("[MapSetup3] Planting additional trees...")
local globalTrees = getOrMake(terrain, "GlobalTrees")

for i = 1, 35 do -- 60 total trees
	local pos = Vector3.new(
		-370 + RNG:NextNumber() * 740,
		0,
		-370 + RNG:NextNumber() * 740
	)
	
	-- Skip built areas
	local skipArea = false
	if pos.X > -80 and pos.X &lt; 80 and pos.Z > -30 and pos.Z &lt; 130 then
		skipArea = true
	end
	
	if not skipArea then
		makeTree(pos, globalTrees, 0.7 + RNG:NextNumber() * 0.6)
	end
end

-- BUSHES everywhere
print("[MapSetup3] Adding bushes...")
local globalBushes = getOrMake(terrain, "GlobalBushes")

for i = 1, 40 do
	local pos = Vector3.new(
		-350 + RNG:NextNumber() * 700,
		0,
		-350 + RNG:NextNumber() * 700
	)
	makeBush(pos, globalBushes, nil, 0.5 + RNG:NextNumber() * 1.0)
end

-- PONDS scattered around
print("[MapSetup3] Creating scattered ponds...")
local globalPonds = getOrMake(terrain, "GlobalPonds")

for i = 1, 20 do
	local pos = Vector3.new(
		-320 + RNG:NextNumber() * 640,
		0,
		-320 + RNG:NextNumber() * 640
	)
	
	-- Skip central areas
	local skipArea = false
	if pos.X > -100 and pos.X &lt; 100 and pos.Z > -50 and pos.Z &lt; 150 then
		skipArea = true
	end
	
	if not skipArea then
		makePond(pos, globalPonds, 0.8 + RNG:NextNumber() * 0.4)
	end
end

-- FLOWER PATCHES
print("[MapSetup3] Planting flower patches...")
local globalFlowers = getOrMake(terrain, "GlobalFlowers")

for i = 1, 30 do
	local pos = Vector3.new(
		-300 + RNG:NextNumber() * 600,
		0,
		-300 + RNG:NextNumber() * 600
	)
	makeFlowerPatch(pos, globalFlowers)
end

-- MISC DECORATIONS
print("[MapSetup3] Adding miscellaneous decorations...")
local miscDecorations = getOrMake(terrain, "MiscDecorations")

-- Fallen logs
for i = 1, 20 do
	local pos = Vector3.new(
		-350 + RNG:NextNumber() * 700,
		0,
		-350 + RNG:NextNumber() * 700
	)
	local angle = RNG:NextNumber() * 360
	makePart(
		"FallenLog",
		Vector3.new(6, 0.8, 0.8),
		pos + Vector3.new(0, 0.4, 0),
		Color3.fromRGB(101, 67, 33),
		Enum.Material.Wood,
		miscDecorations,
		{ Orientation = Vector3.new(0, angle, 0) }
	)
end

-- Stone wall fragments
for i = 1, 15 do
	local pos = Vector3.new(
		-330 + RNG:NextNumber() * 660,
		0,
		-330 + RNG:NextNumber() * 660
	)
	local wallLength = 5 + RNG:NextNumber() * 10
	makePart(
		"StoneWallFragment",
		Vector3.new(wallLength, 1.5 + RNG:NextNumber(), 0.5),
		pos + Vector3.new(0, 0.75 + RNG:NextNumber() * 0.5, 0),
		Color3.fromRGB(120, 120, 120),
		Enum.Material.Cobblestone,
		miscDecorations
	)
end

-- Random mushrooms
for i = 1, 15 do
	local pos = Vector3.new(
		-340 + RNG:NextNumber() * 680,
		0,
		-340 + RNG:NextNumber() * 680
	)
	makePart(
		"Mushroom",
		Vector3.new(1, 1.5, 1),
		pos + Vector3.new(0, 0.75, 0),
		Color3.fromRGB(200, 50, 50),
		Enum.Material.Neon,
		miscDecorations,
		{ Shape = Enum.PartType.Ball }
	)
end

-- CONNECTING STREAMS between ponds
print("[MapSetup3] Creating connecting streams...")
local streams = getOrMake(terrain, "Streams")

-- Create a few streams connecting some ponds
for i = 1, 8 do
	local startPos = Vector3.new(
		-200 + RNG:NextNumber() * 400,
		0,
		-200 + RNG:NextNumber() * 400
	)
	local endPos = startPos + Vector3.new(
		-50 + RNG:NextNumber() * 100,
		0,
		-50 + RNG:NextNumber() * 100
	)
	
	local direction = (endPos - startPos).Unit
	local distance = (endPos - startPos).Magnitude
	local segments = math.floor(distance / 3)
	
	for j = 0, segments do
		local segmentPos = startPos + direction * (j * 3)
		makePart(
			"StreamSegment",
			Vector3.new(2, 0.2, 3),
			segmentPos + Vector3.new(0, 0.1, 0),
			Color3.fromRGB(65, 130, 175),
			Enum.Material.Water,
			streams,
			{ Transparency = 0.4, CanCollide = false }
		)
	end
end

print("[MapSetup3] Map filling complete!")
print("[MapSetup3] Generated terrain features:")
print("- 80+ hills of various sizes")
print("- 100+ boulders and rocks")
print("- 60+ trees (regular + dead)")
print("- 40+ bushes")
print("- 20+ ponds with lily pads")
print("- 30+ flower patches")
print("- Border walls on all 4 edges")
print("- 50+ misc decorations (fences, logs, mushrooms, ruins)")
print("- Themed quadrants: NE farmland, NW highlands, SE marshland, SW dark forest")
print("- Connecting streams and atmospheric details")
print("[MapSetup3] No empty space remains!")</string>
      </Properties>
    </Item>
    <Item class="Script" referent="144">
      <Properties>
        <string name="Name">MapSetup4</string>
        <token name="RunContext">0</token>
        <string name="Source">--[[
	MapSetup4.server.lua
	ServerScriptService

	Adds 7 new dense themed areas across the map:
	1. Whispering Woods (X: 200-350, Z: 50-200)
	2. Deep Mine (X: -300 to -200, Z: -50 to 50)
	3. Crystal Cavern (X: -350 to -250, Z: -150 to -80)
	4. Moonlit Pond (X: 250-320, Z: -50 to 20)
	5. Thornwood Thicket (X: -200 to -100, Z: 200-350)
	6. Sunflower Fields (X: 100-250, Z: 250-380)
	7. Abandoned Quarry (X: -150 to -50, Z: -250 to -150)
]]

-- Wait for other MapSetup files to finish
task.wait(5)

print("[MapSetup4] Starting themed area creation...")

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------
local function getOrMake(parent, name)
	local existing = parent:FindFirstChild(name)
	if existing then return existing end
	local folder = Instance.new("Folder")
	folder.Name = name
	folder.Parent = parent
	return folder
end

local function makePart(name, size, position, color, material, parent, props)
	local part = Instance.new("Part")
	part.Name = name
	part.Size = size
	part.Position = position
	part.Anchored = true
	part.CanCollide = true
	part.Color = typeof(color) == "string" and BrickColor.new(color).Color or color
	part.Material = material or Enum.Material.SmoothPlastic
	
	if props then
		for key, value in pairs(props) do
			if key == "Orientation" then
				part.Orientation = value
			else
				part[key] = value
			end
		end
	end
	
	part.Parent = parent
	return part
end

local function randomInRange(min, max)
	return min + math.random() * (max - min)
end

local function randomPointInRect(xMin, xMax, zMin, zMax)
	return Vector3.new(randomInRange(xMin, xMax), 0, randomInRange(zMin, zMax))
end

local Workspace = game:GetService("Workspace")
local MapDecorations = getOrMake(Workspace, "MapDecorations")

--------------------------------------------------------------------------------
-- 1. WHISPERING WOODS (X: 200-350, Z: 50-200)
--------------------------------------------------------------------------------
print("[MapSetup4] Building Whispering Woods...")
local WhisperingWoods = getOrMake(MapDecorations, "WhisperingWoods")

-- Create 40+ trees of varying sizes
for i = 1, 45 do
	local pos = randomPointInRect(200, 350, 50, 200)
	local treeHeight = randomInRange(8, 18)
	local trunkSize = randomInRange(1.5, 3.0)
	local crownSize = randomInRange(6, 12)
	
	-- Tree trunk
	makePart("TreeTrunk" .. i, Vector3.new(trunkSize, treeHeight, trunkSize), pos + Vector3.new(0, treeHeight/2, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, WhisperingWoods)
	
	-- Tree crown
	makePart("TreeCrown" .. i, Vector3.new(crownSize, crownSize * 0.8, crownSize), pos + Vector3.new(0, treeHeight + crownSize/3, 0), 
		Color3.fromRGB(34, 139, 34), Enum.Material.Grass, WhisperingWoods, {Shape = Enum.PartType.Ball})
end

-- Undergrowth bushes
for i = 1, 25 do
	local pos = randomPointInRect(200, 350, 50, 200)
	makePart("Bush" .. i, Vector3.new(randomInRange(2, 4), randomInRange(1.5, 2.5), randomInRange(2, 4)), 
		pos + Vector3.new(0, 1, 0), Color3.fromRGB(85, 107, 47), Enum.Material.Grass, WhisperingWoods)
end

-- Fallen logs
for i = 1, 8 do
	local pos = randomPointInRect(200, 350, 50, 200)
	makePart("FallenLog" .. i, Vector3.new(0.8, 0.8, randomInRange(6, 12)), pos + Vector3.new(0, 0.4, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, WhisperingWoods, 
		{Orientation = Vector3.new(0, randomInRange(0, 360), randomInRange(-15, 15))})
end

-- Mushroom rings
for ring = 1, 3 do
	local centerPos = randomPointInRect(210, 340, 60, 190)
	local radius = randomInRange(3, 6)
	for j = 1, 8 do
		local angle = (j / 8) * 2 * math.pi
		local mushroomPos = centerPos + Vector3.new(math.cos(angle) * radius, 0, math.sin(angle) * radius)
		makePart("Mushroom" .. ring .. "_" .. j, Vector3.new(0.6, 1.2, 0.6), mushroomPos + Vector3.new(0, 0.6, 0), 
			Color3.fromRGB(160, 82, 45), Enum.Material.SmoothPlastic, WhisperingWoods)
		-- Mushroom cap
		makePart("MushroomCap" .. ring .. "_" .. j, Vector3.new(1.5, 0.3, 1.5), mushroomPos + Vector3.new(0, 1.35, 0), 
			Color3.fromRGB(220, 20, 60), Enum.Material.SmoothPlastic, WhisperingWoods, {Shape = Enum.PartType.Cylinder})
	end
end

-- Hidden clearing with ancient stones
local clearingCenter = Vector3.new(275, 0, 125)
for i = 1, 6 do
	local angle = (i / 6) * 2 * math.pi
	local stonePos = clearingCenter + Vector3.new(math.cos(angle) * 8, 0, math.sin(angle) * 8)
	makePart("AncientStone" .. i, Vector3.new(randomInRange(2, 3), randomInRange(4, 7), randomInRange(1.5, 2.5)), 
		stonePos + Vector3.new(0, 2.5, 0), Color3.fromRGB(105, 105, 105), Enum.Material.Rock, WhisperingWoods)
end

-- Fog-colored ground patches
for i = 1, 15 do
	local pos = randomPointInRect(200, 350, 50, 200)
	makePart("FogPatch" .. i, Vector3.new(randomInRange(4, 8), 0.1, randomInRange(4, 8)), 
		pos + Vector3.new(0, 0.05, 0), Color3.fromRGB(248, 248, 255), Enum.Material.ForceField, WhisperingWoods, 
		{Transparency = 0.7, CanCollide = false})
end

-- Owl perches on tall trees
for i = 1, 5 do
	local pos = randomPointInRect(220, 330, 70, 180)
	makePart("OwlPerch" .. i, Vector3.new(0.5, 0.5, 1.2), pos + Vector3.new(0, 15, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, WhisperingWoods)
	-- Owl
	makePart("Owl" .. i, Vector3.new(0.8, 1, 0.6), pos + Vector3.new(0, 15.7, 0), 
		Color3.fromRGB(139, 69, 19), Enum.Material.SmoothPlastic, WhisperingWoods)
end

-- Firefly particles (neon dots)
for i = 1, 20 do
	local pos = randomPointInRect(200, 350, 50, 200)
	makePart("Firefly" .. i, Vector3.new(0.1, 0.1, 0.1), pos + Vector3.new(0, randomInRange(2, 6), 0), 
		Color3.fromRGB(255, 255, 0), Enum.Material.Neon, WhisperingWoods, 
		{Transparency = 0.3, CanCollide = false, Shape = Enum.PartType.Ball})
	-- Add light
	local light = Instance.new("PointLight")
	light.Color = Color3.fromRGB(255, 255, 0)
	light.Brightness = 1
	light.Range = 3
	light.Parent = WhisperingWoods:FindFirstChild("Firefly" .. i)
end

--------------------------------------------------------------------------------
-- 2. DEEP MINE (X: -300 to -200, Z: -50 to 50)
--------------------------------------------------------------------------------
print("[MapSetup4] Building Deep Mine...")
local DeepMine = getOrMake(MapDecorations, "DeepMine")

-- Mine entrance (stone arch)
makePart("MineEntrance", Vector3.new(12, 8, 3), Vector3.new(-250, 4, 0), 
	Color3.fromRGB(105, 105, 105), Enum.Material.Rock, DeepMine)
makePart("MineEntranceHole", Vector3.new(6, 6, 4), Vector3.new(-250, 3, 0), 
	Color3.fromRGB(0, 0, 0), Enum.Material.SmoothPlastic, DeepMine, {Transparency = 0.9})

-- Minecart tracks (parallel thin dark parts)
for i = 1, 20 do
	local zPos = -40 + (i * 4)
	-- Left rail
	makePart("RailLeft" .. i, Vector3.new(0.2, 0.3, 2), Vector3.new(-275, 0.15, zPos), 
		Color3.fromRGB(64, 64, 64), Enum.Material.Metal, DeepMine)
	-- Right rail
	makePart("RailRight" .. i, Vector3.new(0.2, 0.3, 2), Vector3.new(-272, 0.15, zPos), 
		Color3.fromRGB(64, 64, 64), Enum.Material.Metal, DeepMine)
	-- Cross ties
	if i % 2 == 0 then
		makePart("CrossTie" .. i, Vector3.new(4, 0.5, 0.3), Vector3.new(-273.5, 0.1, zPos), 
			Color3.fromRGB(101, 67, 33), Enum.Material.Wood, DeepMine)
	end
end

-- Support beams (brown blocks)
for i = 1, 12 do
	local pos = randomPointInRect(-295, -205, -45, 45)
	makePart("SupportBeam" .. i, Vector3.new(0.8, randomInRange(6, 10), 0.8), pos + Vector3.new(0, 4, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, DeepMine)
	-- Cross beam
	makePart("CrossBeam" .. i, Vector3.new(randomInRange(4, 8), 0.6, 0.6), pos + Vector3.new(0, 8, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, DeepMine)
end

-- Ore veins glowing on walls
for i = 1, 15 do
	local pos = randomPointInRect(-295, -205, -45, 45)
	local oreColor = ({Color3.fromRGB(255, 215, 0), Color3.fromRGB(169, 169, 169), Color3.fromRGB(184, 115, 51)})[math.random(1,3)]
	makePart("OreVein" .. i, Vector3.new(randomInRange(2, 4), randomInRange(1.5, 3), 0.5), pos + Vector3.new(0, 2, 0), 
		oreColor, Enum.Material.Neon, DeepMine, {Transparency = 0.2})
end

-- Mine shaft going down (dark hole with ladder)
makePart("MineShaft", Vector3.new(6, 20, 6), Vector3.new(-260, -10, 10), 
	Color3.fromRGB(0, 0, 0), Enum.Material.SmoothPlastic, DeepMine, {Transparency = 0.8})
-- Ladder
for i = 1, 10 do
	makePart("LadderRung" .. i, Vector3.new(0.3, 0.2, 2), Vector3.new(-257, i * -2, 10), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, DeepMine)
end

-- Lanterns
for i = 1, 8 do
	local pos = randomPointInRect(-290, -210, -40, 40)
	makePart("LanternPost" .. i, Vector3.new(0.3, 4, 0.3), pos + Vector3.new(0, 2, 0), 
		Color3.fromRGB(64, 64, 64), Enum.Material.Metal, DeepMine)
	makePart("Lantern" .. i, Vector3.new(1, 1.5, 1), pos + Vector3.new(0, 4.5, 0), 
		Color3.fromRGB(255, 140, 0), Enum.Material.Neon, DeepMine, {Transparency = 0.3})
	-- Light
	local light = Instance.new("PointLight")
	light.Color = Color3.fromRGB(255, 140, 0)
	light.Brightness = 2
	light.Range = 12
	light.Parent = DeepMine:FindFirstChild("Lantern" .. i)
end

-- Rubble piles
for i = 1, 10 do
	local pos = randomPointInRect(-295, -205, -45, 45)
	makePart("RubblePile" .. i, Vector3.new(randomInRange(2, 5), randomInRange(1, 2.5), randomInRange(2, 5)), 
		pos + Vector3.new(0, 1, 0), Color3.fromRGB(105, 105, 105), Enum.Material.Rock, DeepMine)
end

--------------------------------------------------------------------------------
-- 3. CRYSTAL CAVERN (X: -350 to -250, Z: -150 to -80)
--------------------------------------------------------------------------------
print("[MapSetup4] Building Crystal Cavern...")
local CrystalCavern = getOrMake(MapDecorations, "CrystalCavern")

-- Large crystal spires (neon purple/blue/pink transparent parts pointing up at angles)
for i = 1, 20 do
	local pos = randomPointInRect(-345, -255, -145, -85)
	local crystalColors = {Color3.fromRGB(138, 43, 226), Color3.fromRGB(75, 0, 130), Color3.fromRGB(255, 20, 147)}
	local color = crystalColors[math.random(1, #crystalColors)]
	local height = randomInRange(6, 15)
	
	makePart("CrystalSpire" .. i, Vector3.new(randomInRange(1.5, 3), height, randomInRange(1.5, 3)), 
		pos + Vector3.new(0, height/2, 0), color, Enum.Material.ForceField, CrystalCavern,
		{Transparency = 0.4, Orientation = Vector3.new(randomInRange(-10, 10), randomInRange(0, 360), randomInRange(-10, 10))})
	
	-- Crystal glow
	local light = Instance.new("PointLight")
	light.Color = color
	light.Brightness = 1.5
	light.Range = 8
	light.Parent = CrystalCavern:FindFirstChild("CrystalSpire" .. i)
end

-- Crystal pools (blue transparent floors)
for i = 1, 6 do
	local pos = randomPointInRect(-340, -260, -140, -90)
	makePart("CrystalPool" .. i, Vector3.new(randomInRange(6, 12), 0.5, randomInRange(6, 12)), 
		pos + Vector3.new(0, 0.25, 0), Color3.fromRGB(65, 130, 175), Enum.Material.Water, CrystalCavern,
		{Transparency = 0.3})
end

-- Glowing mushrooms
for i = 1, 15 do
	local pos = randomPointInRect(-345, -255, -145, -85)
	makePart("GlowMushroom" .. i, Vector3.new(randomInRange(0.8, 2), randomInRange(1, 3), randomInRange(0.8, 2)), 
		pos + Vector3.new(0, 1, 0), Color3.fromRGB(0, 255, 127), Enum.Material.Neon, CrystalCavern, 
		{Transparency = 0.3})
end

-- Ambient sparkle parts
for i = 1, 30 do
	local pos = randomPointInRect(-345, -255, -145, -85)
	makePart("Sparkle" .. i, Vector3.new(0.2, 0.2, 0.2), pos + Vector3.new(0, randomInRange(1, 8), 0), 
		Color3.fromRGB(255, 255, 255), Enum.Material.Neon, CrystalCavern,
		{Transparency = 0.2, CanCollide = false, Shape = Enum.PartType.Ball})
end

--------------------------------------------------------------------------------
-- 4. MOONLIT POND (X: 250-320, Z: -50 to 20)
--------------------------------------------------------------------------------
print("[MapSetup4] Building Moonlit Pond...")
local MoonlitPond = getOrMake(MapDecorations, "MoonlitPond")

-- Large scenic pond (blue transparent part)
makePart("MainPond", Vector3.new(60, 2, 60), Vector3.new(285, 1, -15), 
	Color3.fromRGB(65, 130, 175), Enum.Material.Water, MoonlitPond, {Transparency = 0.3})

-- Water lilies (green+pink flat parts)
for i = 1, 12 do
	local pos = randomPointInRect(260, 310, -40, 10)
	makePart("LilyPad" .. i, Vector3.new(randomInRange(2, 3), 0.1, randomInRange(2, 3)), 
		pos + Vector3.new(0, 2.1, 0), Color3.fromRGB(34, 139, 34), Enum.Material.SmoothPlastic, MoonlitPond,
		{CanCollide = false, Shape = Enum.PartType.Cylinder})
	-- Lily flower
	makePart("LilyFlower" .. i, Vector3.new(0.8, 0.3, 0.8), pos + Vector3.new(0, 2.3, 0), 
		Color3.fromRGB(255, 182, 193), Enum.Material.SmoothPlastic, MoonlitPond, {CanCollide = false})
end

-- Cattails (thin brown+green parts)
for i = 1, 20 do
	local pos = randomPointInRect(255, 315, -45, 15)
	makePart("CattailStem" .. i, Vector3.new(0.3, randomInRange(4, 6), 0.3), pos + Vector3.new(0, 2.5, 0), 
		Color3.fromRGB(85, 107, 47), Enum.Material.SmoothPlastic, MoonlitPond)
	makePart("CattailHead" .. i, Vector3.new(0.5, 1.5, 0.5), pos + Vector3.new(0, 5.5, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.SmoothPlastic, MoonlitPond, {Shape = Enum.PartType.Cylinder})
end

-- Wooden dock (brown planks)
local dockStart = Vector3.new(270, 2, -5)
for i = 1, 8 do
	makePart("DockPlank" .. i, Vector3.new(3, 0.5, 12), dockStart + Vector3.new(i * 3, 0, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, MoonlitPond)
end
-- Dock posts
for i = 1, 3 do
	makePart("DockPost" .. i, Vector3.new(0.8, 4, 0.8), dockStart + Vector3.new(i * 8, -1, -5), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, MoonlitPond)
	makePart("DockPost" .. i .. "B", Vector3.new(0.8, 4, 0.8), dockStart + Vector3.new(i * 8, -1, 5), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, MoonlitPond)
end

-- Frogs (small green parts)
for i = 1, 8 do
	local pos = randomPointInRect(260, 310, -40, 10)
	makePart("Frog" .. i, Vector3.new(0.8, 0.6, 1.2), pos + Vector3.new(0, 2.3, 0), 
		Color3.fromRGB(0, 128, 0), Enum.Material.SmoothPlastic, MoonlitPond, {CanCollide = false})
end

-- Willow trees (drooping branch parts)
for i = 1, 5 do
	local pos = randomPointInRect(252, 318, -48, 18)
	-- Main trunk
	makePart("WillowTrunk" .. i, Vector3.new(2, 12, 2), pos + Vector3.new(0, 6, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, MoonlitPond)
	-- Drooping branches
	for j = 1, 8 do
		local angle = (j / 8) * 2 * math.pi
		local branchPos = pos + Vector3.new(math.cos(angle) * 4, 10, math.sin(angle) * 4)
		makePart("WillowBranch" .. i .. "_" .. j, Vector3.new(0.5, randomInRange(6, 10), 0.5), 
			branchPos + Vector3.new(0, -3, 0), Color3.fromRGB(85, 107, 47), Enum.Material.Grass, MoonlitPond,
			{Orientation = Vector3.new(randomInRange(15, 35), randomInRange(0, 360), randomInRange(-10, 10))})
	end
end

--------------------------------------------------------------------------------
-- 5. THORNWOOD THICKET (X: -200 to -100, Z: 200-350)
--------------------------------------------------------------------------------
print("[MapSetup4] Building Thornwood Thicket...")
local ThornwoodThicket = getOrMake(MapDecorations, "ThornwoodThicket")

-- Twisted dark trees
for i = 1, 25 do
	local pos = randomPointInRect(-195, -105, 205, 345)
	local height = randomInRange(8, 16)
	makePart("TwistedTrunk" .. i, Vector3.new(randomInRange(1.5, 2.5), height, randomInRange(1.5, 2.5)), 
		pos + Vector3.new(0, height/2, 0), Color3.fromRGB(64, 64, 64), Enum.Material.Wood, ThornwoodThicket,
		{Orientation = Vector3.new(0, randomInRange(0, 360), randomInRange(-15, 15))})
	-- Dark crown
	makePart("TwistedCrown" .. i, Vector3.new(randomInRange(5, 8), randomInRange(3, 5), randomInRange(5, 8)), 
		pos + Vector3.new(0, height + 2, 0), Color3.fromRGB(25, 25, 25), Enum.Material.Grass, ThornwoodThicket,
		{Shape = Enum.PartType.Ball})
end

-- Thorny bushes (dark green with red dots)
for i = 1, 20 do
	local pos = randomPointInRect(-195, -105, 205, 345)
	makePart("ThornBush" .. i, Vector3.new(randomInRange(3, 5), randomInRange(2, 3), randomInRange(3, 5)), 
		pos + Vector3.new(0, 1.5, 0), Color3.fromRGB(25, 25, 25), Enum.Material.Grass, ThornwoodThicket)
	-- Red thorns
	for j = 1, 5 do
		local thornPos = pos + Vector3.new(randomInRange(-2, 2), randomInRange(1, 3), randomInRange(-2, 2))
		makePart("Thorn" .. i .. "_" .. j, Vector3.new(0.2, 0.8, 0.2), thornPos, 
			Color3.fromRGB(139, 0, 0), Enum.Material.SmoothPlastic, ThornwoodThicket, {CanCollide = false})
	end
end

-- Spider webs between trees (white thin parts)
for i = 1, 12 do
	local pos = randomPointInRect(-190, -110, 210, 340)
	makePart("SpiderWeb" .. i, Vector3.new(randomInRange(3, 6), 0.1, randomInRange(3, 6)), 
		pos + Vector3.new(0, randomInRange(3, 8), 0), Color3.fromRGB(248, 248, 255), Enum.Material.ForceField, 
		ThornwoodThicket, {Transparency = 0.7, CanCollide = false})
end

-- Dark purple ground patches
for i = 1, 15 do
	local pos = randomPointInRect(-195, -105, 205, 345)
	makePart("DarkPatch" .. i, Vector3.new(randomInRange(4, 8), 0.1, randomInRange(4, 8)), 
		pos + Vector3.new(0, 0.05, 0), Color3.fromRGB(75, 0, 130), Enum.Material.SmoothPlastic, ThornwoodThicket,
		{Transparency = 0.5, CanCollide = false})
end

-- Ravens (small black parts on trees)
for i = 1, 8 do
	local pos = randomPointInRect(-190, -110, 210, 340)
	makePart("Raven" .. i, Vector3.new(0.6, 0.5, 0.8), pos + Vector3.new(0, randomInRange(10, 15), 0), 
		Color3.fromRGB(0, 0, 0), Enum.Material.SmoothPlastic, ThornwoodThicket, {CanCollide = false})
end

--------------------------------------------------------------------------------
-- 6. SUNFLOWER FIELDS (X: 100-250, Z: 250-380)
--------------------------------------------------------------------------------
print("[MapSetup4] Building Sunflower Fields...")
local SunflowerFields = getOrMake(MapDecorations, "SunflowerFields")

-- Rows of sunflowers (yellow circles on green stems)
for row = 1, 8 do
	for col = 1, 15 do
		local pos = Vector3.new(110 + col * 9, 0, 260 + row * 15)
		-- Stem
		makePart("SunflowerStem" .. row .. "_" .. col, Vector3.new(0.4, randomInRange(4, 7), 0.4), 
			pos + Vector3.new(0, 2.5, 0), Color3.fromRGB(85, 107, 47), Enum.Material.Grass, SunflowerFields)
		-- Flower head
		makePart("SunflowerHead" .. row .. "_" .. col, Vector3.new(2, 0.5, 2), 
			pos + Vector3.new(0, randomInRange(5, 8), 0), Color3.fromRGB(255, 215, 0), Enum.Material.SmoothPlastic, 
			SunflowerFields, {Shape = Enum.PartType.Cylinder})
	end
end

-- Bee hives (yellow cubes)
for i = 1, 6 do
	local pos = randomPointInRect(120, 240, 270, 370)
	makePart("BeeHive" .. i, Vector3.new(2, 3, 2), pos + Vector3.new(0, 1.5, 0), 
		Color3.fromRGB(255, 215, 0), Enum.Material.SmoothPlastic, SunflowerFields)
	makePart("BeeHiveEntry" .. i, Vector3.new(0.8, 0.8, 0.3), pos + Vector3.new(0, 1.5, 1.2), 
		Color3.fromRGB(0, 0, 0), Enum.Material.SmoothPlastic, SunflowerFields)
end

-- Honey puddles
for i = 1, 8 do
	local pos = randomPointInRect(110, 240, 260, 370)
	makePart("HoneyPuddle" .. i, Vector3.new(randomInRange(2, 4), 0.2, randomInRange(2, 4)), 
		pos + Vector3.new(0, 0.1, 0), Color3.fromRGB(255, 140, 0), Enum.Material.SmoothPlastic, SunflowerFields,
		{Transparency = 0.3})
end

-- Picket fences
for i = 1, 20 do
	local pos = Vector3.new(105 + i * 7, 0, 255)
	makePart("FencePost" .. i, Vector3.new(0.3, 2, 0.3), pos + Vector3.new(0, 1, 0), 
		Color3.fromRGB(245, 245, 220), Enum.Material.SmoothPlastic, SunflowerFields)
	if i &lt; 20 then
		makePart("FenceRail" .. i, Vector3.new(7, 0.2, 0.3), pos + Vector3.new(3.5, 1.5, 0), 
			Color3.fromRGB(245, 245, 220), Enum.Material.SmoothPlastic, SunflowerFields)
	end
end

-- Windmill (large structure)
local windmillPos = Vector3.new(175, 0, 315)
makePart("WindmillBase", Vector3.new(6, 20, 6), windmillPos + Vector3.new(0, 10, 0), 
	Color3.fromRGB(245, 245, 220), Enum.Material.SmoothPlastic, SunflowerFields, {Shape = Enum.PartType.Cylinder})
-- Windmill blades
for i = 1, 4 do
	local angle = (i / 4) * 2 * math.pi
	makePart("WindmillBlade" .. i, Vector3.new(0.5, 12, 1), 
		windmillPos + Vector3.new(math.cos(angle) * 8, 20, math.sin(angle) * 8), 
		Color3.fromRGB(245, 245, 220), Enum.Material.SmoothPlastic, SunflowerFields,
		{Orientation = Vector3.new(0, math.deg(angle), 0)})
end

-- Wheat patches (tan thin parts)
for i = 1, 15 do
	local pos = randomPointInRect(120, 230, 270, 370)
	for j = 1, 10 do
		makePart("WheatStalk" .. i .. "_" .. j, Vector3.new(0.1, randomInRange(2, 3), 0.1), 
			pos + Vector3.new(randomInRange(-2, 2), 1.5, randomInRange(-2, 2)), 
			Color3.fromRGB(210, 180, 140), Enum.Material.SmoothPlastic, SunflowerFields)
	end
end

--------------------------------------------------------------------------------
-- 7. ABANDONED QUARRY (X: -150 to -50, Z: -250 to -150)
--------------------------------------------------------------------------------
print("[MapSetup4] Building Abandoned Quarry...")
local AbandonedQuarry = getOrMake(MapDecorations, "AbandonedQuarry")

-- Stepped terrain going down
for level = 1, 5 do
	local yPos = -(level * 3)
	local size = 80 - (level * 10)
	makePart("QuarryLevel" .. level, Vector3.new(size, 1, size), 
		Vector3.new(-100, yPos, -200), Color3.fromRGB(105, 105, 105), Enum.Material.Rock, AbandonedQuarry)
end

-- Broken machinery
for i = 1, 6 do
	local pos = randomPointInRect(-145, -55, -245, -155)
	makePart("BrokenMachine" .. i, Vector3.new(randomInRange(3, 6), randomInRange(2, 4), randomInRange(2, 5)), 
		pos + Vector3.new(0, 1.5, 0), Color3.fromRGB(64, 64, 64), Enum.Material.Metal, AbandonedQuarry)
	-- Rust patches
	makePart("RustPatch" .. i, Vector3.new(randomInRange(1, 3), randomInRange(1, 2), 0.1), 
		pos + Vector3.new(0, 2, 2.6), Color3.fromRGB(139, 69, 19), Enum.Material.SmoothPlastic, AbandonedQuarry)
end

-- Ore carts
for i = 1, 4 do
	local pos = randomPointInRect(-140, -60, -240, -160)
	makePart("OreCart" .. i, Vector3.new(3, 2, 4), pos + Vector3.new(0, 1, 0), 
		Color3.fromRGB(64, 64, 64), Enum.Material.Metal, AbandonedQuarry)
	-- Cart contents (ore)
	makePart("CartOre" .. i, Vector3.new(2.5, 1, 3.5), pos + Vector3.new(0, 2.25, 0), 
		Color3.fromRGB(105, 105, 105), Enum.Material.Rock, AbandonedQuarry)
end

-- Stagnant water at bottom
makePart("StagnantWater", Vector3.new(60, 1, 60), Vector3.new(-100, -14.5, -200), 
	Color3.fromRGB(30, 80, 120), Enum.Material.Water, AbandonedQuarry, {Transparency = 0.3})

-- Rusted metal parts
for i = 1, 12 do
	local pos = randomPointInRect(-145, -55, -245, -155)
	makePart("RustedMetal" .. i, Vector3.new(randomInRange(1, 3), randomInRange(0.5, 2), randomInRange(1, 3)), 
		pos + Vector3.new(0, 0.75, 0), Color3.fromRGB(139, 69, 19), Enum.Material.Metal, AbandonedQuarry)
end

-- Danger signs
for i = 1, 5 do
	local pos = randomPointInRect(-140, -60, -240, -160)
	makePart("DangerSignPost" .. i, Vector3.new(0.3, 4, 0.3), pos + Vector3.new(0, 2, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, AbandonedQuarry)
	makePart("DangerSign" .. i, Vector3.new(0.2, 2, 3), pos + Vector3.new(0, 3, 0), 
		Color3.fromRGB(255, 0, 0), Enum.Material.SmoothPlastic, AbandonedQuarry)
end

print("[MapSetup4] All themed areas completed!")</string>
      </Properties>
    </Item>
    <Item class="Script" referent="145">
      <Properties>
        <string name="Name">MapSetup5</string>
        <token name="RunContext">0</token>
        <string name="Source">--[[
	MapSetup5.server.lua
	ServerScriptService

	Creates 6 MASSIVE new themed areas with incredible detail (50-80 parts each):
	1. Pirate Cove (X: 300-400, Z: -200 to -100)
	2. Frozen Peaks (X: -400 to -300, Z: -300 to -200)
	3. Volcanic Crater (X: 300-400, Z: -400 to -300)
	4. Enchanted Garden (X: -300 to -200, Z: 200-350)
	5. Underground Ruins (X: -100 to 50, Z: -450 to -350)
	6. Dragon's Nest (X: 0-100, Z: -500 to -450)
]]

-- Wait for previous map setups to finish
task.wait(7)

print("[MapSetup5] Starting major new area creation...")

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------
local function getOrMake(parent, name)
	local existing = parent:FindFirstChild(name)
	if existing then return existing end
	local folder = Instance.new("Folder")
	folder.Name = name
	folder.Parent = parent
	return folder
end

local function makePart(name, size, position, color, material, parent, props)
	local part = Instance.new("Part")
	part.Name = name
	part.Size = size
	part.Position = position
	part.Anchored = true
	part.CanCollide = true
	part.Color = typeof(color) == "string" and BrickColor.new(color).Color or color
	part.Material = material or Enum.Material.SmoothPlastic
	
	if props then
		for key, value in pairs(props) do
			if key == "Orientation" then
				part.Orientation = value
			elseif key == "Transparency" then
				part.Transparency = value
			elseif key == "CanCollide" then
				part.CanCollide = value
			elseif key == "Shape" then
				part.Shape = value
			else
				part[key] = value
			end
		end
	end
	
	part.Parent = parent
	return part
end

local function makeSign(parent, text, offset, size)
	local bg = Instance.new("BillboardGui")
	bg.Size = size or UDim2.new(12, 0, 3, 0)
	bg.StudsOffset = offset or Vector3.new(0, 5, 0)
	bg.Parent = parent
	local tl = Instance.new("TextLabel")
	tl.Size = UDim2.new(1, 0, 1, 0)
	tl.BackgroundTransparency = 1
	tl.Text = text
	tl.TextColor3 = Color3.fromRGB(255, 255, 255)
	tl.TextScaled = true
	tl.Font = Enum.Font.GothamBold
	tl.TextStrokeTransparency = 0.3
	tl.Parent = bg
	return bg
end

local function randomInRange(min, max)
	return min + math.random() * (max - min)
end

local function randomPointInRect(xMin, xMax, zMin, zMax)
	return Vector3.new(randomInRange(xMin, xMax), 0, randomInRange(zMin, zMax))
end

local Workspace = game:GetService("Workspace")
local NewAreas = getOrMake(Workspace, "NewAreas")
local ResourceNodes = getOrMake(Workspace, "ResourceNodes")

--------------------------------------------------------------------------------
-- 1. PIRATE COVE (X: 300-400, Z: -200 to -100)
--------------------------------------------------------------------------------
print("[MapSetup5] Building Pirate Cove...")
local PirateCove = getOrMake(NewAreas, "PirateCove")

-- Sandy beach ground
for i = 1, 8 do
	local pos = randomPointInRect(300, 400, -200, -100)
	makePart("SandPatch" .. i, Vector3.new(randomInRange(15, 25), 0.5, randomInRange(15, 25)), 
		pos + Vector3.new(0, 0.25, 0), Color3.fromRGB(194, 178, 128), Enum.Material.Sand, PirateCove)
end

-- WRECKED PIRATE SHIP (massive centerpiece)
local shipCenter = Vector3.new(350, 0, -150)
-- Hull pieces (broken ship)
makePart("ShipHullMain", Vector3.new(25, 8, 5), shipCenter + Vector3.new(0, 4, 0), 
	Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove)
makePart("ShipHullBow", Vector3.new(15, 6, 4), shipCenter + Vector3.new(15, 3, -2), 
	Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove, {Orientation = Vector3.new(0, 15, -10)})
makePart("ShipHullStern", Vector3.new(12, 5, 4), shipCenter + Vector3.new(-18, 2.5, 3), 
	Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove, {Orientation = Vector3.new(0, -20, 5)})

-- Broken mast
makePart("MainMast", Vector3.new(1.5, 20, 1.5), shipCenter + Vector3.new(0, 10, 0), 
	Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove, {Orientation = Vector3.new(0, 0, -15)})
makePart("BrokenMastTop", Vector3.new(1, 8, 1), shipCenter + Vector3.new(-8, 4, -5), 
	Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove, {Orientation = Vector3.new(0, 45, -30)})

-- Tattered sails
for i = 1, 4 do
	local sailPos = shipCenter + Vector3.new(randomInRange(-10, 10), randomInRange(8, 15), randomInRange(-8, 8))
	makePart("TatteredSail" .. i, Vector3.new(randomInRange(6, 12), randomInRange(4, 8), 0.2), 
		sailPos, Color3.fromRGB(240, 230, 200), Enum.Material.Fabric, PirateCove, 
		{Transparency = 0.2, Orientation = Vector3.new(randomInRange(-20, 20), randomInRange(0, 360), randomInRange(-15, 15))})
end

-- Ship rigging (ropes)
for i = 1, 12 do
	local startPos = shipCenter + Vector3.new(randomInRange(-12, 12), randomInRange(5, 18), randomInRange(-6, 6))
	local endPos = startPos + Vector3.new(randomInRange(-8, 8), randomInRange(-5, 5), randomInRange(-8, 8))
	local midPoint = (startPos + endPos) * 0.5
	local length = (endPos - startPos).Magnitude
	makePart("Rigging" .. i, Vector3.new(0.15, 0.15, length), midPoint, 
		Color3.fromRGB(139, 90, 43), Enum.Material.Fabric, PirateCove)
end

-- Treasure chests scattered around
local treasurePositions = {
	{325, 0, -140}, {370, 0, -165}, {340, 0, -185}, {385, 0, -120}, {315, 0, -170}
}
for i, pos in ipairs(treasurePositions) do
	makePart("TreasureChest" .. i, Vector3.new(3, 2, 2), Vector3.new(pos[1], 1, pos[3]), 
		Color3.fromRGB(139, 90, 43), Enum.Material.Wood, PirateCove)
	makePart("ChestBanding" .. i, Vector3.new(3.2, 0.3, 2.2), Vector3.new(pos[1], 1, pos[3]), 
		Color3.fromRGB(64, 64, 64), Enum.Material.Metal, PirateCove)
	makePart("ChestLock" .. i, Vector3.new(0.6, 0.6, 0.4), Vector3.new(pos[1], 1, pos[3] + 1.2), 
		Color3.fromRGB(255, 215, 0), Enum.Material.Metal, PirateCove)
	-- Spilled treasure
	for j = 1, 5 do
		local coinPos = Vector3.new(pos[1], 0.2, pos[3]) + Vector3.new(randomInRange(-3, 3), 0, randomInRange(-3, 3))
		makePart("Coin" .. i .. "_" .. j, Vector3.new(0.3, 0.1, 0.3), coinPos, 
			Color3.fromRGB(255, 215, 0), Enum.Material.Metal, PirateCove, {Shape = Enum.PartType.Cylinder})
	end
end

-- Wooden dock with rope posts
local dockStart = Vector3.new(320, 0, -120)
for i = 1, 15 do
	makePart("DockPlank" .. i, Vector3.new(4, 0.5, 20), dockStart + Vector3.new(i * 4, 0.25, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove)
end
-- Dock posts with ropes
for i = 1, 4 do
	local postPos = dockStart + Vector3.new(i * 15, 0, -12)
	makePart("DockPost" .. i, Vector3.new(0.8, 6, 0.8), postPos + Vector3.new(0, 3, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove)
	-- Rope coiled around post
	makePart("CoiledRope" .. i, Vector3.new(2, 1.5, 2), postPos + Vector3.new(0, 1.5, 0), 
		Color3.fromRGB(139, 90, 43), Enum.Material.Fabric, PirateCove, {Shape = Enum.PartType.Ball})
end

-- Barrels and crates scattered around
for i = 1, 15 do
	local pos = randomPointInRect(305, 395, -195, -105)
	if math.random() > 0.5 then
		-- Barrel
		makePart("Barrel" .. i, Vector3.new(2.5, 3, 2.5), pos + Vector3.new(0, 1.5, 0), 
			Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove, {Shape = Enum.PartType.Cylinder})
		makePart("BarrelBand" .. i, Vector3.new(2.7, 0.2, 2.7), pos + Vector3.new(0, 1.5, 0), 
			Color3.fromRGB(64, 64, 64), Enum.Material.Metal, PirateCove)
	else
		-- Crate
		makePart("Crate" .. i, Vector3.new(2.5, 2.5, 2.5), pos + Vector3.new(0, 1.25, 0), 
			Color3.fromRGB(139, 90, 43), Enum.Material.Wood, PirateCove)
	end
end

-- Cannons (old ship artillery)
for i = 1, 6 do
	local cannonPos = randomPointInRect(320, 380, -180, -120)
	makePart("CannonBase" .. i, Vector3.new(3, 1, 4), cannonPos + Vector3.new(0, 0.5, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove)
	makePart("CannonBarrel" .. i, Vector3.new(1.5, 1.5, 6), cannonPos + Vector3.new(0, 1.5, 0), 
		Color3.fromRGB(64, 64, 64), Enum.Material.Metal, PirateCove, 
		{Shape = Enum.PartType.Cylinder, Orientation = Vector3.new(0, 0, 90)})
	makePart("CannonMuzzle" .. i, Vector3.new(1.8, 1.8, 0.5), cannonPos + Vector3.new(0, 1.5, 3.5), 
		Color3.fromRGB(40, 40, 40), Enum.Material.Metal, PirateCove, {Shape = Enum.PartType.Cylinder})
end

-- Palm trees (curved trunks)
for i = 1, 12 do
	local palmPos = randomPointInRect(310, 390, -190, -110)
	-- Curved trunk
	makePart("PalmTrunk" .. i, Vector3.new(1.5, 12, 1.5), palmPos + Vector3.new(0, 6, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove, 
		{Orientation = Vector3.new(randomInRange(-15, 15), randomInRange(0, 360), randomInRange(-20, 20))})
	-- Palm fronds (large leaves)
	for j = 1, 8 do
		local angle = (j / 8) * 360
		local frondPos = palmPos + Vector3.new(
			math.cos(math.rad(angle)) * 4, 
			12, 
			math.sin(math.rad(angle)) * 4
		)
		makePart("PalmFrond" .. i .. "_" .. j, Vector3.new(0.5, 0.2, 6), frondPos, 
			Color3.fromRGB(34, 139, 34), Enum.Material.Grass, PirateCove, 
			{Orientation = Vector3.new(randomInRange(-20, 20), angle, randomInRange(-30, 30))})
	end
	-- Coconuts
	for k = 1, 3 do
		local coconutPos = palmPos + Vector3.new(randomInRange(-2, 2), 10, randomInRange(-2, 2))
		makePart("Coconut" .. i .. "_" .. k, Vector3.new(0.8, 1, 0.8), coconutPos, 
			Color3.fromRGB(139, 69, 19), Enum.Material.Wood, PirateCove, {Shape = Enum.PartType.Ball})
	end
end

-- Tide pools (small water features)
for i = 1, 8 do
	local poolPos = randomPointInRect(305, 395, -195, -105)
	makePart("TidePool" .. i, Vector3.new(randomInRange(3, 6), 0.3, randomInRange(3, 6)), 
		poolPos + Vector3.new(0, 0.15, 0), Color3.fromRGB(65, 130, 175), Enum.Material.Water, 
		PirateCove, {Transparency = 0.3, Shape = Enum.PartType.Ball})
	-- Pool creatures
	for j = 1, 3 do
		local creaturePos = poolPos + Vector3.new(randomInRange(-2, 2), 0.5, randomInRange(-2, 2))
		makePart("Starfish" .. i .. "_" .. j, Vector3.new(0.5, 0.1, 0.5), creaturePos, 
			Color3.fromRGB(255, 69, 0), Enum.Material.SmoothPlastic, PirateCove)
	end
end

-- Cave entrance in cliff
makePart("CliffWallL", Vector3.new(8, 15, 12), Vector3.new(390, 7.5, -180), 
	Color3.fromRGB(105, 105, 105), Enum.Material.Rock, PirateCove)
makePart("CliffWallR", Vector3.new(8, 15, 12), Vector3.new(405, 7.5, -180), 
	Color3.fromRGB(105, 105, 105), Enum.Material.Rock, PirateCove)
makePart("CaveArch", Vector3.new(9, 6, 8), Vector3.new(397.5, 13, -180), 
	Color3.fromRGB(105, 105, 105), Enum.Material.Rock, PirateCove)
makePart("CaveEntrance", Vector3.new(6, 8, 10), Vector3.new(397.5, 4, -175), 
	Color3.fromRGB(20, 20, 20), Enum.Material.SmoothPlastic, PirateCove, {Transparency = 0.8})

-- Seagull perches (tall posts)
for i = 1, 6 do
	local perchPos = randomPointInRect(315, 385, -185, -115)
	makePart("SeagullPerch" .. i, Vector3.new(0.5, 8, 0.5), perchPos + Vector3.new(0, 4, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove)
	makePart("Seagull" .. i, Vector3.new(1, 0.8, 1.5), perchPos + Vector3.new(0, 8.5, 0), 
		Color3.fromRGB(240, 240, 240), Enum.Material.SmoothPlastic, PirateCove)
end

-- Ship anchor
makePart("Anchor", Vector3.new(2, 4, 1), Vector3.new(345, 1, -130), 
	Color3.fromRGB(64, 64, 64), Enum.Material.Metal, PirateCove)
makePart("AnchorChain", Vector3.new(0.3, 15, 0.3), Vector3.new(345, 8, -130), 
	Color3.fromRGB(64, 64, 64), Enum.Material.Metal, PirateCove)

-- Pirate Cove sign
local pirateSign = makePart("PirateSign", Vector3.new(1, 1, 1), Vector3.new(350, 12, -100), 
	"White", nil, PirateCove, {Transparency = 1})
makeSign(pirateSign, "ðŸ´â€â˜ ï¸ PIRATE COVE", Vector3.new(0, 0, 0))

--------------------------------------------------------------------------------
-- 2. FROZEN PEAKS (X: -400 to -300, Z: -300 to -200)
--------------------------------------------------------------------------------
print("[MapSetup5] Building Frozen Peaks...")
local FrozenPeaks = getOrMake(NewAreas, "FrozenPeaks")

-- Snow-covered ground patches
for i = 1, 12 do
	local pos = randomPointInRect(-400, -300, -300, -200)
	makePart("SnowPatch" .. i, Vector3.new(randomInRange(12, 20), 0.8, randomInRange(12, 20)), 
		pos + Vector3.new(0, 0.4, 0), Color3.fromRGB(248, 248, 255), Enum.Material.Snow, FrozenPeaks)
end

-- Massive ice crystals (angled spires)
for i = 1, 15 do
	local pos = randomPointInRect(-395, -305, -295, -205)
	local height = randomInRange(8, 18)
	makePart("IceCrystal" .. i, Vector3.new(randomInRange(2, 4), height, randomInRange(2, 4)), 
		pos + Vector3.new(0, height/2, 0), Color3.fromRGB(173, 216, 230), Enum.Material.ForceField, 
		FrozenPeaks, {Transparency = 0.3, Orientation = Vector3.new(randomInRange(-15, 15), randomInRange(0, 360), randomInRange(-15, 15))})
	-- Crystal glow
	local light = Instance.new("PointLight")
	light.Color = Color3.fromRGB(173, 216, 230)
	light.Brightness = 1.5
	light.Range = 12
	light.Parent = FrozenPeaks:FindFirstChild("IceCrystal" .. i)
end

-- Frozen waterfall (vertical ice strip)
makePart("WaterfallIce", Vector3.new(6, 25, 1), Vector3.new(-370, 12.5, -220), 
	Color3.fromRGB(173, 216, 230), Enum.Material.ForceField, FrozenPeaks, {Transparency = 0.4})
makePart("WaterfallBase", Vector3.new(8, 2, 8), Vector3.new(-370, 1, -220), 
	Color3.fromRGB(173, 216, 230), Enum.Material.Ice, FrozenPeaks, {Transparency = 0.2})
-- Icicles around waterfall
for i = 1, 12 do
	local iciclePos = Vector3.new(-370, 0, -220) + Vector3.new(randomInRange(-8, 8), randomInRange(15, 22), randomInRange(-3, 3))
	makePart("Icicle" .. i, Vector3.new(0.5, randomInRange(3, 8), 0.5), iciclePos, 
		Color3.fromRGB(240, 248, 255), Enum.Material.Ice, FrozenPeaks, {Transparency = 0.2})
end

-- Snow-covered pine trees
for i = 1, 20 do
	local treePos = randomPointInRect(-390, -310, -290, -210)
	-- Trunk
	makePart("PineTrunk" .. i, Vector3.new(1.5, randomInRange(10, 16), 1.5), 
		treePos + Vector3.new(0, 6, 0), Color3.fromRGB(101, 67, 33), Enum.Material.Wood, FrozenPeaks)
	-- Layered pine branches with snow
	local treeHeight = 12
	for layer = 1, 4 do
		local layerY = treeHeight - (layer * 2.5)
		local layerSize = 5 + (4 - layer) * 1.5
		-- Green base
		makePart("PineBranch" .. i .. "_" .. layer, 
			Vector3.new(layerSize, 1.5, layerSize), 
			treePos + Vector3.new(0, layerY, 0), 
			Color3.fromRGB(34, 139, 34), Enum.Material.Grass, FrozenPeaks, {Shape = Enum.PartType.Ball})
		-- Snow topping
		makePart("PineSnow" .. i .. "_" .. layer, 
			Vector3.new(layerSize * 0.8, 0.8, layerSize * 0.8), 
			treePos + Vector3.new(0, layerY + 0.8, 0), 
			Color3.fromRGB(248, 248, 255), Enum.Material.Snow, FrozenPeaks, {Shape = Enum.PartType.Ball})
	end
end

-- Ice cave entrance
makePart("IceCaveL", Vector3.new(8, 12, 8), Vector3.new(-380, 6, -260), 
	Color3.fromRGB(173, 216, 230), Enum.Material.Ice, FrozenPeaks, {Transparency = 0.2})
makePart("IceCaveR", Vector3.new(8, 12, 8), Vector3.new(-365, 6, -260), 
	Color3.fromRGB(173, 216, 230), Enum.Material.Ice, FrozenPeaks, {Transparency = 0.2})
makePart("IceCaveTop", Vector3.new(23, 5, 8), Vector3.new(-372.5, 14, -260), 
	Color3.fromRGB(173, 216, 230), Enum.Material.Ice, FrozenPeaks, {Transparency = 0.2})
makePart("CaveInterior", Vector3.new(12, 8, 15), Vector3.new(-372.5, 4, -255), 
	Color3.fromRGB(30, 30, 60), Enum.Material.SmoothPlastic, FrozenPeaks, {Transparency = 0.7})

-- Frozen lake (large ice sheet)
makePart("FrozenLake", Vector3.new(40, 0.8, 30), Vector3.new(-350, 0.4, -240), 
	Color3.fromRGB(173, 216, 230), Enum.Material.Ice, FrozenPeaks, {Transparency = 0.3})
-- Cracks in ice
for i = 1, 8 do
	local crackPos = Vector3.new(-350, 0.9, -240) + Vector3.new(randomInRange(-18, 18), 0, randomInRange(-13, 13))
	makePart("IceCrack" .. i, Vector3.new(0.2, 0.1, randomInRange(5, 12)), crackPos, 
		Color3.fromRGB(100, 150, 200), Enum.Material.Ice, FrozenPeaks, {Transparency = 0.5})
end

-- Snow drifts (white bumps)
for i = 1, 15 do
	local driftPos = randomPointInRect(-395, -305, -295, -205)
	makePart("SnowDrift" .. i, Vector3.new(randomInRange(4, 8), randomInRange(2, 4), randomInRange(4, 8)), 
		driftPos + Vector3.new(0, 1, 0), Color3.fromRGB(248, 248, 255), Enum.Material.Snow, FrozenPeaks, 
		{Shape = Enum.PartType.Ball})
end

-- Rock overhangs with icicles
for i = 1, 6 do
	local overhangPos = randomPointInRect(-390, -310, -290, -210)
	makePart("RockOverhang" .. i, Vector3.new(randomInRange(8, 12), 3, randomInRange(6, 10)), 
		overhangPos + Vector3.new(0, 8, 0), Color3.fromRGB(105, 105, 105), Enum.Material.Rock, FrozenPeaks)
	-- Hanging icicles
	for j = 1, 6 do
		local iciclePos = overhangPos + Vector3.new(randomInRange(-5, 5), 6.5, randomInRange(-4, 4))
		makePart("HangingIcicle" .. i .. "_" .. j, 
			Vector3.new(0.4, randomInRange(2, 5), 0.4), iciclePos, 
			Color3.fromRGB(240, 248, 255), Enum.Material.Ice, FrozenPeaks, {Transparency = 0.2})
	end
end

-- Frozen Peaks sign
local frozenSign = makePart("FrozenSign", Vector3.new(1, 1, 1), Vector3.new(-350, 15, -200), 
	"White", nil, FrozenPeaks, {Transparency = 1})
makeSign(frozenSign, "ðŸ—» FROZEN PEAKS", Vector3.new(0, 0, 0))

--------------------------------------------------------------------------------
-- 3. VOLCANIC CRATER (X: 300-400, Z: -400 to -300)
--------------------------------------------------------------------------------
print("[MapSetup5] Building Volcanic Crater...")
local VolcanicCrater = getOrMake(NewAreas, "VolcanicCrater")

-- Dark volcanic rock terrain
for i = 1, 10 do
	local pos = randomPointInRect(300, 400, -400, -300)
	makePart("VolcanicGround" .. i, Vector3.new(randomInRange(15, 25), 1, randomInRange(15, 25)), 
		pos + Vector3.new(0, 0.5, 0), Color3.fromRGB(64, 32, 32), Enum.Material.Rock, VolcanicCrater)
end

-- Lava pools (orange-red neon with lights)
for i = 1, 12 do
	local poolPos = randomPointInRect(310, 390, -390, -310)
	local pool = makePart("LavaPool" .. i, Vector3.new(randomInRange(5, 10), 0.8, randomInRange(5, 10)), 
		poolPos + Vector3.new(0, 0.4, 0), Color3.fromRGB(255, 69, 0), Enum.Material.Neon, 
		VolcanicCrater, {Transparency = 0.2})
	-- Lava light
	local lavaLight = Instance.new("PointLight")
	lavaLight.Color = Color3.fromRGB(255, 100, 20)
	lavaLight.Brightness = 3
	lavaLight.Range = 15
	lavaLight.Parent = pool
	-- Bubbling effect
	for j = 1, 3 do
		local bubblePos = poolPos + Vector3.new(randomInRange(-3, 3), 1.5, randomInRange(-3, 3))
		makePart("LavaBubble" .. i .. "_" .. j, Vector3.new(0.8, 0.8, 0.8), bubblePos, 
			Color3.fromRGB(255, 140, 0), Enum.Material.Neon, VolcanicCrater, 
			{Transparency = 0.4, Shape = Enum.PartType.Ball, CanCollide = false})
	end
end

-- Obsidian spikes (black shiny pointed parts)
for i = 1, 18 do
	local spikePos = randomPointInRect(305, 395, -395, -305)
	local height = randomInRange(4, 12)
	makePart("ObsidianSpike" .. i, Vector3.new(randomInRange(1.5, 3), height, randomInRange(1.5, 3)), 
		spikePos + Vector3.new(0, height/2, 0), Color3.fromRGB(20, 20, 20), Enum.Material.Glass, 
		VolcanicCrater, {Orientation = Vector3.new(randomInRange(-10, 10), randomInRange(0, 360), randomInRange(-10, 10))})
end

-- Sulfur vents (yellow parts with smoke effect)
for i = 1, 8 do
	local ventPos = randomPointInRect(315, 385, -385, -315)
	makePart("SulfurVent" .. i, Vector3.new(2, 1, 2), ventPos + Vector3.new(0, 0.5, 0), 
		Color3.fromRGB(255, 255, 0), Enum.Material.Neon, VolcanicCrater, {Transparency = 0.3})
	-- Sulfur crystals around vent
	for j = 1, 4 do
		local crystalPos = ventPos + Vector3.new(randomInRange(-3, 3), 0.5, randomInRange(-3, 3))
		makePart("SulfurCrystal" .. i .. "_" .. j, Vector3.new(0.5, randomInRange(1, 2), 0.5), crystalPos, 
			Color3.fromRGB(255, 215, 0), Enum.Material.Neon, VolcanicCrater, {Transparency = 0.4})
	end
	-- Smoke effect (gray transparent parts)
	for k = 1, 3 do
		local smokeHeight = k * 3
		makePart("Smoke" .. i .. "_" .. k, Vector3.new(3 + k, 2, 3 + k), 
			ventPos + Vector3.new(0, smokeHeight, 0), Color3.fromRGB(100, 100, 100), 
			Enum.Material.ForceField, VolcanicCrater, 
			{Transparency = 0.7 + (k * 0.1), CanCollide = false, Shape = Enum.PartType.Ball})
	end
end

-- Charred trees (black trunks, no leaves)
for i = 1, 15 do
	local treePos = randomPointInRect(310, 390, -390, -310)
	local height = randomInRange(6, 12)
	makePart("CharredTrunk" .. i, Vector3.new(1.2, height, 1.2), 
		treePos + Vector3.new(0, height/2, 0), Color3.fromRGB(20, 20, 20), 
		Enum.Material.Wood, VolcanicCrater)
	-- Charred branches
	for j = 1, 3 do
		local branchAngle = (j / 3) * 360
		local branchPos = treePos + Vector3.new(
			math.cos(math.rad(branchAngle)) * 2, 
			height * 0.7, 
			math.sin(math.rad(branchAngle)) * 2
		)
		makePart("CharredBranch" .. i .. "_" .. j, Vector3.new(0.5, 0.5, 3), branchPos, 
			Color3.fromRGB(30, 30, 30), Enum.Material.Wood, VolcanicCrater, 
			{Orientation = Vector3.new(0, branchAngle, randomInRange(-30, 30))})
	end
end

-- Volcanic boulders
for i = 1, 20 do
	local boulderPos = randomPointInRect(305, 395, -395, -305)
	makePart("VolcanicBoulder" .. i, 
		Vector3.new(randomInRange(3, 8), randomInRange(2, 5), randomInRange(3, 8)), 
		boulderPos + Vector3.new(0, 2, 0), Color3.fromRGB(80, 40, 40), 
		Enum.Material.Rock, VolcanicCrater, {Shape = Enum.PartType.Ball})
end

-- Cracked earth (dark lines on ground)
for i = 1, 15 do
	local crackPos = randomPointInRect(310, 390, -390, -310)
	makePart("EarthCrack" .. i, Vector3.new(0.5, 0.2, randomInRange(8, 15)), crackPos, 
		Color3.fromRGB(40, 20, 20), Enum.Material.Concrete, VolcanicCrater, 
		{Orientation = Vector3.new(0, randomInRange(0, 360), 0)})
end

-- Fire geysers
for i = 1, 6 do
	local geyserPos = randomPointInRect(320, 380, -380, -320)
	makePart("GeyserBase" .. i, Vector3.new(3, 0.8, 3), geyserPos + Vector3.new(0, 0.4, 0), 
		Color3.fromRGB(60, 30, 30), Enum.Material.Rock, VolcanicCrater)
	-- Fire column
	for j = 1, 5 do
		local fireHeight = j * 2
		makePart("GeyserFire" .. i .. "_" .. j, Vector3.new(2 - (j * 0.2), 1.5, 2 - (j * 0.2)), 
			geyserPos + Vector3.new(0, fireHeight, 0), Color3.fromRGB(255, 100 - (j * 15), 0), 
			Enum.Material.Neon, VolcanicCrater, 
			{Transparency = 0.2 + (j * 0.1), CanCollide = false})
	end
end

-- Ash piles
for i = 1, 12 do
	local ashPos = randomPointInRect(315, 385, -385, -315)
	makePart("AshPile" .. i, Vector3.new(randomInRange(3, 6), randomInRange(1, 2), randomInRange(3, 6)), 
		ashPos + Vector3.new(0, 0.75, 0), Color3.fromRGB(64, 64, 64), 
		Enum.Material.Sand, VolcanicCrater, {Shape = Enum.PartType.Ball})
end

-- Volcanic Crater sign
local volcanicSign = makePart("VolcanicSign", Vector3.new(1, 1, 1), Vector3.new(350, 12, -300), 
	"White", nil, VolcanicCrater, {Transparency = 1})
makeSign(volcanicSign, "ðŸŒ‹ VOLCANIC CRATER", Vector3.new(0, 0, 0))

--------------------------------------------------------------------------------
-- 4. ENCHANTED GARDEN (X: -300 to -200, Z: 200-350)
--------------------------------------------------------------------------------
print("[MapSetup5] Building Enchanted Garden...")
local EnchantedGarden = getOrMake(NewAreas, "EnchantedGarden")

-- Magical flower paradise - giant flowers
for i = 1, 20 do
	local flowerPos = randomPointInRect(-295, -205, 205, 345)
	local colors = {Color3.fromRGB(255, 20, 147), Color3.fromRGB(138, 43, 226), Color3.fromRGB(255, 69, 0), 
					Color3.fromRGB(50, 205, 50), Color3.fromRGB(30, 144, 255), Color3.fromRGB(255, 215, 0)}
	local color = colors[math.random(1, #colors)]
	
	-- Stem
	makePart("FlowerStem" .. i, Vector3.new(0.8, randomInRange(6, 10), 0.8), 
		flowerPos + Vector3.new(0, 4, 0), Color3.fromRGB(34, 139, 34), 
		Enum.Material.Grass, EnchantedGarden)
	
	-- Oversized petals
	local petalCount = 6
	local stemHeight = 8
	for j = 1, petalCount do
		local angle = (j / petalCount) * 360
		local petalPos = flowerPos + Vector3.new(
			math.cos(math.rad(angle)) * 3, 
			stemHeight, 
			math.sin(math.rad(angle)) * 3
		)
		makePart("FlowerPetal" .. i .. "_" .. j, Vector3.new(2, 0.3, 4), petalPos, 
			color, Enum.Material.Neon, EnchantedGarden, 
			{Transparency = 0.2, Orientation = Vector3.new(randomInRange(-15, 15), angle, randomInRange(-20, 20))})
	end
	
	-- Flower center
	makePart("FlowerCenter" .. i, Vector3.new(2, 1, 2), flowerPos + Vector3.new(0, stemHeight, 0), 
		Color3.fromRGB(255, 215, 0), Enum.Material.Neon, EnchantedGarden, 
		{Transparency = 0.1, Shape = Enum.PartType.Ball})
end

-- Fairy rings (circles of glowing mushrooms)
for ring = 1, 5 do
	local centerPos = randomPointInRect(-280, -220, 220, 330)
	local radius = randomInRange(5, 8)
	for i = 1, 12 do
		local angle = (i / 12) * 360
		local mushroomPos = centerPos + Vector3.new(
			math.cos(math.rad(angle)) * radius, 
			0, 
			math.sin(math.rad(angle)) * radius
		)
		local mushroom = makePart("FairyMushroom" .. ring .. "_" .. i, 
			Vector3.new(0.8, 1.5, 0.8), mushroomPos + Vector3.new(0, 0.75, 0), 
			Color3.fromRGB(147, 0, 211), Enum.Material.Neon, EnchantedGarden, 
			{Transparency = 0.3})
		-- Mushroom glow
		local mushroomLight = Instance.new("PointLight")
		mushroomLight.Color = Color3.fromRGB(147, 0, 211)
		mushroomLight.Brightness = 1.5
		mushroomLight.Range = 5
		mushroomLight.Parent = mushroom
		
		-- Mushroom cap
		makePart("FairyMushroomCap" .. ring .. "_" .. i, Vector3.new(1.5, 0.4, 1.5), 
			mushroomPos + Vector3.new(0, 1.7, 0), Color3.fromRGB(255, 20, 147), 
			Enum.Material.Neon, EnchantedGarden, {Transparency = 0.2, Shape = Enum.PartType.Ball})
	end
	-- Fairy ring center glow
	makePart("FairyRingCenter" .. ring, Vector3.new(radius * 2, 0.1, radius * 2), centerPos, 
		Color3.fromRGB(186, 85, 211), Enum.Material.Neon, EnchantedGarden, 
		{Transparency = 0.8, CanCollide = false})
end

-- Enchanted fountain
local fountainCenter = Vector3.new(-250, 0, 275)
makePart("FountainBase", Vector3.new(12, 3, 12), fountainCenter + Vector3.new(0, 1.5, 0), 
	Color3.fromRGB(176, 196, 222), Enum.Material.Marble, EnchantedGarden)
makePart("FountainPool", Vector3.new(10, 0.5, 10), fountainCenter + Vector3.new(0, 3.25, 0), 
	Color3.fromRGB(176, 196, 222), Enum.Material.Marble, EnchantedGarden)
makePart("FountainWater", Vector3.new(9, 0.4, 9), fountainCenter + Vector3.new(0, 3.5, 0), 
	Color3.fromRGB(65, 130, 175), Enum.Material.Water, EnchantedGarden, 
	{Transparency = 0.3, CanCollide = false})
makePart("FountainPillar", Vector3.new(2, 8, 2), fountainCenter + Vector3.new(0, 8, 0), 
	Color3.fromRGB(176, 196, 222), Enum.Material.Marble, EnchantedGarden)
makePart("FountainSpray", Vector3.new(1, 6, 1), fountainCenter + Vector3.new(0, 15, 0), 
	Color3.fromRGB(0, 191, 255), Enum.Material.Neon, EnchantedGarden, 
	{Transparency = 0.4, CanCollide = false})

-- Rainbow bridge (multi-colored arc)
local bridgeCenter = Vector3.new(-250, 0, 320)
local colors = {Color3.fromRGB(255, 0, 0), Color3.fromRGB(255, 165, 0), Color3.fromRGB(255, 255, 0), 
				Color3.fromRGB(0, 255, 0), Color3.fromRGB(0, 0, 255), Color3.fromRGB(75, 0, 130), 
				Color3.fromRGB(238, 130, 238)}
for i, color in ipairs(colors) do
	local angle = (i - 1) * 15 - 45
	local radius = 15
	local bridgePos = bridgeCenter + Vector3.new(
		math.cos(math.rad(angle)) * radius, 
		8 + math.sin(math.rad(angle)) * 5, 
		0
	)
	makePart("RainbowSegment" .. i, Vector3.new(3, 1, 2), bridgePos, 
		color, Enum.Material.Neon, EnchantedGarden, 
		{Transparency = 0.2, Orientation = Vector3.new(0, 0, angle)})
end

-- Crystal butterflies (small neon parts)
for i = 1, 25 do
	local butterflyPos = randomPointInRect(-295, -205, 205, 345)
	butterflyPos = butterflyPos + Vector3.new(0, randomInRange(3, 8), 0)
	local colors = {Color3.fromRGB(255, 20, 147), Color3.fromRGB(0, 255, 255), Color3.fromRGB(255, 255, 0), 
					Color3.fromRGB(255, 0, 255), Color3.fromRGB(0, 255, 0)}
	local color = colors[math.random(1, #colors)]
	
	-- Butterfly body
	makePart("ButterflyBody" .. i, Vector3.new(0.1, 0.8, 0.1), butterflyPos, 
		Color3.fromRGB(0, 0, 0), Enum.Material.SmoothPlastic, EnchantedGarden, {CanCollide = false})
	-- Butterfly wings
	makePart("ButterflyWingL" .. i, Vector3.new(0.8, 0.1, 1), 
		butterflyPos + Vector3.new(-0.5, 0, 0), color, Enum.Material.Neon, 
		EnchantedGarden, {Transparency = 0.3, CanCollide = false})
	makePart("ButterflyWingR" .. i, Vector3.new(0.8, 0.1, 1), 
		butterflyPos + Vector3.new(0.5, 0, 0), color, Enum.Material.Neon, 
		EnchantedGarden, {Transparency = 0.3, CanCollide = false})
end

-- Magic trees with glowing fruit
for i = 1, 12 do
	local treePos = randomPointInRect(-290, -210, 210, 340)
	-- Trunk
	makePart("MagicTrunk" .. i, Vector3.new(2, randomInRange(10, 15), 2), 
		treePos + Vector3.new(0, 6, 0), Color3.fromRGB(139, 69, 19), 
		Enum.Material.Wood, EnchantedGarden)
	-- Magical canopy
	makePart("MagicCanopy" .. i, Vector3.new(8, 6, 8), treePos + Vector3.new(0, 14, 0), 
		Color3.fromRGB(50, 205, 50), Enum.Material.Grass, EnchantedGarden, {Shape = Enum.PartType.Ball})
	-- Glowing fruit
	for j = 1, 6 do
		local fruitPos = treePos + Vector3.new(randomInRange(-3, 3), randomInRange(11, 16), randomInRange(-3, 3))
		local fruit = makePart("MagicFruit" .. i .. "_" .. j, Vector3.new(0.6, 0.8, 0.6), fruitPos, 
			Color3.fromRGB(255, 215, 0), Enum.Material.Neon, EnchantedGarden, 
			{Transparency = 0.2, Shape = Enum.PartType.Ball, CanCollide = false})
		-- Fruit glow
		local fruitLight = Instance.new("PointLight")
		fruitLight.Color = Color3.fromRGB(255, 215, 0)
		fruitLight.Brightness = 1
		fruitLight.Range = 4
		fruitLight.Parent = fruit
	end
end

-- Hedge maze walls (green blocks in maze pattern)
local mazeCenter = Vector3.new(-270, 0, 300)
local mazeSize = 20
-- Outer walls
for i = 0, mazeSize do
	makePart("MazeWallN" .. i, Vector3.new(2, 4, 2), 
		mazeCenter + Vector3.new(-mazeSize + i * 2, 2, -mazeSize), 
		Color3.fromRGB(34, 139, 34), Enum.Material.Grass, EnchantedGarden)
	makePart("MazeWallS" .. i, Vector3.new(2, 4, 2), 
		mazeCenter + Vector3.new(-mazeSize + i * 2, 2, mazeSize), 
		Color3.fromRGB(34, 139, 34), Enum.Material.Grass, EnchantedGarden)
end
for i = 0, mazeSize do
	makePart("MazeWallW" .. i, Vector3.new(2, 4, 2), 
		mazeCenter + Vector3.new(-mazeSize, 2, -mazeSize + i * 2), 
		Color3.fromRGB(34, 139, 34), Enum.Material.Grass, EnchantedGarden)
	makePart("MazeWallE" .. i, Vector3.new(2, 4, 2), 
		mazeCenter + Vector3.new(mazeSize, 2, -mazeSize + i * 2), 
		Color3.fromRGB(34, 139, 34), Enum.Material.Grass, EnchantedGarden)
end
-- Internal maze walls (simple pattern)
local mazePattern = {
	{-10, -10, 8, 2}, {-5, -15, 2, 12}, {5, -10, 2, 8}, {10, -5, 8, 2},
	{-15, 5, 12, 2}, {0, 0, 2, 10}, {-8, 8, 16, 2}, {8, 12, 2, 8}
}
for i, wall in ipairs(mazePattern) do
	makePart("MazeInternal" .. i, Vector3.new(wall[3], 4, wall[4]), 
		mazeCenter + Vector3.new(wall[1], 2, wall[2]), 
		Color3.fromRGB(34, 139, 34), Enum.Material.Grass, EnchantedGarden)
end

-- Wishing well
local wellPos = Vector3.new(-230, 0, 250)
makePart("WishingWellBase", Vector3.new(5, 4, 5), wellPos + Vector3.new(0, 2, 0), 
	Color3.fromRGB(105, 105, 105), Enum.Material.Cobblestone, EnchantedGarden)
makePart("WellWater", Vector3.new(3, 0.5, 3), wellPos + Vector3.new(0, 4.5, 0), 
	Color3.fromRGB(65, 130, 175), Enum.Material.Water, EnchantedGarden, 
	{Transparency = 0.3, CanCollide = false})
makePart("WellRoof", Vector3.new(7, 0.5, 7), wellPos + Vector3.new(0, 8, 0), 
	Color3.fromRGB(139, 69, 19), Enum.Material.Wood, EnchantedGarden)
-- Well posts
makePart("WellPostL", Vector3.new(0.5, 6, 0.5), wellPos + Vector3.new(-3, 6, 0), 
	Color3.fromRGB(139, 69, 19), Enum.Material.Wood, EnchantedGarden)
makePart("WellPostR", Vector3.new(0.5, 6, 0.5), wellPos + Vector3.new(3, 6, 0), 
	Color3.fromRGB(139, 69, 19), Enum.Material.Wood, EnchantedGarden)

-- Enchanted Garden sign
local gardenSign = makePart("GardenSign", Vector3.new(1, 1, 1), Vector3.new(-250, 12, 350), 
	"White", nil, EnchantedGarden, {Transparency = 1})
makeSign(gardenSign, "ðŸŒº ENCHANTED GARDEN", Vector3.new(0, 0, 0))

--------------------------------------------------------------------------------
-- 5. UNDERGROUND RUINS (X: -100 to 50, Z: -450 to -350)
--------------------------------------------------------------------------------
print("[MapSetup5] Building Underground Ruins...")
local UndergroundRuins = getOrMake(NewAreas, "UndergroundRuins")

-- Ancient civilization remains - broken pillars
for i = 1, 15 do
	local pillarPos = randomPointInRect(-95, 45, -445, -355)
	local height = randomInRange(8, 16)
	local isToppled = math.random() > 0.6
	
	if isToppled then
		-- Toppled pillar (horizontal)
		makePart("TopplePillar" .. i, Vector3.new(height, 2, 2), pillarPos + Vector3.new(height/2, 1, 0), 
			Color3.fromRGB(105, 105, 105), Enum.Material.Cobblestone, UndergroundRuins, 
			{Orientation = Vector3.new(0, 0, -90)})
	else
		-- Standing pillar (may be broken)
		local actualHeight = isToppled and height * 0.6 or height
		makePart("StandingPillar" .. i, Vector3.new(2, actualHeight, 2), 
			pillarPos + Vector3.new(0, actualHeight/2, 0), Color3.fromRGB(105, 105, 105), 
			Enum.Material.Cobblestone, UndergroundRuins)
		-- Pillar capital
		makePart("PillarCapital" .. i, Vector3.new(3, 1, 3), 
			pillarPos + Vector3.new(0, actualHeight + 0.5, 0), Color3.fromRGB(145, 145, 145), 
			Enum.Material.Marble, UndergroundRuins)
	end
end

-- Crumbled walls (stone blocks in ruined patterns)
local wallSections = {
	{-80, 0, -420, 20, 6}, {-50, 0, -440, 15, 4}, {-10, 0, -410, 25, 8},
	{20, 0, -380, 18, 5}, {-20, 0, -370, 22, 7}, {40, 0, -400, 16, 6}
}
for i, wall in ipairs(wallSections) do
	local basePos = Vector3.new(wall[1], wall[2], wall[3])
	local length = wall[4]
	local height = wall[5]
	-- Main wall section
	makePart("RuinedWall" .. i, Vector3.new(length, height, 3), 
		basePos + Vector3.new(0, height/2, 0), Color3.fromRGB(105, 105, 105), 
		Enum.Material.Cobblestone, UndergroundRuins)
	-- Wall breach (gap)
	local breachPos = basePos + Vector3.new(randomInRange(-length/3, length/3), height/2, 0)
	makePart("WallBreach" .. i, Vector3.new(randomInRange(4, 8), height * 0.7, 3.5), 
		breachPos, Color3.fromRGB(20, 20, 20), Enum.Material.SmoothPlastic, 
		UndergroundRuins, {Transparency = 0.9, CanCollide = false})
	-- Rubble at base
	for j = 1, 5 do
		local rubblePos = basePos + Vector3.new(randomInRange(-length/2, length/2), 1, randomInRange(-2, 5))
		makePart("WallRubble" .. i .. "_" .. j, 
			Vector3.new(randomInRange(1, 3), randomInRange(1, 2), randomInRange(1, 3)), 
			rubblePos, Color3.fromRGB(85, 85, 85), Enum.Material.Concrete, UndergroundRuins)
	end
end

-- Hieroglyph panels (decorated stone slabs)
for i = 1, 10 do
	local panelPos = randomPointInRect(-90, 40, -440, -360)
	makePart("HieroglyphPanel" .. i, Vector3.new(4, 6, 0.5), panelPos + Vector3.new(0, 3, 0), 
		Color3.fromRGB(139, 134, 130), Enum.Material.Slate, UndergroundRuins)
	-- Hieroglyph symbols (simple geometric shapes)
	for j = 1, 6 do
		local symbolPos = panelPos + Vector3.new(randomInRange(-1.5, 1.5), randomInRange(1, 5), 0.3)
		local shapes = {Enum.PartType.Block, Enum.PartType.Ball, Enum.PartType.Cylinder}
		makePart("Hieroglyph" .. i .. "_" .. j, Vector3.new(0.3, 0.3, 0.1), symbolPos, 
			Color3.fromRGB(205, 133, 63), Enum.Material.Neon, UndergroundRuins, 
			{Transparency = 0.3, Shape = shapes[math.random(1, #shapes)], CanCollide = false})
	end
end

-- Sacrificial altar (dark stone platform)
local altarPos = Vector3.new(-25, 0, -400)
makePart("AltarBase", Vector3.new(8, 2, 12), altarPos + Vector3.new(0, 1, 0), 
	Color3.fromRGB(64, 64, 64), Enum.Material.Slate, UndergroundRuins)
makePart("AltarTop", Vector3.new(6, 0.5, 10), altarPos + Vector3.new(0, 2.5, 0), 
	Color3.fromRGB(40, 40, 40), Enum.Material.Marble, UndergroundRuins)
makePart("AltarBowl", Vector3.new(3, 0.8, 3), altarPos + Vector3.new(0, 3.2, 0), 
	Color3.fromRGB(80, 0, 0), Enum.Material.Neon, UndergroundRuins, 
	{Transparency = 0.4, Shape = Enum.PartType.Ball})
-- Altar steps
for i = 1, 3 do
	makePart("AltarStep" .. i, Vector3.new(10 + i * 2, 1, 14 + i * 2), 
		altarPos + Vector3.new(0, -i * 0.5, 0), Color3.fromRGB(85, 85, 85), 
		Enum.Material.Cobblestone, UndergroundRuins)
end

-- Underground river (blue transparent strip)
local riverPath = {{-80, 0, -380}, {-50, 0, -390}, {-20, 0, -420}, {10, 0, -430}, {40, 0, -420}}
for i = 1, #riverPath - 1 do
	local startPos = Vector3.new(riverPath[i][1], riverPath[i][2], riverPath[i][3])
	local endPos = Vector3.new(riverPath[i+1][1], riverPath[i+1][2], riverPath[i+1][3])
	local midPos = (startPos + endPos) * 0.5
	local length = (endPos - startPos).Magnitude
	makePart("RiverSegment" .. i, Vector3.new(6, 0.8, length), midPos + Vector3.new(0, 0.4, 0), 
		Color3.fromRGB(30, 80, 120), Enum.Material.Water, UndergroundRuins, 
		{Transparency = 0.3, CanCollide = false})
	-- River rocks
	for j = 1, 3 do
		local rockPos = midPos + Vector3.new(randomInRange(-4, 4), 0.5, randomInRange(-length/2, length/2))
		makePart("RiverRock" .. i .. "_" .. j, 
			Vector3.new(randomInRange(0.8, 1.5), randomInRange(0.5, 1), randomInRange(0.8, 1.5)), 
			rockPos, Color3.fromRGB(105, 105, 105), Enum.Material.Rock, UndergroundRuins, 
			{Shape = Enum.PartType.Ball})
	end
end

-- Ancient statues (gray humanoid shapes)
for i = 1, 8 do
	local statuePos = randomPointInRect(-85, 35, -435, -365)
	-- Statue base/pedestal
	makePart("StatuePedestal" .. i, Vector3.new(3, 2, 3), statuePos + Vector3.new(0, 1, 0), 
		Color3.fromRGB(105, 105, 105), Enum.Material.Marble, UndergroundRuins)
	-- Statue body
	makePart("StatueBody" .. i, Vector3.new(2, 4, 1.5), statuePos + Vector3.new(0, 4, 0), 
		Color3.fromRGB(145, 145, 145), Enum.Material.Marble, UndergroundRuins)
	-- Statue head (some may be missing)
	if math.random() > 0.3 then
		makePart("StatueHead" .. i, Vector3.new(1.2, 1.2, 1.2), statuePos + Vector3.new(0, 6.5, 0), 
			Color3.fromRGB(145, 145, 145), Enum.Material.Marble, UndergroundRuins, {Shape = Enum.PartType.Ball})
	end
	-- Statue arms (may be broken)
	if math.random() > 0.4 then
		makePart("StatueArmL" .. i, Vector3.new(0.8, 3, 0.8), statuePos + Vector3.new(-1.5, 4, 0), 
			Color3.fromRGB(145, 145, 145), Enum.Material.Marble, UndergroundRuins)
	end
	if math.random() > 0.4 then
		makePart("StatueArmR" .. i, Vector3.new(0.8, 3, 0.8), statuePos + Vector3.new(1.5, 4, 0), 
			Color3.fromRGB(145, 145, 145), Enum.Material.Marble, UndergroundRuins)
	end
end

-- Treasure vault door (large ornate golden door)
local vaultPos = Vector3.new(30, 0, -380)
makePart("VaultDoorFrame", Vector3.new(12, 15, 4), vaultPos + Vector3.new(0, 7.5, 0), 
	Color3.fromRGB(105, 105, 105), Enum.Material.Slate, UndergroundRuins)
makePart("VaultDoor", Vector3.new(8, 12, 1), vaultPos + Vector3.new(0, 6, 2), 
	Color3.fromRGB(255, 215, 0), Enum.Material.Metal, UndergroundRuins)
-- Door decorations
for i = 1, 4 do
	local decorPos = vaultPos + Vector3.new(-2 + i, 6, 2.5)
	makePart("VaultDecor" .. i, Vector3.new(0.8, 0.8, 0.3), decorPos, 
		Color3.fromRGB(184, 134, 11), Enum.Material.Metal, UndergroundRuins, {Shape = Enum.PartType.Ball})
end
-- Door handles
makePart("VaultHandleL", Vector3.new(0.5, 1.5, 0.8), vaultPos + Vector3.new(-2, 6, 2.8), 
	Color3.fromRGB(139, 69, 19), Enum.Material.Wood, UndergroundRuins)
makePart("VaultHandleR", Vector3.new(0.5, 1.5, 0.8), vaultPos + Vector3.new(2, 6, 2.8), 
	Color3.fromRGB(139, 69, 19), Enum.Material.Wood, UndergroundRuins)

-- Trap floor tiles (slightly different colored)
for i = 1, 12 do
	local trapPos = randomPointInRect(-75, 25, -425, -375)
	makePart("TrapTile" .. i, Vector3.new(4, 0.2, 4), trapPos + Vector3.new(0, 0.1, 0), 
		Color3.fromRGB(120, 120, 120), Enum.Material.Slate, UndergroundRuins, {Transparency = 0.1})
	-- Trap mechanism (spikes that could emerge)
	for j = 1, 4 do
		local spikePos = trapPos + Vector3.new(randomInRange(-1.5, 1.5), -0.5, randomInRange(-1.5, 1.5))
		makePart("TrapSpike" .. i .. "_" .. j, Vector3.new(0.2, 1, 0.2), spikePos, 
			Color3.fromRGB(64, 64, 64), Enum.Material.Metal, UndergroundRuins, {Transparency = 0.7})
	end
end

-- Torch sconces (wall-mounted torches)
for i = 1, 15 do
	local sconcePillar = randomPointInRect(-90, 40, -440, -360)
	makePart("TorchSconce" .. i, Vector3.new(0.8, 6, 0.8), sconcePillar + Vector3.new(0, 3, 0), 
		Color3.fromRGB(139, 69, 19), Enum.Material.Wood, UndergroundRuins)
	makePart("TorchFlame" .. i, Vector3.new(0.8, 1.5, 0.8), sconcePillar + Vector3.new(0, 6.5, 0), 
		Color3.fromRGB(255, 140, 0), Enum.Material.Neon, UndergroundRuins, {Transparency = 0.3})
	-- Torch light
	local torchLight = Instance.new("PointLight")
	torchLight.Color = Color3.fromRGB(255, 140, 0)
	torchLight.Brightness = 2
	torchLight.Range = 12
	torchLight.Parent = UndergroundRuins:FindFirstChild("TorchFlame" .. i)
end

-- Underground Ruins sign
local ruinsSign = makePart("RuinsSign", Vector3.new(1, 1, 1), Vector3.new(-25, 15, -350), 
	"White", nil, UndergroundRuins, {Transparency = 1})
makeSign(ruinsSign, "ðŸ›ï¸ UNDERGROUND RUINS", Vector3.new(0, 0, 0))

--------------------------------------------------------------------------------
-- 6. DRAGON'S NEST (X: 0-100, Z: -500 to -450)
--------------------------------------------------------------------------------
print("[MapSetup5] Building Dragon's Nest...")
local DragonNest = getOrMake(NewAreas, "DragonNest")

-- Scorched earth (black/dark brown ground)
for i = 1, 8 do
	local pos = randomPointInRect(5, 95, -495, -455)
	makePart("ScorchedGround" .. i, Vector3.new(randomInRange(12, 20), 0.5, randomInRange(12, 20)), 
		pos + Vector3.new(0, 0.25, 0), Color3.fromRGB(25, 25, 25), Enum.Material.Asphalt, DragonNest)
end

-- MASSIVE dragon skeleton (centerpiece)
local skeletonCenter = Vector3.new(50, 0, -475)
-- Dragon skull (huge)
makePart("DragonSkull", Vector3.new(12, 8, 15), skeletonCenter + Vector3.new(0, 4, 20), 
	Color3.fromRGB(230, 225, 210), Enum.Material.SmoothPlastic, DragonNest)
-- Skull eye sockets
makePart("SkullEyeL", Vector3.new(2.5, 2.5, 2), skeletonCenter + Vector3.new(-3, 5, 26), 
	Color3.fromRGB(20, 20, 20), Enum.Material.SmoothPlastic, DragonNest, {Shape = Enum.PartType.Ball})
makePart("SkullEyeR", Vector3.new(2.5, 2.5, 2), skeletonCenter + Vector3.new(3, 5, 26), 
	Color3.fromRGB(20, 20, 20), Enum.Material.SmoothPlastic, DragonNest, {Shape = Enum.PartType.Ball})
-- Dragon fangs
makePart("SkullFangL", Vector3.new(0.8, 3, 0.8), skeletonCenter + Vector3.new(-2, 2, 27), 
	Color3.fromRGB(240, 235, 220), Enum.Material.SmoothPlastic, DragonNest)
makePart("SkullFangR", Vector3.new(0.8, 3, 0.8), skeletonCenter + Vector3.new(2, 2, 27), 
	Color3.fromRGB(240, 235, 220), Enum.Material.SmoothPlastic, DragonNest)

-- Dragon spine (vertebrae)
for i = 1, 20 do
	local vertebraPos = skeletonCenter + Vector3.new(0, 2, 15 - i * 3)
	makePart("Vertebra" .. i, Vector3.new(3, 2, 2), vertebraPos, 
		Color3.fromRGB(230, 225, 210), Enum.Material.SmoothPlastic, DragonNest)
	-- Spine spikes
	makePart("SpineSpike" .. i, Vector3.new(0.5, randomInRange(2, 4), 0.5), vertebraPos + Vector3.new(0, 2, 0), 
		Color3.fromRGB(210, 205, 190), Enum.Material.SmoothPlastic, DragonNest)
end

-- Dragon ribcage (curved ribs)
for i = 1, 12 do
	local ribSpacing = i * 3
	local ribHeight = 8 - (i * 0.3)
	local ribPos = skeletonCenter + Vector3.new(0, 0, 10 - ribSpacing)
	-- Left rib
	makePart("RibL" .. i, Vector3.new(0.8, 0.8, ribHeight), ribPos + Vector3.new(-ribHeight/2, ribHeight/2, 0), 
		Color3.fromRGB(230, 225, 210), Enum.Material.SmoothPlastic, DragonNest, 
		{Orientation = Vector3.new(0, 0, -45)})
	-- Right rib
	makePart("RibR" .. i, Vector3.new(0.8, 0.8, ribHeight), ribPos + Vector3.new(ribHeight/2, ribHeight/2, 0), 
		Color3.fromRGB(230, 225, 210), Enum.Material.SmoothPlastic, DragonNest, 
		{Orientation = Vector3.new(0, 0, 45)})
end

-- Dragon wing bones
for side = 1, 2 do
	local sideMultiplier = side == 1 and -1 or 1
	local wingBase = skeletonCenter + Vector3.new(sideMultiplier * 8, 2, 0)
	-- Wing arm bone
	makePart("WingArm" .. side, Vector3.new(1.5, 1.5, 12), wingBase + Vector3.new(sideMultiplier * 6, 3, 0), 
		Color3.fromRGB(220, 215, 200), Enum.Material.SmoothPlastic, DragonNest, 
		{Orientation = Vector3.new(0, sideMultiplier * 30, sideMultiplier * 20)})
	-- Wing finger bones
	for finger = 1, 4 do
		local fingerAngle = finger * 15
		local fingerPos = wingBase + Vector3.new(sideMultiplier * 12, 2, finger * 3)
		makePart("WingFinger" .. side .. "_" .. finger, Vector3.new(0.8, 0.8, 8), fingerPos, 
			Color3.fromRGB(210, 205, 190), Enum.Material.SmoothPlastic, DragonNest, 
			{Orientation = Vector3.new(0, sideMultiplier * fingerAngle, sideMultiplier * 10)})
	end
end

-- Dragon leg bones
for leg = 1, 4 do
	local legX = (leg &lt;= 2) and -3 or 3
	local legZ = (leg == 1 or leg == 3) and 5 or -10
	local legPos = skeletonCenter + Vector3.new(legX, 0, legZ)
	-- Thigh bone
	makePart("LegThigh" .. leg, Vector3.new(1.5, 1.5, 6), legPos + Vector3.new(0, 3, 0), 
		Color3.fromRGB(225, 220, 205), Enum.Material.SmoothPlastic, DragonNest, 
		{Orientation = Vector3.new(-30, 0, 0)})
	-- Shin bone
	makePart("LegShin" .. leg, Vector3.new(1.2, 1.2, 5), legPos + Vector3.new(0, 1, 3), 
		Color3.fromRGB(215, 210, 195), Enum.Material.SmoothPlastic, DragonNest, 
		{Orientation = Vector3.new(30, 0, 0)})
	-- Foot/claw
	makePart("LegClaw" .. leg, Vector3.new(2, 1, 3), legPos + Vector3.new(0, 0, 5), 
		Color3.fromRGB(200, 195, 180), Enum.Material.SmoothPlastic, DragonNest)
end

-- Dragon tail bones (long chain)
for i = 1, 15 do
	local tailPos = skeletonCenter + Vector3.new(0, 1, -45 - i * 2)
	local tailSize = 2.5 - (i * 0.1)
	makePart("TailBone" .. i, Vector3.new(tailSize, tailSize, 1.5), tailPos, 
		Color3.fromRGB(220, 215, 200), Enum.Material.SmoothPlastic, DragonNest)
end

-- Egg nest (large oval parts in a crater)
local nestCenter = Vector3.new(75, 0, -480)
makePart("NestCrater", Vector3.new(20, 3, 15), nestCenter + Vector3.new(0, -1.5, 0), 
	Color3.fromRGB(64, 32, 32), Enum.Material.Rock, DragonNest, {Shape = Enum.PartType.Ball})
-- Dragon eggs (various sizes)
local eggSizes = {{4, 5, 3}, {3.5, 4.5, 2.5}, {5, 6, 4}, {3, 4, 2.5}, {4.5, 5.5, 3.5}}
for i, size in ipairs(eggSizes) do
	local eggPos = nestCenter + Vector3.new(randomInRange(-8, 8), 1, randomInRange(-6, 6))
	makePart("DragonEgg" .. i, Vector3.new(size[1], size[2], size[3]), eggPos, 
		Color3.fromRGB(139, 0, 0), Enum.Material.SmoothPlastic, DragonNest, {Shape = Enum.PartType.Ball})
	-- Egg patterns
	makePart("EggPattern" .. i, Vector3.new(size[1] * 0.8, size[2] * 0.8, size[3] * 0.8), eggPos, 
		Color3.fromRGB(255, 215, 0), Enum.Material.Neon, DragonNest, 
		{Shape = Enum.PartType.Ball, Transparency = 0.7, CanCollide = false})
end

-- Treasure hoard (gold-colored pile)
local treasureCenter = Vector3.new(25, 0, -465)
-- Gold pile base
makePart("TreasurePile", Vector3.new(15, 4, 12), treasureCenter + Vector3.new(0, 2, 0), 
	Color3.fromRGB(255, 215, 0), Enum.Material.Metal, DragonNest, {Shape = Enum.PartType.Ball})
-- Individual treasure items
for i = 1, 25 do
	local treasurePos = treasureCenter + Vector3.new(randomInRange(-8, 8), randomInRange(1, 5), randomInRange(-6, 6))
	local treasureTypes = {"Coin", "Gem", "Crown", "Goblet", "Sword"}
	local treasureType = treasureTypes[math.random(1, #treasureTypes)]
	
	if treasureType == "Coin" then
		makePart("TreasureCoin" .. i, Vector3.new(0.6, 0.1, 0.6), treasurePos, 
			Color3.fromRGB(255, 215, 0), Enum.Material.Metal, DragonNest, {Shape = Enum.PartType.Cylinder})
	elseif treasureType == "Gem" then
		makePart("TreasureGem" .. i, Vector3.new(0.8, 0.8, 0.8), treasurePos, 
			Color3.fromRGB(138, 43, 226), Enum.Material.Neon, DragonNest, 
			{Shape = Enum.PartType.Ball, Transparency = 0.3})
	elseif treasureType == "Crown" then
		makePart("TreasureCrown" .. i, Vector3.new(1.5, 1, 1.5), treasurePos, 
			Color3.fromRGB(255, 215, 0), Enum.Material.Metal, DragonNest)
	elseif treasureType == "Goblet" then
		makePart("TreasureGoblet" .. i, Vector3.new(0.8, 1.2, 0.8), treasurePos, 
			Color3.fromRGB(192, 192, 192), Enum.Material.Metal, DragonNest, {Shape = Enum.PartType.Cylinder})
	elseif treasureType == "Sword" then
		makePart("TreasureSword" .. i, Vector3.new(0.3, 3, 0.8), treasurePos, 
			Color3.fromRGB(192, 192, 192), Enum.Material.Metal, DragonNest)
	end
end

-- Dragon scale fragments scattered
for i = 1, 30 do
	local scalePos = randomPointInRect(10, 90, -490, -460)
	makePart("DragonScale" .. i, Vector3.new(randomInRange(0.5, 1.5), 0.2, randomInRange(0.8, 2)), scalePos, 
		Color3.fromRGB(139, 0, 0), Enum.Material.SmoothPlastic, DragonNest, 
		{Orientation = Vector3.new(randomInRange(0, 30), randomInRange(0, 360), randomInRange(0, 30))})
end

-- Burning ground patches (neon orange)
for i = 1, 10 do
	local firePos = randomPointInRect(15, 85, -485, -465)
	local fire = makePart("GroundFire" .. i, Vector3.new(randomInRange(4, 8), 1, randomInRange(4, 8)), 
		firePos + Vector3.new(0, 0.5, 0), Color3.fromRGB(255, 69, 0), Enum.Material.Neon, 
		DragonNest, {Transparency = 0.3})
	-- Fire light
	local fireLight = Instance.new("PointLight")
	fireLight.Color = Color3.fromRGB(255, 100, 20)
	fireLight.Brightness = 3
	fireLight.Range = 12
	fireLight.Parent = fire
end

-- Volcanic vents
for i = 1, 6 do
	local ventPos = randomPointInRect(20, 80, -485, -465)
	makePart("DragonVent" .. i, Vector3.new(3, 2, 3), ventPos + Vector3.new(0, 1, 0), 
		Color3.fromRGB(64, 32, 32), Enum.Material.Rock, DragonNest)
	-- Vent glow
	makePart("VentGlow" .. i, Vector3.new(2, 1, 2), ventPos + Vector3.new(0, 2.5, 0), 
		Color3.fromRGB(255, 140, 0), Enum.Material.Neon, DragonNest, {Transparency = 0.4})
end

-- Bones scattered everywhere (various creature remains)
for i = 1, 20 do
	local bonePos = randomPointInRect(10, 90, -490, -460)
	local boneTypes = {"Skull", "Femur", "Rib", "Spine"}
	local boneType = boneTypes[math.random(1, #boneTypes)]
	
	if boneType == "Skull" then
		makePart("ScatteredSkull" .. i, Vector3.new(1.5, 1, 2), bonePos + Vector3.new(0, 0.5, 0), 
			Color3.fromRGB(240, 235, 220), Enum.Material.SmoothPlastic, DragonNest)
	elseif boneType == "Femur" then
		makePart("ScatteredFemur" .. i, Vector3.new(0.8, 0.8, 3), bonePos + Vector3.new(0, 0.4, 0), 
			Color3.fromRGB(230, 225, 210), Enum.Material.SmoothPlastic, DragonNest)
	elseif boneType == "Rib" then
		makePart("ScatteredRib" .. i, Vector3.new(0.5, 2, 0.5), bonePos + Vector3.new(0, 1, 0), 
			Color3.fromRGB(225, 220, 205), Enum.Material.SmoothPlastic, DragonNest, 
			{Orientation = Vector3.new(randomInRange(0, 90), randomInRange(0, 360), randomInRange(0, 90))})
	elseif boneType == "Spine" then
		makePart("ScatteredSpine" .. i, Vector3.new(1, 1, 2), bonePos + Vector3.new(0, 0.5, 0), 
			Color3.fromRGB(220, 215, 200), Enum.Material.SmoothPlastic, DragonNest)
	end
end

-- Dragon's Nest sign
local nestSign = makePart("NestSign", Vector3.new(1, 1, 1), Vector3.new(50, 15, -450), 
	"White", nil, DragonNest, {Transparency = 1})
makeSign(nestSign, "ðŸ‰ DRAGON'S NEST", Vector3.new(0, 0, 0))

--------------------------------------------------------------------------------
-- RESOURCE NODES CREATION
--------------------------------------------------------------------------------
print("[MapSetup5] Creating resource nodes...")

-- Resource node creation helper
local function createResourceNode(name, position, nodeType, parent)
	local node = makePart(name, Vector3.new(2, 3, 2), position + Vector3.new(0, 1.5, 0), 
		Color3.fromRGB(105, 105, 105), Enum.Material.Rock, parent)
	
	-- Add ClickDetector
	local cd = Instance.new("ClickDetector")
	cd.MaxActivationDistance = 10
	cd.Parent = node
	
	-- Add BillboardGui label
	local bg = Instance.new("BillboardGui")
	bg.Size = UDim2.new(4, 0, 1, 0)
	bg.StudsOffset = Vector3.new(0, 2, 0)
	bg.Parent = node
	
	local tl = Instance.new("TextLabel")
	tl.Size = UDim2.new(1, 0, 1, 0)
	tl.BackgroundTransparency = 1
	tl.Text = nodeType
	tl.TextColor3 = Color3.fromRGB(255, 255, 255)
	tl.TextScaled = true
	tl.Font = Enum.Font.GothamBold
	tl.TextStrokeTransparency = 0.3
	tl.Parent = bg
	
	return node
end

-- Frozen Peaks nodes
for i = 1, 5 do
	local pos = randomPointInRect(-390, -310, -290, -210)
	local iceNode = createResourceNode("IceMiningNode" .. i, pos, "â›ï¸ Ice Ore", ResourceNodes)
	iceNode.Color = Color3.fromRGB(173, 216, 230)
	iceNode.Material = Enum.Material.Ice
end

for i = 1, 3 do
	local pos = randomPointInRect(-385, -315, -285, -215)
	local frozenTree = createResourceNode("FrozenTreeNode" .. i, pos, "ðŸŒ² Frozen Wood", ResourceNodes)
	frozenTree.Color = Color3.fromRGB(101, 67, 33)
	frozenTree.Material = Enum.Material.Wood
	frozenTree.Size = Vector3.new(2, 6, 2)
	frozenTree.Position = pos + Vector3.new(0, 3, 0)
end

-- Pirate Cove nodes
local coastalPositions = {{320, 0, -120}, {340, 0, -110}, {360, 0, -115}, {380, 0, -125}}
for i, pos in ipairs(coastalPositions) do
	local fishNode = createResourceNode("FishingSpot" .. i, Vector3.new(pos[1], pos[2], pos[3]), "ðŸŽ£ Fishing", ResourceNodes)
	fishNode.Color = Color3.fromRGB(0, 162, 232)
	fishNode.Material = Enum.Material.Neon
	fishNode.Transparency = 0.3
	fishNode.Shape = Enum.PartType.Ball
end

for i = 1, 2 do
	local pos = randomPointInRect(315, 385, -185, -115)
	local palmNode = createResourceNode("PalmTreeNode" .. i, pos, "ðŸŒ´ Palm Wood", ResourceNodes)
	palmNode.Color = Color3.fromRGB(101, 67, 33)
	palmNode.Material = Enum.Material.Wood
	palmNode.Size = Vector3.new(1.5, 8, 1.5)
	palmNode.Position = pos + Vector3.new(0, 4, 0)
end

-- Volcanic Crater nodes
for i = 1, 5 do
	local pos = randomPointInRect(315, 385, -385, -315)
	local obsidianNode = createResourceNode("ObsidianMiningNode" .. i, pos, "â›ï¸ Obsidian", ResourceNodes)
	obsidianNode.Color = Color3.fromRGB(20, 20, 20)
	obsidianNode.Material = Enum.Material.Glass
end

for i = 1, 3 do
	local pos = randomPointInRect(320, 380, -380, -320)
	local volcanicNode = createResourceNode("VolcanicOreMiningNode" .. i, pos, "â›ï¸ Volcanic Ore", ResourceNodes)
	volcanicNode.Color = Color3.fromRGB(255, 69, 0)
	volcanicNode.Material = Enum.Material.Neon
	volcanicNode.Transparency = 0.2
end

-- Enchanted Garden nodes
for i = 1, 4 do
	local pos = randomPointInRect(-290, -210, 210, 340)
	local magicTree = createResourceNode("MagicTreeNode" .. i, pos, "ðŸŒ² Magic Wood", ResourceNodes)
	magicTree.Color = Color3.fromRGB(139, 69, 19)
	magicTree.Material = Enum.Material.Wood
	magicTree.Size = Vector3.new(2, 8, 2)
	magicTree.Position = pos + Vector3.new(0, 4, 0)
	-- Add glow
	local light = Instance.new("PointLight")
	light.Color = Color3.fromRGB(255, 215, 0)
	light.Brightness = 1
	light.Range = 6
	light.Parent = magicTree
end

for i = 1, 3 do
	local pos = randomPointInRect(-285, -215, 215, 335)
	local herbNode = createResourceNode("HerbGatheringNode" .. i, pos, "ðŸŒ¿ Magic Herbs", ResourceNodes)
	herbNode.Color = Color3.fromRGB(50, 205, 50)
	herbNode.Material = Enum.Material.Grass
	herbNode.Size = Vector3.new(3, 1, 3)
	herbNode.Position = pos + Vector3.new(0, 0.5, 0)
end

-- Underground Ruins nodes
for i = 1, 6 do
	local pos = randomPointInRect(-85, 35, -435, -365)
	local ancientNode = createResourceNode("AncientOreMiningNode" .. i, pos, "â›ï¸ Ancient Ore", ResourceNodes)
	ancientNode.Color = Color3.fromRGB(139, 134, 130)
	ancientNode.Material = Enum.Material.Slate
end

-- Dragon's Nest nodes
for i = 1, 3 do
	local pos = randomPointInRect(15, 85, -485, -465)
	local dragonstoneNode = createResourceNode("DragonstoneMiningNode" .. i, pos, "â›ï¸ Dragonstone", ResourceNodes)
	dragonstoneNode.Color = Color3.fromRGB(139, 0, 0)
	dragonstoneNode.Material = Enum.Material.Neon
	dragonstoneNode.Transparency = 0.1
	-- Add dramatic lighting
	local light = Instance.new("PointLight")
	light.Color = Color3.fromRGB(255, 0, 0)
	light.Brightness = 2
	light.Range = 8
	light.Parent = dragonstoneNode
end

print("[MapSetup5] All major new areas completed!")
print("[MapSetup5] Areas built:")
print("- ðŸ´â€â˜ ï¸ Pirate Cove (300-400, -200 to -100): Wrecked ship, treasure, palm trees")
print("- ðŸ—» Frozen Peaks (-400 to -300, -300 to -200): Ice crystals, frozen waterfall, snow trees")
print("- ðŸŒ‹ Volcanic Crater (300-400, -400 to -300): Lava pools, obsidian spikes, fire geysers")
print("- ðŸŒº Enchanted Garden (-300 to -200, 200-350): Giant flowers, fairy rings, rainbow bridge")
print("- ðŸ›ï¸ Underground Ruins (-100 to 50, -450 to -350): Ancient pillars, treasure vault, river")
print("- ðŸ‰ Dragon's Nest (0-100, -500 to -450): Massive skeleton, egg nest, treasure hoard")
print("- Resource nodes added for all areas with appropriate types")</string>
      </Properties>
    </Item>
    <Item class="Script" referent="146">
      <Properties>
        <string name="Name">MiningManager</string>
        <token name="RunContext">0</token>
        <string name="Source">-- MiningManager.server.lua
-- Server-side mining system with error handling

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")

-- Wait for dependencies with timeouts
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 5)
local Modules = ReplicatedStorage:WaitForChild("Modules", 5)

-- Load ErrorHandler first for error handling
local ErrorHandler
local itemDatabaseSuccess, ItemDatabase = pcall(function()
	return require(Modules:WaitForChild("ItemDatabase", 5))
end)

local dataManagerSuccess, DataManager = pcall(function()
	return require(Modules:WaitForChild("DataManager", 5))
end)

-- Initialize ErrorHandler
local errorHandlerSuccess, errorHandlerResult = pcall(function()
	return require(Modules:WaitForChild("ErrorHandler", 5))
end)

if errorHandlerSuccess then
	ErrorHandler = errorHandlerResult
else
	-- Fallback ErrorHandler
	ErrorHandler = {
		LogWarning = function(self, msg, data) warn(tostring(msg)) end,
		LogError = function(self, msg, data) warn(tostring(msg)) end,
		ValidateNotNil = function(self, val, ctx, fallback) return val or fallback end,
		LogDebug = function(self, msg, data) warn(tostring(msg)) end,
		LogInfo = function(self, msg, data) warn(tostring(msg)) end
	}
end

-- Validate dependencies
if not itemDatabaseSuccess then
	ErrorHandler:LogError("Failed to load ItemDatabase", {error = ItemDatabase})
	ItemDatabase = {Items = {}}
else
	ItemDatabase = ItemDatabase.Items or {}
end

if not dataManagerSuccess then
	ErrorHandler:LogWarning("Failed to load DataManager, using fallback", {error = DataManager})
	DataManager = {
		GetData = function(player) 
			return {skills = {Mining = 1}, inventory = {}, equipment = {Tool = ""}}
		end,
		UpdateData = function() return true end
	}
end

-- RemoteEvents with validation
local StartMiningEvent = Remotes and Remotes:WaitForChild("StartMining", 5)
local MiningProgressEvent = Remotes and Remotes:WaitForChild("MiningProgress", 5)
local MiningCompleteEvent = Remotes and Remotes:WaitForChild("MiningComplete", 5)
local InventoryUpdateEvent = Remotes and Remotes:WaitForChild("InventoryUpdate", 5)

-- Validate remotes
if not StartMiningEvent then
	ErrorHandler:LogError("StartMining remote not found")
	return
end

-- Mining configuration
local MINING_CONFIG = {
	-- Ore types with their properties
	OreTypes = {
		["Copper Ore"] = {
			id = "copper_ore",
			levelReq = 1,
			xp = 20,
			respawnTime = 30, -- seconds
			baseMiningTime = 3.0 -- seconds
		},
		["Tin Ore"] = {
			id = "tin_ore",
			levelReq = 1,
			xp = 25,
			respawnTime = 35,
			baseMiningTime = 3.5
		},
		["Iron Ore"] = {
			id = "iron_ore",
			levelReq = 15,
			xp = 35,
			respawnTime = 45,
			baseMiningTime = 4.0
		},
		["Coal Ore"] = {
			id = "coal_ore",
			levelReq = 30,
			xp = 50,
			respawnTime = 60,
			baseMiningTime = 4.5
		},
		["Mithril Ore"] = {
			id = "mithril_ore",
			levelReq = 55,
			xp = 80,
			respawnTime = 90,
			baseMiningTime = 5.0
		},
		["Adamant Ore"] = {
			id = "adamant_ore",
			levelReq = 70,
			xp = 95,
			respawnTime = 120,
			baseMiningTime = 5.5
		},
		["Runite Ore"] = {
			id = "runite_ore",
			levelReq = 85,
			xp = 125,
			respawnTime = 180,
			baseMiningTime = 6.0
		}
	},
	
	-- Pickaxe types with speed multipliers
	Pickaxes = {
		["bronze_pickaxe"] = {speedMultiplier = 1.0, levelReq = 1},
		["iron_pickaxe"] = {speedMultiplier = 1.2, levelReq = 10},
		["steel_pickaxe"] = {speedMultiplier = 1.4, levelReq = 20},
		["mithril_pickaxe"] = {speedMultiplier = 1.6, levelReq = 30},
		["adamant_pickaxe"] = {speedMultiplier = 1.8, levelReq = 40},
		["rune_pickaxe"] = {speedMultiplier = 2.0, levelReq = 50}
	}
}

-- Active mining sessions
local activeMiningSessions = {}
local oreNodes = {} -- Track ore node states

-- Helper: Get player's mining level
local function getMiningLevel(player)
	local playerData = DataManager:GetData(player)
	return playerData.skills.Mining or 1
end

-- Helper: Get equipped pickaxe
local function getEquippedPickaxe(player)
	local playerData = DataManager:GetData(player)
	local toolId = playerData.equipment.Tool or ""
	
	if toolId == "" then
		return nil
	end
	
	-- Check if it's a pickaxe
	local toolData = ItemDatabase[toolId]
	if toolData and toolData.type == "Tool" and string.find(toolId:lower(), "pickaxe") then
		return toolId
	end
	
	return nil
end

-- Helper: Calculate mining time
local function calculateMiningTime(player, oreType, pickaxeId)
	local baseTime = MINING_CONFIG.OreTypes[oreType].baseMiningTime
	local miningLevel = getMiningLevel(player)
	
	-- Level-based speed bonus (up to 50% faster at high levels)
	local levelBonus = math.min(0.5, (miningLevel - MINING_CONFIG.OreTypes[oreType].levelReq) * 0.02)
	
	-- Pickaxe speed multiplier
	local pickaxeMultiplier = 1.0
	if pickaxeId and MINING_CONFIG.Pickaxes[pickaxeId] then
		pickaxeMultiplier = MINING_CONFIG.Pickaxes[pickaxeId].speedMultiplier
	end
	
	-- Random variation Â±20%
	local randomFactor = 0.8 + (math.random() * 0.4)
	
	local totalTime = baseTime * (1 - levelBonus) / pickaxeMultiplier * randomFactor
	
	return math.max(1.0, totalTime) -- Minimum 1 second
end

-- Helper: Award mining XP
local function awardMiningXP(player, oreType)
	local xpAmount = MINING_CONFIG.OreTypes[oreType].xp
	local playerData = DataManager:GetData(player)
	
	-- Update mining skill
	playerData.skills.Mining = (playerData.skills.Mining or 1) + xpAmount
	
	-- Save updated data
	DataManager:UpdateData(player, {skills = playerData.skills})
	
	-- Notify client of XP gain
	if Remotes then
		local xpEvent = Remotes:WaitForChild("SkillXPUpdate", 5)
		if xpEvent then
			xpEvent:FireClient(player, "Mining", xpAmount, playerData.skills.Mining)
		end
	end
	
	ErrorHandler:LogDebug("Awarded mining XP", {
		player = player.Name,
		ore = oreType,
		xp = xpAmount,
		newLevel = playerData.skills.Mining
	})
end

-- Helper: Add ore to inventory
local function addOreToInventory(player, oreType)
	local oreId = MINING_CONFIG.OreTypes[oreType].id
	
	-- Get player data
	local playerData = DataManager:GetData(player)
	
	-- Initialize inventory if needed
	playerData.inventory = playerData.inventory or {}
	
	-- Add ore to inventory
	local currentCount = playerData.inventory[oreId] or 0
	playerData.inventory[oreId] = currentCount + 1
	
	-- Save updated data
	DataManager:UpdateData(player, {inventory = playerData.inventory})
	
	-- Notify client of inventory update
	if InventoryUpdateEvent then
		InventoryUpdateEvent:FireClient(player, oreId, playerData.inventory[oreId])
	end
	
	ErrorHandler:LogDebug("Added ore to inventory", {
		player = player.Name,
		ore = oreId,
		count = playerData.inventory[oreId]
	})
	
	return true
end

-- Helper: Validate mining attempt
local function validateMining(player, oreNode)
	-- Check player character
	if not player or not player.Character then
		return false, "Player character not found"
	end
	
	-- Check ore node
	if not oreNode or not oreNode:IsA("BasePart") then
		return false, "Invalid ore node"
	end
	
	-- Check if node is already being mined
	if activeMiningSessions[player.UserId] then
		return false, "Already mining"
	end
	
	-- Check if node is depleted
	if oreNodes[oreNode] and oreNodes[oreNode].depleted then
		return false, "Ore node depleted"
	end
	
	-- Get ore type from node name
	local oreType = oreNode.Name
	if not MINING_CONFIG.OreTypes[oreType] then
		return false, "Unknown ore type: " .. oreType
	end
	
	-- Check mining level requirement
	local miningLevel = getMiningLevel(player)
	if miningLevel &lt; MINING_CONFIG.OreTypes[oreType].levelReq then
		return false, string.format("Need Mining level %d (current: %d)", 
			MINING_CONFIG.OreTypes[oreType].levelReq, miningLevel)
	end
	
	-- Check for pickaxe
	local pickaxeId = getEquippedPickaxe(player)
	if not pickaxeId then
		return false, "Need a pickaxe equipped"
	end
	
	-- Check pickaxe level requirement
	local pickaxeData = MINING_CONFIG.Pickaxes[pickaxeId]
	if not pickaxeData then
		return false, "Invalid pickaxe"
	end
	
	if miningLevel &lt; pickaxeData.levelReq then
		return false, string.format("Need Mining level %d for this pickaxe", pickaxeData.levelReq)
	end
	
	return true, "Valid", oreType, pickaxeId
end

-- Main mining handler
StartMiningEvent.OnServerEvent:Connect(function(player, oreNode)
	-- Validate input
	if not player or not player:IsA("Player") then
		ErrorHandler:LogWarning("Invalid player in mining attempt")
		return
	end
	
	if not oreNode then
		ErrorHandler:LogWarning("No ore node provided", {player = player.Name})
		return
	end
	
	-- Validate mining attempt
	local isValid, errorMessage, oreType, pickaxeId = validateMining(player, oreNode)
	
	if not isValid then
		ErrorHandler:LogDebug("Mining validation failed", {
			player = player.Name,
			error = errorMessage
		})
		
		-- Notify client of failure
		if MiningCompleteEvent then
			MiningCompleteEvent:FireClient(player, false, errorMessage)
		end
		return
	end
	
	-- Calculate mining time
	local miningTime = calculateMiningTime(player, oreType, pickaxeId)
	
	-- Start mining session
	activeMiningSessions[player.UserId] = {
		player = player,
		oreNode = oreNode,
		oreType = oreType,
		startTime = tick(),
		miningTime = miningTime,
		completed = false
	}
	
	ErrorHandler:LogDebug("Mining session started", {
		player = player.Name,
		ore = oreType,
		time = miningTime,
		pickaxe = pickaxeId
	})
	
	-- Start progress updates
	local startTime = tick()
	local updateInterval = 0.1 -- Update every 100ms
	
	while tick() - startTime &lt; miningTime do
		if not activeMiningSessions[player.UserId] then
			-- Session cancelled
			break
		end
		
		local progress = (tick() - startTime) / miningTime
		
		-- Send progress update to client
		if MiningProgressEvent then
			MiningProgressEvent:FireClient(player, oreType, progress)
		end
		
		wait(updateInterval)
	end
	
	-- Check if mining was completed
	local session = activeMiningSessions[player.UserId]
	if session and not session.completed then
		-- Mining completed successfully
		session.completed = true
		
		-- Award XP
		awardMiningXP(player, oreType)
		
		-- Add ore to inventory
		addOreToInventory(player, oreType)
		
		-- Deplete ore node
		oreNodes[oreNode] = {
			depleted = true,
			respawnTime = tick() + MINING_CONFIG.OreTypes[oreType].respawnTime,
			oreType = oreType
		}
		
		-- Notify client of completion
		if MiningCompleteEvent then
			MiningCompleteEvent:FireClient(player, true, "Mined " .. oreType)
		end
		
		ErrorHandler:LogInfo("Mining completed", {
			player = player.Name,
			ore = oreType,
			timeTaken = tick() - startTime
		})
		
		-- Hide ore node visually (client will handle this)
		-- In a full implementation, we'd change the node's appearance
		
	else
		-- Mining was cancelled or failed
		if MiningCompleteEvent then
			MiningCompleteEvent:FireClient(player, false, "Mining cancelled")
		end
	end
	
	-- Clean up session
	activeMiningSessions[player.UserId] = nil
end)

-- Cancel mining if player moves too far
local function checkMiningDistance()
	for userId, session in pairs(activeMiningSessions) do
		if session.player and session.player.Character and session.oreNode then
			local character = session.player.Character
			local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
			
			if humanoidRootPart then
				local distance = (humanoidRootPart.Position - session.oreNode.Position).Magnitude
				
				if distance > 10 then -- Cancel if more than 10 studs away
					ErrorHandler:LogDebug("Mining cancelled due to distance", {
						player = session.player.Name,
						distance = distance
					})
					
					activeMiningSessions[userId] = nil
					
					if MiningCompleteEvent then
						MiningCompleteEvent:FireClient(session.player, false, "Moved too far from ore")
					end
				end
			end
		end
	end
end

-- Periodic distance check
RunService.Heartbeat:Connect(function(deltaTime)
	checkMiningDistance()
end)

-- Ore node respawn system
local function respawnOreNodes()
	for oreNode, nodeData in pairs(oreNodes) do
		if nodeData.depleted and tick() >= nodeData.respawnTime then
			-- Respawn the ore node
			oreNodes[oreNode] = nil
			
			ErrorHandler:LogDebug("Ore node respawned", {
				ore = nodeData.oreType,
				node = oreNode:GetFullName()
			})
			
			-- Notify clients that node is available again
			-- In a full implementation, we'd change the node's appearance back
		end
	end
end

-- Periodic respawn check
RunService.Heartbeat:Connect(function(deltaTime)
	respawnOreNodes()
end)

-- Clean up when player leaves
Players.PlayerRemoving:Connect(function(player)
	if activeMiningSessions[player.UserId] then
		activeMiningSessions[player.UserId] = nil
		ErrorHandler:LogDebug("Cleaned up mining session", {player = player.Name})
	end
end)

-- Initialize ore nodes in workspace
local function initializeOreNodes()
	-- Look for ore nodes in workspace
	-- In a full implementation, we'd tag parts with CollectionService
	-- For now, we'll just log that initialization happened
	
	ErrorHandler:LogInfo("MiningManager initialized", {
		oreTypes = #MINING_CONFIG.OreTypes,
		pickaxeTypes = #MINING_CONFIG.Pickaxes
	})
end

-- Initialize on server start
game:GetService("Players").PlayerAdded:Wait()
initializeOreNodes()

ErrorHandler:LogInfo("MiningManager loaded successfully!")</string>
      </Properties>
    </Item>
    <Item class="Script" referent="147">
      <Properties>
        <string name="Name">MonetizationManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- MonetizationManager.server.lua
local MarketplaceService = game:GetService("MarketplaceService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DataManager = require(ReplicatedStorage.Modules.DataManager)
local ItemDatabase = require(ReplicatedStorage.Modules.ItemDatabase)
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 5)

-- Product IDs (LIVE ROBLOX PRODUCT IDS)
local PRODUCT_IDS = {
    -- Double XP (1 hour) = Developer Product
    DOUBLE_XP_1HR = 3539561334,
    -- Starweave Set (individual pieces) - 50 Robux each
    STARWEAVE_SWORD = 3539559450,
    STARWEAVE_HELM = 3539559585,
    STARWEAVE_PLATEBODY = 3539559706,
    STARWEAVE_PLATELEGS = 3539559963,
    STARWEAVE_SHIELD = 3539560087,
    -- Emberfrost Set - 100 Robux each
    EMBERFROST_BLADE = 3539560175,
    EMBERFROST_CROWN = 3539560288,
    EMBERFROST_PLATEBODY = 3539560378,
    EMBERFROST_PLATELEGS = 3539560601,
    EMBERFROST_BULWARK = 3539560715,
    -- Voidborn Set - 500 Robux each
    VOIDBORN_GREATSWORD = 3539560841,
    VOIDBORN_VISAGE = 3539560916,
    VOIDBORN_PLATEBODY = 3539561044,
    VOIDBORN_PLATELEGS = 3539561143,
    VOIDBORN_AEGIS = 3539561215,
}

-- Reverse lookup: productId -> item name
local PRODUCT_TO_ITEM = {
    [3539559450] = "Starweave Sword",
    [3539559585] = "Starweave Helm",
    [3539559706] = "Starweave Platebody",
    [3539559963] = "Starweave Platelegs",
    [3539560087] = "Starweave Shield",
    [3539560175] = "Emberfrost Blade",
    [3539560288] = "Emberfrost Crown",
    [3539560378] = "Emberfrost Platebody",
    [3539560601] = "Emberfrost Platelegs",
    [3539560715] = "Emberfrost Bulwark",
    [3539560841] = "Voidborn Greatsword",
    [3539560916] = "Voidborn Visage",
    [3539561044] = "Voidborn Platebody",
    [3539561143] = "Voidborn Platelegs",
    [3539561215] = "Voidborn Aegis",
}

-- GamePass IDs
local GAMEPASS_IDS = {
    DOUBLE_XP_PERMANENT = 0, -- Permanent 2x XP gamepass
}

-- Double XP tracking (in-memory, per session)
local doubleXPPlayers = {} -- [userId] = expireTime (os.time)

-- Check if player has double XP active
local function hasDoubleXP(player)
    -- Check permanent gamepass first
    local hasPass = false
    pcall(function()
        hasPass = MarketplaceService:UserOwnsGamePassAsync(player.UserId, GAMEPASS_IDS.DOUBLE_XP_PERMANENT)
    end)
    if hasPass then return true end
    -- Check timed boost
    local expire = doubleXPPlayers[player.UserId]
    if expire and os.time() < expire then return true end
    return false
end

-- Grant item to player
local function grantItem(player, itemName)
    local item = ItemDatabase.GetItem(itemName)
    if not item then return false end
    local data = DataManager:GetData(player)
    if not data then return false end
    -- Check if already owns it
    for _, inv in ipairs(data.Inventory) do
        if inv.name == itemName then
            -- Already owns, don't duplicate
            return false
        end
    end
    table.insert(data.Inventory, {name = itemName, quantity = 1})
    Remotes.InventoryUpdate:FireClient(player, data.Inventory)
    return true
end

-- Process receipts
MarketplaceService.ProcessReceipt = function(receiptInfo)
    local player = Players:GetPlayerByUserId(receiptInfo.PlayerId)
    if not player then return Enum.ProductPurchaseDecision.NotProcessedYet end
    
    local productId = receiptInfo.ProductId
    
    -- Double XP 1hr
    if productId == PRODUCT_IDS.DOUBLE_XP_1HR then
        doubleXPPlayers[player.UserId] = os.time() + 3600
        Remotes.DoubleXPStatus:FireClient(player, true)
        return Enum.ProductPurchaseDecision.PurchaseGranted
    end
    
    -- Item purchase
    local itemName = PRODUCT_TO_ITEM[productId]
    if itemName then
        local success = grantItem(player, itemName)
        if success then
            return Enum.ProductPurchaseDecision.PurchaseGranted
        end
    end
    
    return Enum.ProductPurchaseDecision.NotProcessedYet
end

-- Handle premium item purchase requests
Remotes.PurchasePremiumItem.OnServerEvent:Connect(function(player, itemName)
    local item = ItemDatabase.GetItem(itemName)
    if not item or not item.premium or not item.robuxPrice then
        return
    end
    
    -- Find the product ID for this item
    local productId = nil
    for id, name in pairs(PRODUCT_TO_ITEM) do
        if name == itemName then
            productId = id
            break
        end
    end
    
    if productId and productId > 0 then
        MarketplaceService:PromptProductPurchase(player, productId)
    else
        warn("[MonetizationManager] No product ID set for item: " .. itemName)
    end
end)

-- Send double XP status to client on join
Players.PlayerAdded:Connect(function(player)
    task.wait(1) -- Wait for data to load
    local isActive = hasDoubleXP(player)
    Remotes.DoubleXPStatus:FireClient(player, isActive)
end)

-- Expose hasDoubleXP for other scripts
_G.HasDoubleXP = hasDoubleXP

-- Cleanup on leave
Players.PlayerRemoving:Connect(function(player)
    doubleXPPlayers[player.UserId] = nil
end)

print("[MonetizationManager] Loaded - Product IDs need to be set after publishing")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="148">
      <Properties>
        <string name="Name">MonsterManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	MonsterManager.server.lua
	ServerScriptService

	Spawns all monsters in the world, runs their AI (wander / aggro / attack),
	handles death, loot bags, respawning, and XP awards.
]]

--------------------------------------------------------------------------------
-- SERVICES & MODULES
--------------------------------------------------------------------------------
local Players            = game:GetService("Players")
local RunService         = game:GetService("RunService")
local ReplicatedStorage  = game:GetService("ReplicatedStorage")

-- Wait for map to finish building
task.wait(4)

local MonsterDatabase = require(ReplicatedStorage.Modules.MonsterDatabase)
local DataManager     = require(ReplicatedStorage.Modules.DataManager)
local ItemDatabase    = require(ReplicatedStorage.Modules.ItemDatabase)
local ItemVisuals     = require(ReplicatedStorage.Modules.ItemVisuals)

--------------------------------------------------------------------------------
-- REMOTE EVENTS (from Remotes folder in project.json)
--------------------------------------------------------------------------------
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 5)
local TweenService = game:GetService("TweenService")

local MonsterDamageEvent = Remotes:WaitForChild("MonsterDamage", 10)
local MonsterDeathEvent  = Remotes:WaitForChild("MonsterDeath", 10)
local MonsterLootEvent   = Remotes:WaitForChild("MonsterLoot", 10)
local XPPopupEvent       = Remotes:WaitForChild("XPPopup", 10)

--------------------------------------------------------------------------------
-- CONSTANTS
--------------------------------------------------------------------------------
local WANDER_RADIUS        = 15
local AGGRO_RANGE_DEFAULT  = 20
local AGGRO_RANGE_PASSIVE  = 10
local AGGRO_RANGE_BOSS     = 40
local DEAGGRO_RANGE        = 40
local LEASH_RANGE          = 80  -- max distance from spawn before forced deaggro
local ATTACK_RANGE         = 7
local ATTACK_COOLDOWN      = 2
local LOOT_DESPAWN_TIME    = 30
local WANDER_INTERVAL      = 3   -- seconds between wander moves
local MOVE_SPEED           = 12  -- studs/sec for normal monsters
local MOVE_SPEED_BOSS      = 8

--------------------------------------------------------------------------------
-- STATE
--------------------------------------------------------------------------------
local activeMonsters = {}  -- model -> state table
local totalSpawned = 0

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------
local RNG = Random.new()

local function lerp(a, b, t)
	return a + (b - a) * t
end

local function randomInRange(min, max)
	return lerp(min, max, RNG:NextNumber())
end

--- Pick a random point within a rectangle defined by min/max x/z, at ground level
local function randomPointInRect(xMin, xMax, zMin, zMax)
	return Vector3.new(
		randomInRange(xMin, xMax),
		0,
		randomInRange(zMin, zMax)
	)
end

--- Distance between two Vector3 (XZ plane only)
local function distXZ(a, b)
	local dx = a.X - b.X
	local dz = a.Z - b.Z
	return math.sqrt(dx * dx + dz * dz)
end

--------------------------------------------------------------------------------
-- MONSTER MODEL BUILDER
--------------------------------------------------------------------------------
local function buildMonsterModel(def, position)
	local model = Instance.new("Model")
	model.Name = def.name

	local m = def.model

	-- Body
	local body = Instance.new("Part")
	body.Name = "Body"
	body.Shape = Enum.PartType.Block
	body.Size = m.size
	body.Color = m.bodyColor
	body.Anchored = true
	body.CanCollide = true
	-- Auto-calculate elevation: find the lowest bodyRelative extra so nothing clips underground
	local lowestY = 0
	if m.extras then
		for _, extra in ipairs(m.extras) do
			if extra.bodyRelative and extra.offset then
				local partBottom = extra.offset.Y - (extra.size and extra.size.Y / 2 or 0)
				if partBottom < lowestY then
					lowestY = partBottom
				end
			end
		end
	end
	-- Body center Y: must be high enough that lowest extra touches ground (Y=0)
	local autoElevation = math.abs(lowestY)
	local bodyY = math.max(m.size.Y / 2, m.elevation or 0, autoElevation)
	body.Position = Vector3.new(position.X, bodyY, position.Z)
	body.Parent = model

	-- Head (ball on top of body)
	local head = Instance.new("Part")
	head.Name = "Head"
	head.Shape = Enum.PartType.Ball
	head.Size = Vector3.new(m.headSize, m.headSize, m.headSize) * 2
	head.Color = m.bodyColor
	head.Anchored = true
	head.CanCollide = false
	head.Position = Vector3.new(position.X, bodyY + m.size.Y / 2 + m.headSize, position.Z)
	head.Parent = model

	-- Humanoid (for health tracking)
	local humanoid = Instance.new("Humanoid")
	humanoid.MaxHealth = def.hp
	humanoid.Health = def.hp
	humanoid.Parent = model

	-- PrimaryPart
	model.PrimaryPart = body

	-- BillboardGui ÃƒÂ¢Ã¢'Â¬" name, level, HP bar
	local bbg = Instance.new("BillboardGui")
	bbg.Name = "OverheadGui"
	bbg.Size = UDim2.new(4, 0, 1.5, 0)
	bbg.StudsOffset = Vector3.new(0, m.size.Y / 2 + m.headSize * 2 + 1, 0)
	bbg.AlwaysOnTop = true
	bbg.Adornee = body
	bbg.Parent = model

	-- Name label
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Name = "NameLabel"
	nameLabel.Size = UDim2.new(1, 0, 0.4, 0)
	nameLabel.Position = UDim2.new(0, 0, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = def.name .. (def.level > 0 and (" [Lv." .. def.level .. "]") or "")
	nameLabel.TextColor3 = def.boss and Color3.fromRGB(255, 50, 50) or
	                        def.zone == "Wilderness" and Color3.fromRGB(255, 170, 50) or
	                        Color3.fromRGB(255, 255, 255)
	nameLabel.TextScaled = true
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.Parent = bbg

	-- HP bar background
	local hpBg = Instance.new("Frame")
	hpBg.Name = "HPBarBG"
	hpBg.Size = UDim2.new(0.8, 0, 0.15, 0)
	hpBg.Position = UDim2.new(0.1, 0, 0.45, 0)
	hpBg.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	hpBg.BorderSizePixel = 0
	hpBg.Parent = bbg

	local hpFill = Instance.new("Frame")
	hpFill.Name = "HPFill"
	hpFill.Size = UDim2.new(1, 0, 1, 0)
	hpFill.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
	hpFill.BorderSizePixel = 0
	hpFill.Parent = hpBg

	-- HP text
	local hpText = Instance.new("TextLabel")
	hpText.Name = "HPText"
	hpText.Size = UDim2.new(1, 0, 0.3, 0)
	hpText.Position = UDim2.new(0, 0, 0.65, 0)
	hpText.BackgroundTransparency = 1
	hpText.Text = def.hp .. " / " .. def.hp
	hpText.TextColor3 = Color3.fromRGB(255, 255, 255)
	hpText.TextScaled = true
	hpText.Font = Enum.Font.Gotham
	hpText.Parent = bbg

	-- ClickDetector for targeting - ADD TO ALL PARTS
	local function addClickDetectorToAllParts()
		for _, child in ipairs(model:GetChildren()) do
			if child:IsA("BasePart") then
				local click = Instance.new("ClickDetector")
				click.Name = "TargetClick"
				click.MaxActivationDistance = 30
				click.Parent = child
			end
		end
	end

	-- === EXTRA PARTS (legs, arms, horns, eyes, etc.) ===
	if m.extras then
		for _, extra in ipairs(m.extras) do
			local part = Instance.new("Part")
			part.Name = extra.name
			part.Anchored = true
			part.CanCollide = false
			part.Size = extra.size
			part.Color = extra.color
			part.Material = extra.material or Enum.Material.SmoothPlastic
			if extra.transparency then
				part.Transparency = extra.transparency
			end

			if extra.shape == "Ball" then
				part.Shape = Enum.PartType.Ball
			else
				part.Shape = Enum.PartType.Block
			end

			-- Position relative to body or head
			if extra.bodyRelative then
				part.Position = body.Position + extra.offset
			else
				-- Relative to head
				part.Position = head.Position + extra.offset
			end

			if extra.rotation then
				part.Orientation = extra.rotation
			end

			-- Add glow for neon parts
			if extra.material == Enum.Material.Neon then
				local light = Instance.new("PointLight")
				light.Color = extra.color
				light.Brightness = 1
				light.Range = 6
				light.Parent = part
			end

			part.Parent = model
		end
	end

	-- Add ClickDetectors to all parts
	addClickDetectorToAllParts()

	return model
end

--------------------------------------------------------------------------------
-- HP BAR UPDATE
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- MONSTER DEATH ANIMATION
--------------------------------------------------------------------------------
local function playDeathAnimation(model, deathPos)
	-- Dust/smoke puff at death location
	for i = 1, 6 do
		local puff = Instance.new("Part")
		puff.Name = "DeathPuff"
		puff.Shape = Enum.PartType.Ball
		puff.Size = Vector3.new(1, 1, 1)
		puff.Position = deathPos + Vector3.new(math.random(-2, 2), math.random(0, 2), math.random(-2, 2))
		puff.Color = Color3.fromRGB(180, 170, 150)
		puff.Material = Enum.Material.SmoothPlastic
		puff.Anchored = true
		puff.CanCollide = false
		puff.Transparency = 0.3
		puff.Parent = workspace

		TweenService:Create(puff, TweenInfo.new(1.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			Size = Vector3.new(3, 3, 3),
			Transparency = 1,
			Position = puff.Position + Vector3.new(0, 3, 0),
		}):Play()

		task.delay(1.3, function()
			if puff and puff.Parent then puff:Destroy() end
		end)
	end

	-- Body falls to the side and fades out
	local body = model.PrimaryPart
	if body then
		-- Tilt the body to fall over
		local fallCF = body.CFrame * CFrame.Angles(0, 0, math.rad(90))
		TweenService:Create(body, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
			CFrame = fallCF,
		}):Play()
	end

	-- Fade all parts
	for _, child in model:GetDescendants() do
		if child:IsA("BasePart") then
			TweenService:Create(child, TweenInfo.new(1.5, Enum.EasingStyle.Quad), {
				Transparency = 1,
			}):Play()
		elseif child:IsA("BillboardGui") then
			child.Enabled = false
		end
	end

	-- Destroy after fade completes
	task.delay(2, function()
		if model and model.Parent then
			model:Destroy()
		end
	end)
end

local function updateHPBar(model, currentHP, maxHP)
	local bbg = model:FindFirstChild("OverheadGui")
	if not bbg then return end
	local bg = bbg:FindFirstChild("HPBarBG")
	if bg then
		local fill = bg:FindFirstChild("HPFill")
		if fill then
			local pct = math.clamp(currentHP / maxHP, 0, 1)
			fill.Size = UDim2.new(pct, 0, 1, 0)
			-- Color: green ÃƒÂ¢Ã¢â‚¬ ' yellow ÃƒÂ¢Ã¢â‚¬ ' red
			if pct > 0.5 then
				fill.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
			elseif pct > 0.25 then
				fill.BackgroundColor3 = Color3.fromRGB(220, 200, 30)
			else
				fill.BackgroundColor3 = Color3.fromRGB(220, 40, 40)
			end
		end
	end
	local hpLabel = bbg:FindFirstChild("HPText")
	if hpLabel then
		hpLabel.Text = math.max(0, math.floor(currentHP)) .. " / " .. maxHP
	end
end

--------------------------------------------------------------------------------
-- LOOT BAG
--------------------------------------------------------------------------------
local function rollDrops(def)
	local results = {}
	for _, drop in def.drops do
		if RNG:NextNumber() <= drop.chance then
			local qty = RNG:NextInteger(drop.minQty, drop.maxQty)
			table.insert(results, { item = drop.item, qty = qty })
		end
	end
	return results
end

-- Rarity colors for loot items
local RARITY_COLORS = {
	common = Color3.fromRGB(157, 157, 157),
	uncommon = Color3.fromRGB(30, 255, 0),
	rare = Color3.fromRGB(0, 112, 221),
	epic = Color3.fromRGB(163, 53, 238),
	legendary = Color3.fromRGB(255, 128, 0),
}

local function createLootDrops(position, drops, killerPlayer)
	if #drops == 0 then return end

	-- Spread items in a circle around death position
	local angleStep = (2 * math.pi) / math.max(#drops, 1)
	local spreadRadius = 2.5

	for i, drop in ipairs(drops) do
		local angle = angleStep * (i - 1) + (math.random() * 0.5)
		local offsetX = math.cos(angle) * spreadRadius
		local offsetZ = math.sin(angle) * spreadRadius

		-- Get item visuals
		local visual = ItemVisuals.GetVisual(drop.item)
		local itemDef = ItemDatabase and ItemDatabase.Items and ItemDatabase.Items[drop.item]
		local rarity = (itemDef and itemDef.rarity) or "common"
		local rarityColor = RARITY_COLORS[rarity] or RARITY_COLORS.common

		-- Create different shapes based on item type
		local itemPart
		local dropSize = Vector3.new(1.2, 1.2, 1.2)
		
		if visual.shape == "sword" then
			-- Swords: elongated thin part
			dropSize = Vector3.new(0.3, 2.5, 0.3)
		elseif visual.shape == "shield" then
			-- Shields: flat wide part
			dropSize = Vector3.new(2.0, 0.3, 1.5)
		elseif visual.shape == "ore" or visual.shape == "bar" then
			-- Ores/bars: small cube
			dropSize = Vector3.new(0.8, 0.8, 0.8)
		elseif visual.shape == "log" then
			-- Logs: cylinder-shaped (elongated block)
			itemPart = Instance.new("Part")
			itemPart.Size = Vector3.new(0.6, 0.6, 2.0)
			itemPart.Shape = Enum.PartType.Cylinder
		elseif visual.shape == "fish" then
			-- Fish: flat oval
			dropSize = Vector3.new(1.0, 0.4, 1.8)
		elseif visual.shape == "food" then
			-- Food: small round
			itemPart = Instance.new("Part")
			itemPart.Size = Vector3.new(0.8, 0.8, 0.8)
			itemPart.Shape = Enum.PartType.Ball
		elseif visual.shape == "arrow" then
			-- Arrows: very thin long
			dropSize = Vector3.new(0.1, 0.1, 2.2)
		elseif visual.shape == "gem" then
			-- Gems: small wedge for crystalline look
			itemPart = Instance.new("WedgePart")
			itemPart.Size = Vector3.new(0.6, 0.8, 0.6)
		elseif visual.shape == "bone" then
			-- Bones: thin cylindrical
			itemPart = Instance.new("Part")
			itemPart.Size = Vector3.new(0.3, 0.3, 1.5)
			itemPart.Shape = Enum.PartType.Cylinder
		elseif visual.shape == "feather" then
			-- Feathers: thin flat
			dropSize = Vector3.new(0.8, 0.1, 1.2)
		elseif visual.shape == "bow" then
			-- Bows: elongated curved (approximated with block)
			dropSize = Vector3.new(0.4, 1.8, 0.2)
		else
			-- Default: small cube for misc items
			dropSize = Vector3.new(1.0, 1.0, 1.0)
		end
		
		-- Create part if not already created
		if not itemPart then
			itemPart = Instance.new("Part")
			itemPart.Size = dropSize
			itemPart.Shape = Enum.PartType.Block
		end

		itemPart.Name = "LootDrop_" .. drop.item
		itemPart.Anchored = true
		itemPart.CanCollide = false
		itemPart.Position = position + Vector3.new(offsetX, 0.6, offsetZ)
		itemPart.Material = Enum.Material.SmoothPlastic
		
		-- Use item's unique color from ItemVisuals
		itemPart.Color = visual.color
		
		-- Add glow effect for special items
		if visual.glowColor then
			local glow = Instance.new("PointLight")
			glow.Color = visual.glowColor
			glow.Brightness = 2
			glow.Range = 8
			glow.Parent = itemPart
		end

		itemPart.Parent = workspace

		-- Floating label with item emoji and name
		local bbg = Instance.new("BillboardGui")
		bbg.Size = UDim2.new(5, 0, 1, 0)
		bbg.StudsOffset = Vector3.new(0, 1.5, 0)
		bbg.AlwaysOnTop = true
		bbg.Adornee = itemPart
		bbg.Parent = itemPart

		local label = Instance.new("TextLabel")
		label.Size = UDim2.new(1, 0, 1, 0)
		label.BackgroundTransparency = 1
		
		-- Display emoji + name + quantity
		local displayText = visual.emoji .. " " .. drop.item
		if drop.qty > 1 then
			displayText = displayText .. " x" .. drop.qty
		end
		
		label.Text = displayText
		label.TextColor3 = rarityColor
		label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
		label.TextStrokeTransparency = 0
		label.TextScaled = true
		label.Font = Enum.Font.GothamBold
		label.Parent = bbg

		-- Click to pick up
		local click = Instance.new("ClickDetector")
		click.MaxActivationDistance = 14
		click.Parent = itemPart

		local picked = false
		click.MouseClick:Connect(function(player)
			if picked then return end
			picked = true

			local ok, err = pcall(function()
				DataManager.AddItem(player, drop.item, drop.qty)
			end)
			if not ok then
				warn("[MonsterManager] Failed to give item:", err)
			end

			-- Notify client
			MonsterLootEvent:FireClient(player, {{item = drop.item, qty = drop.qty}})

			-- Pick up effect: shrink and vanish
			local TweenService = game:GetService("TweenService")
			local tween = TweenService:Create(itemPart, TweenInfo.new(0.3), {
				Size = Vector3.new(0.1, 0.1, 0.1),
				Transparency = 1,
			})
			tween:Play()
			tween.Completed:Once(function()
				itemPart:Destroy()
			end)
		end)

		-- Gentle bobbing animation (with race condition protection)
		task.spawn(function()
			if not itemPart or not itemPart.Parent then return end
			local startY = itemPart.Position.Y
			local t = math.random() * math.pi * 2 -- random phase so items don't bob in sync
			while true do
				-- Double-check every iteration to prevent race condition
				if not itemPart or not itemPart.Parent then break end
				t = t + 0.05
				
				-- Protect the Position assignment
				local success, err = pcall(function()
					if itemPart and itemPart.Parent then
						itemPart.Position = Vector3.new(
							itemPart.Position.X,
							startY + math.sin(t) * 0.3,
							itemPart.Position.Z
						)
					end
				end)
				if not success then break end -- Exit loop if casting error occurs
				
				task.wait(0.03)
			end
		end)

		-- Auto-despawn
		task.delay(LOOT_DESPAWN_TIME, function()
			if itemPart and itemPart.Parent then
				itemPart:Destroy()
			end
		end)
	end
end

--------------------------------------------------------------------------------
-- MOVEMENT HELPERS
--------------------------------------------------------------------------------
local function moveModelTo(model, targetPos, dt, speed)
	local body = model.PrimaryPart
	if not body then return end
	local current = body.Position
	local dir = (targetPos - current) * Vector3.new(1, 0, 1) -- XZ only
	local dist = dir.Magnitude
	if dist < 0.5 then return end

	local step = math.min(speed * dt, dist)
	local offset = dir.Unit * step
	local newPos = current + offset

	-- Keep Y stable
	newPos = Vector3.new(newPos.X, current.Y, newPos.Z)

	-- Face movement direction and move entire model atomically
	local newCF = CFrame.new(newPos, newPos + dir.Unit)
	model:PivotTo(newCF)
end

local function teleportModel(model, pos)
	local body = model.PrimaryPart
	if not body then return end
	-- Keep current rotation, just change position
	local oldCF = body.CFrame
	local newCF = CFrame.new(pos) * (oldCF - oldCF.Position)
	model:PivotTo(newCF)
end

--------------------------------------------------------------------------------
-- FIND NEAREST PLAYER (alive, with character)
--------------------------------------------------------------------------------
local function findNearestPlayer(position, maxRange)
	local nearest= nil
	local nearestDist = math.huge
	for _, player in Players:GetPlayers() do
		local char = player.Character
		if char then
			local hrp = char:FindFirstChild("HumanoidRootPart")
			local hum = char:FindFirstChildOfClass("Humanoid")
			if hrp and hum and hum.Health > 0 then
				local d = distXZ(position, hrp.Position)
				if d < nearestDist and d <= maxRange then
					nearestDist = d
					nearest = player
				end
			end
		end
	end
	return nearest, nearestDist
end

--------------------------------------------------------------------------------
-- SPAWN A SINGLE MONSTER
--------------------------------------------------------------------------------
local function spawnMonster(defKey, position)
	local def = MonsterDatabase.Monsters[defKey]
	if not def then
		warn("[MonsterManager] Unknown monster key:", defKey)
		return
	end

	local model = buildMonsterModel(def, position)
	model.Parent = workspace

	-- State
	local state = {
		defKey       = defKey,
		def          = def,
		model        = model,
		spawnPos     = position,
		currentHP    = def.hp,
		maxHP        = def.hp,
		alive        = true,
		aiState      = "idle",   -- idle | wander | chase | returning
		wanderTarget = nil,
		wanderTimer  = RNG:NextNumber() * WANDER_INTERVAL, -- stagger initial wander
		attackTimer  = 0,
		targetPlayer = nil,
	}

	activeMonsters[model] = state

	-- ClickDetector: player attacks monster (connect ALL ClickDetectors)
	local function onMonsterClicked(player)
			if not state.alive then return end

			local char = player.Character
			if not char then return end
			local hrp = char:FindFirstChild("HumanoidRootPart")
			if not hrp then return end

			-- Must be close enough to attack
			if distXZ(hrp.Position, model.PrimaryPart.Position) > ATTACK_RANGE * 3 then return end

			-- Player deals damage (base + weapon + level bonus)
			local playerLevel = 1
			pcall(function()
				playerLevel = DataManager.GetCombatLevel(player) or 1
			end)
			-- Check equipped weapon damage
			local weaponDmg = 0
			pcall(function()
				local data = DataManager:GetData(player)
				if data and data.Equipment and data.Equipment.Weapon and data.Equipment.Weapon ~= "" then
					local weaponInfo = ItemDatabase.GetItem(data.Equipment.Weapon)
					if weaponInfo and weaponInfo.damage then
						weaponDmg = weaponInfo.damage
					end
				end
			end)
			local baseDmg = math.max(5, weaponDmg)
			local dmg = baseDmg + math.floor(playerLevel * 1.5)
			-- Random variance 80-120%
			dmg = math.floor(dmg * (0.8 + math.random() * 0.4))

			state.currentHP = state.currentHP - dmg
			updateHPBar(model, state.currentHP, state.maxHP)

			-- Fire to all clients for hit effects (include attacker for animation trigger)
			MonsterDamageEvent:FireAllClients(model, dmg, state.currentHP, state.maxHP, player)

			-- Determine weapon type for animation
			local weaponTypeForAnim = "unarmed"
			pcall(function()
				local data = DataManager:GetData(player)
				if data and data.Equipment and data.Equipment.Weapon and data.Equipment.Weapon ~= "" then
					local wName = data.Equipment.Weapon:lower()
					if wName:find("bow") or wName:find("crossbow") then
						weaponTypeForAnim = "ranged"
					else
						weaponTypeForAnim = "melee"
					end
				end
			end)

			-- Broadcast player attack visual to nearby clients
			if shared.AttackVisualHandler then
				shared.AttackVisualHandler.BroadcastPlayerAttack(player, model, weaponTypeForAnim, dmg >= (state.maxHP * 0.2))
			end

			-- Aggro onto attacker
			if state.aiState ~= "chase" then
				state.aiState = "chase"
				state.targetPlayer = player
			end

			-- Death check
			if state.currentHP <= 0 and not def.immortal then
				state.alive = false
				state.currentHP = 0
				updateHPBar(model, 0, state.maxHP)

				-- Award XP
				pcall(function()
					DataManager.AddSkillXP(player, "Strength", def.xp)
				end)

				-- Roll & drop loot
				local drops = rollDrops(def)
				local deathPos = model.PrimaryPart.Position
				MonsterDeathEvent:FireAllClients(model, player, drops)

				-- Send XP popup to killer
				XPPopupEvent:FireClient(player, deathPos, def.xp, def.name)

				-- Remove from active tracking immediately (stop AI)
				activeMonsters[model] = nil

				-- Play death animation (delays destroy by 2s)
				playDeathAnimation(model, deathPos)

				-- Drop individual loot items
				createLootDrops(deathPos, drops, player)

				-- Respawn after delay (add 2s for death anim)
				task.delay(def.respawnTime + 2, function()
					spawnMonster(defKey, position)
				end)
			end
	end

	-- Connect all ClickDetectors in the model to the click handler
	for _, desc in ipairs(model:GetDescendants()) do
		if desc:IsA("ClickDetector") and desc.Name == "TargetClick" then
			desc.MouseClick:Connect(onMonsterClicked)
		end
	end

	totalSpawned += 1
end

--------------------------------------------------------------------------------
-- AI LOOP (runs every Heartbeat)
--------------------------------------------------------------------------------
RunService.Heartbeat:Connect(function(dt)
	for model, state in activeMonsters do
		if not state.alive then continue end
		if state.def.stationary then continue end
		if not model.PrimaryPart then continue end

		local pos = model.PrimaryPart.Position
		local aggroRange = state.def.boss and AGGRO_RANGE_BOSS
		                   or state.def.passive and AGGRO_RANGE_PASSIVE
		                   or AGGRO_RANGE_DEFAULT
		local speed = state.def.boss and MOVE_SPEED_BOSS or MOVE_SPEED

		--------------------------------------------------------------------
		-- ATTACK TIMER (deal damage while chasing & in range)
		--------------------------------------------------------------------
		if state.aiState == "chase" and state.targetPlayer then
			state.attackTimer -= dt
			local char = state.targetPlayer.Character
			if char then
				local hrp = char:FindFirstChild("HumanoidRootPart")
				local hum = char:FindFirstChildOfClass("Humanoid")
				if hrp and hum and hum.Health > 0 then
					local d = distXZ(pos, hrp.Position)
					local distFromSpawn = distXZ(pos, state.spawnPos)

					-- De-aggro if player too far OR monster too far from spawn (leash)
					if d > DEAGGRO_RANGE or distFromSpawn > LEASH_RANGE then
						state.aiState = "returning"
						state.targetPlayer = nil
					else
						-- Move toward player
						moveModelTo(model, hrp.Position, dt, speed)

						-- Attack if close enough
						if d <= ATTACK_RANGE and state.attackTimer <= 0 then
							state.attackTimer = ATTACK_COOLDOWN
							hum:TakeDamage(state.def.damage)

							-- Broadcast monster attack visual
							if shared.AttackVisualHandler then
								shared.AttackVisualHandler.BroadcastMonsterAttack(model, state.targetPlayer, state.def.name)
								-- Send hit effect to target player
								if hrp then
									shared.AttackVisualHandler.BroadcastHitEffect(
										hrp.Position,
										state.def.damage,
										"damage_taken",
										state.def.damage >= 50,
										state.targetPlayer
									)
								end
							end
						end
					end
				else
					-- Player dead or gone
					state.aiState = "returning"
					state.targetPlayer = nil
				end
			else
				state.aiState = "returning"
				state.targetPlayer = nil
			end

		--------------------------------------------------------------------
		-- RETURNING TO SPAWN
		--------------------------------------------------------------------
		elseif state.aiState == "returning" then
			local d = distXZ(pos, state.spawnPos)
			if d < 2 then
				state.aiState = "idle"
				state.wanderTimer = WANDER_INTERVAL
			else
				moveModelTo(model, state.spawnPos, dt, speed)
			end

			-- Heal while returning
			if state.currentHP < state.maxHP then
				state.currentHP = math.min(state.maxHP, state.currentHP + state.maxHP * 0.05 * dt)
				updateHPBar(model, state.currentHP, state.maxHP)
			end

		--------------------------------------------------------------------
		-- IDLE / WANDER
		--------------------------------------------------------------------
		else
			-- Check for nearby player to aggro
			local nearPlayer, nearDist = findNearestPlayer(pos, aggroRange)
			if nearPlayer then
				state.aiState = "chase"
				state.targetPlayer = nearPlayer
				state.attackTimer = 0
			else
				-- Wander logic
				state.wanderTimer -= dt
				if state.wanderTimer <= 0 then
					state.wanderTimer = WANDER_INTERVAL + RNG:NextNumber() * 2
					-- Pick random point near spawn
					local angle = RNG:NextNumber() * math.pi * 2
					local radius = RNG:NextNumber() * WANDER_RADIUS
					state.wanderTarget = state.spawnPos + Vector3.new(
						math.cos(angle) * radius,
						0,
						math.sin(angle) * radius
					)
					state.aiState = "wander"
				end

				if state.aiState == "wander" and state.wanderTarget then
					local d = distXZ(pos, state.wanderTarget)
					if d < 1 then
						state.aiState = "idle"
					else
						moveModelTo(model, state.wanderTarget, dt, speed * 0.4) -- slow wander
					end
				end
			end
		end
	end
end)

--------------------------------------------------------------------------------
-- SPAWN DEFINITIONS ÃƒÂ¢Ã¢'Â¬" where each monster type appears in the world
--------------------------------------------------------------------------------
local spawnTable = {
	-- SAFE ZONE
	{ key = "Chicken",       count = 5, xMin = 120,  xMax = 180,  zMin = 120,  zMax = 160  },
	{ key = "Cow",           count = 4, xMin = 160,  xMax = 220,  zMin = 140,  zMax = 180  },
	{ key = "Goblin",        count = 4, xMin = -30,  xMax = 30,   zMin = 170,  zMax = 200  },
	{ key = "GuardDog",      count = 3, xMin = 160,  xMax = 200,  zMin = 0,    zMax = 40   },
	{ key = "GiantRat",      count = 5, xMin = -110, xMax = -80,  zMin = 20,   zMax = 40   },
	{ key = "TrainingDummy", count = 3, xMin = 170,  xMax = 210,  zMin = 10,   zMax = 40   },

	-- SAFE ZONE BOSSES
	{ key = "King Rooster",       count = 1, xMin = 140,  xMax = 160,  zMin = 130,  zMax = 150  },
	{ key = "Elder Treant",       count = 1, xMin = -200, xMax = -150, zMin = -30,  zMax = 30   },
	{ key = "Iron Golem",         count = 1, xMin = 190,  xMax = 220,  zMin = 20,   zMax = 50   },
	{ key = "Lake Serpent",       count = 1, xMin = -170, xMax = -130, zMin = 140,  zMax = 180  },
	{ key = "Corrupted Guardian", count = 1, xMin = 210,  xMax = 230,  zMin = -75,  zMax = -55  },

	-- WILDERNESS
	{ key = "Skeleton",      count = 5, xMin = -50,  xMax = -20,  zMin = -160, zMax = -140 },
	{ key = "DarkWizard",    count = 3, xMin = 50,   xMax = 70,   zMin = -180, zMax = -170 },
	{ key = "Demon",         count = 3, xMin = -20,  xMax = 20,   zMin = -320, zMax = -280 },

	-- NEW AREA MONSTERS (MapSetup5)
	-- Pirate Cove (X: 300-400, Z: -200 to -100) - Safe Zone
	{ key = "Pirate Ghost",  count = 4, xMin = 310,  xMax = 390,  zMin = -190, zMax = -110 },
	
	-- Frozen Peaks (X: -400 to -300, Z: -300 to -200) - Safe Zone  
	{ key = "Ice Elemental", count = 3, xMin = -390, xMax = -310, zMin = -290, zMax = -210 },
	{ key = "Frost Wyrm",    count = 1, xMin = -380, xMax = -320, zMin = -280, zMax = -220 }, -- boss
	
	-- Volcanic Crater (X: 300-400, Z: -400 to -300) - Wilderness
	{ key = "Lava Golem",    count = 3, xMin = 310,  xMax = 390,  zMin = -390, zMax = -310 },
	
	-- Enchanted Garden (X: -300 to -200, Z: 200-350) - Safe Zone
	{ key = "Fairy Dragon",  count = 5, xMin = -290, xMax = -210, zMin = 210,  zMax = 340  },
	
	-- Underground Ruins (X: -100 to 50, Z: -450 to -350) - Wilderness
	{ key = "Ancient Guardian", count = 1, xMin = -90, xMax = 40,   zMin = -440, zMax = -360 }, -- boss
	
	-- Dragon's Nest (X: 0-100, Z: -500 to -450) - no regular spawns (just boss area)
}

-- Spawn all regular monsters
for _, entry in spawnTable do
	for i = 1, entry.count do
		local pos = randomPointInRect(entry.xMin, entry.xMax, entry.zMin, entry.zMax)
		spawnMonster(entry.key, pos)
	end
end

-- Crimson Warlord BOSS â€” mid-tier safe zone centerpiece, Battle Arena
spawnMonster("Crimson Warlord", Vector3.new(0, 0, 250))

-- Shadow Dragon BOSS â€” single fixed spawn (center of Dragon's Nest, accessible from all sides)
spawnMonster("ShadowDragon", Vector3.new(50, 0, -475))

-- Lich King Malachar BOSS â€” deep wilderness undead sorcerer
spawnMonster("Lich King Malachar", Vector3.new(-50, 0, -400))

print("[MonsterManager] Spawned " .. totalSpawned .. " monsters!")

]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="149">
      <Properties>
        <string name="Name">PartyManager</string>
        <token name="RunContext">0</token>
        <string name="Source">-- PartyManager.server.lua
-- Party/Group system for Wilderness MMO

print("[PartyManager] Starting...")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Wait for dependencies with timeouts
local Modules = ReplicatedStorage:WaitForChild("Modules", 10)
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)

-- Load required modules
local DataManager = require(Modules:WaitForChild("DataManager", 10))

-- Get remotes
local PartyInvite = Remotes:WaitForChild("PartyInvite", 5)
local PartyAccept = Remotes:WaitForChild("PartyAccept", 5)
local PartyLeave = Remotes:WaitForChild("PartyLeave", 5)
local PartyKick = Remotes:WaitForChild("PartyKick", 5)
local PartyUpdate = Remotes:WaitForChild("PartyUpdate", 5)
local PartyChat = Remotes:WaitForChild("PartyChat", 5)

-- Validate remotes
if not PartyInvite or not PartyAccept or not PartyLeave or not PartyKick or not PartyUpdate or not PartyChat then
	warn("[PartyManager] Missing remotes!")
	return
end

-- Party data structure
local parties = {} -- partyId -> {leader = userId, members = {userId1, userId2, ...}}
local playerToParty = {} -- userId -> partyId
local partyInvites = {} -- {inviterUserId: {targetUserId: timestamp}}

-- Constants
local MAX_PARTY_SIZE = 4
local SHARED_XP_RANGE = 50 -- studs
local XP_BONUS_PER_MEMBER = 0.10 -- 10% per member

-- Helper function to get party by player
local function getPlayerParty(player)
	local partyId = playerToParty[player.UserId]
	if partyId then
		return parties[partyId]
	end
	return nil
end

-- Helper function to create new party
local function createParty(leader)
	local partyId = "party_" .. leader.UserId .. "_" .. os.time()
	
	parties[partyId] = {
		leader = leader.UserId,
		members = {leader.UserId},
		created = os.time()
	}
	
	playerToParty[leader.UserId] = partyId
	
	-- Notify leader
	PartyUpdate:FireClient(leader, {
		type = "created",
		partyId = partyId,
		leader = leader.UserId,
		members = {leader.UserId}
	})
	
	return partyId
end

-- Helper function to disband party
local function disbandParty(partyId)
	local party = parties[partyId]
	if not party then return end
	
	-- Notify all members
	for _, memberId in ipairs(party.members) do
		local member = Players:GetPlayerByUserId(memberId)
		if member then
			PartyUpdate:FireClient(member, {
				type = "disbanded",
				partyId = partyId
			})
			playerToParty[memberId] = nil
		end
	end
	
	-- Remove party
	parties[partyId] = nil
end

-- Helper function to add member to party
local function addMemberToParty(partyId, player)
	local party = parties[partyId]
	if not party then return false end
	
	-- Check if party is full
	if #party.members >= MAX_PARTY_SIZE then
		return false, "Party is full"
	end
	
	-- Add player
	table.insert(party.members, player.UserId)
	playerToParty[player.UserId] = partyId
	
	-- Notify all party members
	for _, memberId in ipairs(party.members) do
		local member = Players:GetPlayerByUserId(memberId)
		if member then
			PartyUpdate:FireClient(member, {
				type = "member_joined",
				partyId = partyId,
				member = player.UserId,
				members = party.members
			})
		end
	end
	
	return true
end

-- Helper function to remove member from party
local function removeMemberFromParty(partyId, userId, kickedBy)
	local party = parties[partyId]
	if not party then return end
	
	-- Find and remove member
	for i, memberId in ipairs(party.members) do
		if memberId == userId then
			table.remove(party.members, i)
			break
		end
	end
	
	playerToParty[userId] = nil
	
	-- Notify removed player
	local removedPlayer = Players:GetPlayerByUserId(userId)
	if removedPlayer then
		PartyUpdate:FireClient(removedPlayer, {
			type = kickedBy and "kicked" or "left",
			partyId = partyId,
			kickedBy = kickedBy
		})
	end
	
	-- Notify remaining members
	for _, memberId in ipairs(party.members) do
		local member = Players:GetPlayerByUserId(memberId)
		if member then
			PartyUpdate:FireClient(member, {
				type = "member_left",
				partyId = partyId,
				member = userId,
				members = party.members
			})
		end
	end
	
	-- Disband if empty or only leader left
	if #party.members &lt;= 1 then
		disbandParty(partyId)
	end
end

-- Helper function to get nearby party members
local function getNearbyPartyMembers(player, range)
	local party = getPlayerParty(player)
	if not party then return {} end
	
	local playerPos = player.Character and player.Character:GetPivot().Position
	if not playerPos then return {} end
	
	local nearby = {}
	
	for _, memberId in ipairs(party.members) do
		if memberId ~= player.UserId then
			local member = Players:GetPlayerByUserId(memberId)
			if member and member.Character then
				local memberPos = member.Character:GetPivot().Position
				if (memberPos - playerPos).Magnitude &lt;= range then
					table.insert(nearby, member)
				end
			end
		end
	end
	
	return nearby
end

-- Calculate XP bonus for party
local function calculatePartyXPBonus(player, baseXP)
	local party = getPlayerParty(player)
	if not party then return baseXP end
	
	local nearbyMembers = getNearbyPartyMembers(player, SHARED_XP_RANGE)
	local bonusMultiplier = 1.0 + (#nearbyMembers * XP_BONUS_PER_MEMBER)
	
	return math.floor(baseXP * bonusMultiplier)
end

-- Handle party invites
PartyInvite.OnServerEvent:Connect(function(inviter, targetPlayer)
	if not inviter or not targetPlayer then return end
	
	-- Check if inviter is in a party
	local inviterParty = getPlayerParty(inviter)
	if not inviterParty then
		-- Create new party for inviter
		createParty(inviter)
		inviterParty = getPlayerParty(inviter)
	end
	
	-- Check if inviter is party leader
	if inviterParty.leader ~= inviter.UserId then
		PartyUpdate:FireClient(inviter, {
			type = "error",
			message = "Only party leader can invite players"
		})
		return
	end
	
	-- Check if target is already in a party
	if getPlayerParty(targetPlayer) then
		PartyUpdate:FireClient(inviter, {
			type = "error",
			message = targetPlayer.Name .. " is already in a party"
		})
		return
	end
	
	-- Check if party is full
	if #inviterParty.members >= MAX_PARTY_SIZE then
		PartyUpdate:FireClient(inviter, {
			type = "error",
			message = "Party is full"
		})
		return
	end
	
	-- Create invite
	partyInvites[inviter.UserId] = partyInvites[inviter.UserId] or {}
	partyInvites[inviter.UserId][targetPlayer.UserId] = os.time()
	
	-- Send invite to target
	PartyUpdate:FireClient(targetPlayer, {
		type = "invite",
		partyId = playerToParty[inviter.UserId],
		inviter = inviter.UserId,
		inviterName = inviter.Name
	})
	
	-- Notify inviter
	PartyUpdate:FireClient(inviter, {
		type = "invite_sent",
		target = targetPlayer.UserId,
		targetName = targetPlayer.Name
	})
end)

-- Handle party accept
PartyAccept.OnServerEvent:Connect(function(player, partyId, inviterId)
	if not player then return end
	
	-- Check if invite exists and is recent (within 60 seconds)
	local inviteTime = partyInvites[inviterId] and partyInvites[inviterId][player.UserId]
	if not inviteTime or os.time() - inviteTime > 60 then
		PartyUpdate:FireClient(player, {
			type = "error",
			message = "Invite expired"
		})
		return
	end
	
	-- Check if player is already in a party
	if getPlayerParty(player) then
		PartyUpdate:FireClient(player, {
			type = "error",
			message = "You are already in a party"
		})
		return
	end
	
	-- Add to party
	local success, message = addMemberToParty(partyId, player)
	if not success then
		PartyUpdate:FireClient(player, {
			type = "error",
			message = message
		})
		return
	end
	
	-- Clean up invite
	if partyInvites[inviterId] then
		partyInvites[inviterId][player.UserId] = nil
	end
end)

-- Handle party leave
PartyLeave.OnServerEvent:Connect(function(player)
	if not player then return end
	
	local party = getPlayerParty(player)
	if not party then
		PartyUpdate:FireClient(player, {
			type = "error",
			message = "You are not in a party"
		})
		return
	end
	
	removeMemberFromParty(playerToParty[player.UserId], player.UserId)
end)

-- Handle party kick
PartyKick.OnServerEvent:Connect(function(kicker, targetUserId)
	if not kicker then return end
	
	local party = getPlayerParty(kicker)
	if not party or party.leader ~= kicker.UserId then
		PartyUpdate:FireClient(kicker, {
			type = "error",
			message = "Only party leader can kick members"
		})
		return
	end
	
	-- Can't kick yourself
	if targetUserId == kicker.UserId then return end
	
	removeMemberFromParty(playerToParty[kicker.UserId], targetUserId, kicker.UserId)
end)

-- Handle party chat
PartyChat.OnServerEvent:Connect(function(player, message)
	if not player or not message or message == "" then return end
	
	local party = getPlayerParty(player)
	if not party then return end
	
	-- Broadcast to all party members
	for _, memberId in ipairs(party.members) do
		local member = Players:GetPlayerByUserId(memberId)
		if member then
			PartyUpdate:FireClient(member, {
				type = "chat",
				sender = player.UserId,
				senderName = player.Name,
				message = message
			})
		end
	end
end)

-- Clean up on player leave
Players.PlayerRemoving:Connect(function(player)
	local party = getPlayerParty(player)
	if party then
		removeMemberFromParty(playerToParty[player.UserId], player.UserId)
	end
	
	-- Clean up invites
	for inviterId, invites in pairs(partyInvites) do
		invites[player.UserId] = nil
	end
end)

-- Function to award XP with party bonus (to be called by other systems)
local function awardPartyXP(player, skill, baseXP)
	local party = getPlayerParty(player)
	if not party then return baseXP end
	
	local finalXP = calculatePartyXPBonus(player, baseXP)
	
	-- Award XP to player
	DataManager.AddSkillXP(player, skill, finalXP)
	
	-- Share XP with nearby party members
	local nearbyMembers = getNearbyPartyMembers(player, SHARED_XP_RANGE)
	for _, member in ipairs(nearbyMembers) do
		DataManager.AddSkillXP(member, skill, baseXP) -- Base XP only, not bonus
	end
	
	return finalXP
end

-- Functions are local to this script - no need to export since this is a server script

print("[PartyManager] Ready!")</string>
      </Properties>
    </Item>
    <Item class="Script" referent="150">
      <Properties>
        <string name="Name">PrayerManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	PrayerManager.server.lua
	COMPLETE OVERHAUL: 30 prayers in 4 tiers with branching skill tree
	Prayer effects modify combat stats and provide special abilities
]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

print("[PrayerManager] Starting with new 30-prayer system...")

local Config = require(ReplicatedStorage.Modules.Config)
local DataManager = require(ReplicatedStorage.Modules.DataManager)

-- Remotes
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 5)
local toggleEvent = Remotes:WaitForChild("TogglePrayer", 10)
local updateEvent = Remotes:WaitForChild("PrayerUpdate", 10)
local getDataFunc = Remotes:WaitForChild("GetPrayerData", 10)
local buryBonesEvent = Remotes:WaitForChild("BuryBones", 10)

-- Prayer definitions - 30 prayers in 4 tiers with 3 branches
local PRAYERS = {
	-- TIER 1 â€” NOVICE (Level 1-15) - Foundation prayers
	{id = 1,  name = "Thick Skin",           level = 1,  ppRate = 1, tier = 1, branch = "protector", effects = {defenseBonus = 0.05}, description = "+5% Defense"},
	{id = 2,  name = "Burst of Strength",    level = 1,  ppRate = 1, tier = 1, branch = "warrior",   effects = {strengthBonus = 0.05}, description = "+5% Strength"},
	{id = 3,  name = "Sharp Eye",            level = 1,  ppRate = 1, tier = 1, branch = "ranger",    effects = {rangedAccuracy = 0.05}, description = "+5% Ranged accuracy"},
	{id = 4,  name = "Rock Skin",            level = 5,  ppRate = 2, tier = 1, branch = "protector", effects = {defenseBonus = 0.10}, description = "+10% Defense", prereq = {1}},
	{id = 5,  name = "Clarity of Thought",   level = 8,  ppRate = 2, tier = 1, branch = "warrior",   effects = {allAccuracy = 0.10}, description = "+10% accuracy all styles", prereq = {2}},
	{id = 6,  name = "Mystic Will",          level = 12, ppRate = 2, tier = 1, branch = "ranger",    effects = {allStats = 0.05}, description = "+5% all combat stats", prereq = {3}},

	-- TIER 2 â€” ACOLYTE (Level 16-35) - Intermediate prayers
	{id = 7,  name = "Superhuman Strength",  level = 16, ppRate = 3, tier = 2, branch = "warrior",   effects = {strengthBonus = 0.15}, description = "+15% Strength", prereq = {2}},
	{id = 8,  name = "Improved Reflexes",    level = 18, ppRate = 3, tier = 2, branch = "protector", effects = {defenseBonus = 0.15}, description = "+15% Defense", prereq = {4}},
	{id = 9,  name = "Hawk Eye",             level = 20, ppRate = 3, tier = 2, branch = "ranger",    effects = {rangedBonus = 0.15}, description = "+15% Ranged", prereq = {3}},
	{id = 10, name = "Steel Skin",           level = 22, ppRate = 4, tier = 2, branch = "protector", effects = {defenseBonus = 0.20}, description = "+20% Defense", prereq = {8}},
	{id = 11, name = "Ultimate Strength",    level = 25, ppRate = 4, tier = 2, branch = "warrior",   effects = {strengthBonus = 0.20}, description = "+20% Strength", prereq = {7}},
	{id = 12, name = "Eagle Eye",            level = 28, ppRate = 4, tier = 2, branch = "ranger",    effects = {rangedBonus = 0.20}, description = "+20% Ranged", prereq = {9}},
	{id = 13, name = "Rapid Heal",           level = 30, ppRate = 3, tier = 2, branch = "protector", effects = {hpRegenBoost = 2.0}, description = "2x HP regeneration", prereq = {8}},
	{id = 14, name = "Rapid Restore",        level = 35, ppRate = 2, tier = 2, branch = "protector", effects = {ppRegenBoost = 2.0}, description = "2x PP regeneration", prereq = {13}},

	-- TIER 3 â€” PRIEST (Level 36-60) - Advanced prayers with special effects
	{id = 15, name = "Protect from Melee",   level = 36, ppRate = 6, tier = 3, branch = "protector", effects = {meleeProt = 0.50}, description = "Block 50% melee damage", prereq = {10}},
	{id = 16, name = "Protect from Ranged",  level = 38, ppRate = 6, tier = 3, branch = "protector", effects = {rangedProt = 0.50}, description = "Block 50% ranged damage", prereq = {10}},
	{id = 17, name = "Protect from Magic",   level = 40, ppRate = 6, tier = 3, branch = "protector", effects = {magicProt = 0.50}, description = "Block 50% magic damage", prereq = {10}},
	{id = 18, name = "Retribution",          level = 42, ppRate = 3, tier = 3, branch = "warrior",   effects = {retribution = true}, description = "On death, deal 25% max HP as AoE damage", prereq = {11}},
	{id = 19, name = "Redemption",           level = 45, ppRate = 4, tier = 3, branch = "protector", effects = {redemption = true}, description = "Auto-heal 25% HP when below 10%", prereq = {15}},
	{id = 20, name = "Smite",                level = 48, ppRate = 5, tier = 3, branch = "warrior",   effects = {smite = true}, description = "Drain enemy prayer on hit", prereq = {18}},
	{id = 21, name = "Holy Strength",        level = 52, ppRate = 7, tier = 3, branch = "warrior",   effects = {strengthBonus = 0.25, defenseBonus = 0.10}, description = "+25% Strength, +10% Defense", prereq = {11}},
	{id = 22, name = "Divine Aim",           level = 55, ppRate = 7, tier = 3, branch = "ranger",    effects = {rangedBonus = 0.25, allAccuracy = 0.10}, description = "+25% Ranged, +10% accuracy", prereq = {12}},

	-- TIER 4 â€” HIGH PRIEST (Level 61-99) - Master tier prayers
	{id = 23, name = "Chivalry",             level = 61, ppRate = 8,  tier = 4, branch = "warrior",   effects = {strengthBonus = 0.20, defenseBonus = 0.20, allAccuracy = 0.15}, description = "+20% Strength, +20% Defense, +15% accuracy", prereq = {21}},
	{id = 24, name = "Piety",                level = 70, ppRate = 10, tier = 4, branch = "warrior",   effects = {strengthBonus = 0.25, defenseBonus = 0.25, allAccuracy = 0.20}, description = "+25% Strength, +25% Defense, +20% accuracy", prereq = {23}},
	{id = 25, name = "Rigour",               level = 74, ppRate = 10, tier = 4, branch = "ranger",    effects = {rangedBonus = 0.25, defenseBonus = 0.25}, description = "+25% Ranged, +25% Defense", prereq = {22}},
	{id = 26, name = "Augury",               level = 78, ppRate = 12, tier = 4, branch = "ranger",    effects = {allStats = 0.25, allAccuracy = 0.15}, description = "+25% all stats, +15% accuracy", prereq = {25}},
	{id = 27, name = "Soul Split",           level = 82, ppRate = 12, tier = 4, branch = "protector", effects = {soulSplit = true}, description = "Heal 10% of damage dealt", prereq = {19}},
	{id = 28, name = "Turmoil",              level = 86, ppRate = 15, tier = 4, branch = "warrior",   effects = {strengthBonus = 0.30, defenseBonus = 0.30, turmoil = true}, description = "+30% Strength, +30% Defense, drain enemy stats", prereq = {24}},
	{id = 29, name = "Wrath",                level = 90, ppRate = 5,  tier = 4, branch = "warrior",   effects = {wrath = true}, description = "On death, massive AoE explosion", prereq = {28}},
	{id = 30, name = "Divine Shield",        level = 95, ppRate = 20, tier = 4, branch = "protector", effects = {divineShield = true}, description = "Reduce ALL damage by 40% for 30 seconds, then 5 min cooldown", prereq = {27}},
}

-- Create lookup tables
local prayerById = {}
local prayerByName = {}
for _, p in ipairs(PRAYERS) do
	prayerById[p.id] = p
	prayerByName[p.name] = p
end

-- Per-player state
local playerPrayers = {} -- [player] = {active = {id1=true, id2=true}, pp = 100, lastTick = tick()}
local playerCooldowns = {} -- [player] = {divineShield = endTime}

-- Prayer point system - Max PP = 10 + Prayer Level
local function getMaxPrayerPoints(player)
	local data = DataManager:GetData(player)
	if not data then return 10 end
	local prayerLevel = Config.GetLevelFromXP(data.Skills.Prayer or 0)
	return 10 + prayerLevel
end

-- Get current prayer level
local function getPrayerLevel(player)
	local data = DataManager:GetData(player)
	if not data then return 1 end
	return Config.GetLevelFromXP(data.Skills.Prayer or 0)
end

-- Check if player meets prayer prerequisites
local function canUsePrayer(player, prayerId)
	local prayer = prayerById[prayerId]
	if not prayer then return false end
	
	-- Level requirement
	local playerLevel = getPrayerLevel(player)
	if playerLevel < prayer.level then return false end
	
	-- Prerequisites
	if prayer.prereq then
		local playerState = playerPrayers[player]
		if not playerState then return false end
		
		for _, reqId in ipairs(prayer.prereq) do
			-- Check if player has access to prerequisite (either active or previously unlocked)
			local reqPrayer = prayerById[reqId]
			if reqPrayer and playerLevel < reqPrayer.level then
				return false
			end
		end
	end
	
	return true
end

-- Calculate total PP drain rate
local function getTotalPPDrain(player)
	local playerState = playerPrayers[player]
	if not playerState or not playerState.active then return 0 end
	
	local totalDrain = 0
	for prayerId, active in pairs(playerState.active) do
		if active then
			local prayer = prayerById[prayerId]
			if prayer then
				totalDrain = totalDrain + prayer.ppRate
			end
		end
	end
	
	-- Rapid Restore doubles PP regen, which effectively halves drain
	if playerState.active[14] then -- Rapid Restore
		totalDrain = totalDrain * 0.5
	end
	
	return totalDrain
end

-- Apply prayer effects to player
local function applyPrayerEffects(player)
	local playerState = playerPrayers[player]
	if not playerState or not playerState.active then return end
	
	-- This would integrate with CombatManager to actually modify stats
	-- For now, we'll just store the effects for other systems to query
	local totalEffects = {
		strengthBonus = 0, defenseBonus = 0, rangedBonus = 0,
		allAccuracy = 0, allStats = 0, hpRegenBoost = 1, ppRegenBoost = 1,
		meleeProt = 0, rangedProt = 0, magicProt = 0,
		retribution = false, redemption = false, smite = false,
		soulSplit = false, turmoil = false, wrath = false, divineShield = false
	}
	
	-- Combine effects from all active prayers
	for prayerId, active in pairs(playerState.active) do
		if active then
			local prayer = prayerById[prayerId]
			if prayer then
				for effect, value in pairs(prayer.effects) do
					if type(value) == "number" then
						-- Additive for number effects
						if totalEffects[effect] then
							totalEffects[effect] = totalEffects[effect] + value
						end
					else
						-- Boolean effects
						totalEffects[effect] = value
					end
				end
			end
		end
	end
	
	playerState.effects = totalEffects
end

-- Initialize player prayer state
local function initializePlayer(player)
	playerPrayers[player] = {
		active = {},
		pp = getMaxPrayerPoints(player),
		lastTick = tick(),
		effects = {}
	}
	playerCooldowns[player] = {}
end

-- Handle prayer toggle
toggleEvent.OnServerEvent:Connect(function(player, prayerId)
	if not playerPrayers[player] then
		initializePlayer(player)
	end
	
	local playerState = playerPrayers[player]
	local prayer = prayerById[prayerId]
	
	if not prayer then
		warn("[PrayerManager] Unknown prayer ID:", prayerId)
		return
	end
	
	-- Check if player can use this prayer
	if not canUsePrayer(player, prayerId) then
		print("[PrayerManager] Player cannot use prayer:", prayer.name)
		return
	end
	
	-- Check Divine Shield cooldown
	if prayer.effects.divineShield and playerCooldowns[player].divineShield and 
	   playerCooldowns[player].divineShield > tick() then
		print("[PrayerManager] Divine Shield on cooldown")
		return
	end
	
	-- Toggle the prayer
	local wasActive = playerState.active[prayerId] or false
	playerState.active[prayerId] = not wasActive
	
	print("[PrayerManager] " .. player.Name .. " " .. (wasActive and "disabled" or "enabled") .. " " .. prayer.name)
	
	-- Handle special activation effects
	if not wasActive then -- Just activated
		if prayer.effects.divineShield then
			-- Start Divine Shield duration and cooldown
			task.delay(30, function() -- 30 second duration
				if playerState.active[prayerId] then
					playerState.active[prayerId] = false
					playerCooldowns[player].divineShield = tick() + 300 -- 5 minute cooldown
					applyPrayerEffects(player)
					updateEvent:FireClient(player)
				end
			end)
		end
	end
	
	-- Apply new effects
	applyPrayerEffects(player)
	
	-- Notify client
	updateEvent:FireClient(player)
end)

-- Get prayer data for client
getDataFunc.OnServerInvoke = function(player)
	if not playerPrayers[player] then
		initializePlayer(player)
	end
	
	local playerState = playerPrayers[player]
	local playerLevel = getPrayerLevel(player)
	local maxPP = getMaxPrayerPoints(player)
	local totalDrain = getTotalPPDrain(player)
	
	-- Build prayer availability
	local availablePrayers = {}
	for _, prayer in ipairs(PRAYERS) do
		availablePrayers[prayer.id] = {
			id = prayer.id,
			name = prayer.name,
			level = prayer.level,
			ppRate = prayer.ppRate,
			tier = prayer.tier,
			branch = prayer.branch,
			description = prayer.description,
			prereq = prayer.prereq,
			canUse = canUsePrayer(player, prayer.id),
			active = playerState.active[prayer.id] or false
		}
	end
	
	return {
		prayers = availablePrayers,
		currentPP = math.floor(playerState.pp),
		maxPP = maxPP,
		ppDrainRate = totalDrain,
		playerLevel = playerLevel,
		effects = playerState.effects,
		cooldowns = playerCooldowns[player]
	}
end

-- Handle bone burying for Prayer XP
buryBonesEvent.OnServerEvent:Connect(function(player, boneName)
	local boneXP = {
		["Bones"] = 10,
		["Big Bones"] = 30,
		["Dragon Bones"] = 100
	}
	
	local xp = boneXP[boneName] or 10
	
	-- Check if player has the bones
	local removed = DataManager.RemoveItem(player, boneName, 1)
	if removed then
		-- Give Prayer XP
		DataManager.AddSkillXP(player, "Prayer", xp)
		print("[PrayerManager] " .. player.Name .. " buried " .. boneName .. " for " .. xp .. " Prayer XP")
		
		-- Update max PP if leveled up
		if playerPrayers[player] then
			playerPrayers[player].pp = math.min(playerPrayers[player].pp, getMaxPrayerPoints(player))
		end
	end
end)

-- Prayer point regeneration and drain system
local lastUpdateTime = tick()
RunService.Heartbeat:Connect(function()
	local currentTime = tick()
	local deltaTime = currentTime - lastUpdateTime
	lastUpdateTime = currentTime
	
	-- Update every 6 seconds (10 times per minute)
	if deltaTime < 6 then return end
	
	for player, playerState in pairs(playerPrayers) do
		if not player.Parent then
			-- Clean up disconnected players
			playerPrayers[player] = nil
			playerCooldowns[player] = nil
			continue
		end
		
		local totalDrain = getTotalPPDrain(player)
		local maxPP = getMaxPrayerPoints(player)
		
		if totalDrain > 0 then
			-- Drain PP (rate is per minute, so divide by 10 for 6-second intervals)
			playerState.pp = playerState.pp - (totalDrain / 10)
			
			-- Disable prayers if out of PP
			if playerState.pp <= 0 then
				playerState.pp = 0
				playerState.active = {}
				applyPrayerEffects(player)
				updateEvent:FireClient(player)
				print("[PrayerManager] " .. player.Name .. " ran out of Prayer Points")
			end
		else
			-- Regenerate PP when no prayers active (1 PP per 10 seconds base)
			local regenRate = 0.6 -- 0.6 PP per 6 seconds = 6 PP per minute
			if playerState.active[14] then -- Rapid Restore
				regenRate = regenRate * 2
			end
			
			playerState.pp = math.min(playerState.pp + regenRate, maxPP)
		end
	end
end)

-- Player initialization
local function onPlayerAdded(player)
	player.CharacterAdded:Connect(function()
		task.wait(2) -- Wait for character to fully load
		initializePlayer(player)
	end)
end

-- Existing players
for _, player in ipairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end

-- New players
Players.PlayerAdded:Connect(onPlayerAdded)

-- Cleanup on player leaving
Players.PlayerRemoving:Connect(function(player)
	playerPrayers[player] = nil
	playerCooldowns[player] = nil
end)

print("[PrayerManager] New 30-prayer system ready!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="151">
      <Properties>
        <string name="Name">PrestigeManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- PrestigeManager.server.lua
-- Handles prestige resets when all skills reach 99

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Modules = ReplicatedStorage:WaitForChild("Modules", 5)
local Config = require(Modules:WaitForChild("Config", 5))
local DataManager = require(Modules:WaitForChild("DataManager", 5))
local ItemDatabase = require(Modules:WaitForChild("ItemDatabase", 5))
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 5)

local PrestigeRemote = Remotes:WaitForChild("Prestige", 5)
local PrestigeInfo = Remotes:WaitForChild("GetPrestigeInfo", 5)

-- All skills that must be 99
local ALL_SKILLS = {"Mining", "Woodcutting", "Fishing", "Smithing", "Cooking", "Strength", "Defense", "Ranged", "Fletching", "Prayer"}

-- Cape names by prestige level
local PRESTIGE_CAPES = {
    "Prestige Cape I", "Prestige Cape II", "Prestige Cape III",
    "Prestige Cape IV", "Prestige Cape V", "Prestige Cape VI",
    "Prestige Cape VII", "Prestige Cape VIII", "Prestige Cape IX",
    "Prestige Cape X",
}

local function canPrestige(data)
    for _, skill in ipairs(ALL_SKILLS) do
        local xp = data.Skills[skill] or 0
        local level = Config.GetLevelFromXP(xp)
        if level < 99 then
            return false
        end
    end
    return true
end

local function doPrestige(player)
    local data = DataManager:GetData(player)
    if not data then return false, "No data" end
    if not canPrestige(data) then return false, "Not all skills are 99" end
    
    local currentPrestige = data.Prestige or 0
    if currentPrestige >= 10 then return false, "Max prestige reached" end
    
    local newPrestige = currentPrestige + 1
    
    -- Reset all skills to 0
    for _, skill in ipairs(ALL_SKILLS) do
        data.Skills[skill] = 0
    end
    
    -- Set new prestige level
    data.Prestige = newPrestige
    
    -- Remove old prestige cape if equipped
    if data.Equipment.Cape and data.Equipment.Cape ~= "" then
        -- Unequip old cape
        data.Equipment.Cape = ""
    end
    
    -- Remove any old prestige capes from inventory
    local newInventory = {}
    for _, item in ipairs(data.Inventory) do
        local isPrestigeCape = false
        for _, capeName in ipairs(PRESTIGE_CAPES) do
            if item.name == capeName then
                isPrestigeCape = true
                break
            end
        end
        if not isPrestigeCape then
            table.insert(newInventory, item)
        end
    end
    data.Inventory = newInventory
    
    -- Grant new prestige cape
    local capeName = PRESTIGE_CAPES[newPrestige]
    if capeName then
        table.insert(data.Inventory, {name = capeName, quantity = 1})
        -- Auto-equip the new cape
        data.Equipment.Cape = capeName
    end
    
    -- Fire updates to client
    Remotes.InventoryUpdate:FireClient(player, data.Inventory)
    Remotes.XPUpdate:FireClient(player, data.Skills)
    
    print("[PrestigeManager] " .. player.Name .. " prestiged to level " .. newPrestige .. "!")
    return true, newPrestige
end

-- Handle prestige request from client
PrestigeRemote.OnServerEvent:Connect(function(player)
    local success, result = doPrestige(player)
    if success then
        -- Announce to all players
        for _, p in ipairs(Players:GetPlayers()) do
            Remotes.LevelUp:FireClient(p, player.Name .. " has reached Prestige " .. tostring(result) .. "!")
        end
    end
end)

-- Handle prestige info request
PrestigeInfo.OnServerInvoke = function(player)
    local data = DataManager:GetData(player)
    if not data then return {prestige = 0, canPrestige = false, skills = {}} end
    
    local skillLevels = {}
    for _, skill in ipairs(ALL_SKILLS) do
        local xp = data.Skills[skill] or 0
        skillLevels[skill] = Config.GetLevelFromXP(xp)
    end
    
    return {
        prestige = data.Prestige or 0,
        canPrestige = canPrestige(data),
        skills = skillLevels,
        maxPrestige = 10,
    }
end

print("[PrestigeManager] Loaded â€” 10 prestige levels, cape rewards")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="152">
      <Properties>
        <string name="Name">PvPManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- PvPManager.server.lua
-- Handles all PvP-related functionality including wilderness detection, combat, skulling, and death

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

-- Wait for remotes
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
local PvPAttackRemote = Remotes:WaitForChild("PvPAttack", 5)
local PvPDeathRemote = Remotes:WaitForChild("PvPDeath", 5)
local SkullUpdateRemote = Remotes:WaitForChild("SkullUpdate", 5)
local WildernessWarningRemote = Remotes:WaitForChild("WildernessWarning", 5)
local ZoneChangedRemote = Remotes:WaitForChild("ZoneChanged", 5)
local DamageDealtRemote = Remotes:WaitForChild("DamageDealt", 5)
local InventoryUpdateRemote = Remotes:WaitForChild("InventoryUpdate", 5)
local EquipmentUpdateRemote = Remotes:WaitForChild("EquipmentUpdate", 5)

-- Get DataManager
local DataManager = require(ReplicatedStorage.Modules:WaitForChild("DataManager", 5))

-- PvP System Variables
local SAFE_ZONE_BOUNDARY = -100  -- z > -100 is safe zone
local SKULL_DURATION = 300  -- 5 minutes in seconds
local HAVEN_RESPAWN_POSITION = Vector3.new(0, 3, 50)

-- Player tracking
local playersInWilderness = {}
local skulledPlayers = {}
local combatTimers = {}
local recentAttackers = {}  -- Track who attacked who recently for self-defense

-- Utility Functions
local function isInWilderness(position)
    return position.Z < SAFE_ZONE_BOUNDARY
end

local function getWildernessLevel(position)
    if not isInWilderness(position) then return 0 end
    return math.floor(math.abs(position.Z + 100) / 20) + 1
end

local function getCombatLevel(playerData)
    if not playerData or not playerData.Skills then
        return 3  -- Default level
    end
    
    local attack = playerData.Skills.Attack or 1
    local strength = playerData.Skills.Strength or 1
    local defence = playerData.Skills.Defence or 1
    local hitpoints = playerData.Skills.Hitpoints or 10
    local ranged = playerData.Skills.Ranged or 1
    local magic = playerData.Skills.Magic or 1
    local prayer = playerData.Skills.Prayer or 1
    
    local combatLevel = (defence + hitpoints + math.floor(prayer / 2)) * 0.25 +
                       math.max(attack + strength, math.max(ranged * 1.5, magic * 1.5)) * 0.325
    
    return math.floor(combatLevel)
end

local function getEquipmentBonus(equipment, bonusType)
    local total = 0
    
    -- Equipment stat bonuses (simplified - you can expand this)
    local equipmentStats = {
        -- Weapons
        ["Bronze Sword"] = {attack = 5, accuracy = 0},
        ["Iron Sword"] = {attack = 10, accuracy = 5},
        ["Steel Sword"] = {attack = 15, accuracy = 10},
        ["Mithril Sword"] = {attack = 20, accuracy = 15},
        ["Adamant Sword"] = {attack = 25, accuracy = 20},
        ["Rune Sword"] = {attack = 35, accuracy = 30},
        
        -- Armor
        ["Bronze Helmet"] = {defence = 2},
        ["Iron Helmet"] = {defence = 5},
        ["Steel Helmet"] = {defence = 8},
        ["Bronze Platebody"] = {defence = 8},
        ["Iron Platebody"] = {defence = 15},
        ["Steel Platebody"] = {defence = 25},
        ["Bronze Platelegs"] = {defence = 6},
        ["Iron Platelegs"] = {defence = 12},
        ["Steel Platelegs"] = {defence = 20},
    }
    
    for slot, item in pairs(equipment) do
        if item and equipmentStats[item] then
            total = total + (equipmentStats[item][bonusType] or 0)
        end
    end
    
    return total
end

local function calculateDamage(attacker, defender, attackerData, defenderData)
    -- Get combat levels
    local attackerCombat = getCombatLevel(attackerData)
    local defenderCombat = getCombatLevel(defenderData)
    
    -- Get equipment bonuses
    local attackBonus = getEquipmentBonus(attackerData.Equipment or {}, "attack")
    local accuracyBonus = getEquipmentBonus(attackerData.Equipment or {}, "accuracy")
    local defenceBonus = getEquipmentBonus(defenderData.Equipment or {}, "defence")
    
    -- Calculate max damage based on weapon and strength
    local strengthLevel = attackerData.Skills.Strength or 1
    local maxDamage = math.floor((strengthLevel + attackBonus) * 0.5) + math.random(1, 5)
    
    -- Accuracy check (simplified)
    local accuracy = (attackerCombat + accuracyBonus) / (defenderCombat + defenceBonus + 1)
    local hitChance = math.min(0.95, math.max(0.05, accuracy * 0.8))
    
    if math.random() > hitChance then
        return 0  -- Miss
    end
    
    -- Apply defense reduction
    local damage = maxDamage - math.floor(defenceBonus * 0.3)
    return math.max(1, damage)  -- Minimum 1 damage on hit
end

local function createSkullIcon(player)
    local character = player.Character
    if not character or not character:FindFirstChild("Head") then return end
    
    local head = character.Head
    
    -- Remove existing skull icon
    local existingSkull = head:FindFirstChild("SkullIcon")
    if existingSkull then
        existingSkull:Destroy()
    end
    
    -- Create new skull icon
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "SkullIcon"
    billboardGui.Size = UDim2.new(0, 50, 0, 50)
    billboardGui.StudsOffset = Vector3.new(0, 3, 0)
    billboardGui.Parent = head
    
    local skullLabel = Instance.new("TextLabel")
    skullLabel.Size = UDim2.new(1, 0, 1, 0)
    skullLabel.BackgroundTransparency = 1
    skullLabel.Text = "â˜ ï¸"
    skullLabel.TextScaled = true
    skullLabel.Font = Enum.Font.SourceSansBold
    skullLabel.TextColor3 = Color3.new(1, 0, 0)
    skullLabel.Parent = billboardGui
end

local function removeSkullIcon(player)
    local character = player.Character
    if not character or not character:FindFirstChild("Head") then return end
    
    local head = character.Head
    local skullIcon = head:FindFirstChild("SkullIcon")
    if skullIcon then
        skullIcon:Destroy()
    end
end

local function createCombatLevelDisplay(player)
    local character = player.Character
    if not character or not character:FindFirstChild("Head") then return end
    
    local head = character.Head
    
    -- Remove existing display
    local existingDisplay = head:FindFirstChild("CombatLevelDisplay")
    if existingDisplay then
        existingDisplay:Destroy()
    end
    
    local playerData = DataManager:GetData(player)
    local combatLevel = getCombatLevel(playerData)
    local isWilderness = playersInWilderness[player.UserId]
    
    -- Create combat level display
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "CombatLevelDisplay"
    billboardGui.Size = UDim2.new(0, 100, 0, 30)
    billboardGui.StudsOffset = Vector3.new(0, 2, 0)
    billboardGui.Parent = head
    
    local levelLabel = Instance.new("TextLabel")
    levelLabel.Size = UDim2.new(1, 0, 1, 0)
    levelLabel.BackgroundTransparency = 1
    levelLabel.Text = "Combat: " .. combatLevel
    levelLabel.TextScaled = true
    levelLabel.Font = Enum.Font.SourceSans
    levelLabel.TextColor3 = isWilderness and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
    levelLabel.TextStrokeTransparency = 0
    levelLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    levelLabel.Parent = billboardGui
end

local function updateCombatLevelColor(player)
    local character = player.Character
    if not character or not character:FindFirstChild("Head") then return end
    
    local head = character.Head
    local display = head:FindFirstChild("CombatLevelDisplay")
    if not display then return end
    
    local levelLabel = display:FindFirstChild("TextLabel")
    if not levelLabel then return end
    
    local isWilderness = playersInWilderness[player.UserId]
    levelLabel.TextColor3 = isWilderness and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
end

local function addSkull(player, duration)
    duration = duration or SKULL_DURATION
    
    skulledPlayers[player.UserId] = {
        player = player,
        endTime = tick() + duration,
        wildernessTimeOnly = true
    }
    
    createSkullIcon(player)
    SkullUpdateRemote:FireClient(player, true, duration)
    
    -- Notify all players
    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer ~= player then
            SkullUpdateRemote:FireClient(otherPlayer, true, duration, player)
        end
    end
end

local function removeSkull(player)
    if skulledPlayers[player.UserId] then
        skulledPlayers[player.UserId] = nil
        removeSkullIcon(player)
        SkullUpdateRemote:FireClient(player, false)
        
        -- Notify all players
        for _, otherPlayer in pairs(Players:GetPlayers()) do
            if otherPlayer ~= player then
                SkullUpdateRemote:FireClient(otherPlayer, false, 0, player)
            end
        end
    end
end

local function isRecentlyAttacked(attacker, defender)
    local key = defender.UserId .. ":" .. attacker.UserId
    local attackTime = recentAttackers[key]
    return attackTime and (tick() - attackTime) < 60  -- 1 minute window for self-defense
end

local function recordAttack(attacker, defender)
    local key = attacker.UserId .. ":" .. defender.UserId
    recentAttackers[key] = tick()
end

local function getItemValue(itemName, quantity)
    -- Simple item value system - you can expand this
    local itemValues = {
        ["Coins"] = 1,
        ["Rune Sword"] = 5000,
        ["Adamant Sword"] = 2000,
        ["Mithril Sword"] = 1000,
        ["Steel Sword"] = 500,
        ["Iron Sword"] = 200,
        ["Bronze Sword"] = 50,
        ["Steel Platebody"] = 800,
        ["Iron Platebody"] = 300,
        ["Bronze Platebody"] = 100,
        -- Add more items as needed
    }
    
    return (itemValues[itemName] or 10) * (quantity or 1)
end

local function dropLoot(player, position, items, gold)
    -- Create loot bag/drops at position
    local lootFolder = workspace:FindFirstChild("LootDrops")
    if not lootFolder then
        lootFolder = Instance.new("Folder")
        lootFolder.Name = "LootDrops"
        lootFolder.Parent = workspace
    end
    
    -- Create individual item drops
    for _, item in pairs(items) do
        local dropPart = Instance.new("Part")
        dropPart.Name = "ItemDrop_" .. item.name
        dropPart.Size = Vector3.new(2, 0.5, 2)
        dropPart.Position = position + Vector3.new(math.random(-3, 3), 1, math.random(-3, 3))
        dropPart.Anchored = true
        dropPart.CanCollide = false
        dropPart.BrickColor = BrickColor.new("Bright yellow")
        dropPart.Parent = lootFolder
        
        -- Add pickup detector
        local clickDetector = Instance.new("ClickDetector")
        clickDetector.MaxActivationDistance = 10
        clickDetector.Parent = dropPart
        
        -- Store item data
        local stringValue = Instance.new("StringValue")
        stringValue.Name = "ItemData"
        stringValue.Value = item.name .. ":" .. item.quantity
        stringValue.Parent = dropPart
        
        -- Pickup function
        clickDetector.MouseClick:Connect(function(clickingPlayer)
            local playerData = DataManager:GetData(clickingPlayer)
            if playerData then
                DataManager.AddToInventory(playerData, item.name, item.quantity)
                InventoryUpdateRemote:FireClient(clickingPlayer, playerData.Inventory)
                dropPart:Destroy()
            end
        end)
        
        -- Auto-cleanup after 5 minutes
        task.delay(300, function()
            if dropPart and dropPart.Parent then
                dropPart:Destroy()
            end
        end)
    end
    
    -- Drop gold if any
    if gold > 0 then
        local goldDrop = Instance.new("Part")
        goldDrop.Name = "GoldDrop"
        goldDrop.Size = Vector3.new(1.5, 0.5, 1.5)
        goldDrop.Position = position + Vector3.new(0, 1, 0)
        goldDrop.Anchored = true
        goldDrop.CanCollide = false
        goldDrop.BrickColor = BrickColor.new("Bright yellow")
        goldDrop.Parent = lootFolder
        
        local clickDetector = Instance.new("ClickDetector")
        clickDetector.MaxActivationDistance = 10
        clickDetector.Parent = goldDrop
        
        local stringValue = Instance.new("StringValue")
        stringValue.Name = "GoldAmount"
        stringValue.Value = tostring(gold)
        stringValue.Parent = goldDrop
        
        clickDetector.MouseClick:Connect(function(clickingPlayer)
            local playerData = DataManager:GetData(clickingPlayer)
            if playerData then
                DataManager.AddGold(playerData, gold)
                goldDrop:Destroy()
            end
        end)
        
        task.delay(300, function()
            if goldDrop and goldDrop.Parent then
                goldDrop:Destroy()
            end
        end)
    end
end

local function handlePlayerDeath(deadPlayer, killer, position)
    local deadPlayerData = DataManager:GetData(deadPlayer)
    if not deadPlayerData then return end
    
    local isPlayerSkulled = skulledPlayers[deadPlayer.UserId] ~= nil
    local droppedItems = {}
    local keptItems = {}
    local goldDropped = math.floor(deadPlayerData.Gold * 0.5)  -- Drop 50% of gold
    
    if isPlayerSkulled then
        -- Skulled: Drop everything
        for _, item in pairs(deadPlayerData.Inventory) do
            table.insert(droppedItems, {name = item.name, quantity = item.quantity})
        end
        
        for slot, item in pairs(deadPlayerData.Equipment or {}) do
            if item and item ~= "" then
                table.insert(droppedItems, {name = item, quantity = 1})
                deadPlayerData.Equipment[slot] = ""
            end
        end
        
        deadPlayerData.Inventory = {}
    else
        -- Unskulled: Keep 3 most valuable items
        local allItems = {}
        
        -- Add inventory items
        for _, item in pairs(deadPlayerData.Inventory) do
            table.insert(allItems, {
                name = item.name,
                quantity = item.quantity,
                value = getItemValue(item.name, item.quantity),
                isEquipped = false
            })
        end
        
        -- Add equipped items
        for slot, item in pairs(deadPlayerData.Equipment or {}) do
            if item and item ~= "" then
                table.insert(allItems, {
                    name = item,
                    quantity = 1,
                    value = getItemValue(item, 1),
                    isEquipped = true,
                    slot = slot
                })
            end
        end
        
        -- Sort by value (highest first)
        table.sort(allItems, function(a, b) return a.value > b.value end)
        
        -- Keep top 3 most valuable
        for i, item in pairs(allItems) do
            if i <= 3 then
                table.insert(keptItems, item)
            else
                table.insert(droppedItems, {name = item.name, quantity = item.quantity})
                if item.isEquipped then
                    deadPlayerData.Equipment[item.slot] = ""
                end
            end
        end
        
        -- Update inventory with only kept items
        deadPlayerData.Inventory = {}
        for _, item in pairs(keptItems) do
            if not item.isEquipped then
                table.insert(deadPlayerData.Inventory, {name = item.name, quantity = item.quantity})
            end
        end
    end
    
    -- Remove gold
    DataManager.RemoveGold(deadPlayerData, goldDropped)
    
    -- Drop loot at death position
    dropLoot(deadPlayer, position, droppedItems, goldDropped)
    
    -- Remove skull if present
    removeSkull(deadPlayer)
    
    -- Send death notifications
    PvPDeathRemote:FireClient(deadPlayer, false, killer.Name, #droppedItems)
    PvPDeathRemote:FireClient(killer, true, deadPlayer.Name, #droppedItems)
    
    -- Notify nearby players
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= deadPlayer and player ~= killer then
            local character = player.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                local distance = (character.HumanoidRootPart.Position - position).Magnitude
                if distance < 100 then  -- Within 100 studs
                    PvPDeathRemote:FireClient(player, nil, killer.Name .. " has defeated " .. deadPlayer.Name)
                end
            end
        end
    end
    
    -- Respawn player in Haven
    task.wait(3)  -- Death screen delay
    if deadPlayer.Character and deadPlayer.Character:FindFirstChild("HumanoidRootPart") then
        deadPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(HAVEN_RESPAWN_POSITION)
    end
    
    -- Update client data
    InventoryUpdateRemote:FireClient(deadPlayer, deadPlayerData.Inventory)
    EquipmentUpdateRemote:FireClient(deadPlayer, deadPlayerData.Equipment)
end

-- Event Handlers
PvPAttackRemote.OnServerEvent:Connect(function(attacker, targetPlayer)
    -- Validate attack
    if not targetPlayer or targetPlayer == attacker then return end
    if not attacker.Character or not targetPlayer.Character then return end
    if not attacker.Character:FindFirstChild("HumanoidRootPart") then return end
    if not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    
    local attackerPos = attacker.Character.HumanoidRootPart.Position
    local targetPos = targetPlayer.Character.HumanoidRootPart.Position
    
    -- Must be in wilderness
    if not isInWilderness(attackerPos) or not isInWilderness(targetPos) then
        return
    end
    
    -- Check distance (within 10 studs)
    if (attackerPos - targetPos).Magnitude > 10 then return end
    
    -- Get player data
    local attackerData = DataManager:GetData(attacker)
    local targetData = DataManager:GetData(targetPlayer)
    if not attackerData or not targetData then return end
    
    -- Check if this is self-defense
    local isSelfDefense = isRecentlyAttacked(attacker, targetPlayer)
    
    -- Apply skull if not self-defense
    if not isSelfDefense and not skulledPlayers[attacker.UserId] then
        addSkull(attacker)
    end
    
    -- Record the attack
    recordAttack(attacker, targetPlayer)
    
    -- Calculate and apply damage
    local damage = calculateDamage(attacker, targetPlayer, attackerData, targetData)
    local targetHumanoid = targetPlayer.Character:FindFirstChild("Humanoid")
    
    if targetHumanoid and damage > 0 then
        targetHumanoid.Health = math.max(0, targetHumanoid.Health - damage)
        DamageDealtRemote:FireClient(targetPlayer, damage)
        
        -- Check if target died
        if targetHumanoid.Health <= 0 then
            handlePlayerDeath(targetPlayer, attacker, targetPos)
        end
    end
end)

-- Track players entering/leaving wilderness
local function checkWildernessStatus()
    for _, player in pairs(Players:GetPlayers()) do
        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            local position = character.HumanoidRootPart.Position
            local wasInWilderness = playersInWilderness[player.UserId]
            local nowInWilderness = isInWilderness(position)
            
            if wasInWilderness ~= nowInWilderness then
                playersInWilderness[player.UserId] = nowInWilderness
                
                if nowInWilderness then
                    WildernessWarningRemote:FireClient(player, true, getWildernessLevel(position))
                else
                    WildernessWarningRemote:FireClient(player, false)
                end
                
                ZoneChangedRemote:FireClient(player, nowInWilderness and "Wilderness" or "Safe Zone")
                updateCombatLevelColor(player)
            end
        end
    end
end

-- Update skull timers
local function updateSkullTimers()
    for userId, skullData in pairs(skulledPlayers) do
        local player = skullData.player
        local isInWild = playersInWilderness[userId]
        
        -- Only count down timer when in wilderness
        if isInWild then
            if tick() >= skullData.endTime then
                removeSkull(player)
            end
        end
    end
end

-- Player joined
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        task.wait(1)  -- Wait for character to load
        createCombatLevelDisplay(player)
    end)
end)

-- Player leaving cleanup
Players.PlayerRemoving:Connect(function(player)
    playersInWilderness[player.UserId] = nil
    skulledPlayers[player.UserId] = nil
    combatTimers[player.UserId] = nil
end)

-- Main update loop
RunService.Heartbeat:Connect(function()
    checkWildernessStatus()
    updateSkullTimers()
end)

print("PvPManager loaded successfully!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="153">
      <Properties>
        <string name="Name">QuestManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	QuestManager.server.lua
	Server-side quest system for the RuneScape-inspired MMO.
	Tracks player quest progress, listens for game events, awards rewards.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local DataManager = require(ReplicatedStorage.Modules.DataManager)
local QuestDatabase = require(ReplicatedStorage.Modules.QuestDatabase)

------------------------------------------------------------
-- Remote Events Setup
------------------------------------------------------------
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
local QuestAcceptEvent = Remotes:WaitForChild("QuestAccept", 10)
local QuestProgressEvent = Remotes:WaitForChild("QuestProgress", 10)
local QuestCompleteEvent = Remotes:WaitForChild("QuestComplete", 10)
local QuestListEvent = Remotes:WaitForChild("QuestList", 10)

-- Bindable events for other server scripts to fire into the quest system
local function getOrCreateBindable(name)
	local existing = ReplicatedStorage:FindFirstChild(name)
	if existing then return existing end
	local b = Instance.new("BindableEvent")
	b.Name = name
	b.Parent = ReplicatedStorage
	return b
end

local GatherEvent = getOrCreateBindable("QuestGatherEvent")
local CraftEvent = getOrCreateBindable("QuestCraftEvent")
local KillEvent = getOrCreateBindable("QuestKillEvent")
local ZoneEvent = getOrCreateBindable("QuestZoneEvent")
local TalkEvent = getOrCreateBindable("QuestTalkEvent")

------------------------------------------------------------
-- Helpers
------------------------------------------------------------

-- Initialise the Quests field on player data if missing
local function ensureQuestData(player)
	local data = DataManager:GetData(player)
	if not data then return end
	if not data.Quests then
		data.Quests = {
			active = {},    -- { [questId] = { objectives = { [index] = currentProgress } } }
			completed = {}, -- { [questId] = true }
		}
	end
	return data
end

-- Check if a player meets quest requirements
local function meetsRequirements(player, quest)
	local data = DataManager:GetData(player)
	if not data then return false end

	-- Level requirements
	for _, req in quest.requirements.level do
		local skills = data.Skills or {}
		local skillData = skills[req.skill] or {}
		local playerLevel = skillData.Level or 1
		if playerLevel < req.level then
			return false
		end
	end

	-- Prerequisite quests
	local questData = data.Quests or {}
	for _, requiredQuestId in quest.requirements.quests do
		if not (questData.completed and questData.completed[requiredQuestId]) then
			return false
		end
	end

	return true
end

-- Send current quest state to a player
local function sendQuestList(player)
	local data = ensureQuestData(player)
	if not data then return end

	-- Find the first active quest for the client's simple structure
	local activeQuestId = nil
	for questId in data.Quests.active do
		activeQuestId = questId
		break -- Take first one as primary active quest
	end

	-- Build progress data for all active quests
	local questProgressData = {}
	for questId, progress in data.Quests.active do
		questProgressData[questId] = {}
		for i, current in progress.objectives do
			questProgressData[questId][i] = {
				current = current,
				done = false -- Will be set below
			}
		end
		
		-- Check if objectives are complete
		local quest = QuestDatabase.ById[questId]
		if quest then
			for i, obj in quest.objectives do
				local current = progress.objectives[i] or 0
				if current >= (obj.amount or 1) then
					questProgressData[questId][i].done = true
				end
			end
		end
	end

	local payload = {
		activeQuest = activeQuestId,
		completedQuests = {},
		questProgress = questProgressData,
	}

	-- Completed quests as array
	for questId in data.Quests.completed do
		table.insert(payload.completedQuests, questId)
	end

	QuestProgressEvent:FireClient(player, payload)
end

------------------------------------------------------------
-- Quest Accept
------------------------------------------------------------
QuestAcceptEvent.OnServerEvent:Connect(function(player, questId)
	local data = ensureQuestData(player)
	if not data then return end

	-- Validate quest exists
	local quest = QuestDatabase.ById[questId]
	if not quest then return end

	-- Already active or completed?
	if data.Quests.active[questId] or data.Quests.completed[questId] then return end

	-- Check requirements
	if not meetsRequirements(player, quest) then return end

	-- Accept the quest
	local objectives = {}
	for i in quest.objectives do
		objectives[i] = 0
	end
	data.Quests.active[questId] = { objectives = objectives }

	print(`[QuestManager] {player.Name} accepted quest: {quest.name}`)
	sendQuestList(player)
end)

------------------------------------------------------------
-- Quest List Request (client asks for current state)
------------------------------------------------------------
QuestListEvent.OnServerEvent:Connect(function(player)
	sendQuestList(player)
end)

------------------------------------------------------------
-- Progress Tracking
------------------------------------------------------------

-- Try to complete a quest if all objectives are met
local function tryComplete(player, questId)
	local data = DataManager:GetData(player)
	if not data or not data.Quests then return end

	local progress = data.Quests.active[questId]
	if not progress then return end

	local quest = QuestDatabase.ById[questId]
	if not quest then return end

	-- Check all objectives
	for i, obj in quest.objectives do
		if (progress.objectives[i] or 0) < obj.amount then
			return -- not done yet
		end
	end

	-- Complete! Remove from active, add to completed
	data.Quests.active[questId] = nil
	data.Quests.completed[questId] = true

	-- Award gold
	data.Gold = (data.Gold or 0) + quest.rewards.gold

	-- Award XP
	for _, xpReward in quest.rewards.xp do
		local skills = data.Skills or {}
		if not skills[xpReward.skill] then
			skills[xpReward.skill] = { Level = 1, XP = 0 }
		end
		skills[xpReward.skill].XP += xpReward.amount
		data.Skills = skills
	end

	-- Award items
	local inventory = data.Inventory or {}
	for _, itemName in quest.rewards.items do
		table.insert(inventory, { name = itemName, amount = 1 })
	end
	data.Inventory = inventory

	print(`[QuestManager] {player.Name} completed quest: {quest.name}`)
	QuestCompleteEvent:FireClient(player, questId, quest.rewards)
	sendQuestList(player)
end

-- Update progress for a specific objective type and target
local function updateProgress(player, objectiveType, target, amount)
	local data = DataManager:GetData(player)
	if not data or not data.Quests then return end

	local changed = false

	for questId, progress in data.Quests.active do
		local quest = QuestDatabase.ById[questId]
		if quest then
			for i, obj in quest.objectives do
				if obj.type == objectiveType and obj.target == target then
					local prev = progress.objectives[i] or 0
					if prev < obj.amount then
						progress.objectives[i] = math.min(prev + amount, obj.amount)
						changed = true
					end
				end
			end
		end
	end

	if changed then
		-- Notify client of progress update
		QuestProgressEvent:FireClient(player, {})
		sendQuestList(player)

		-- Check completions
		for questId in data.Quests.active do
			tryComplete(player, questId)
		end
	end
end

------------------------------------------------------------
-- Event Listeners (from other server scripts)
------------------------------------------------------------

-- Gather event: fired when player gathers a resource
-- Args: player, itemName, amount
GatherEvent.Event:Connect(function(player, itemName, amount)
	updateProgress(player, "gather", itemName, amount or 1)
end)

-- Craft event: fired when player crafts an item
-- Args: player, itemName, amount
CraftEvent.Event:Connect(function(player, itemName, amount)
	updateProgress(player, "craft", itemName, amount or 1)
end)

-- Kill event: fired when player defeats a target
-- Args: player, targetType, amount
KillEvent.Event:Connect(function(player, targetType, amount)
	updateProgress(player, "kill", targetType, amount or 1)
end)

-- Zone event: fired when player enters/exits a zone
-- Args: player, zoneName
ZoneEvent.Event:Connect(function(player, zoneName)
	updateProgress(player, "visit", zoneName, 1)
end)

-- Talk event: fired when player talks to an NPC
-- Args: player, npcName
TalkEvent.Event:Connect(function(player, npcName)
	updateProgress(player, "talk", npcName, 1)
end)

------------------------------------------------------------
-- Player Setup
------------------------------------------------------------
Players.PlayerAdded:Connect(function(player)
	-- Wait for DataManager to load player data
	task.wait(1)
	ensureQuestData(player)
	sendQuestList(player)
end)

print("[QuestManager] Quest system active!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="154">
      <Properties>
        <string name="Name">RangedCombatManager</string>
        <token name="RunContext">0</token>
        <string name="Source">-- RangedCombatManager.server.lua
-- Server-side ranged combat system for bows and crossbows with error handling

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Wait for dependencies with timeouts
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
local Modules = ReplicatedStorage:WaitForChild("Modules", 10)

-- Load ErrorHandler first for error handling
local ErrorHandler
local itemDatabaseSuccess, ItemDatabase = pcall(function()
	return require(Modules:WaitForChild("ItemDatabase", 5))
end)

local dataManagerSuccess, DataManager = pcall(function()
	return require(Modules:WaitForChild("DataManager", 5))
end)

-- Initialize ErrorHandler
local errorHandlerSuccess, errorHandlerResult = pcall(function()
	return require(Modules:WaitForChild("ErrorHandler", 5))
end)

if errorHandlerSuccess then
	ErrorHandler = errorHandlerResult
else
	-- Fallback ErrorHandler
	ErrorHandler = {
		LogWarning = function(self, msg, data) warn("[RangedCombat] " .. tostring(msg)) end,
		LogError = function(self, msg, data) warn("[RangedCombat] " .. tostring(msg)) end,
		ValidateNotNil = function(self, val, ctx, fallback) return val or fallback end
	}
end

-- Validate dependencies
if not itemDatabaseSuccess then
	ErrorHandler:LogError("Failed to load ItemDatabase", {error = ItemDatabase})
	ItemDatabase = {}
end

if not dataManagerSuccess then
	ErrorHandler:LogWarning("Failed to load DataManager, using fallback", {error = DataManager})
	DataManager = {
		GetData = function() return {skills = {ranged = 1}} end,
		SaveData = function() return true end
	}
end

-- RemoteEvents with validation
local RangedAttackEvent = Remotes and Remotes:WaitForChild("RangedAttack", 5)
local RangedHitEvent = Remotes and Remotes:WaitForChild("RangedHit", 5)
local RangedAmmoUpdateEvent = Remotes and Remotes:WaitForChild("RangedAmmoUpdate", 5)

-- Validate remotes
if not RangedAttackEvent then
	ErrorHandler:LogError("RangedAttack remote not found")
	return
end

-- Constants
local MAX_RANGE_BOW = 50
local MAX_RANGE_CROSSBOW = 70
local PROJECTILE_SPEED = 100 -- studs per second
local PROJECTILE_LIFETIME = 5 -- seconds

-- Weapon type definitions
local WEAPON_TYPES = {
	["Bow"] = {
		range = MAX_RANGE_BOW,
		speedMultiplier = 1.0,
		ammoType = "Arrow"
	},
	["Crossbow"] = {
		range = MAX_RANGE_CROSSBOW,
		speedMultiplier = 0.8, -- slower attack speed
		ammoType = "Bolt"
	}
}

-- Projectile tracking
local activeProjectiles = {}
local lastAttackTimes = {}

-- Helper: Get appropriate ammo for weapon
local function getAmmoForWeapon(weaponId)
	local weaponData = ItemDatabase[weaponId]
	if not weaponData then return nil end
	
	local weaponType = weaponData.subtype or "Bow"
	local ammoType = WEAPON_TYPES[weaponType] and WEAPON_TYPES[weaponType].ammoType or "Arrow"
	
	-- Find matching ammo in player's inventory
	-- This would be implemented with actual inventory lookup
	return ammoType
end

-- Helper: Calculate ranged damage
local function calculateRangedDamage(player, weaponId, ammoId, targetDistance)
	local playerData = DataManager:GetData(player)
	if not playerData then return 0 end
	
	local weaponData = ItemDatabase[weaponId]
	local ammoData = ammoId and ItemDatabase[ammoId]
	
	if not weaponData then return 0 end
	
	-- Base damage from weapon
	local baseDamage = weaponData.damage or 1
	
	-- Ammo bonus
	local ammoBonus = ammoData and ammoData.damage or 0
	
	-- Ranged skill bonus
	local rangedLevel = playerData.skills.ranged or 1
	local skillBonus = math.floor(rangedLevel / 10) + 1
	
	-- Distance penalty (reduced damage at max range)
	local maxRange = WEAPON_TYPES[weaponData.subtype or "Bow"] and WEAPON_TYPES[weaponData.subtype or "Bow"].range or MAX_RANGE_BOW
	local distancePenalty = 1 - (targetDistance / maxRange) * 0.3
	distancePenalty = math.max(0.7, distancePenalty)
	
	-- Calculate final damage
	local damage = (baseDamage + ammoBonus + skillBonus) * distancePenalty
	
	-- Random variation Â±10%
	local variation = 0.9 + math.random() * 0.2
	damage = math.floor(damage * variation)
	
	return math.max(1, damage)
end

-- Helper: Consume ammo from inventory
local function consumeAmmo(player, ammoId)
	-- This would interface with the inventory system
	-- For now, just return true
	return true
end

-- Helper: Award ranged XP
local function awardRangedXP(player, damageDealt)
	local playerData = DataManager:GetData(player)
	if not playerData then return end
	
	-- XP based on damage dealt
	local xpGained = math.floor(damageDealt * 0.5)
	
	-- Update player's ranged skill
	playerData.skills.ranged = (playerData.skills.ranged or 1) + xpGained
	DataManager:SaveData(player, playerData)
	
	-- Notify client of XP gain
	-- This would use an existing XP notification system
end

-- Main ranged attack handler with error handling
RangedAttackEvent.OnServerEvent:Connect(function(player, weaponId, targetPosition)
	-- Validate input parameters
	if not player or not player:IsA("Player") then
		ErrorHandler:LogWarning("Invalid player in ranged attack", {player = player})
		return
	end
	
	if not weaponId or type(weaponId) ~= "string" then
		ErrorHandler:LogWarning("Invalid weaponId", {player = player.Name, weaponId = weaponId})
		return
	end
	
	if not targetPosition or not targetPosition:IsA("Vector3") then
		ErrorHandler:LogWarning("Invalid target position", {player = player.Name})
		return
	end
	
	-- Validate player character
	local character = player.Character
	if not character then
		ErrorHandler:LogWarning("Player has no character", {player = player.Name})
		return
	end
	
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then
		ErrorHandler:LogWarning("Player has no HumanoidRootPart", {player = player.Name})
		return
	end
	
	-- Get weapon data with validation
	local weaponData = ItemDatabase[weaponId]
	if not weaponData then
		ErrorHandler:LogWarning("Weapon not found in database", {player = player.Name, weaponId = weaponId})
		return
	end
	
	if weaponData.type ~= "Weapon" then
		ErrorHandler:LogWarning("Item is not a weapon", {player = player.Name, weaponId = weaponId, type = weaponData.type})
		return
	end
	
	-- Check weapon type
	local weaponType = weaponData.subtype or "Bow"
	if not WEAPON_TYPES[weaponType] then
		ErrorHandler:LogWarning("Invalid weapon type", {player = player.Name, weaponType = weaponType})
		return
	end
	
	-- Get appropriate ammo
	local ammoType = WEAPON_TYPES[weaponType].ammoType
	
	-- Calculate distance with validation
	local distance
	local success, err = pcall(function()
		distance = (targetPosition - humanoidRootPart.Position).Magnitude
	end)
	
	if not success then
		ErrorHandler:LogError("Distance calculation failed", {player = player.Name, error = err})
		return
	end
	
	local maxRange = WEAPON_TYPES[weaponType].range
	
	if distance > maxRange then
		ErrorHandler:LogDebug("Target out of range", {player = player.Name, distance = distance, maxRange = maxRange})
		return
	end
	
	-- Check attack cooldown (would use existing cooldown system)
	-- For now, we'll implement a simple cooldown
	local currentTime = tick()
	local lastAttackTime = lastAttackTimes[player.UserId] or 0
	local attackCooldown = 1.0 -- 1 second cooldown
	
	if currentTime - lastAttackTime &lt; attackCooldown then
		ErrorHandler:LogDebug("Attack on cooldown", {player = player.Name})
		return
	end
	
	lastAttackTimes[player.UserId] = currentTime
	
	-- Consume ammo
	local ammoConsumed = consumeAmmo(player, ammoType)
	if not ammoConsumed then
		ErrorHandler:LogWarning("No ammo available", {player = player.Name, ammoType = ammoType})
		return
	end
	
	-- Calculate damage
	local damage = calculateRangedDamage(player, weaponId, ammoType, distance)
	
	-- Create projectile on server with error handling
	local projectile
	local success, err = pcall(function()
		projectile = Instance.new("Part")
		projectile.Name = "RangedProjectile"
		projectile.Size = Vector3.new(0.2, 0.2, 0.2)
		projectile.Color = Color3.fromRGB(255, 255, 255)
		projectile.Material = Enum.Material.Neon
		projectile.CanCollide = false
		projectile.Anchored = true
		projectile.Position = humanoidRootPart.Position + Vector3.new(0, 1.5, 0)
		projectile.Parent = workspace
	end)
	
	if not success or not projectile then
		ErrorHandler:LogError("Failed to create projectile", {player = player.Name, error = err})
		return
	end
	
	-- Store projectile data
	local projectileId = #activeProjectiles + 1
	activeProjectiles[projectileId] = {
		part = projectile,
		player = player,
		weaponId = weaponId,
		damage = damage,
		startPosition = projectile.Position,
		targetPosition = targetPosition,
		startTime = tick(),
		speed = PROJECTILE_SPEED
	}
	
	-- Notify clients to create visual projectile
	if RangedHitEvent then
		local fireSuccess, fireErr = pcall(function()
			RangedHitEvent:FireAllClients(player, projectile.Position, targetPosition, weaponType)
		end)
		
		if not fireSuccess then
			ErrorHandler:LogWarning("Failed to fire RangedHitEvent", {player = player.Name, error = fireErr})
		end
	end
	
	-- Schedule projectile cleanup
	game:GetService("Debris"):AddItem(projectile, PROJECTILE_LIFETIME)
	
	ErrorHandler:LogDebug("Ranged attack executed", {
		player = player.Name,
		weapon = weaponId,
		damage = damage,
		distance = distance
	})
end)

-- Projectile update loop with error handling
RunService.Heartbeat:Connect(function(deltaTime)
	for id, projectileData in pairs(activeProjectiles) do
		local success, err = pcall(function()
			local projectile = projectileData.part
			if not projectile or not projectile.Parent then
				activeProjectiles[id] = nil
				return
			end
			
			-- Calculate progress
			local elapsed = tick() - projectileData.startTime
			local travelDistance = projectileData.speed * elapsed
			local totalDistance = (projectileData.targetPosition - projectileData.startPosition).Magnitude
			
			if travelDistance >= totalDistance then
				-- Projectile reached target
				projectile.Position = projectileData.targetPosition
				
				-- Check for hits with error handling
				local hitSuccess, hitErr = pcall(function()
					local hitCharacters = workspace:GetPartsInSphere(projectile.Position, 3)
					for _, part in pairs(hitCharacters) do
						local character = part.Parent
						if character and character:IsA("Model") then
							-- Check if it's a monster
							local monsterTag = character:FindFirstChild("Monster")
							if monsterTag then
								-- Apply damage to monster via Humanoid
								local humanoid = character:FindFirstChild("Humanoid")
								if humanoid and humanoid.Health > 0 then
									humanoid:TakeDamage(projectileData.damage)
									-- Fire damage event for UI feedback
									if Remotes then
										local monsterDamageEvent = Remotes:FindFirstChild("MonsterDamage")
										if monsterDamageEvent and projectileData.player then
											monsterDamageEvent:FireClient(projectileData.player, character, projectileData.damage)
										end
									end
								end
								
								-- Award XP to player
								awardRangedXP(projectileData.player, projectileData.damage)
								
								ErrorHandler:LogDebug("Projectile hit monster", {
									player = projectileData.player and projectileData.player.Name or "Unknown",
									damage = projectileData.damage
								})
								break
							end
						end
					end
				end)
				
				if not hitSuccess then
					ErrorHandler:LogWarning("Hit detection failed", {error = hitErr})
				end
				
				-- Remove projectile
				projectile:Destroy()
				activeProjectiles[id] = nil
			else
				-- Update projectile position
				local progress = travelDistance / totalDistance
				projectile.Position = projectileData.startPosition:Lerp(projectileData.targetPosition, progress)
			end
		end)
		
		if not success then
			ErrorHandler:LogWarning("Projectile update failed", {error = err, projectileId = id})
			-- Clean up failed projectile
			if projectileData and projectileData.part then
				pcall(function() projectileData.part:Destroy() end)
			end
			activeProjectiles[id] = nil
		end
	end
end)

-- Cleanup when player leaves
Players.PlayerRemoving:Connect(function(player)
	for id, projectileData in pairs(activeProjectiles) do
		if projectileData.player == player then
			if projectileData.part then
				projectileData.part:Destroy()
			end
			activeProjectiles[id] = nil
		end
	end
end)

print("[RangedCombatManager] Loaded!")</string>
      </Properties>
    </Item>
    <Item class="Script" referent="155">
      <Properties>
        <string name="Name">ShopManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	ShopManager.server.lua
	Server-side shop system for NPCs with merchant role.
	Handles buying/selling items with gold, 60% sell-back value.
	Updated to use correct DataManager API.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local DataManager = require(ReplicatedStorage.Modules.DataManager)
local ItemDatabase = require(ReplicatedStorage.Modules.ItemDatabase)

print("[ShopManager] Loading...")

------------------------------------------------------------
-- Remote Events
------------------------------------------------------------
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
local BuyItemEvent = Remotes:WaitForChild("BuyItem", 10)
local SellItemEvent = Remotes:WaitForChild("SellItem", 10)

------------------------------------------------------------
-- Shop Inventories by NPC Name (ONLY EXISTING ITEMS!)
------------------------------------------------------------
local ShopInventories = {
	["Mara the Merchant"] = {
		{item = "Cooked Shrimp", stock = 40, basePrice = 15},
		{item = "Cooked Trout", stock = 30, basePrice = 30},
		{item = "Cooked Chicken", stock = 30, basePrice = 12},
		{item = "Cooked Beef", stock = 25, basePrice = 20},
		{item = "Cooked Lobster", stock = 15, basePrice = 80},
		{item = "Wooden Shield", stock = 5, basePrice = 50},
		{item = "Bronze Helmet", stock = 5, basePrice = 60},
		{item = "Bones", stock = 20, basePrice = 10},
		{item = "Feather", stock = 50, basePrice = 5},
	},
	["Grimnir the Smith"] = {
		{item = "Copper Sword", stock = 10, basePrice = 50},
		{item = "Iron Sword", stock = 8, basePrice = 200},
		{item = "Gold Sword", stock = 5, basePrice = 800},
		{item = "Bronze Platebody", stock = 8, basePrice = 100},
		{item = "Iron Platebody", stock = 5, basePrice = 400},
		{item = "Gold Platebody", stock = 3, basePrice = 1500},
		{item = "Bronze Platelegs", stock = 8, basePrice = 80},
		{item = "Iron Platelegs", stock = 5, basePrice = 350},
		{item = "Iron Chainbody", stock = 5, basePrice = 300},
		{item = "Iron Shield", stock = 5, basePrice = 250},
		{item = "Gold Shield", stock = 3, basePrice = 900},
		{item = "Copper Bar", stock = 30, basePrice = 25},
		{item = "Iron Bar", stock = 20, basePrice = 60},
		{item = "Gold Bar", stock = 10, basePrice = 200},
	},
	["Old Bess the Cook"] = {
		{item = "Cooked Shrimp", stock = 40, basePrice = 15},
		{item = "Cooked Trout", stock = 30, basePrice = 30},
		{item = "Cooked Chicken", stock = 30, basePrice = 12},
		{item = "Cooked Beef", stock = 25, basePrice = 20},
		{item = "Cooked Lobster", stock = 15, basePrice = 80},
		{item = "Raw Chicken", stock = 20, basePrice = 5},
		{item = "Raw Beef", stock = 20, basePrice = 8},
	},
	["Fisher Tom"] = {
		{item = "Wooden Rod", stock = 10, basePrice = 50},
		{item = "Iron Rod", stock = 5, basePrice = 200},
		{item = "Gold Rod", stock = 3, basePrice = 600},
		{item = "Shrimp", stock = 30, basePrice = 8},
		{item = "Trout", stock = 20, basePrice = 20},
		{item = "Lobster", stock = 10, basePrice = 50},
	},
	["Woodsman Jake"] = {
		{item = "Bronze Axe", stock = 10, basePrice = 50},
		{item = "Iron Axe", stock = 5, basePrice = 200},
		{item = "Gold Axe", stock = 3, basePrice = 600},
		{item = "Oak Shortbow", stock = 8, basePrice = 100},
		{item = "Willow Shortbow", stock = 5, basePrice = 300},
		{item = "Bronze Arrows", stock = 99, basePrice = 5},
		{item = "Iron Arrows", stock = 50, basePrice = 15},
		{item = "Arrow Shafts", stock = 99, basePrice = 3},
		{item = "Bowstring", stock = 30, basePrice = 10},
		{item = "Feather", stock = 99, basePrice = 5},
	},
	["Captain Blackbeard"] = {
		{item = "Pirate Cutlass", stock = 3, basePrice = 500},
		{item = "Gold Crossbow", stock = 2, basePrice = 1200},
		{item = "Gold Arrows", stock = 30, basePrice = 40},
		{item = "Gold Bolts", stock = 20, basePrice = 50},
		{item = "Studded Body", stock = 3, basePrice = 600},
		{item = "Studded Chaps", stock = 3, basePrice = 500},
		{item = "Leather Body", stock = 5, basePrice = 200},
		{item = "Leather Chaps", stock = 5, basePrice = 150},
	},
	["Priestess Solara"] = {
		{item = "Bronze Pickaxe", stock = 10, basePrice = 50},
		{item = "Iron Pickaxe", stock = 5, basePrice = 200},
		{item = "Gold Pickaxe", stock = 3, basePrice = 600},
		{item = "Bones", stock = 20, basePrice = 10},
		{item = "Bone Dust", stock = 15, basePrice = 20},
	},
}

------------------------------------------------------------
-- Helper Functions (Updated to use correct DataManager API)
------------------------------------------------------------
local function getShopInventory(npcName)
	return ShopInventories[npcName] or {}
end

local function canAfford(player, price)
	local data = DataManager:GetData(player)
	return data and data.Gold >= price
end

local function countItemInInventory(player, itemName)
	local data = DataManager:GetData(player)
	if not data or not data.Inventory then return 0 end
	
	local count = 0
	for _, slot in ipairs(data.Inventory) do
		if slot.name == itemName then
			count = count + slot.quantity
		end
	end
	return count
end

local function fireInventoryUpdate(player)
	local invRemote = Remotes:FindFirstChild("InventoryUpdate")
	if invRemote then
		local data = DataManager:GetData(player)
		if data and data.Inventory then
			invRemote:FireClient(player, data.Inventory)
		end
	end
end

------------------------------------------------------------
-- Buy Item Handler
------------------------------------------------------------
local function onBuyItem(player, npcName, itemName, quantity)
	-- Validate inputs
	if not player or not npcName or not itemName or not quantity then return end
	if quantity <= 0 or quantity > 100 then return end -- Sanity check

	-- Check if item exists in ItemDatabase
	local itemData = ItemDatabase.GetItem(itemName)
	if not itemData then
		warn("[ShopManager] Item does not exist in ItemDatabase:", itemName)
		return
	end

	-- Get shop inventory
	local shopItems = getShopInventory(npcName)
	local shopItem = nil
	for _, item in ipairs(shopItems) do
		if item.item == itemName then
			shopItem = item
			break
		end
	end

	if not shopItem then
		warn("[ShopManager] Item not found in shop:", itemName, "for NPC:", npcName)
		return
	end

	-- Check stock
	if shopItem.stock < quantity then
		print("[ShopManager] Insufficient stock for", itemName, "in", npcName, "shop")
		return
	end

	-- Calculate total price
	local totalPrice = shopItem.basePrice * quantity

	-- Check if player can afford
	if not canAfford(player, totalPrice) then
		print("[ShopManager]", player.Name, "cannot afford", quantity, itemName, "for", totalPrice, "gold")
		return
	end

	-- Process purchase
	if DataManager.RemoveGold(player, totalPrice) then
		if DataManager.AddToInventory(player, itemName, quantity) then
			-- Reduce shop stock
			shopItem.stock = shopItem.stock - quantity
			
			-- Fire inventory update
			fireInventoryUpdate(player)
			
			print("[ShopManager]", player.Name, "bought", quantity, itemName, "for", totalPrice, "gold from", npcName)
		else
			-- Refund if inventory add failed
			DataManager.AddGold(player, totalPrice)
			print("[ShopManager] Failed to add item to inventory, refunding")
		end
	else
		warn("[ShopManager] Failed to remove gold from player")
	end
end

------------------------------------------------------------
-- Sell Item Handler
------------------------------------------------------------
local function onSellItem(player, npcName, itemName, quantity)
	-- Validate inputs
	if not player or not npcName or not itemName or not quantity then return end
	if quantity <= 0 or quantity > 100 then return end

	-- Check if item exists in ItemDatabase
	local itemData = ItemDatabase.GetItem(itemName)
	if not itemData then
		warn("[ShopManager] Item does not exist in ItemDatabase:", itemName)
		return
	end

	-- Check if player has enough of the item
	local playerHas = countItemInInventory(player, itemName)
	if playerHas < quantity then
		print("[ShopManager]", player.Name, "doesn't have enough", itemName, "to sell")
		return
	end

	-- Get item value and calculate sell price (60% of base value)
	local itemValue = itemData.value or 1
	local sellPrice = math.floor(itemValue * quantity * 0.6)

	-- Remove items from inventory
	if DataManager.RemoveFromInventory(player, itemName, quantity) then
		-- Give gold to player
		DataManager.AddGold(player, sellPrice)
		
		-- Fire inventory update
		fireInventoryUpdate(player)
		
		print("[ShopManager]", player.Name, "sold", quantity, itemName, "for", sellPrice, "gold to", npcName)
	else
		warn("[ShopManager] Failed to remove items from inventory")
	end
end

------------------------------------------------------------
-- Event Connections
------------------------------------------------------------
BuyItemEvent.OnServerEvent:Connect(onBuyItem)
SellItemEvent.OnServerEvent:Connect(onSellItem)

print("[ShopManager] Initialized with", #ShopInventories, "shop inventories")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="156">
      <Properties>
        <string name="Name">SimpleNPCTest</string>
        <token name="RunContext">0</token>
        <string name="Source">--[[
	SimpleNPCTest.server.lua
	Minimal NPC spawner to test if NPC creation works at all.
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

-- Wait a bit for game to load
task.wait(5)

print("[SimpleNPCTest] Starting NPC test...")

-- Try to get Remotes (but don't crash if they don't exist)
local Remotes = ReplicatedStorage:FindFirstChild("Remotes")
if not Remotes then
	print("[SimpleNPCTest] Warning: No Remotes folder found")
else
	print("[SimpleNPCTest] Remotes folder found")
end

-- Simple NPC creation function
local function createSimpleNPC(name, position)
	print("[SimpleNPCTest] Creating NPC:", name, "at", position)
	
	-- Create a simple NPC model
	local npcModel = Instance.new("Model")
	npcModel.Name = name
	npcModel.Parent = Workspace
	
	-- Create basic body parts
	local torso = Instance.new("Part")
	torso.Name = "Torso"
	torso.Size = Vector3.new(2, 2, 1)
	torso.Position = position
	torso.Material = Enum.Material.SmoothPlastic
	torso.Color = Color3.fromRGB(245, 205, 148) -- Skin color
	torso.Anchored = true
	torso.Parent = npcModel
	
	local head = Instance.new("Part")
	head.Name = "Head"
	head.Shape = Enum.PartType.Ball
	head.Size = Vector3.new(2, 1, 1)
	head.Position = position + Vector3.new(0, 2, 0)
	head.Material = Enum.Material.SmoothPlastic
	head.Color = Color3.fromRGB(245, 205, 148) -- Skin color
	head.Anchored = true
	head.Parent = npcModel
	
	-- Add name tag
	local billboard = Instance.new("BillboardGui")
	billboard.Size = UDim2.new(0, 100, 0, 50)
	billboard.StudsOffset = Vector3.new(0, 3, 0)
	billboard.Parent = head
	
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(1, 0, 1, 0)
	nameLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	nameLabel.BackgroundTransparency = 0.5
	nameLabel.Text = name
	nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	nameLabel.TextScaled = true
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.Parent = billboard
	
	-- Add click detector
	local clickDetector = Instance.new("ClickDetector")
	clickDetector.MaxActivationDistance = 25
	clickDetector.Parent = torso
	
	clickDetector.MouseClick:Connect(function(player)
		print("[SimpleNPCTest]", player.Name, "clicked", name)
		
		-- Try to send a message to the player
		local Remotes = ReplicatedStorage:FindFirstChild("Remotes")
		if Remotes then
			local NPCInteractEvent = Remotes:FindFirstChild("NPCInteract")
			if NPCInteractEvent then
				NPCInteractEvent:FireClient(player, {
					npcName = name,
					dialog = "Welcome to the bank! (This is a test NPC)"
				})
			end
		end
	end)
	
	print("[SimpleNPCTest] Created NPC:", name)
	return npcModel
end

-- Try to create one test NPC
pcall(function()
	local testNPC = createSimpleNPC("Test Banker", Vector3.new(10, 15, 10))
	if testNPC then
		print("[SimpleNPCTest] SUCCESS: Test NPC created!")
	else
		print("[SimpleNPCTest] FAILED: Could not create test NPC")
	end
end)

print("[SimpleNPCTest] Test complete")</string>
      </Properties>
    </Item>
    <Item class="Script" referent="157">
      <Properties>
        <string name="Name">SkillManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- SkillManager.server.lua
-- Handles resource gathering (mining, woodcutting, fishing)

print("[SkillManager] Starting...")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Modules = ReplicatedStorage:WaitForChild("Modules", 10)
print("[SkillManager] Modules folder found: " .. tostring(Modules ~= nil))

local ok1, Config = pcall(function() return require(Modules:WaitForChild("Config", 10)) end)
print("[SkillManager] Config loaded: " .. tostring(ok1))

local ok2, ItemDB = pcall(function() return require(Modules:WaitForChild("ItemDatabase", 10)) end)
print("[SkillManager] ItemDB loaded: " .. tostring(ok2))

local ok3, DataManager = pcall(function() return require(Modules:WaitForChild("DataManager", 10)) end)
print("[SkillManager] DataManager loaded: " .. tostring(ok3))

if not ok1 or not ok2 or not ok3 then
	warn("[SkillManager] FAILED to load modules! Config=" .. tostring(ok1) .. " ItemDB=" .. tostring(ok2) .. " DataManager=" .. tostring(ok3))
	return
end

-- Get gather feedback remote
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
local gatherRemote = Remotes:WaitForChild("GatherFeedback", 10)

-- Skill mapping
local skillMap = {
	Rock = "Mining",
	Tree = "Woodcutting",
	FishingSpot = "Fishing",
}

-- === RESOURCE NODE SETUP ===
local function createResourceNode(name, nodeType, position, parent, levelReq, itemDrop, xpReward, quantity)
	-- Use a Model to group all parts together
	local model = Instance.new("Model")
	model.Name = name
	model.Parent = parent

	local mainPart -- the part that gets the ClickDetector

	if nodeType == "Rock" then
		-- Determine ore color based on item drop
		local oreColors = {
			["Copper Ore"] = {main = Color3.fromRGB(140, 90, 50), vein = Color3.fromRGB(184, 115, 51)},
			["Iron Ore"] = {main = Color3.fromRGB(80, 80, 85), vein = Color3.fromRGB(160, 160, 170)},
			["Gold Ore"] = {main = Color3.fromRGB(100, 95, 75), vein = Color3.fromRGB(218, 165, 32)},
			["Runite Ore"] = {main = Color3.fromRGB(50, 80, 80), vein = Color3.fromRGB(0, 170, 170)},
		}
		local colors = oreColors[itemDrop] or {main = Color3.fromRGB(90, 90, 90), vein = Color3.fromRGB(150, 150, 150)}

		mainPart = Instance.new("Part")
		mainPart.Name = "Rock"
		mainPart.Size = Vector3.new(3, 2.5, 3)
		mainPart.Position = position + Vector3.new(0, 1.25, 0)
		mainPart.Anchored = true
		mainPart.CanCollide = true
		mainPart.Color = colors.main
		mainPart.Material = Enum.Material.Slate
		mainPart.Parent = model

		-- Smaller rock next to it
		local rock2 = Instance.new("Part")
		rock2.Name = "RockSmall"
		rock2.Size = Vector3.new(1.8, 1.6, 1.8)
		rock2.Position = position + Vector3.new(2, 0.8, 0.8)
		rock2.Anchored = true
		rock2.CanCollide = true
		rock2.Color = colors.main
		rock2.Material = Enum.Material.Rock
		rock2.Parent = model

		-- Colored ore vein on surface
		local vein = Instance.new("Part")
		vein.Name = "OreVein"
		vein.Size = Vector3.new(1.2, 0.8, 0.2)
		vein.Position = position + Vector3.new(0, 1.5, 1.5)
		vein.Anchored = true
		vein.CanCollide = false
		vein.Color = colors.vein
		vein.Material = Enum.Material.SmoothPlastic
		vein.Parent = model

	elseif nodeType == "Tree" then
		-- Determine tree size based on item drop
		local treeSizes = {
			["Oak Log"] = {trunk = Vector3.new(1.5, 6, 1.5), canopy = Vector3.new(5, 4, 5), canopyY = 7, glow = false},
			["Willow Log"] = {trunk = Vector3.new(1.8, 7, 1.8), canopy = Vector3.new(6, 4.5, 6), canopyY = 8, glow = false},
			["Yew Log"] = {trunk = Vector3.new(2, 8, 2), canopy = Vector3.new(7, 5, 7), canopyY = 9, glow = false},
			["Magic Log"] = {trunk = Vector3.new(2.2, 10, 2.2), canopy = Vector3.new(8, 6, 8), canopyY = 11, glow = true},
		}
		local treeInfo = treeSizes[itemDrop] or treeSizes["Oak Log"]

		-- Trunk
		mainPart = Instance.new("Part")
		mainPart.Name = "Trunk"
		mainPart.Size = treeInfo.trunk
		mainPart.Position = position + Vector3.new(0, treeInfo.trunk.Y / 2, 0)
		mainPart.Anchored = true
		mainPart.CanCollide = true
		mainPart.Color = Color3.fromRGB(101, 67, 33)
		mainPart.Material = Enum.Material.Wood
		mainPart.Parent = model

		-- Canopy
		local leaves = Instance.new("Part")
		leaves.Name = "Leaves"
		leaves.Shape = Enum.PartType.Ball
		leaves.Size = treeInfo.canopy
		leaves.Position = position + Vector3.new(0, treeInfo.canopyY, 0)
		leaves.Anchored = true
		leaves.CanCollide = false
		leaves.Color = Color3.fromRGB(34, 100, 34)
		leaves.Material = Enum.Material.Grass
		leaves.Parent = model

		-- Magic trees get a subtle glow
		if treeInfo.glow then
			local glow = Instance.new("PointLight")
			glow.Color = Color3.fromRGB(100, 200, 255)
			glow.Brightness = 1.5
			glow.Range = 14
			glow.Parent = leaves
		end

		-- ClickDetector on leaves too (increased range)
		local leavesClick = Instance.new("ClickDetector")
		leavesClick.MaxActivationDistance = 25
		leavesClick.Parent = leaves
		leaves:SetAttribute("IsGatherNode", true)

	elseif nodeType == "FishingSpot" then
		-- Transparent blue ring on water surface
		mainPart = Instance.new("Part")
		mainPart.Name = "FishingSpot"
		mainPart.Shape = Enum.PartType.Cylinder
		mainPart.Size = Vector3.new(0.3, 6, 6)
		mainPart.CFrame = CFrame.new(position + Vector3.new(0, 0.15, 0)) * CFrame.Angles(0, 0, math.rad(90))
		mainPart.Anchored = true
		mainPart.CanCollide = false
		mainPart.Color = Color3.fromRGB(65, 130, 175)
		mainPart.Material = Enum.Material.Water
		mainPart.Transparency = 0.5
		mainPart.Parent = model

		-- Bobber (small bright sphere)
		local bobber = Instance.new("Part")
		bobber.Name = "Bobber"
		bobber.Shape = Enum.PartType.Ball
		bobber.Size = Vector3.new(0.8, 0.8, 0.8)
		bobber.Position = position + Vector3.new(0, 0.6, 0)
		bobber.Anchored = true
		bobber.CanCollide = false
		bobber.Color = Color3.fromRGB(255, 80, 20)
		bobber.Material = Enum.Material.SmoothPlastic
		bobber.Parent = model

		-- Splash particle effect
		local emitter = Instance.new("ParticleEmitter")
		emitter.Color = ColorSequence.new(Color3.fromRGB(200, 220, 255))
		emitter.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.3), NumberSequenceKeypoint.new(1, 0)})
		emitter.Lifetime = NumberRange.new(0.3, 0.8)
		emitter.Rate = 5
		emitter.Speed = NumberRange.new(1, 3)
		emitter.SpreadAngle = Vector2.new(30, 30)
		emitter.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.3), NumberSequenceKeypoint.new(1, 1)})
		emitter.Parent = bobber
	end

	if not mainPart then
		warn("[SkillManager] Failed to create main part for " .. name)
		return
	end

	-- ClickDetector on main part (increased range for easier clicking)
	local clickDetector = Instance.new("ClickDetector")
	clickDetector.MaxActivationDistance = 25
	clickDetector.Parent = mainPart

	-- Floating label showing what it is
	local billboard = Instance.new("BillboardGui")
	billboard.Size = UDim2.new(5, 0, 1, 0)
	billboard.StudsOffset = Vector3.new(0, 3, 0)
	billboard.Parent = mainPart

	local skillEmojis = {Rock = "â›ï¸", Tree = "ðŸª“", FishingSpot = "ðŸŽ£"}
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = (skillEmojis[nodeType] or "") .. " " .. itemDrop .. " (Lv " .. levelReq .. ")"
	label.TextColor3 = Color3.fromRGB(255, 223, 120)
	label.TextScaled = true
	label.Font = Enum.Font.GothamBold
	label.TextStrokeTransparency = 0.5
	label.Parent = billboard

	-- Tool type required per node type
	local toolRequired = {Rock = "pickaxe", Tree = "axe", FishingSpot = "fishing_rod"}

	-- Track who is currently gathering this node
	local gatheringPlayers = {}

	-- Helper: find best tool for this node
	local function findTool(player, requiredToolType)
		local playerLevel = DataManager.GetSkillLevel(player, skillMap[nodeType])
		local data = DataManager:GetData(player)
		if not data then return false, 1.0 end

		-- Check equipped tool first
		local equippedTool = data.Equipment and data.Equipment.Tool or ""
		if equippedTool ~= "" then
			local toolInfo = ItemDB.GetItem(equippedTool)
			if toolInfo and toolInfo.toolType == requiredToolType and playerLevel >= (toolInfo.levelReq or 1) then
				return true, toolInfo.gatherSpeed or 1.0
			end
		end

		-- Check inventory for best tool
		if data.Inventory then
			local bestSpeed = 999
			local found = false
			for _, slot in ipairs(data.Inventory) do
				local itemInfo = ItemDB.GetItem(slot.name)
				if itemInfo and itemInfo.toolType == requiredToolType and playerLevel >= (itemInfo.levelReq or 1) then
					local spd = itemInfo.gatherSpeed or 1.0
					if spd < bestSpeed then
						bestSpeed = spd
						found = true
					end
				end
			end
			if found then return true, bestSpeed end
		end

		return false, 1.0
	end

	-- Helper: do one gather cycle, returns true if should continue
	local function doOneGather(player, toolSpeed)
		local skill = skillMap[nodeType]
		local playerLevel = DataManager.GetSkillLevel(player, skill)

		-- Calculate gather time
		local baseTime = 2 + (levelReq / 15)
		local gatherTime = baseTime * toolSpeed
		local levelBonus = math.min(0.3, (playerLevel - levelReq) * 0.005)
		gatherTime = gatherTime * (1 - levelBonus)
		gatherTime = math.max(1, gatherTime)

		-- Tell client gathering started
		gatherRemote:FireClient(player, "start", itemDrop, gatherTime)

		-- Wait for gather time, checking player stays near
		local startPos = model.PrimaryPart and model.PrimaryPart.Position or model:GetChildren()[1].Position
		local elapsed = 0
		while elapsed < gatherTime do
			task.wait(0.25)
			elapsed = elapsed + 0.25
			local char = player.Character
			if not char then return false end
			local root = char:FindFirstChild("HumanoidRootPart")
			if not root or (root.Position - startPos).Magnitude > 20 then return false end
			local hum = char:FindFirstChildOfClass("Humanoid")
			if not hum or hum.Health <= 0 then return false end
		end

		-- Check inventory space
		local added = DataManager.AddToInventory(player, itemDrop, 1)
		if not added then
			gatherRemote:FireClient(player, "full", itemDrop, 0)
			return false
		end

		-- Award XP
		DataManager.AddSkillXP(player, skill, xpReward)

		-- Notify client
		gatherRemote:FireClient(player, "gather", itemDrop, xpReward)

		-- Update client inventory
		local invRemote = Remotes:FindFirstChild("InventoryUpdate")
		if invRemote then
			local data = DataManager:GetData(player)
			if data and data.Inventory then
				invRemote:FireClient(player, data.Inventory)
			end
		end

		return true -- keep going
	end

	-- Gather handler â€” click once, auto-repeats until full/walk away/die
	local function onGather(player)
		if gatheringPlayers[player.UserId] then return end -- already gathering here

		local skill = skillMap[nodeType]
		if not skill then return end

		-- Check level requirement
		local playerLevel = DataManager.GetSkillLevel(player, skill)
		if playerLevel < levelReq then
			gatherRemote:FireClient(player, "level", itemDrop, levelReq)
			return
		end

		-- Check for required tool
		local requiredToolType = toolRequired[nodeType]
		local hasTool, toolSpeed = findTool(player, requiredToolType)

		if not hasTool then
			local toolNames = {pickaxe = "pickaxe", axe = "axe", fishing_rod = "fishing rod"}
			gatherRemote:FireClient(player, "notool", toolNames[requiredToolType] or "tool", 0)
			return
		end

		-- Mark player as gathering
		gatheringPlayers[player.UserId] = true

		-- Auto-gather loop â€” keeps going until interrupted
		task.spawn(function()
			while gatheringPlayers[player.UserId] do
				-- Re-check tool each cycle (might break or get dropped)
				local stillHasTool, currentSpeed = findTool(player, requiredToolType)
				if not stillHasTool then
					local toolNames = {pickaxe = "pickaxe", axe = "axe", fishing_rod = "fishing rod"}
					gatherRemote:FireClient(player, "notool", toolNames[requiredToolType] or "tool", 0)
					break
				end

				local keepGoing = doOneGather(player, currentSpeed)
				if not keepGoing then break end

				-- Small pause between gathers
				task.wait(0.5)
			end
			gatheringPlayers[player.UserId] = nil
			gatherRemote:FireClient(player, "stop", itemDrop, 0)
		end)
	end

	-- Stop gathering if player clicks again (toggle off)
	local function onClickToggle(player)
		if gatheringPlayers[player.UserId] then
			-- Already gathering â€” stop
			gatheringPlayers[player.UserId] = nil
			return
		end
		-- Not gathering â€” start
		onGather(player)
	end

	-- Connect main click (toggle: click to start, click again to stop)
	clickDetector.MouseClick:Connect(onClickToggle)

	-- Connect leaf clicks for trees
	if nodeType == "Tree" then
		for _, child in ipairs(model:GetChildren()) do
			local childClick = child:FindFirstChild("ClickDetector")
			if childClick and child ~= mainPart then
				childClick.MouseClick:Connect(onClickToggle)
			end
		end
	end

	-- Stop gathering if player dies or leaves
	Players.PlayerRemoving:Connect(function(p)
		gatheringPlayers[p.UserId] = nil
	end)

	return model
end

-- === SPAWN RESOURCE NODES ===
local WS = game:GetService("Workspace")

-- Wait for MapSetup to run
task.wait(2)
local resourceFolder = WS:FindFirstChild("ResourceNodes")
if not resourceFolder then
	resourceFolder = Instance.new("Folder")
	resourceFolder.Name = "ResourceNodes"
	resourceFolder.Parent = WS
end
print("[SkillManager] ResourceNodes folder ready, spawning nodes...")

-- ============================================================
-- SAFE ZONE RESOURCES
-- ============================================================

-- === HAVEN MINE (copper + iron rocks inside cave) ===
createResourceNode("CopperRock1", "Rock", Vector3.new(-105, 0, 20), resourceFolder, 1, "Copper Ore", 20, 5)
createResourceNode("CopperRock2", "Rock", Vector3.new(-100, 0, 10), resourceFolder, 1, "Copper Ore", 20, 4)
createResourceNode("CopperRock3", "Rock", Vector3.new(-95, 0, 5), resourceFolder, 1, "Copper Ore", 20, 3)
createResourceNode("CopperRock4", "Rock", Vector3.new(-88, 0, 15), resourceFolder, 1, "Copper Ore", 20, 6)
createResourceNode("CopperRock5", "Rock", Vector3.new(-82, 0, 8), resourceFolder, 1, "Copper Ore", 20, 4)

createResourceNode("IronRock1", "Rock", Vector3.new(-105, 0, 3), resourceFolder, 15, "Iron Ore", 35, 3)
createResourceNode("IronRock2", "Rock", Vector3.new(-85, 0, 2), resourceFolder, 15, "Iron Ore", 35, 4)
createResourceNode("IronRock3", "Rock", Vector3.new(-93, 0, 0), resourceFolder, 15, "Iron Ore", 35, 3)

-- A few rocks outside the mine too
createResourceNode("CopperRockOutside1", "Rock", Vector3.new(-80, 0, 40), resourceFolder, 1, "Copper Ore", 20, 3)
createResourceNode("IronRockOutside1", "Rock", Vector3.new(-75, 0, 50), resourceFolder, 15, "Iron Ore", 35, 2)

-- === HAVEN FOREST (oak + willow trees) ===
createResourceNode("OakTree1", "Tree", Vector3.new(100, 0, 25), resourceFolder, 1, "Oak Log", 18, 4)
createResourceNode("OakTree2", "Tree", Vector3.new(112, 0, 35), resourceFolder, 1, "Oak Log", 18, 5)
createResourceNode("OakTree3", "Tree", Vector3.new(125, 0, 20), resourceFolder, 1, "Oak Log", 18, 3)
createResourceNode("OakTree4", "Tree", Vector3.new(108, 0, 45), resourceFolder, 1, "Oak Log", 18, 6)
createResourceNode("OakTree5", "Tree", Vector3.new(135, 0, 50), resourceFolder, 1, "Oak Log", 18, 4)
createResourceNode("OakTree6", "Tree", Vector3.new(140, 0, 30), resourceFolder, 1, "Oak Log", 18, 5)

createResourceNode("WillowTree1", "Tree", Vector3.new(150, 0, 25), resourceFolder, 20, "Willow Log", 40, 3)
createResourceNode("WillowTree2", "Tree", Vector3.new(155, 0, 45), resourceFolder, 20, "Willow Log", 40, 4)
createResourceNode("WillowTree3", "Tree", Vector3.new(145, 0, 60), resourceFolder, 20, "Willow Log", 40, 3)

-- === HAVEN POND (shrimp + trout fishing) ===
createResourceNode("ShrimpSpot1", "FishingSpot", Vector3.new(75, 0, 82), resourceFolder, 1, "Shrimp", 15, 6)
createResourceNode("ShrimpSpot2", "FishingSpot", Vector3.new(85, 0, 78), resourceFolder, 1, "Shrimp", 15, 5)
createResourceNode("ShrimpSpot3", "FishingSpot", Vector3.new(80, 0, 88), resourceFolder, 1, "Shrimp", 15, 7)
createResourceNode("TroutSpot1", "FishingSpot", Vector3.new(72, 0, 75), resourceFolder, 20, "Trout", 35, 4)
createResourceNode("TroutSpot2", "FishingSpot", Vector3.new(88, 0, 85), resourceFolder, 20, "Trout", 35, 3)

-- Lily pond has trout too
createResourceNode("TroutSpot3", "FishingSpot", Vector3.new(108, 0, 58), resourceFolder, 20, "Trout", 35, 4)
createResourceNode("TroutSpot4", "FishingSpot", Vector3.new(114, 0, 62), resourceFolder, 20, "Trout", 35, 5)

-- ============================================================
-- WILDERNESS RESOURCES â€” better loot, more risk
-- ============================================================

-- Gold Rocks (scattered in mid-wilderness)
createResourceNode("GoldRock1", "Rock", Vector3.new(30, 0, -130), resourceFolder, 40, "Gold Ore", 65, 3)
createResourceNode("GoldRock2", "Rock", Vector3.new(45, 0, -145), resourceFolder, 40, "Gold Ore", 65, 2)
createResourceNode("GoldRock3", "Rock", Vector3.new(-20, 0, -135), resourceFolder, 40, "Gold Ore", 65, 4)

-- Runite Rocks (deep wilderness â€” high risk, high reward)
createResourceNode("RuniteRock1", "Rock", Vector3.new(55, 0, -200), resourceFolder, 70, "Runite Ore", 125, 2)
createResourceNode("RuniteRock2", "Rock", Vector3.new(-40, 0, -230), resourceFolder, 70, "Runite Ore", 125, 2)
createResourceNode("RuniteRock3", "Rock", Vector3.new(10, 0, -270), resourceFolder, 70, "Runite Ore", 125, 3)

-- Yew Trees (mid wilderness)
createResourceNode("YewTree1", "Tree", Vector3.new(-30, 0, -130), resourceFolder, 50, "Yew Log", 80, 3)
createResourceNode("YewTree2", "Tree", Vector3.new(-45, 0, -155), resourceFolder, 50, "Yew Log", 80, 4)
createResourceNode("YewTree3", "Tree", Vector3.new(40, 0, -140), resourceFolder, 50, "Yew Log", 80, 3)

-- Magic Trees (deep wilderness â€” rarest resource)
createResourceNode("MagicTree1", "Tree", Vector3.new(-55, 0, -205), resourceFolder, 75, "Magic Log", 150, 2)
createResourceNode("MagicTree2", "Tree", Vector3.new(70, 0, -240), resourceFolder, 75, "Magic Log", 150, 2)

-- Lobster Spots (mid wilderness)
createResourceNode("LobsterSpot1", "FishingSpot", Vector3.new(20, 0, -140), resourceFolder, 40, "Lobster", 60, 4)
createResourceNode("LobsterSpot2", "FishingSpot", Vector3.new(-15, 0, -150), resourceFolder, 40, "Lobster", 60, 3)

-- Dark Crab (deep wilderness dark pond)
createResourceNode("DarkCrabSpot1", "FishingSpot", Vector3.new(-55, 0, -208), resourceFolder, 70, "Dark Crab", 130, 2)
createResourceNode("DarkCrabSpot2", "FishingSpot", Vector3.new(-65, 0, -214), resourceFolder, 70, "Dark Crab", 130, 3)

-- ============================================================
-- NEW AREA RESOURCES
-- ============================================================

-- === HAVEN LAKE (fishing) ===
createResourceNode("LakeShrimpSpot1", "FishingSpot", Vector3.new(-140, 0, 155), resourceFolder, 1, "Shrimp", 15, 8)
createResourceNode("LakeShrimpSpot2", "FishingSpot", Vector3.new(-160, 0, 160), resourceFolder, 1, "Shrimp", 15, 6)
createResourceNode("LakeTroutSpot1", "FishingSpot", Vector3.new(-145, 0, 145), resourceFolder, 20, "Trout", 35, 4)
createResourceNode("LakeTroutSpot2", "FishingSpot", Vector3.new(-130, 0, 150), resourceFolder, 20, "Trout", 35, 5)
createResourceNode("LakeTroutSpot3", "FishingSpot", Vector3.new(-165, 0, 148), resourceFolder, 20, "Trout", 35, 3)

-- === ANCIENT GROVE (willow trees among the ancient ones) ===
createResourceNode("GroveWillow1", "Tree", Vector3.new(-190, 0, 20), resourceFolder, 20, "Willow Log", 40, 4)
createResourceNode("GroveWillow2", "Tree", Vector3.new(-170, 0, 40), resourceFolder, 20, "Willow Log", 40, 3)
createResourceNode("GroveWillow3", "Tree", Vector3.new(-150, 0, 10), resourceFolder, 20, "Willow Log", 40, 5)
createResourceNode("GroveOak1", "Tree", Vector3.new(-200, 0, -10), resourceFolder, 1, "Oak Log", 18, 5)
createResourceNode("GroveOak2", "Tree", Vector3.new(-230, 0, 30), resourceFolder, 1, "Oak Log", 18, 4)

-- === FARMLANDS (a few rocks in the fields) ===
createResourceNode("FarmCopper1", "Rock", Vector3.new(220, 0, 160), resourceFolder, 1, "Copper Ore", 20, 4)
createResourceNode("FarmCopper2", "Rock", Vector3.new(200, 0, 190), resourceFolder, 1, "Copper Ore", 20, 5)

-- === DRAGON'S SPINE (deep wilderness mining â€” gold + runite) ===
createResourceNode("MtnGold1", "Rock", Vector3.new(-140, 2, -290), resourceFolder, 40, "Gold Ore", 65, 3)
createResourceNode("MtnGold2", "Rock", Vector3.new(-110, 2, -310), resourceFolder, 40, "Gold Ore", 65, 4)
createResourceNode("MtnRunite1", "Rock", Vector3.new(-130, 2, -340), resourceFolder, 70, "Runite Ore", 125, 2)
createResourceNode("MtnRunite2", "Rock", Vector3.new(-100, 2, -350), resourceFolder, 70, "Runite Ore", 125, 3)

-- === CURSED SWAMP (dark crabs + lobsters) ===
createResourceNode("SwampLobster1", "FishingSpot", Vector3.new(100, 0, -310), resourceFolder, 40, "Lobster", 60, 4)
createResourceNode("SwampLobster2", "FishingSpot", Vector3.new(130, 0, -330), resourceFolder, 40, "Lobster", 60, 3)
createResourceNode("SwampDarkCrab1", "FishingSpot", Vector3.new(150, 0, -350), resourceFolder, 70, "Dark Crab", 130, 2)

-- === DARK FOREST (yew + magic trees) ===
createResourceNode("DFYew1", "Tree", Vector3.new(100, 0, -160), resourceFolder, 50, "Yew Log", 80, 3)
createResourceNode("DFYew2", "Tree", Vector3.new(150, 0, -180), resourceFolder, 50, "Yew Log", 80, 4)
createResourceNode("DFMagic1", "Tree", Vector3.new(130, 0, -200), resourceFolder, 75, "Magic Log", 150, 2)

-- === THE ABYSS (runite rocks â€” highest risk/reward) ===
createResourceNode("AbyssRunite1", "Rock", Vector3.new(-30, 0, -460), resourceFolder, 70, "Runite Ore", 125, 3)
createResourceNode("AbyssRunite2", "Rock", Vector3.new(30, 0, -480), resourceFolder, 70, "Runite Ore", 125, 2)
createResourceNode("AbyssRunite3", "Rock", Vector3.new(0, 0, -500), resourceFolder, 70, "Runite Ore", 125, 4)

-- === NEW THEMED AREAS (MapSetup4) ===
-- ============================================================

-- === WHISPERING WOODS (X: 200-350, Z: 50-200) - Woodcutting ===
createResourceNode("WWOak1", "Tree", Vector3.new(220, 0, 70), resourceFolder, 1, "Oak Log", 18, 5)
createResourceNode("WWOak2", "Tree", Vector3.new(250, 0, 90), resourceFolder, 1, "Oak Log", 18, 4)
createResourceNode("WWOak3", "Tree", Vector3.new(280, 0, 120), resourceFolder, 1, "Oak Log", 18, 6)
createResourceNode("WWOak4", "Tree", Vector3.new(310, 0, 150), resourceFolder, 1, "Oak Log", 18, 5)
createResourceNode("WWWillow1", "Tree", Vector3.new(230, 0, 110), resourceFolder, 20, "Willow Log", 40, 4)
createResourceNode("WWWillow2", "Tree", Vector3.new(270, 0, 160), resourceFolder, 20, "Willow Log", 40, 3)
createResourceNode("WWWillow3", "Tree", Vector3.new(320, 0, 180), resourceFolder, 20, "Willow Log", 40, 4)

-- === DEEP MINE (X: -300 to -200, Z: -50 to 50) - Mining ===
createResourceNode("DMCopper1", "Rock", Vector3.new(-280, 0, -30), resourceFolder, 1, "Copper Ore", 20, 6)
createResourceNode("DMCopper2", "Rock", Vector3.new(-260, 0, -10), resourceFolder, 1, "Copper Ore", 20, 5)
createResourceNode("DMCopper3", "Rock", Vector3.new(-240, 0, 20), resourceFolder, 1, "Copper Ore", 20, 4)
createResourceNode("DMIron1", "Rock", Vector3.new(-290, 0, 10), resourceFolder, 15, "Iron Ore", 35, 4)
createResourceNode("DMIron2", "Rock", Vector3.new(-270, 0, 30), resourceFolder, 15, "Iron Ore", 35, 3)
createResourceNode("DMIron3", "Rock", Vector3.new(-220, 0, -20), resourceFolder, 15, "Iron Ore", 35, 4)
createResourceNode("DMGold1", "Rock", Vector3.new(-285, 0, 0), resourceFolder, 40, "Gold Ore", 65, 3)
createResourceNode("DMGold2", "Rock", Vector3.new(-250, 0, 40), resourceFolder, 40, "Gold Ore", 65, 2)

-- === CRYSTAL CAVERN (X: -350 to -250, Z: -150 to -80) - Mining ===
createResourceNode("CCGold1", "Rock", Vector3.new(-330, 0, -120), resourceFolder, 40, "Gold Ore", 65, 3)
createResourceNode("CCGold2", "Rock", Vector3.new(-300, 0, -100), resourceFolder, 40, "Gold Ore", 65, 4)
createResourceNode("CCRunite1", "Rock", Vector3.new(-320, 0, -140), resourceFolder, 70, "Runite Ore", 125, 2)
createResourceNode("CCRunite2", "Rock", Vector3.new(-280, 0, -120), resourceFolder, 70, "Runite Ore", 125, 3)

-- === MOONLIT POND (X: 250-320, Z: -50 to 20) - Fishing ===
createResourceNode("MPShrimp1", "FishingSpot", Vector3.new(270, 0, -30), resourceFolder, 1, "Shrimp", 15, 7)
createResourceNode("MPShrimp2", "FishingSpot", Vector3.new(290, 0, -10), resourceFolder, 1, "Shrimp", 15, 6)
createResourceNode("MPTrout1", "FishingSpot", Vector3.new(280, 0, 0), resourceFolder, 20, "Trout", 35, 5)
createResourceNode("MPTrout2", "FishingSpot", Vector3.new(300, 0, -20), resourceFolder, 20, "Trout", 35, 4)
createResourceNode("MPLobster1", "FishingSpot", Vector3.new(285, 0, -15), resourceFolder, 40, "Lobster", 60, 3)

-- === THORNWOOD THICKET (X: -200 to -100, Z: 200-350) - Woodcutting ===
createResourceNode("TTOak1", "Tree", Vector3.new(-180, 0, 220), resourceFolder, 1, "Oak Log", 18, 4)
createResourceNode("TTOak2", "Tree", Vector3.new(-150, 0, 250), resourceFolder, 1, "Oak Log", 18, 5)
createResourceNode("TTWillow1", "Tree", Vector3.new(-170, 0, 280), resourceFolder, 20, "Willow Log", 40, 3)
createResourceNode("TTWillow2", "Tree", Vector3.new(-130, 0, 310), resourceFolder, 20, "Willow Log", 40, 4)
createResourceNode("TTYew1", "Tree", Vector3.new(-160, 0, 330), resourceFolder, 50, "Yew Log", 80, 3)

-- === SUNFLOWER FIELDS (X: 100-250, Z: 250-380) - Low level nodes ===
createResourceNode("SFCopper1", "Rock", Vector3.new(130, 0, 280), resourceFolder, 1, "Copper Ore", 20, 4)
createResourceNode("SFCopper2", "Rock", Vector3.new(180, 0, 320), resourceFolder, 1, "Copper Ore", 20, 3)
createResourceNode("SFOak1", "Tree", Vector3.new(150, 0, 360), resourceFolder, 1, "Oak Log", 18, 5)
createResourceNode("SFOak2", "Tree", Vector3.new(200, 0, 340), resourceFolder, 1, "Oak Log", 18, 4)

-- === ABANDONED QUARRY (X: -150 to -50, Z: -250 to -150) - Mining ===
createResourceNode("AQIron1", "Rock", Vector3.new(-130, 0, -220), resourceFolder, 15, "Iron Ore", 35, 4)
createResourceNode("AQIron2", "Rock", Vector3.new(-100, 0, -200), resourceFolder, 15, "Iron Ore", 35, 3)
createResourceNode("AQIron3", "Rock", Vector3.new(-80, 0, -230), resourceFolder, 15, "Iron Ore", 35, 5)
createResourceNode("AQGold1", "Rock", Vector3.new(-120, 0, -180), resourceFolder, 40, "Gold Ore", 65, 3)
createResourceNode("AQGold2", "Rock", Vector3.new(-90, 0, -210), resourceFolder, 40, "Gold Ore", 65, 2)

local totalNodes = 0
for _, _ in ipairs(resourceFolder:GetChildren()) do totalNodes = totalNodes + 1 end
print("[SkillManager] Resource nodes spawned - " .. totalNodes .. " nodes total")
print("ðŸ”§ [FORCE RELOAD] SkillManager v2.0 LOADED - CASTING ERROR FIXED! - " .. tick())
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="158">
      <Properties>
        <string name="Name">SmithingManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	SmithingManager.server.lua
	Server-side smithing system for the Wilderness MMO.
	Smelt ores into bars at furnace, smith bars into equipment at anvil.
	Gives Smithing XP and skill progression.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local DataManager = require(ReplicatedStorage.Modules.DataManager)
local ItemDatabase = require(ReplicatedStorage.Modules.ItemDatabase)

------------------------------------------------------------
-- Remote Events
------------------------------------------------------------
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 5)

local StartSmithingEvent = Remotes:WaitForChild("StartSmithing", 5)
local SmithingProgressEvent = Remotes:WaitForChild("SmithingProgress", 5)
local SmithingCompleteEvent = Remotes:WaitForChild("SmithingComplete", 5)
local XPUpdateEvent = Remotes:WaitForChild("XPUpdate", 5)
local InventoryUpdateEvent = Remotes:WaitForChild("InventoryUpdate", 5)

------------------------------------------------------------
-- Smithing Recipes
------------------------------------------------------------

-- Smelting: Ore -> Bar
local SmeltingRecipes = {
	["Copper Ore"] = {
		result = "Copper Bar",
		baseTime = 4,
		baseXP = 17.5,
		levelRequired = 1,
	},
	["Iron Ore"] = {
		result = "Iron Bar",
		baseTime = 5,
		baseXP = 25,
		levelRequired = 15,
	},
	["Gold Ore"] = {
		result = "Gold Bar",
		baseTime = 6,
		baseXP = 56.2,
		levelRequired = 40,
	},
	["Runite Ore"] = {
		result = "Runite Bar",
		baseTime = 8,
		baseXP = 125,
		levelRequired = 85,
	},
}

-- Smithing: Bar -> Equipment
local SmithingRecipes = {
	-- Copper Equipment
	["Copper Bar"] = {
		{ result = "Copper Sword", bars = 1, baseTime = 5, baseXP = 37.5, levelRequired = 1 },
		{ result = "Copper Dagger", bars = 1, baseTime = 3, baseXP = 25, levelRequired = 1 },
		{ result = "Copper Axe", bars = 1, baseTime = 4, baseXP = 31.2, levelRequired = 1 },
		{ result = "Copper Mace", bars = 1, baseTime = 4, baseXP = 31.2, levelRequired = 2 },
		{ result = "Copper Shield", bars = 2, baseTime = 6, baseXP = 50, levelRequired = 3 },
	},
	-- Iron Equipment
	["Iron Bar"] = {
		{ result = "Iron Sword", bars = 1, baseTime = 6, baseXP = 50, levelRequired = 19 },
		{ result = "Iron Dagger", bars = 1, baseTime = 4, baseXP = 37.5, levelRequired = 15 },
		{ result = "Iron Axe", bars = 1, baseTime = 5, baseXP = 43.7, levelRequired = 16 },
		{ result = "Iron Mace", bars = 1, baseTime = 5, baseXP = 43.7, levelRequired = 17 },
		{ result = "Iron Shield", bars = 2, baseTime = 7, baseXP = 75, levelRequired = 18 },
		{ result = "Iron Helmet", bars = 1, baseTime = 5, baseXP = 43.7, levelRequired = 20 },
		{ result = "Iron Platebody", bars = 3, baseTime = 8, baseXP = 112.5, levelRequired = 23 },
	},
	-- Gold Equipment (decorative/special)
	["Gold Bar"] = {
		{ result = "Gold Ring", bars = 1, baseTime = 3, baseXP = 75, levelRequired = 40 },
		{ result = "Gold Amulet", bars = 1, baseTime = 4, baseXP = 87.5, levelRequired = 45 },
		{ result = "Gold Bracelet", bars = 1, baseTime = 3, baseXP = 75, levelRequired = 42 },
	},
	-- Runite Equipment (highest tier)
	["Runite Bar"] = {
		{ result = "Runite Sword", bars = 1, baseTime = 10, baseXP = 200, levelRequired = 89 },
		{ result = "Runite Dagger", bars = 1, baseTime = 8, baseXP = 175, levelRequired = 85 },
		{ result = "Runite Axe", bars = 1, baseTime = 9, baseXP = 187.5, levelRequired = 86 },
		{ result = "Runite Shield", bars = 2, baseTime = 12, baseXP = 350, levelRequired = 90 },
		{ result = "Runite Helmet", bars = 1, baseTime = 9, baseXP = 187.5, levelRequired = 87 },
		{ result = "Runite Platebody", bars = 3, baseTime = 15, baseXP = 525, levelRequired = 95 },
	},
}

------------------------------------------------------------
-- Active Smithing Sessions
------------------------------------------------------------
local activeSmithingSessions = {} -- [player] = { recipe, startTime, station, totalTime, type }

------------------------------------------------------------
-- ClickDetectors and Station Setup
------------------------------------------------------------
local function setupClickDetectors()
	local smithingStations = workspace:WaitForChild("SmithingStations", 5)
	
	for _, station in ipairs(smithingStations:GetChildren()) do
		if station:IsA("Part") then
			-- Add ClickDetector
			local clickDetector = Instance.new("ClickDetector")
			clickDetector.MaxActivationDistance = 10
			clickDetector.Parent = station
			
			-- Add BillboardGui with label
			local billboardGui = Instance.new("BillboardGui")
			billboardGui.Size = UDim2.new(0, 200, 0, 50)
			billboardGui.StudsOffset = Vector3.new(0, 3, 0)
			billboardGui.Parent = station
			
			local textLabel = Instance.new("TextLabel")
			textLabel.Size = UDim2.new(1, 0, 1, 0)
			textLabel.BackgroundTransparency = 1
			textLabel.TextColor3 = Color3.new(1, 1, 1)
			textLabel.TextStrokeTransparency = 0
			textLabel.Font = Enum.Font.SourceSansBold
			textLabel.TextSize = 18
			textLabel.Parent = billboardGui
			
			if station.Name:find("Furnace") then
				textLabel.Text = "ðŸ”¥ Furnace (Smelting)"
				clickDetector.MouseClick:Connect(function(player)
					-- Auto-start smelting with first available ore
					for ore, _ in pairs(SmeltingRecipes) do
						if DataManager.HasItem(player, ore, 1) then
							StartSmithingEvent:FireServer("smelt", ore)
							break
						end
					end
				end)
			elseif station.Name:find("Anvil") then
				textLabel.Text = "ðŸ”¨ Anvil (Smithing)"
				clickDetector.MouseClick:Connect(function(player)
					-- Show available recipes (fire event to client)
					StartSmithingEvent:FireClient(player, "showRecipes")
				end)
			end
		end
	end
end

-- Set up click detectors after a short delay to ensure stations exist
game:GetService("Debris"):AddItem(game:GetService("RunService").Heartbeat:Connect(function()
	if workspace:FindFirstChild("SmithingStations") then
		setupClickDetectors()
		return true -- Disconnect
	end
end), 10)

------------------------------------------------------------
-- Smithing Logic
------------------------------------------------------------
local function startSmelting(player, oreItemName)
	if activeSmithingSessions[player] then return end

	local recipe = SmeltingRecipes[oreItemName]
	if not recipe then return end

	local smithingLevel = DataManager.GetSkillLevel(player, "Smithing")
	if smithingLevel < recipe.levelRequired then return end

	if not DataManager.HasItem(player, oreItemName, 1) then return end

	local furnace = findNearbyFurnace(player)
	if not furnace then return end

	if not DataManager.RemoveFromInventory(player, oreItemName, 1) then return end
	local data = DataManager:GetData(player); if data and data.Inventory then InventoryUpdateEvent:FireClient(player, data.Inventory) end

	local totalTime = recipe.baseTime
	activeSmithingSessions[player] = {
		recipe = recipe,
		startTime = tick(),
		station = furnace,
		totalTime = totalTime,
		sourceItem = oreItemName,
		type = "smelting"
	}

	SmithingProgressEvent:FireClient(player, {
		action = "start",
		totalTime = totalTime,
		itemName = oreItemName,
		type = "smelting"
	})

	print("[SmithingManager]", player.Name, "started smelting", oreItemName)
end

local function startSmithing(player, barItemName, equipmentName)
	if activeSmithingSessions[player] then return end

	local recipes = SmithingRecipes[barItemName]
	if not recipes then return end

	local recipe = nil
	for _, r in ipairs(recipes) do
		if r.result == equipmentName then
			recipe = r
			break
		end
	end
	if not recipe then return end

	local smithingLevel = DataManager.GetSkillLevel(player, "Smithing")
	if smithingLevel < recipe.levelRequired then return end

	if not DataManager.HasItem(player, barItemName, recipe.bars) then return end

	local anvil = findNearbyAnvil(player)
	if not anvil then return end

	if not DataManager.RemoveFromInventory(player, barItemName, recipe.bars) then return end
	local data = DataManager:GetData(player); if data and data.Inventory then InventoryUpdateEvent:FireClient(player, data.Inventory) end

	local totalTime = recipe.baseTime
	activeSmithingSessions[player] = {
		recipe = recipe,
		startTime = tick(),
		station = anvil,
		totalTime = totalTime,
		sourceItem = barItemName,
		type = "smithing"
	}

	SmithingProgressEvent:FireClient(player, {
		action = "start",
		totalTime = totalTime,
		itemName = equipmentName,
		type = "smithing"
	})

	print("[SmithingManager]", player.Name, "started smithing", equipmentName)
end

local function completeSmithing(player, session)
	local recipe = session.recipe
	local resultItem = recipe.result
	local xpGained = recipe.baseXP

	DataManager.AddToInventory(player, resultItem, 1)
	local data = DataManager:GetData(player); if data and data.Inventory then InventoryUpdateEvent:FireClient(player, data.Inventory) end
	
	DataManager.AddSkillXP(player, "Smithing", xpGained)
	XPUpdateEvent:FireClient(player, "Smithing", xpGained)

	SmithingCompleteEvent:FireClient(player, {
		result = resultItem,
		xpGained = xpGained,
		type = session.type
	})

	-- Fire quest event
	local questCraftEvent = ReplicatedStorage:FindFirstChild("QuestCraftEvent")
	if questCraftEvent and questCraftEvent:IsA("BindableEvent") then
		questCraftEvent:Fire(player, resultItem, 1)
	end

	print("[SmithingManager]", player.Name, "completed", session.type, ":", resultItem, "XP:", xpGained)
	
	-- Auto-continue if materials available
	if session.type == "smelting" then
		local sameOre = session.sourceItem
		if DataManager.HasItem(player, sameOre, 1) then
			wait(0.1) -- Brief delay then auto-continue
			startSmelting(player, sameOre)
		end
	end
end

function findNearbyFurnace(player)
	local character = player.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") then return nil end

	local position = character.HumanoidRootPart.Position
	local furnaces = workspace:FindFirstChild("SmithingStations")
	if not furnaces then return nil end

	for _, station in ipairs(furnaces:GetChildren()) do
		if station:IsA("Part") and station.Name:find("Furnace") then
			local distance = (station.Position - position).Magnitude
			if distance <= 10 then
				return station
			end
		end
	end
	return nil
end

function findNearbyAnvil(player)
	local character = player.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") then return nil end

	local position = character.HumanoidRootPart.Position
	local anvils = workspace:FindFirstChild("SmithingStations")
	if not anvils then return nil end

	for _, station in ipairs(anvils:GetChildren()) do
		if station:IsA("Part") and station.Name:find("Anvil") then
			local distance = (station.Position - position).Magnitude
			if distance <= 10 then
				return station
			end
		end
	end
	return nil
end

------------------------------------------------------------
-- Update Loop
------------------------------------------------------------
local function updateSmithingSessions()
	local currentTime = tick()

	for player, session in pairs(activeSmithingSessions) do
		local elapsed = currentTime - session.startTime
		local progress = elapsed / session.totalTime

		-- Check if player is still near the station
		local character = player.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			local distance = (character.HumanoidRootPart.Position - session.station.Position).Magnitude
			if distance > 10 then
				-- Player moved too far, cancel
				activeSmithingSessions[player] = nil
				SmithingProgressEvent:FireClient(player, {action = "cancel"})
				-- Return materials
				if session.type == "smelting" then
					DataManager.AddToInventory(player, session.sourceItem, 1)
				else
					DataManager.AddToInventory(player, session.sourceItem, session.recipe.bars)
				end
				local data = DataManager:GetData(player); if data and data.Inventory then InventoryUpdateEvent:FireClient(player, data.Inventory) end
				continue
			end
		end

		if progress >= 1 then
			completeSmithing(player, session)
			activeSmithingSessions[player] = nil
		else
			SmithingProgressEvent:FireClient(player, {
				action = "progress",
				progress = progress
			})
		end
	end
end

RunService.Heartbeat:Connect(updateSmithingSessions)

------------------------------------------------------------
-- Event Handlers
------------------------------------------------------------
StartSmithingEvent.OnServerEvent:Connect(function(player, actionType, sourceItem, targetItem)
	if actionType == "smelt" then
		startSmelting(player, sourceItem)
	elseif actionType == "smith" then
		startSmithing(player, sourceItem, targetItem)
	end
end)

Players.PlayerRemoving:Connect(function(player)
	activeSmithingSessions[player] = nil
end)

print("[SmithingManager] Smithing system initialized")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="159">
      <Properties>
        <string name="Name">SpawnManager</string>
        <token name="RunContext">0</token>
        <string name="Source">--[[
	SpawnManager.server.lua
	Simple player spawning system - just handles spawn position.
	No inventory, no data, no complexity. Just spawn at Haven.
]]

local Players = game:GetService("Players")

-- Haven spawn position (safe zone)
local SPAWN_POSITION = Vector3.new(0, 15, 0)

-- Handle player joining
Players.PlayerAdded:Connect(function(player)
	-- Handle character spawning
	player.CharacterAdded:Connect(function(character)
		-- Wait for HumanoidRootPart
		local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 10)
		
		if humanoidRootPart then
			-- Small delay to ensure character is fully loaded
			task.wait(0.2)
			
			-- Set spawn position at Haven
			humanoidRootPart.CFrame = CFrame.new(SPAWN_POSITION)
			
			print("[SpawnManager] Spawned " .. player.Name .. " at Haven (" .. tostring(SPAWN_POSITION) .. ")")
		else
			warn("[SpawnManager] Failed to find HumanoidRootPart for " .. player.Name)
		end
	end)
	
	print("[SpawnManager] " .. player.Name .. " connected")
end)

print("[SpawnManager] Ready - players will spawn at", SPAWN_POSITION)</string>
      </Properties>
    </Item>
    <Item class="Script" referent="160">
      <Properties>
        <string name="Name">StatsPanelHandler</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	StatsPanelHandler.server.lua
	Handles GetStatsPanel RemoteFunction + GetSkillData RemoteFunction
	Returns player skills, inventory, equipment, and combat level
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DataManager = require(ReplicatedStorage.Modules.DataManager)
local Config = require(ReplicatedStorage.Modules.Config)
local ItemDatabase = require(ReplicatedStorage.Modules.ItemDatabase)

-- Wait for remotes (no delay â€” register handlers ASAP)
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
local GetStatsPanel = Remotes:WaitForChild("GetStatsPanel", 10)
local GetSkillData = Remotes:WaitForChild("GetSkillData", 10)

--------------------------------------------------------------------------------
-- SKILL NAMES
--------------------------------------------------------------------------------
local SKILL_NAMES = {"Mining", "Woodcutting", "Fishing", "Smithing", "Cooking", "Strength", "Defense", "Ranged", "Fletching", "Prayer"}

--------------------------------------------------------------------------------
-- GetStatsPanel â†’ returns full panel data
--------------------------------------------------------------------------------
if GetStatsPanel then
	GetStatsPanel.OnServerInvoke = function(player)
		local data = DataManager:GetData(player)
		if not data then return nil end

		-- Skills (return flat level numbers â€” client expects numbers not tables)
		local skills = {}
		for _, skillName in SKILL_NAMES do
			local level = 1
			if data.Skills and data.Skills[skillName] ~= nil then
				level = Config.GetLevelFromXP(data.Skills[skillName])
			end
			skills[skillName] = level
		end

		-- Inventory (format for client: {name, count, rarity})
		-- DataManager stores Inventory as array of {name=, quantity=}
		local inventory = {}
		local inv = data.Inventory or {}
		for _, slot in ipairs(inv) do
			if slot.name and slot.quantity and slot.quantity > 0 then
				local itemDef = ItemDatabase.Items[slot.name]
				local rarity = "common"
				local itemType = "resource"
				if itemDef then
					rarity = itemDef.rarity or "common"
					itemType = itemDef.type or "resource"
				end
				table.insert(inventory, {
					name = slot.name,
					count = slot.quantity,
					rarity = rarity,
					itemType = itemType,
				})
			end
		end

		-- Equipment (placeholder â€” expand when equip system is built)
		local equipment = data.Equipment or {
			Head = "",
			Body = "",
			Legs = "",
			Weapon = "",
			Shield = "",
		}

		-- Combat level (simple: average of all skill levels, or dedicated combat level)
		local combatLevel = data.CombatLevel or 1
		if not data.CombatLevel then
			local total = 0
			local count = 0
			for _, lvl in pairs(skills) do
				total = total + lvl
				count = count + 1
			end
			combatLevel = math.floor(total / math.max(count, 1))
		end

		-- Gold
		local gold = data.Gold or 0

		-- Sanitize hotbar (only strings/numbers allowed through remotes)
		local hotbar = {}
		if data.Hotbar then
			for i, v in pairs(data.Hotbar) do
				if type(v) == "string" or type(v) == "number" then
					hotbar[i] = v
				end
			end
		end

		return {
			skills = skills,
			inventory = inventory,
			equipment = equipment,
			combatLevel = combatLevel,
			gold = gold,
			hotbar = hotbar,
		}
	end
	print("[StatsPanelHandler] GetStatsPanel ready")
end

--------------------------------------------------------------------------------
-- GetSkillData â†’ returns skill tree data (for SkillTreeUI)
--------------------------------------------------------------------------------
if GetSkillData then
	GetSkillData.OnServerInvoke = function(player)
		local data = DataManager:GetData(player)
		if not data then return nil end

		local skills = {}
		for _, skillName in SKILL_NAMES do
			local level = 1
			local xp = 0
			if data.Skills and data.Skills[skillName] ~= nil then
				xp = data.Skills[skillName]
				level = Config.GetLevelFromXP(xp)
			end
			skills[skillName] = {
				level = level,
				xp = xp,
			}
		end
		return skills
	end
	print("[StatsPanelHandler] GetSkillData ready")
end
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="161">
      <Properties>
        <string name="Name">TradeManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	TradeManager.server.lua
	Server-side trading system for a RuneScape-inspired full-loot PvP MMO.
	Handles trade requests, validation, item swapping, and timeouts.
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Get Remotes folder and remote events
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
local remotes = {
	TradeRequest = Remotes:WaitForChild("TradeRequest", 10),
	TradeUpdate = Remotes:WaitForChild("TradeUpdate", 10),
	TradeAccept = Remotes:WaitForChild("TradeAccept", 10),
	TradeCancel = Remotes:WaitForChild("TradeCancel", 10)
}

-- DataManager module for inventory operations
local DataManager = require(ReplicatedStorage:WaitForChild("Modules", 5):WaitForChild("DataManager", 5))

--------------------------------------------------------------------------------
-- Types & State
--------------------------------------------------------------------------------

-- TradeSession structure: {
--   player1, player2,
--   items1, items2,
--   confirmed1, confirmed2,
--   lastActivity
-- }

-- Active trades keyed by a canonical trade ID (sorted UserId pair)
local activeTrades = {}

-- Map each player to their current trade ID (one trade at a time)
local playerTrade = {}

-- Pending trade requests: requester -> target UserId
local pendingRequests = {}

local TRADE_TIMEOUT = 60  -- seconds of inactivity before auto-cancel
local WILDERNESS_Z_THRESHOLD = -100

--------------------------------------------------------------------------------
-- Helpers
--------------------------------------------------------------------------------

--- Build a deterministic trade ID from two players.
local function tradeId(p1, p2)
	local a, b = math.min(p1.UserId, p2.UserId), math.max(p1.UserId, p2.UserId)
	return `{a}_{b}`
end

--- Check if a player is in the wilderness (Z < -100).
local function isInWilderness(player)
	local char = player.Character
	if not char then return true end
	local root = char:FindFirstChild("HumanoidRootPart")
	if not root then return true end
	return root.Position.Z < WILDERNESS_Z_THRESHOLD
end

--- Validate that a player actually owns all offered items.
local function validateItems(player, items)
	local data = DataManager:GetData(player)
	if not data then return false end
	local inventory = data.Inventory or data.inventory or {}
	for itemName, qty in items do
		if qty <= 0 then return false end
		local owned = inventory[itemName] or 0
		if owned < qty then return false end
	end
	return true
end

--- Send a trade state snapshot to both players.
local function broadcastTradeState(session)
	local payload = {
		items1 = session.items1,
		items2 = session.items2,
		confirmed1 = session.confirmed1,
		confirmed2 = session.confirmed2,
		partner1 = session.player1.Name,
		partner2 = session.player2.Name,
	}
	remotes.TradeUpdate:FireClient(session.player1, payload)
	remotes.TradeUpdate:FireClient(session.player2, payload)
end

--- Cancel and clean up a trade session.
local function cancelTrade(id, reason)
	local session = activeTrades[id]
	if not session then return end

	activeTrades[id] = nil
	playerTrade[session.player1.UserId] = nil
	playerTrade[session.player2.UserId] = nil

	local msg = reason or "Trade cancelled."
	pcall(function() remotes.TradeCancel:FireClient(session.player1, msg) end)
	pcall(function() remotes.TradeCancel:FireClient(session.player2, msg) end)
end

--- Execute a confirmed trade: swap items between players.
local function executeTrade(id)
	local session = activeTrades[id]
	if not session then return end

	local p1, p2 = session.player1, session.player2

	-- Final validation
	if isInWilderness(p1) or isInWilderness(p2) then
		cancelTrade(id, "Cannot trade in the Wilderness!")
		return
	end
	if not validateItems(p1, session.items1) then
		cancelTrade(id, `{p1.Name} no longer has the offered items.`)
		return
	end
	if not validateItems(p2, session.items2) then
		cancelTrade(id, `{p2.Name} no longer has the offered items.`)
		return
	end

	-- Remove items from both players
	for itemName, qty in session.items1 do
		DataManager.RemoveFromInventory(p1, itemName, qty)
	end
	for itemName, qty in session.items2 do
		DataManager.RemoveFromInventory(p2, itemName, qty)
	end

	-- Add swapped items
	for itemName, qty in session.items1 do
		DataManager.AddToInventory(p2, itemName, qty)
	end
	for itemName, qty in session.items2 do
		DataManager.AddToInventory(p1, itemName, qty)
	end

	-- Clean up and notify
	activeTrades[id] = nil
	playerTrade[p1.UserId] = nil
	playerTrade[p2.UserId] = nil

	local summary = { items1 = session.items1, items2 = session.items2 }
	pcall(function() remotes.TradeComplete:FireClient(p1, summary) end)
	pcall(function() remotes.TradeComplete:FireClient(p2, summary) end)

	print(`[TradeManager] Trade completed: {p1.Name} <-> {p2.Name}`)
end

--------------------------------------------------------------------------------
-- Remote Event Handlers
--------------------------------------------------------------------------------

-- TradeRequest: player requests to trade with targetPlayer (by UserId)
remotes.TradeRequest.OnServerEvent:Connect(function(player, targetUserId)
	-- Validate inputs
	if typeof(targetUserId) ~= "number" then return end
	local target = Players:GetPlayerByUserId(targetUserId)
	if not target or target == player then return end

	-- Can't trade if either player is already in a trade
	if playerTrade[player.UserId] then
		remotes.TradeCancel:FireClient(player, "You are already in a trade.")
		return
	end
	if playerTrade[target.UserId] then
		remotes.TradeCancel:FireClient(player, `{target.Name} is already trading.`)
		return
	end

	-- Wilderness check
	if isInWilderness(player) or isInWilderness(target) then
		remotes.TradeCancel:FireClient(player, "Cannot trade in the Wilderness!")
		return
	end

	-- Store pending request and notify target
	pendingRequests[player.UserId] = target.UserId
	remotes.TradeRequest:FireClient(target, player.UserId, player.Name)
	print(`[TradeManager] {player.Name} sent trade request to {target.Name}`)
end)

-- TradeResponse: target accepts or declines a pending request
-- NOTE: Using TradeAccept as TradeResponse since it handles acceptance logic
remotes.TradeAccept.OnServerEvent:Connect(function(player, requesterUserId, accepted)
	if typeof(requesterUserId) ~= "number" or typeof(accepted) ~= "boolean" then return end

	local requester = Players:GetPlayerByUserId(requesterUserId)
	if not requester then return end

	-- Verify the pending request exists and matches
	if pendingRequests[requesterUserId] ~= player.UserId then return end
	pendingRequests[requesterUserId] = nil

	if not accepted then
		remotes.TradeCancel:FireClient(requester, `{player.Name} declined your trade request.`)
		return
	end

	-- Re-check availability
	if playerTrade[player.UserId] or playerTrade[requester.UserId] then
		remotes.TradeCancel:FireClient(requester, "Trade no longer available.")
		remotes.TradeCancel:FireClient(player, "Trade no longer available.")
		return
	end

	-- Create the trade session
	local id = tradeId(requester, player)
	local session = {
		player1 = requester,
		player2 = player,
		items1 = {},
		items2 = {},
		confirmed1 = false,
		confirmed2 = false,
		lastActivity = os.clock(),
	}
	activeTrades[id] = session
	playerTrade[requester.UserId] = id
	playerTrade[player.UserId] = id

	broadcastTradeState(session)
	print(`[TradeManager] Trade started: {requester.Name} <-> {player.Name}`)
end)

-- TradeUpdate: player adds or removes an item from their offer
-- payload: { action = "add" | "remove", item = string, quantity = number }
remotes.TradeUpdate.OnServerEvent:Connect(function(player, payload)
	if typeof(payload) ~= "table" then return end

	local id = playerTrade[player.UserId]
	if not id then return end
	local session = activeTrades[id]
	if not session then return end

	local action = payload.action
	local itemName = payload.item
	local qty = payload.quantity

	if typeof(action) ~= "string" or typeof(itemName) ~= "string" or typeof(qty) ~= "number" then return end
	qty = math.floor(qty)
	if qty <= 0 then return end

	-- Determine which side this player is on
	local items = if player == session.player1 then session.items1 else session.items2

	if action == "add" then
		items[itemName] = (items[itemName] or 0) + qty
		-- Validate the total offered doesn't exceed owned
		if not validateItems(player, if player == session.player1 then session.items1 else session.items2) then
			items[itemName] = items[itemName] - qty
			if items[itemName] <= 0 then items[itemName] = nil end
			return
		end
	elseif action == "remove" then
		if not items[itemName] then return end
		items[itemName] = math.max(0, items[itemName] - qty)
		if items[itemName] <= 0 then items[itemName] = nil end
	else
		return
	end

	-- Any item change resets both confirmations
	session.confirmed1 = false
	session.confirmed2 = false
	session.lastActivity = os.clock()

	broadcastTradeState(session)
end)

-- TradeConfirm: player confirms their side of the trade
remotes.TradeAccept.OnServerEvent:Connect(function(player)
	local id = playerTrade[player.UserId]
	if not id then return end
	local session = activeTrades[id]
	if not session then return end

	if player == session.player1 then
		session.confirmed1 = true
	else
		session.confirmed2 = true
	end
	session.lastActivity = os.clock()

	broadcastTradeState(session)

	-- If both confirmed, execute
	if session.confirmed1 and session.confirmed2 then
		executeTrade(id)
	end
end)

-- TradeCancel: player cancels the trade
remotes.TradeCancel.OnServerEvent:Connect(function(player)
	local id = playerTrade[player.UserId]
	if not id then return end
	cancelTrade(id, `{player.Name} cancelled the trade.`)
end)

--------------------------------------------------------------------------------
-- Timeout Loop
--------------------------------------------------------------------------------

RunService.Heartbeat:Connect(function()
	local now = os.clock()
	for id, session in activeTrades do
		if now - session.lastActivity >= TRADE_TIMEOUT then
			cancelTrade(id, "Trade timed out due to inactivity.")
		end
	end
end)

--------------------------------------------------------------------------------
-- Player cleanup on disconnect
--------------------------------------------------------------------------------

Players.PlayerRemoving:Connect(function(player)
	-- Cancel active trade
	local id = playerTrade[player.UserId]
	if id then
		cancelTrade(id, `{player.Name} disconnected.`)
	end
	-- Clear pending requests
	pendingRequests[player.UserId] = nil
end)

print("[TradeManager] Trade system active!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="162">
      <Properties>
        <string name="Name">TutorialManager</string>
        <token name="RunContext">0</token>
        <string name="Source">-- TutorialManager.server.lua
-- Tutorial/onboarding system for Wilderness MMO

print("[TutorialManager] Starting...")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Wait for dependencies with timeouts
local Modules = ReplicatedStorage:WaitForChild("Modules", 10)
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)

-- Load required modules
local DataManager = require(Modules:WaitForChild("DataManager", 10))

-- Get remotes
local TutorialStep = Remotes:WaitForChild("TutorialStep", 5)
local TutorialComplete = Remotes:WaitForChild("TutorialComplete", 5)
local TutorialSkip = Remotes:WaitForChild("TutorialSkip", 5)

-- Validate remotes
if not TutorialStep or not TutorialComplete or not TutorialSkip then
	warn("[TutorialManager] Missing remotes!")
	return
end

-- Tutorial steps
local TUTORIAL_STEPS = {
	{
		id = "welcome",
		title = "Welcome to Wilderness!",
		description = "Welcome to the world of Wilderness! Let's get you started on your adventure.",
		action = "none",
		uiElement = nil,
		duration = 5
	},
	{
		id = "movement",
		title = "Movement",
		description = "Use WASD keys to move around. Try walking to the marked area.",
		action = "move_to",
		targetPosition = Vector3.new(10, 0, 10),
		radius = 10,
		uiElement = nil,
		duration = 0
	},
	{
		id = "inventory",
		title = "Inventory",
		description = "Press I to open your inventory. This is where you store items.",
		action = "open_ui",
		uiElement = "Inventory",
		key = Enum.KeyCode.I,
		duration = 0
	},
	{
		id = "equip_weapon",
		title = "Equip Weapon",
		description = "Drag the Bronze Sword from your inventory to the equipment slot.",
		action = "equip_item",
		itemName = "Bronze Sword",
		uiElement = "Equipment",
		duration = 0
	},
	{
		id = "attack_monster",
		title = "Combat",
		description = "Left-click on a Goblin to attack. Defeat it to continue.",
		action = "kill_monster",
		monsterType = "Goblin",
		uiElement = nil,
		duration = 0
	},
	{
		id = "pickup_loot",
		title = "Loot",
		description = "Walk over the loot that dropped from the Goblin to pick it up.",
		action = "pickup_item",
		itemName = "Bones",
		uiElement = nil,
		duration = 0
	},
	{
		id = "skills_panel",
		title = "Skills",
		description = "Press K to open your skills panel. This shows your skill levels.",
		action = "open_ui",
		uiElement = "Skills",
		key = Enum.KeyCode.K,
		duration = 0
	},
	{
		id = "complete",
		title = "Tutorial Complete!",
		description = "Great job! You've learned the basics. Now go explore the world!",
		action = "none",
		uiElement = nil,
		duration = 5
	}
}

-- Player tutorial state
local playerTutorials = {}

-- Helper function to get player tutorial state
local function getPlayerTutorialState(player)
	if not player then return nil end
	
	if not playerTutorials[player.UserId] then
		-- Load from player data
		local data = DataManager:GetData(player)
		playerTutorials[player.UserId] = {
			completed = data.tutorialCompleted or false,
			currentStep = data.tutorialStep or 1,
			stepProgress = data.tutorialStepProgress or {}
		}
	end
	
	return playerTutorials[player.UserId]
end

-- Helper function to save player tutorial state
local function savePlayerTutorialState(player)
	if not player then return end
	
	local state = playerTutorials[player.UserId]
	if state then
		DataManager.UpdatePlayerData(player, {
			tutorialCompleted = state.completed,
			tutorialStep = state.currentStep,
			tutorialStepProgress = state.stepProgress
		})
	end
end

-- Function to start tutorial for player
local function startTutorial(player)
	local state = getPlayerTutorialState(player)
	if not state then return end
	
	if state.completed then
		-- Tutorial already completed
		return
	end
	
	-- Reset to step 1
	state.currentStep = 1
	state.stepProgress = {}
	
	-- Send first step
	sendTutorialStep(player, 1)
	
	print("[TutorialManager] Started tutorial for " .. player.Name)
end

-- Function to send tutorial step to player
local function sendTutorialStep(player, stepIndex)
	if not player or stepIndex &lt; 1 or stepIndex > #TUTORIAL_STEPS then return end
	
	local step = TUTORIAL_STEPS[stepIndex]
	local state = getPlayerTutorialState(player)
	
	if not state then return end
	
	-- Update current step
	state.currentStep = stepIndex
	state.stepProgress[stepIndex] = state.stepProgress[stepIndex] or {
		started = os.time(),
		completed = false
	}
	
	-- Send step to client
	TutorialStep:FireClient(player, {
		step = stepIndex,
		totalSteps = #TUTORIAL_STEPS,
		title = step.title,
		description = step.description,
		action = step.action,
		targetPosition = step.targetPosition,
		radius = step.radius,
		uiElement = step.uiElement,
		key = step.key,
		itemName = step.itemName,
		monsterType = step.monsterType,
		duration = step.duration
	})
	
	-- Auto-complete duration-based steps
	if step.duration > 0 then
		task.delay(step.duration, function()
			if player and playerTutorials[player.UserId] and state.currentStep == stepIndex then
				completeTutorialStep(player, stepIndex)
			end
		end)
	end
	
	savePlayerTutorialState(player)
end

-- Function to complete tutorial step
local function completeTutorialStep(player, stepIndex)
	if not player or stepIndex &lt; 1 or stepIndex > #TUTORIAL_STEPS then return end
	
	local state = getPlayerTutorialState(player)
	if not state then return end
	
	-- Mark step as completed
	state.stepProgress[stepIndex] = state.stepProgress[stepIndex] or {}
	state.stepProgress[stepIndex].completed = true
	state.stepProgress[stepIndex].completedTime = os.time()
	
	-- Move to next step or complete tutorial
	if stepIndex &lt; #TUTORIAL_STEPS then
		sendTutorialStep(player, stepIndex + 1)
	else
		completeTutorial(player)
	end
	
	savePlayerTutorialState(player)
end

-- Function to complete entire tutorial
local function completeTutorial(player)
	local state = getPlayerTutorialState(player)
	if not state then return end
	
	state.completed = true
	state.currentStep = #TUTORIAL_STEPS
	
	-- Send completion
	TutorialComplete:FireClient(player, {
		completedSteps = #TUTORIAL_STEPS,
		totalSteps = #TUTORIAL_STEPS
	})
	
	-- Give tutorial reward
	DataManager.AddItem(player, "Bronze Sword", 1)
	DataManager.AddItem(player, "Bronze Pickaxe", 1)
	DataManager.AddItem(player, "Bronze Axe", 1)
	DataManager.AddGold(player, 100)
	
	savePlayerTutorialState(player)
	print("[TutorialManager] Tutorial completed for " .. player.Name)
end

-- Function to skip tutorial
local function skipTutorial(player)
	local state = getPlayerTutorialState(player)
	if not state then return end
	
	state.completed = true
	state.currentStep = #TUTORIAL_STEPS
	
	-- Send skip confirmation
	TutorialComplete:FireClient(player, {
		skipped = true,
		completedSteps = 0,
		totalSteps = #TUTORIAL_STEPS
	})
	
	-- Give tutorial reward (even when skipped)
	DataManager.AddItem(player, "Bronze Sword", 1)
	DataManager.AddItem(player, "Bronze Pickaxe", 1)
	DataManager.AddItem(player, "Bronze Axe", 1)
	DataManager.AddGold(player, 100)
	
	savePlayerTutorialState(player)
	print("[TutorialManager] Tutorial skipped for " .. player.Name)
end

-- Handle tutorial step completion from client
TutorialStep.OnServerEvent:Connect(function(player, stepIndex, success, data)
	if not player then return end
	
	local state = getPlayerTutorialState(player)
	if not state or state.completed or state.currentStep ~= stepIndex then return end
	
	if success then
		completeTutorialStep(player, stepIndex)
	else
		-- Step failed, retry or provide feedback
		print("[TutorialManager] Step " .. tostring(stepIndex) .. " failed for " .. player.Name)
	end
end)

-- Handle tutorial skip
TutorialSkip.OnServerEvent:Connect(function(player)
	if not player then return end
	
	skipTutorial(player)
end)

-- Handle player joined
Players.PlayerAdded:Connect(function(player)
	-- Wait for player data to load
	task.wait(2)
	
	local state = getPlayerTutorialState(player)
	if not state then return end
	
	if not state.completed then
		-- Start tutorial or resume from saved step
		if state.currentStep > 0 and state.currentStep &lt;= #TUTORIAL_STEPS then
			-- Resume from saved step
			sendTutorialStep(player, state.currentStep)
		else
			-- Start new tutorial
			startTutorial(player)
		end
	end
end)

-- Clean up on player leave
Players.PlayerRemoving:Connect(function(player)
	playerTutorials[player.UserId] = nil
end)

-- Public API for other systems to check tutorial progress
local TutorialManager = {
	IsTutorialCompleted = function(player)
		local state = getPlayerTutorialState(player)
		return state and state.completed
	end,
	
	GetCurrentStep = function(player)
		local state = getPlayerTutorialState(player)
		return state and state.currentStep or 0
	end,
	
	CompleteStep = function(player, stepId)
		-- Find step by ID
		for i, step in ipairs(TUTORIAL_STEPS) do
			if step.id == stepId then
				completeTutorialStep(player, i)
				return true
			end
		end
		return false
	end
}

-- Initialize
print("[TutorialManager] Ready with " .. tostring(#TUTORIAL_STEPS) .. " steps!")

return TutorialManager</string>
      </Properties>
    </Item>
    <Item class="Script" referent="163">
      <Properties>
        <string name="Name">VisualEquipment</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local DataManager = require(ReplicatedStorage:WaitForChild("Modules", 5):WaitForChild("DataManager", 5))

-- Create a BindableEvent for other scripts to signal equipment changes
local equipChanged = Instance.new("BindableEvent")
equipChanged.Name = "EquipmentChanged"
equipChanged.Parent = ReplicatedStorage

-- Also listen to the equip/unequip remotes directly
local equipItemEvent = ReplicatedStorage:FindFirstChild("EquipItem") or (ReplicatedStorage:FindFirstChild("Remotes") and ReplicatedStorage.Remotes:FindFirstChild("EquipItem"))
local unequipItemEvent = ReplicatedStorage:FindFirstChild("UnequipItem") or (ReplicatedStorage:FindFirstChild("Remotes") and ReplicatedStorage.Remotes:FindFirstChild("UnequipItem"))

if not equipItemEvent then
	equipItemEvent = ReplicatedStorage:WaitForChild("EquipItem", 15)
end
if not unequipItemEvent then
	unequipItemEvent = ReplicatedStorage:WaitForChild("UnequipItem", 15)
end

--------------------------------------------------------------------------------
-- Helpers
--------------------------------------------------------------------------------

local function clearVisual(character, tag)
	for _, child in ipairs(character:GetChildren()) do
		if child.Name == tag then
			child:Destroy()
		end
	end
end

local function clearBodyColors(character, partNames)
	for _, name in ipairs(partNames) do
		local part = character:FindFirstChild(name)
		if part and part:IsA("BasePart") then
			local orig = part:FindFirstChild("_OriginalColor")
			if orig then
				part.Color = Color3.new(orig.Value.X, orig.Value.Y, orig.Value.Z)
			end
		end
	end
end

local function saveOriginalColor(part)
	if not part:FindFirstChild("_OriginalColor") then
		local v = Instance.new("Vector3Value")
		v.Name = "_OriginalColor"
		v.Value = Vector3.new(part.Color.R, part.Color.G, part.Color.B)
		v.Parent = part
	end
end

local function createAttachedPart(character, attachTo, tag, size, color, offset)
	clearVisual(character, tag)
	local limb = character:FindFirstChild(attachTo)
	if not limb then return nil end

	local part = Instance.new("Part")
	part.Name = tag
	part.Size = size
	part.Color = color
	part.Material = Enum.Material.SmoothPlastic
	part.CanCollide = false
	part.Massless = true
	part.Anchored = false
	part.CFrame = limb.CFrame * offset
	part.Parent = character

	local weld = Instance.new("WeldConstraint")
	weld.Part0 = limb
	weld.Part1 = part
	weld.Parent = part

	return part
end

-- Create a part welded to another part (not the limb directly)
local function createSubPart(parent, rootPart, name, size, color, offset, material)
	local part = Instance.new("Part")
	part.Name = name
	part.Size = size
	part.Color = color
	part.Material = material or Enum.Material.SmoothPlastic
	part.CanCollide = false
	part.Massless = true
	part.Anchored = false
	part.CFrame = rootPart.CFrame * offset
	part.Parent = parent

	local weld = Instance.new("WeldConstraint")
	weld.Part0 = rootPart
	weld.Part1 = part
	weld.Parent = part

	return part
end

-- Create a multi-part model welded to a limb, tagged with tag
local function createModelOnLimb(character, attachTo, tag, builderFn, skipFlip)
	clearVisual(character, tag)
	local limb = character:FindFirstChild(attachTo)
	if not limb then return nil end

	local model = Instance.new("Model")
	model.Name = tag
	model.Parent = character

	local rootPart = builderFn(model, limb)
	if rootPart then
		if skipFlip then
			-- Helmets/shields: position directly on limb without weapon flip
			rootPart.CFrame = limb.CFrame * rootPart.CFrame
		else
			-- Weapons: Flip 180 on Z so blade points UP (away from hand), not down
			rootPart.CFrame = limb.CFrame * CFrame.Angles(0, 0, math.rad(180)) * rootPart.CFrame
		end
		local weld = Instance.new("WeldConstraint")
		weld.Part0 = limb
		weld.Part1 = rootPart
		weld.Parent = rootPart
	end

	return model
end

-- Utility: add PointLight to a part
local function addGlow(part, color, brightness, range)
	local light = Instance.new("PointLight")
	light.Color = color or part.Color
	light.Brightness = brightness or 1.5
	light.Range = range or 8
	light.Parent = part
end

-- Utility: add fire effect
local function addFire(part, color, secondColor, size)
	local fire = Instance.new("Fire")
	fire.Color = color or Color3.fromRGB(255, 80, 20)
	fire.SecondaryColor = secondColor or Color3.fromRGB(255, 160, 40)
	fire.Size = size or 3
	fire.Heat = 5
	fire.Parent = part
end

-- Utility: add sparkle/particle
local function addSparkles(part, color)
	local sparkle = Instance.new("Sparkles")
	sparkle.SparkleColor = color or part.Color
	sparkle.Parent = part
end

--------------------------------------------------------------------------------
-- WEAPON BUILDERS (multi-part swords)
--------------------------------------------------------------------------------

local function buildCopperSword(model, limb)
	-- Handle at hand position, blade extends downward
	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Size = Vector3.new(0.18, 0.9, 0.18)
	handle.Color = Color3.fromRGB(90, 55, 20)
	handle.Material = Enum.Material.Wood
	handle.CanCollide = false
	handle.Massless = true
	handle.Anchored = false
	handle.CFrame = CFrame.new(0, 0, 0)
	handle.Parent = model

	-- Pommel (top of handle, above hand)
	local pommel = createSubPart(model, handle, "Pommel",
		Vector3.new(0.25, 0.2, 0.25), Color3.fromRGB(160, 90, 35),
		CFrame.new(0, 0.55, 0), Enum.Material.Metal)

	-- Crossguard (below hand)
	local guard = createSubPart(model, handle, "Crossguard",
		Vector3.new(0.7, 0.15, 0.25), Color3.fromRGB(160, 90, 35),
		CFrame.new(0, -0.5, 0), Enum.Material.Metal)

	-- Blade (extends down from crossguard)
	local blade = createSubPart(model, handle, "Blade",
		Vector3.new(0.22, 2.2, 0.1), Color3.fromRGB(190, 115, 50),
		CFrame.new(0, -1.7, 0), Enum.Material.Metal)
	blade.Reflectance = 0.15

	return handle
end

local function buildIronSword(model, limb)
	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Size = Vector3.new(0.18, 1.0, 0.18)
	handle.Color = Color3.fromRGB(70, 45, 20)
	handle.Material = Enum.Material.Fabric
	handle.CanCollide = false
	handle.Massless = true
	handle.Anchored = false
	handle.CFrame = CFrame.new(0, 0, 0)
	handle.Parent = model

	local pommel = createSubPart(model, handle, "Pommel",
		Vector3.new(0.28, 0.22, 0.28), Color3.fromRGB(140, 140, 150),
		CFrame.new(0, 0.6, 0), Enum.Material.Metal)

	local guard = createSubPart(model, handle, "Crossguard",
		Vector3.new(0.9, 0.16, 0.28), Color3.fromRGB(160, 160, 170),
		CFrame.new(0, -0.55, 0), Enum.Material.Metal)

	local blade = createSubPart(model, handle, "Blade",
		Vector3.new(0.28, 2.8, 0.1), Color3.fromRGB(190, 190, 200),
		CFrame.new(0, -2.0, 0), Enum.Material.Metal)
	blade.Reflectance = 0.25

	return handle
end

local function buildSteelSword(model, limb)
	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Size = Vector3.new(0.18, 1.0, 0.18)
	handle.Color = Color3.fromRGB(60, 40, 22)
	handle.Material = Enum.Material.Fabric
	handle.CanCollide = false
	handle.Massless = true
	handle.Anchored = false
	handle.CFrame = CFrame.new(0, 0, 0)
	handle.Parent = model

	local pommel = createSubPart(model, handle, "Pommel",
		Vector3.new(0.3, 0.22, 0.3), Color3.fromRGB(130, 130, 145),
		CFrame.new(0, 0.6, 0), Enum.Material.Metal)

	local guard = createSubPart(model, handle, "Crossguard",
		Vector3.new(1.0, 0.18, 0.3), Color3.fromRGB(140, 140, 155),
		CFrame.new(0, -0.55, 0), Enum.Material.Metal)

	local blade = createSubPart(model, handle, "Blade",
		Vector3.new(0.3, 3.0, 0.1), Color3.fromRGB(170, 170, 185),
		CFrame.new(0, -2.1, 0), Enum.Material.Metal)
	blade.Reflectance = 0.4

	-- Fuller (groove detail)
	local fuller = createSubPart(model, blade, "Fuller",
		Vector3.new(0.1, 2.4, 0.12), Color3.fromRGB(130, 130, 145),
		CFrame.new(0, 0.1, 0), Enum.Material.Metal)
	fuller.Reflectance = 0.2

	return handle
end

local function buildGoldSword(model, limb)
	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Size = Vector3.new(0.2, 1.0, 0.2)
	handle.Color = Color3.fromRGB(80, 40, 15)
	handle.Material = Enum.Material.Fabric
	handle.CanCollide = false
	handle.Massless = true
	handle.Anchored = false
	handle.CFrame = CFrame.new(0, 0, 0)
	handle.Parent = model

	-- Pommel with gem (above hand)
	local pommel = createSubPart(model, handle, "Pommel",
		Vector3.new(0.35, 0.25, 0.35), Color3.fromRGB(255, 200, 50),
		CFrame.new(0, 0.62, 0), Enum.Material.Metal)
	pommel.Reflectance = 0.3

	local gem = createSubPart(model, pommel, "Gem",
		Vector3.new(0.15, 0.15, 0.15), Color3.fromRGB(200, 20, 20),
		CFrame.new(0, 0.1, 0), Enum.Material.Neon)

	local guard = createSubPart(model, handle, "Crossguard",
		Vector3.new(1.2, 0.2, 0.32), Color3.fromRGB(255, 200, 50),
		CFrame.new(0, -0.55, 0), Enum.Material.Metal)
	guard.Reflectance = 0.3

	local blade = createSubPart(model, handle, "Blade",
		Vector3.new(0.32, 3.0, 0.12), Color3.fromRGB(255, 210, 70),
		CFrame.new(0, -2.1, 0), Enum.Material.Metal)
	blade.Reflectance = 0.35

	return handle
end

local function buildRuniteSword(model, limb)
	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Size = Vector3.new(0.2, 1.1, 0.2)
	handle.Color = Color3.fromRGB(30, 80, 80)
	handle.Material = Enum.Material.Fabric
	handle.CanCollide = false
	handle.Massless = true
	handle.Anchored = false
	handle.CFrame = CFrame.new(0, 0, 0)
	handle.Parent = model

	local pommel = createSubPart(model, handle, "Pommel",
		Vector3.new(0.32, 0.25, 0.32), Color3.fromRGB(0, 180, 180),
		CFrame.new(0, 0.65, 0), Enum.Material.Glass)
	pommel.Transparency = 0.3

	local guard = createSubPart(model, handle, "Crossguard",
		Vector3.new(1.1, 0.2, 0.3), Color3.fromRGB(0, 200, 200),
		CFrame.new(0, -0.6, 0), Enum.Material.Glass)
	guard.Transparency = 0.2

	local blade = createSubPart(model, handle, "Blade",
		Vector3.new(0.32, 3.2, 0.12), Color3.fromRGB(0, 210, 210),
		CFrame.new(0, -2.3, 0), Enum.Material.Glass)
	blade.Transparency = 0.15
	blade.Reflectance = 0.3
	addGlow(blade, Color3.fromRGB(0, 220, 220), 2, 12)
	addSparkles(blade, Color3.fromRGB(0, 255, 255))

	return handle
end

local function buildDragonSword(model, limb)
	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Size = Vector3.new(0.22, 1.2, 0.22)
	handle.Color = Color3.fromRGB(30, 10, 10)
	handle.Material = Enum.Material.Fabric
	handle.CanCollide = false
	handle.Massless = true
	handle.Anchored = false
	handle.CFrame = CFrame.new(0, 0, 0)
	handle.Parent = model

	local pommel = createSubPart(model, handle, "Pommel",
		Vector3.new(0.35, 0.28, 0.35), Color3.fromRGB(200, 30, 30),
		CFrame.new(0, 0.7, 0), Enum.Material.Metal)

	local guard = createSubPart(model, handle, "Crossguard",
		Vector3.new(1.3, 0.22, 0.35), Color3.fromRGB(180, 20, 20),
		CFrame.new(0, -0.65, 0), Enum.Material.Metal)

	-- Main blade (extends downward)
	local blade = createSubPart(model, handle, "Blade",
		Vector3.new(0.35, 3.6, 0.14), Color3.fromRGB(210, 30, 30),
		CFrame.new(0, -2.5, 0), Enum.Material.Metal)
	blade.Reflectance = 0.2

	-- Serrated edges (jagged shapes on both sides)
	for i = 0, 4 do
		local side = (i % 2 == 0) and 1 or -1
		local tooth = createSubPart(model, blade, "Serration" .. i,
			Vector3.new(0.15, 0.3, 0.14), Color3.fromRGB(60, 10, 10),
			CFrame.new(side * 0.2, 1.2 - i * 0.6, 0) * CFrame.Angles(0, 0, math.rad(side * 30)),
			Enum.Material.Metal)
	end

	addGlow(blade, Color3.fromRGB(255, 50, 20), 1.5, 10)
	addFire(blade, Color3.fromRGB(255, 50, 20), Color3.fromRGB(255, 140, 30), 2)

	return handle
end

local WEAPON_BUILDERS = {
	["Copper Sword"] = buildCopperSword,
	["Iron Sword"] = buildIronSword,
	["Steel Sword"] = buildSteelSword,
	["Gold Sword"] = buildGoldSword,
	["Runite Sword"] = buildRuniteSword,
	["Dragon Sword"] = buildDragonSword,
}

--------------------------------------------------------------------------------
-- BOW BUILDERS (attach to back)
--------------------------------------------------------------------------------

local function buildBow(model, limb, limbWidth, color, material, stringColor, stringGlow, height)
	-- Bow grip (center handle)
	local grip = Instance.new("Part")
	grip.Name = "BowGrip"
	grip.Size = Vector3.new(0.18, height * 0.25, 0.35)
	grip.Color = Color3.fromRGB(90, 55, 30) -- darker wood for grip
	grip.Material = Enum.Material.Wood
	grip.CanCollide = false
	grip.Massless = true
	grip.Anchored = false
	grip.CFrame = CFrame.new(0.6, 0, -0.5)
	grip.Parent = model

	-- Upper limb (curved outward)
	local upperLimb = createSubPart(model, grip, "UpperLimb",
		Vector3.new(0.15, height * 0.35, 0.18), color,
		CFrame.new(0, height * 0.3, -0.2) * CFrame.Angles(math.rad(-20), 0, 0),
		material or Enum.Material.Wood)

	-- Lower limb (curved outward)
	local lowerLimb = createSubPart(model, grip, "LowerLimb",
		Vector3.new(0.15, height * 0.35, 0.18), color,
		CFrame.new(0, -height * 0.3, -0.2) * CFrame.Angles(math.rad(20), 0, 0),
		material or Enum.Material.Wood)

	-- Upper limb tip (curves back)
	local upperTip = createSubPart(model, upperLimb, "UpperTip",
		Vector3.new(0.12, height * 0.15, 0.12), color,
		CFrame.new(0, height * 0.2, -0.1) * CFrame.Angles(math.rad(-10), 0, 0),
		material or Enum.Material.Wood)

	-- Lower limb tip (curves back)
	local lowerTip = createSubPart(model, lowerLimb, "LowerTip",
		Vector3.new(0.12, height * 0.15, 0.12), color,
		CFrame.new(0, -height * 0.2, -0.1) * CFrame.Angles(math.rad(10), 0, 0),
		material or Enum.Material.Wood)

	-- Bowstring (connects the tips)
	local str = createSubPart(model, grip, "String",
		Vector3.new(0.03, height * 0.9, 0.03), stringColor or Color3.fromRGB(200, 190, 170),
		CFrame.new(0, 0, -0.25), Enum.Material.Fabric)
	
	-- String nocks (small notches at bow tips)
	local upperNock = createSubPart(model, upperTip, "UpperNock",
		Vector3.new(0.08, 0.1, 0.08), Color3.fromRGB(160, 120, 80),
		CFrame.new(0, height * 0.08, -0.05), Enum.Material.Wood)
	local lowerNock = createSubPart(model, lowerTip, "LowerNock",
		Vector3.new(0.08, 0.1, 0.08), Color3.fromRGB(160, 120, 80),
		CFrame.new(0, -height * 0.08, -0.05), Enum.Material.Wood)

	if stringGlow then
		str.Material = Enum.Material.Neon
		addGlow(str, stringColor, 1, 6)
	end

	return grip
end

local BOW_BUILDERS = {
	["Oak Shortbow"] = function(model, limb)
		return buildBow(model, limb, 0, Color3.fromRGB(160, 120, 60), Enum.Material.Wood, nil, false, 2.5)
	end,
	["Willow Longbow"] = function(model, limb)
		return buildBow(model, limb, 0, Color3.fromRGB(140, 110, 50), Enum.Material.Wood, nil, false, 3.5)
	end,
	["Yew Longbow"] = function(model, limb)
		return buildBow(model, limb, 0, Color3.fromRGB(90, 55, 30), Enum.Material.Wood, nil, false, 3.8)
	end,
	["Magic Longbow"] = function(model, limb)
		return buildBow(model, limb, 0, Color3.fromRGB(100, 30, 140), Enum.Material.Wood,
			Color3.fromRGB(180, 80, 255), true, 4.0)
	end,
	["Dragon Crossbow"] = function(model, limb)
		-- Crossbow stock (main body)
		local stock = Instance.new("Part")
		stock.Name = "Stock"
		stock.Size = Vector3.new(0.25, 2.2, 0.4)
		stock.Color = Color3.fromRGB(80, 40, 20) -- dark wood
		stock.Material = Enum.Material.Wood
		stock.CanCollide = false
		stock.Massless = true
		stock.Anchored = false
		stock.CFrame = CFrame.new(0.6, 0, -0.5)
		stock.Parent = model

		-- Shoulder rest (buttstock)
		local buttstock = createSubPart(model, stock, "Buttstock",
			Vector3.new(0.4, 0.6, 0.5), Color3.fromRGB(70, 35, 15),
			CFrame.new(0, -0.8, -0.2), Enum.Material.Wood)

		-- Prod (horizontal crossbow limb)
		local prod = createSubPart(model, stock, "Prod",
			Vector3.new(2.4, 0.15, 0.3), Color3.fromRGB(180, 20, 20),
			CFrame.new(0, 1.0, -0.1), Enum.Material.Metal)

		-- Prod tips (reinforced ends)
		local prodTipL = createSubPart(model, prod, "ProdTipL",
			Vector3.new(0.2, 0.2, 0.35), Color3.fromRGB(160, 15, 15),
			CFrame.new(-1.1, 0, 0), Enum.Material.Metal)
		local prodTipR = createSubPart(model, prod, "ProdTipR",
			Vector3.new(0.2, 0.2, 0.35), Color3.fromRGB(160, 15, 15),
			CFrame.new(1.1, 0, 0), Enum.Material.Metal)

		-- String (connects the prod tips)
		local str = createSubPart(model, prod, "String",
			Vector3.new(2.0, 0.04, 0.04), Color3.fromRGB(100, 15, 15),
			CFrame.new(0, -0.05, 0.15), Enum.Material.Fabric)

		-- Trigger mechanism
		local trigger = createSubPart(model, stock, "Trigger",
			Vector3.new(0.15, 0.3, 0.2), Color3.fromRGB(50, 10, 10),
			CFrame.new(0, 0.3, 0.25), Enum.Material.Metal)

		-- Bolt rail (where bolt sits)
		local rail = createSubPart(model, stock, "BoltRail",
			Vector3.new(0.1, 1.5, 0.15), Color3.fromRGB(140, 130, 120),
			CFrame.new(0, 0.6, 0.18), Enum.Material.Metal)

		-- Stirrup (foot loop for cocking)
		local stirrup = createSubPart(model, stock, "Stirrup",
			Vector3.new(0.8, 0.08, 0.08), Color3.fromRGB(40, 8, 8),
			CFrame.new(0, 1.15, 0.1), Enum.Material.Metal)

		-- Dragon decorative elements
		local dragonHead = createSubPart(model, stock, "DragonHead",
			Vector3.new(0.3, 0.4, 0.3), Color3.fromRGB(200, 30, 30),
			CFrame.new(0, 0.8, 0.22), Enum.Material.Metal)
		
		-- Dragon eyes (glowing)
		local eyeL = createSubPart(model, dragonHead, "DragonEyeL",
			Vector3.new(0.08, 0.08, 0.08), Color3.fromRGB(255, 80, 20),
			CFrame.new(-0.08, 0.05, 0.12), Enum.Material.Neon)
		local eyeR = createSubPart(model, dragonHead, "DragonEyeR",
			Vector3.new(0.08, 0.08, 0.08), Color3.fromRGB(255, 80, 20),
			CFrame.new(0.08, 0.05, 0.12), Enum.Material.Neon)

		addGlow(dragonHead, Color3.fromRGB(255, 40, 20), 0.8, 5)

		return stock
	end,
}

--------------------------------------------------------------------------------
-- SHIELD BUILDERS
--------------------------------------------------------------------------------

local function buildWoodenShield(model, limb)
	-- Main round body (approximate with a slightly wider part)
	local body = Instance.new("Part")
	body.Name = "ShieldBody"
	body.Size = Vector3.new(0.25, 2.0, 1.8)
	body.Color = Color3.fromRGB(150, 100, 45)
	body.Material = Enum.Material.Wood
	body.CanCollide = false
	body.Massless = true
	body.Anchored = false
	body.CFrame = CFrame.new(-0.8, 0, 0)
	body.Parent = model

	-- Iron rim (top)
	local rimTop = createSubPart(model, body, "RimTop",
		Vector3.new(0.27, 0.12, 1.85), Color3.fromRGB(140, 140, 150),
		CFrame.new(0, 1.0, 0), Enum.Material.Metal)
	-- Iron rim (bottom)
	local rimBot = createSubPart(model, body, "RimBot",
		Vector3.new(0.27, 0.12, 1.85), Color3.fromRGB(140, 140, 150),
		CFrame.new(0, -1.0, 0), Enum.Material.Metal)

	-- Boss (center bump)
	local boss = createSubPart(model, body, "Boss",
		Vector3.new(0.3, 0.5, 0.5), Color3.fromRGB(130, 130, 140),
		CFrame.new(-0.15, 0, 0), Enum.Material.Metal)

	return body
end

local function buildIronShield(model, limb)
	-- Kite/heater shape - taller
	local body = Instance.new("Part")
	body.Name = "ShieldBody"
	body.Size = Vector3.new(0.22, 2.5, 1.7)
	body.Color = Color3.fromRGB(180, 180, 190)
	body.Material = Enum.Material.Metal
	body.CanCollide = false
	body.Massless = true
	body.Anchored = false
	body.CFrame = CFrame.new(-0.8, 0, 0)
	body.Parent = model
	body.Reflectance = 0.15

	-- Darker trim border (top and sides)
	local trim = createSubPart(model, body, "Trim",
		Vector3.new(0.24, 2.55, 1.75), Color3.fromRGB(100, 100, 110),
		CFrame.new(-0.02, 0, 0), Enum.Material.Metal)

	-- Boss
	local boss = createSubPart(model, body, "Boss",
		Vector3.new(0.3, 0.55, 0.55), Color3.fromRGB(160, 160, 170),
		CFrame.new(-0.15, 0, 0), Enum.Material.Metal)
	boss.Reflectance = 0.2

	return body
end

local function buildGoldShield(model, limb)
	local body = Instance.new("Part")
	body.Name = "ShieldBody"
	body.Size = Vector3.new(0.22, 2.5, 1.8)
	body.Color = Color3.fromRGB(255, 210, 60)
	body.Material = Enum.Material.Metal
	body.CanCollide = false
	body.Massless = true
	body.Anchored = false
	body.CFrame = CFrame.new(-0.8, 0, 0)
	body.Reflectance = 0.3
	body.Parent = model

	-- Golden trim
	local trim = createSubPart(model, body, "Trim",
		Vector3.new(0.24, 2.55, 1.85), Color3.fromRGB(200, 160, 30),
		CFrame.new(-0.02, 0, 0), Enum.Material.Metal)
	trim.Reflectance = 0.25

	-- Embossed cross pattern
	local cross1 = createSubPart(model, body, "Emboss1",
		Vector3.new(0.25, 2.0, 0.15), Color3.fromRGB(220, 175, 40),
		CFrame.new(-0.03, 0, 0), Enum.Material.Metal)
	local cross2 = createSubPart(model, body, "Emboss2",
		Vector3.new(0.25, 0.15, 1.3), Color3.fromRGB(220, 175, 40),
		CFrame.new(-0.03, 0, 0), Enum.Material.Metal)

	-- Boss with gem
	local boss = createSubPart(model, body, "Boss",
		Vector3.new(0.3, 0.5, 0.5), Color3.fromRGB(255, 220, 80),
		CFrame.new(-0.15, 0, 0), Enum.Material.Metal)
	boss.Reflectance = 0.35

	return body
end

local function buildRuniteShield(model, limb)
	local body = Instance.new("Part")
	body.Name = "ShieldBody"
	body.Size = Vector3.new(0.22, 2.6, 1.8)
	body.Color = Color3.fromRGB(0, 190, 190)
	body.Material = Enum.Material.Glass
	body.CanCollide = false
	body.Massless = true
	body.Anchored = false
	body.Transparency = 0.2
	body.CFrame = CFrame.new(-0.8, 0, 0)
	body.Parent = model

	local trim = createSubPart(model, body, "Trim",
		Vector3.new(0.24, 2.65, 1.85), Color3.fromRGB(0, 140, 140),
		CFrame.new(-0.02, 0, 0), Enum.Material.Glass)
	trim.Transparency = 0.4

	addGlow(body, Color3.fromRGB(0, 220, 220), 2, 10)
	addSparkles(body, Color3.fromRGB(0, 255, 255))

	return body
end

local function buildDragonShield(model, limb)
	local body = Instance.new("Part")
	body.Name = "ShieldBody"
	body.Size = Vector3.new(0.25, 2.7, 2.0)
	body.Color = Color3.fromRGB(200, 25, 25)
	body.Material = Enum.Material.Metal
	body.CanCollide = false
	body.Massless = true
	body.Anchored = false
	body.CFrame = CFrame.new(-0.8, 0, 0)
	body.Reflectance = 0.15
	body.Parent = model

	-- Black border
	local trim = createSubPart(model, body, "Trim",
		Vector3.new(0.27, 2.75, 2.05), Color3.fromRGB(30, 10, 10),
		CFrame.new(-0.02, 0, 0), Enum.Material.Metal)

	-- Spikes on edges
	for i = -1, 1, 1 do
		local spike = createSubPart(model, body, "Spike" .. i,
			Vector3.new(0.15, 0.5, 0.15), Color3.fromRGB(40, 10, 10),
			CFrame.new(-0.15, i * 0.9, 1.0) * CFrame.Angles(0, 0, math.rad(45)),
			Enum.Material.Metal)
		local spike2 = createSubPart(model, body, "SpikeR" .. i,
			Vector3.new(0.15, 0.5, 0.15), Color3.fromRGB(40, 10, 10),
			CFrame.new(-0.15, i * 0.9, -1.0) * CFrame.Angles(0, 0, math.rad(-45)),
			Enum.Material.Metal)
	end

	-- Dragon emblem (contrasting center piece)
	local emblem = createSubPart(model, body, "Emblem",
		Vector3.new(0.28, 1.0, 0.8), Color3.fromRGB(30, 10, 10),
		CFrame.new(-0.04, 0, 0), Enum.Material.Metal)

	addGlow(body, Color3.fromRGB(255, 40, 20), 1, 8)

	return body
end

local SHIELD_BUILDERS = {
	["Wooden Shield"] = buildWoodenShield,
	["Iron Shield"] = buildIronShield,
	["Gold Shield"] = buildGoldShield,
	["Runite Shield"] = buildRuniteShield,
	["Dragon Shield"] = buildDragonShield,
}

--------------------------------------------------------------------------------
-- HELMET BUILDERS
--------------------------------------------------------------------------------

local function buildBronzeHelmet(model, limb)
	local base = Instance.new("Part")
	base.Name = "HelmetBase"
	base.Size = Vector3.new(1.25, 0.7, 1.25)
	base.Color = Color3.fromRGB(170, 115, 55)
	base.Material = Enum.Material.Metal
	base.CanCollide = false
	base.Massless = true
	base.Anchored = false
	base.CFrame = CFrame.new(0, 0.85, 0)
	base.Parent = model

	-- Nose guard
	local nose = createSubPart(model, base, "NoseGuard",
		Vector3.new(0.1, 0.7, 0.12), Color3.fromRGB(160, 105, 45),
		CFrame.new(0, -0.5, -0.6), Enum.Material.Metal)

	return base
end

local function buildIronHelmet(model, limb)
	local base = Instance.new("Part")
	base.Name = "HelmetBase"
	base.Size = Vector3.new(1.3, 0.8, 1.3)
	base.Color = Color3.fromRGB(180, 180, 190)
	base.Material = Enum.Material.Metal
	base.CanCollide = false
	base.Massless = true
	base.Anchored = false
	base.CFrame = CFrame.new(0, 0.85, 0)
	base.Reflectance = 0.15
	base.Parent = model

	-- Cheek guards
	local cheekL = createSubPart(model, base, "CheekL",
		Vector3.new(0.15, 0.6, 0.5), Color3.fromRGB(165, 165, 175),
		CFrame.new(-0.65, -0.45, -0.2), Enum.Material.Metal)
	local cheekR = createSubPart(model, base, "CheekR",
		Vector3.new(0.15, 0.6, 0.5), Color3.fromRGB(165, 165, 175),
		CFrame.new(0.65, -0.45, -0.2), Enum.Material.Metal)

	-- Nose guard
	local nose = createSubPart(model, base, "NoseGuard",
		Vector3.new(0.1, 0.5, 0.12), Color3.fromRGB(170, 170, 180),
		CFrame.new(0, -0.45, -0.6), Enum.Material.Metal)

	return base
end

local function buildGoldHelmet(model, limb)
	local base = Instance.new("Part")
	base.Name = "HelmetBase"
	base.Size = Vector3.new(1.3, 0.6, 1.3)
	base.Color = Color3.fromRGB(255, 205, 55)
	base.Material = Enum.Material.Metal
	base.CanCollide = false
	base.Massless = true
	base.Anchored = false
	base.CFrame = CFrame.new(0, 0.82, 0)
	base.Reflectance = 0.3
	base.Parent = model

	-- Crown points
	for i = 0, 4 do
		local angle = math.rad(i * 72)
		local px = math.cos(angle) * 0.5
		local pz = math.sin(angle) * 0.5
		local point = createSubPart(model, base, "Crown" .. i,
			Vector3.new(0.15, 0.4, 0.15), Color3.fromRGB(255, 210, 60),
			CFrame.new(px, 0.45, pz), Enum.Material.Metal)
		point.Reflectance = 0.3
	end

	-- Gem in front
	local gem = createSubPart(model, base, "Gem",
		Vector3.new(0.18, 0.18, 0.18), Color3.fromRGB(200, 20, 20),
		CFrame.new(0, 0.15, -0.65), Enum.Material.Neon)

	return base
end

local function buildRuniteHelmet(model, limb)
	local base = Instance.new("Part")
	base.Name = "HelmetBase"
	base.Size = Vector3.new(1.35, 0.9, 1.35)
	base.Color = Color3.fromRGB(0, 185, 185)
	base.Material = Enum.Material.Glass
	base.CanCollide = false
	base.Massless = true
	base.Anchored = false
	base.Transparency = 0.15
	base.CFrame = CFrame.new(0, 0.85, 0)
	base.Parent = model

	-- Full face plate
	local face = createSubPart(model, base, "FacePlate",
		Vector3.new(1.1, 0.8, 0.12), Color3.fromRGB(0, 160, 160),
		CFrame.new(0, -0.3, -0.65), Enum.Material.Glass)
	face.Transparency = 0.3

	-- Visor slit (glowing)
	local visor = createSubPart(model, face, "Visor",
		Vector3.new(0.8, 0.1, 0.14), Color3.fromRGB(0, 255, 255),
		CFrame.new(0, 0.1, -0.02), Enum.Material.Neon)
	addGlow(visor, Color3.fromRGB(0, 255, 255), 2, 8)

	return base
end

local function buildDragonHelmet(model, limb)
	local base = Instance.new("Part")
	base.Name = "HelmetBase"
	base.Size = Vector3.new(1.35, 0.9, 1.35)
	base.Color = Color3.fromRGB(200, 25, 25)
	base.Material = Enum.Material.Metal
	base.CanCollide = false
	base.Massless = true
	base.Anchored = false
	base.CFrame = CFrame.new(0, 0.85, 0)
	base.Reflectance = 0.1
	base.Parent = model

	-- Face plate
	local face = createSubPart(model, base, "FacePlate",
		Vector3.new(1.15, 0.85, 0.12), Color3.fromRGB(40, 10, 10),
		CFrame.new(0, -0.3, -0.65), Enum.Material.Metal)

	-- Menacing visor slit
	local visor = createSubPart(model, face, "Visor",
		Vector3.new(0.85, 0.08, 0.14), Color3.fromRGB(255, 40, 20),
		CFrame.new(0, 0.1, -0.02), Enum.Material.Neon)
	addGlow(visor, Color3.fromRGB(255, 40, 20), 1.5, 6)

	-- Horns
	local hornL = createSubPart(model, base, "HornL",
		Vector3.new(0.15, 0.8, 0.15), Color3.fromRGB(50, 10, 10),
		CFrame.new(-0.5, 0.6, -0.2) * CFrame.Angles(math.rad(-20), 0, math.rad(-25)),
		Enum.Material.Metal)
	local hornR = createSubPart(model, base, "HornR",
		Vector3.new(0.15, 0.8, 0.15), Color3.fromRGB(50, 10, 10),
		CFrame.new(0.5, 0.6, -0.2) * CFrame.Angles(math.rad(-20), 0, math.rad(25)),
		Enum.Material.Metal)

	return base
end

local HELMET_BUILDERS = {
	["Bronze Helmet"] = buildBronzeHelmet,
	["Iron Helmet"] = buildIronHelmet,
	["Gold Helmet"] = buildGoldHelmet,
	["Runite Helmet"] = buildRuniteHelmet,
	["Dragon Helmet"] = buildDragonHelmet,
}

--------------------------------------------------------------------------------
-- BODY ARMOR VISUALS (color + overlay parts)
--------------------------------------------------------------------------------

local BODY_VISUALS = {
	["Goblin Mail"] = { color = Color3.fromRGB(50, 100, 40) },
	["Wizard Robe"] = { color = Color3.fromRGB(120, 40, 160) },
	["Iron Platebody"] = { color = Color3.fromRGB(180, 180, 190) },
	["Gold Platebody"] = { color = Color3.fromRGB(255, 200, 50) },
	["Runite Platebody"] = { color = Color3.fromRGB(0, 180, 180) },
	["Dragon Platebody"] = { color = Color3.fromRGB(200, 30, 30) },
}

-- Overlay builders for body armor (create extra parts on torso)
local function buildBodyOverlay(character, bodyName)
	clearVisual(character, "VisualEquip_BodyOverlay")
	local torsoName = character:FindFirstChild("UpperTorso") and "UpperTorso" or "Torso"
	local torso = character:FindFirstChild(torsoName)
	if not torso then return end

	local model = Instance.new("Model")
	model.Name = "VisualEquip_BodyOverlay"
	model.Parent = character

	if bodyName == "Goblin Mail" then
		-- Chain mail overlay with tattered bottom
		local chain = Instance.new("Part")
		chain.Name = "ChainBody"
		chain.Size = Vector3.new(2.05, 1.6, 1.05)
		chain.Color = Color3.fromRGB(60, 110, 45)
		chain.Material = Enum.Material.Fabric
		chain.Transparency = 0.1
		chain.CanCollide = false
		chain.Massless = true
		chain.Anchored = false
		chain.CFrame = torso.CFrame * CFrame.new(0, -0.1, 0)
		chain.Parent = model
		local w = Instance.new("WeldConstraint")
		w.Part0 = torso
		w.Part1 = chain
		w.Parent = chain

		-- Tattered bottom strip
		local tatter = createSubPart(model, chain, "Tatter",
			Vector3.new(1.8, 0.3, 0.9), Color3.fromRGB(45, 85, 35),
			CFrame.new(0, -0.9, 0), Enum.Material.Fabric)

	elseif bodyName == "Wizard Robe" then
		local robe = Instance.new("Part")
		robe.Name = "RobeBody"
		robe.Size = Vector3.new(2.1, 1.65, 1.1)
		robe.Color = Color3.fromRGB(120, 40, 160)
		robe.Material = Enum.Material.Fabric
		robe.CanCollide = false
		robe.Massless = true
		robe.Anchored = false
		robe.CFrame = torso.CFrame * CFrame.new(0, -0.1, 0)
		robe.Parent = model
		local w = Instance.new("WeldConstraint")
		w.Part0 = torso
		w.Part1 = robe
		w.Parent = robe

		-- Gold trim line
		local trimFront = createSubPart(model, robe, "TrimFront",
			Vector3.new(0.08, 1.6, 0.08), Color3.fromRGB(255, 200, 50),
			CFrame.new(0, 0, -0.55), Enum.Material.Neon)
		local trimBottom = createSubPart(model, robe, "TrimBottom",
			Vector3.new(2.0, 0.06, 1.0), Color3.fromRGB(255, 200, 50),
			CFrame.new(0, -0.8, 0), Enum.Material.Neon)

		-- Hood piece on head
		local head = character:FindFirstChild("Head")
		if head then
			local hood = Instance.new("Part")
			hood.Name = "VisualEquip_BodyOverlay"
			hood.Size = Vector3.new(1.4, 0.8, 1.4)
			hood.Color = Color3.fromRGB(110, 35, 145)
			hood.Material = Enum.Material.Fabric
			hood.CanCollide = false
			hood.Massless = true
			hood.Anchored = false
			hood.CFrame = head.CFrame * CFrame.new(0, 0.5, 0.1)
			hood.Parent = character  -- separate part, same tag for cleanup
			local hw = Instance.new("WeldConstraint")
			hw.Part0 = head
			hw.Part1 = hood
			hw.Parent = hood
		end

	elseif bodyName == "Iron Platebody" then
		local plate = Instance.new("Part")
		plate.Name = "PlateBody"
		plate.Size = Vector3.new(2.08, 1.65, 1.08)
		plate.Color = Color3.fromRGB(185, 185, 195)
		plate.Material = Enum.Material.Metal
		plate.Reflectance = 0.2
		plate.CanCollide = false
		plate.Massless = true
		plate.Anchored = false
		plate.CFrame = torso.CFrame
		plate.Parent = model
		local w = Instance.new("WeldConstraint")
		w.Part0 = torso
		w.Part1 = plate
		w.Parent = plate

		-- Shoulder pads
		local shoulderL = createSubPart(model, plate, "ShoulderL",
			Vector3.new(0.6, 0.3, 0.8), Color3.fromRGB(170, 170, 180),
			CFrame.new(-1.1, 0.7, 0), Enum.Material.Metal)
		local shoulderR = createSubPart(model, plate, "ShoulderR",
			Vector3.new(0.6, 0.3, 0.8), Color3.fromRGB(170, 170, 180),
			CFrame.new(1.1, 0.7, 0), Enum.Material.Metal)

	elseif bodyName == "Gold Platebody" then
		local plate = Instance.new("Part")
		plate.Name = "PlateBody"
		plate.Size = Vector3.new(2.08, 1.65, 1.08)
		plate.Color = Color3.fromRGB(255, 210, 60)
		plate.Material = Enum.Material.Metal
		plate.Reflectance = 0.3
		plate.CanCollide = false
		plate.Massless = true
		plate.Anchored = false
		plate.CFrame = torso.CFrame
		plate.Parent = model
		local w = Instance.new("WeldConstraint")
		w.Part0 = torso
		w.Part1 = plate
		w.Parent = plate

		local shoulderL = createSubPart(model, plate, "ShoulderL",
			Vector3.new(0.65, 0.35, 0.85), Color3.fromRGB(240, 190, 40),
			CFrame.new(-1.1, 0.7, 0), Enum.Material.Metal)
		shoulderL.Reflectance = 0.3
		local shoulderR = createSubPart(model, plate, "ShoulderR",
			Vector3.new(0.65, 0.35, 0.85), Color3.fromRGB(240, 190, 40),
			CFrame.new(1.1, 0.7, 0), Enum.Material.Metal)
		shoulderR.Reflectance = 0.3

		-- Chest emblem
		local emblem = createSubPart(model, plate, "Emblem",
			Vector3.new(0.1, 0.5, 0.5), Color3.fromRGB(200, 155, 25),
			CFrame.new(0, 0.1, -0.55), Enum.Material.Metal)

	elseif bodyName == "Runite Platebody" then
		local plate = Instance.new("Part")
		plate.Name = "PlateBody"
		plate.Size = Vector3.new(2.1, 1.68, 1.1)
		plate.Color = Color3.fromRGB(0, 190, 190)
		plate.Material = Enum.Material.Glass
		plate.Transparency = 0.15
		plate.CanCollide = false
		plate.Massless = true
		plate.Anchored = false
		plate.CFrame = torso.CFrame
		plate.Parent = model
		local w = Instance.new("WeldConstraint")
		w.Part0 = torso
		w.Part1 = plate
		w.Parent = plate
		addGlow(plate, Color3.fromRGB(0, 220, 220), 1, 8)

		local shoulderL = createSubPart(model, plate, "ShoulderL",
			Vector3.new(0.65, 0.35, 0.85), Color3.fromRGB(0, 160, 160),
			CFrame.new(-1.1, 0.7, 0), Enum.Material.Glass)
		shoulderL.Transparency = 0.2
		local shoulderR = createSubPart(model, plate, "ShoulderR",
			Vector3.new(0.65, 0.35, 0.85), Color3.fromRGB(0, 160, 160),
			CFrame.new(1.1, 0.7, 0), Enum.Material.Glass)
		shoulderR.Transparency = 0.2

	elseif bodyName == "Dragon Platebody" then
		local plate = Instance.new("Part")
		plate.Name = "PlateBody"
		plate.Size = Vector3.new(2.12, 1.7, 1.12)
		plate.Color = Color3.fromRGB(200, 25, 25)
		plate.Material = Enum.Material.Metal
		plate.Reflectance = 0.15
		plate.CanCollide = false
		plate.Massless = true
		plate.Anchored = false
		plate.CFrame = torso.CFrame
		plate.Parent = model
		local w = Instance.new("WeldConstraint")
		w.Part0 = torso
		w.Part1 = plate
		w.Parent = plate

		-- Black trim
		local trimBottom = createSubPart(model, plate, "TrimBottom",
			Vector3.new(2.15, 0.1, 1.15), Color3.fromRGB(30, 10, 10),
			CFrame.new(0, -0.82, 0), Enum.Material.Metal)

		-- Spiked shoulders
		local shoulderL = createSubPart(model, plate, "ShoulderL",
			Vector3.new(0.7, 0.4, 0.9), Color3.fromRGB(180, 20, 20),
			CFrame.new(-1.1, 0.7, 0), Enum.Material.Metal)
		local spikeL = createSubPart(model, shoulderL, "SpikeL",
			Vector3.new(0.15, 0.5, 0.15), Color3.fromRGB(40, 10, 10),
			CFrame.new(0, 0.35, 0), Enum.Material.Metal)
		local shoulderR = createSubPart(model, plate, "ShoulderR",
			Vector3.new(0.7, 0.4, 0.9), Color3.fromRGB(180, 20, 20),
			CFrame.new(1.1, 0.7, 0), Enum.Material.Metal)
		local spikeR = createSubPart(model, shoulderR, "SpikeR",
			Vector3.new(0.15, 0.5, 0.15), Color3.fromRGB(40, 10, 10),
			CFrame.new(0, 0.35, 0), Enum.Material.Metal)

		addGlow(plate, Color3.fromRGB(255, 40, 20), 0.8, 6)
	end
end

--------------------------------------------------------------------------------
-- LEGS VISUALS
--------------------------------------------------------------------------------

local LEGS_VISUALS = {
	["Iron Legs"] = { color = Color3.fromRGB(180, 180, 190) },
	["Gold Legs"] = { color = Color3.fromRGB(255, 200, 50) },
	["Runite Legs"] = { color = Color3.fromRGB(0, 180, 180) },
	["Dragon Legs"] = { color = Color3.fromRGB(200, 30, 30) },
}

--------------------------------------------------------------------------------
-- TOOL BUILDERS (pickaxes, axes, fishing rods)
--------------------------------------------------------------------------------

local TOOL_TIER_COLORS = {
	["Copper"] = Color3.fromRGB(180, 100, 40),
	["Iron"] = Color3.fromRGB(180, 180, 190),
	["Steel"] = Color3.fromRGB(140, 140, 155),
	["Gold"] = Color3.fromRGB(255, 200, 50),
	["Runite"] = Color3.fromRGB(0, 180, 180),
	["Dragon"] = Color3.fromRGB(200, 30, 30),
}

local function getToolTierColor(toolName)
	for tier, col in pairs(TOOL_TIER_COLORS) do
		if string.find(toolName, tier) then
			return col
		end
	end
	return Color3.fromRGB(140, 100, 50)
end

local function buildPickaxe(model, limb, toolName)
	local tierColor = getToolTierColor(toolName)

	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Size = Vector3.new(0.2, 2.8, 0.2)
	handle.Color = Color3.fromRGB(120, 80, 35)
	handle.Material = Enum.Material.Wood
	handle.CanCollide = false
	handle.Massless = true
	handle.Anchored = false
	handle.CFrame = CFrame.new(0.7, 0, 0.5) * CFrame.Angles(0, 0, math.rad(30))
	handle.Parent = model

	-- Pickaxe head (wedge-like)
	local head = createSubPart(model, handle, "PickHead",
		Vector3.new(0.15, 0.3, 1.2), tierColor,
		CFrame.new(0, 1.3, 0.3), Enum.Material.Metal)
	head.Reflectance = 0.15

	-- Back spike
	local spike = createSubPart(model, handle, "BackSpike",
		Vector3.new(0.12, 0.2, 0.6), tierColor,
		CFrame.new(0, 1.3, -0.3), Enum.Material.Metal)

	if string.find(toolName, "Runite") then addGlow(head, tierColor, 1, 5) end
	if string.find(toolName, "Dragon") then addGlow(head, tierColor, 0.8, 4) end

	return handle
end

local function buildAxe(model, limb, toolName)
	local tierColor = getToolTierColor(toolName)

	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Size = Vector3.new(0.2, 2.5, 0.2)
	handle.Color = Color3.fromRGB(120, 80, 35)
	handle.Material = Enum.Material.Wood
	handle.CanCollide = false
	handle.Massless = true
	handle.Anchored = false
	handle.CFrame = CFrame.new(0.7, 0, 0.5) * CFrame.Angles(0, 0, math.rad(30))
	handle.Parent = model

	-- Axe head (flat blade)
	local head = createSubPart(model, handle, "AxeHead",
		Vector3.new(0.12, 0.8, 0.9), tierColor,
		CFrame.new(0, 1.1, 0.35), Enum.Material.Metal)
	head.Reflectance = 0.15

	if string.find(toolName, "Runite") then addGlow(head, tierColor, 1, 5) end
	if string.find(toolName, "Dragon") then addGlow(head, tierColor, 0.8, 4) end

	return handle
end

local function buildFishingRod(model, limb, toolName)
	local tierColor = getToolTierColor(toolName)

	local rod = Instance.new("Part")
	rod.Name = "Rod"
	rod.Size = Vector3.new(0.1, 3.5, 0.1)
	rod.Color = tierColor
	rod.Material = Enum.Material.Wood
	rod.CanCollide = false
	rod.Massless = true
	rod.Anchored = false
	rod.CFrame = CFrame.new(0.7, 0.3, 0.5) * CFrame.Angles(0, 0, math.rad(15))
	rod.Parent = model

	-- Reel
	local reel = createSubPart(model, rod, "Reel",
		Vector3.new(0.2, 0.25, 0.25), Color3.fromRGB(100, 100, 110),
		CFrame.new(0.1, -1.0, 0), Enum.Material.Metal)

	-- Fishing line (thin neon)
	local line = createSubPart(model, rod, "Line",
		Vector3.new(0.03, 1.2, 0.03), Color3.fromRGB(220, 220, 230),
		CFrame.new(0, 2.2, 0), Enum.Material.Neon)

	return rod
end

local function buildTool(character, toolName)
	clearVisual(character, "VisualEquip_Tool")
	local torsoName = character:FindFirstChild("UpperTorso") and "UpperTorso" or "Torso"
	local torso = character:FindFirstChild(torsoName)
	if not torso then return end

	local model = Instance.new("Model")
	model.Name = "VisualEquip_Tool"
	model.Parent = character

	local rootPart
	if string.find(toolName, "Pickaxe") or string.find(toolName, "pickaxe") then
		rootPart = buildPickaxe(model, torso, toolName)
	elseif string.find(toolName, "Axe") or string.find(toolName, "axe") then
		rootPart = buildAxe(model, torso, toolName)
	elseif string.find(toolName, "Rod") or string.find(toolName, "rod") or string.find(toolName, "Fishing") then
		rootPart = buildFishingRod(model, torso, toolName)
	else
		-- Generic tool (stick)
		rootPart = Instance.new("Part")
		rootPart.Name = "ToolGeneric"
		rootPart.Size = Vector3.new(0.25, 2.5, 0.25)
		rootPart.Color = getToolTierColor(toolName)
		rootPart.Material = Enum.Material.Wood
		rootPart.CanCollide = false
		rootPart.Massless = true
		rootPart.Anchored = false
		rootPart.CFrame = CFrame.new(0.7, 0, 0.5) * CFrame.Angles(0, 0, math.rad(30))
		rootPart.Parent = model
	end

	if rootPart then
		rootPart.CFrame = torso.CFrame * rootPart.CFrame
		local weld = Instance.new("WeldConstraint")
		weld.Part0 = torso
		weld.Part1 = rootPart
		weld.Parent = rootPart
	end
end

--------------------------------------------------------------------------------
-- Apply visuals for a single player
--------------------------------------------------------------------------------

local function applyVisuals(player)
	local character = player.Character
	if not character then return end
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid or humanoid.Health <= 0 then return end

	local data = DataManager:GetData(player)
	if not data or not data.Equipment then return end

	local equip = data.Equipment

	-- WEAPON (Right Arm / RightHand) or BOW (back)
	local weaponName = equip.Weapon
	clearVisual(character, "VisualEquip_Weapon")
	if weaponName and weaponName ~= "" then
		local builder = WEAPON_BUILDERS[weaponName]
		local bowBuilder = BOW_BUILDERS[weaponName]

		if builder then
			-- Multi-part sword
			local attachTo = character:FindFirstChild("RightHand") and "RightHand" or "Right Arm"
			createModelOnLimb(character, attachTo, "VisualEquip_Weapon", function(model, limb)
				return builder(model, limb)
			end)
			print("[VisualEquip] Weapon attached: " .. weaponName .. " to " .. attachTo)
		elseif bowBuilder then
			-- Bows go on back
			local attachTo = character:FindFirstChild("UpperTorso") and "UpperTorso" or "Torso"
			createModelOnLimb(character, attachTo, "VisualEquip_Weapon", function(model, limb)
				return bowBuilder(model, limb)
			end)
			print("[VisualEquip] Bow attached: " .. weaponName .. " to back")
		else
			-- Fallback: basic blade
			local attachTo = character:FindFirstChild("RightHand") and "RightHand" or "Right Arm"
			local offset = CFrame.new(0, -2.0, 0)
			local part = createAttachedPart(character, attachTo, "VisualEquip_Weapon",
				Vector3.new(0.3, 3, 0.15), Color3.fromRGB(180, 180, 180), offset)
			if part then
				part.Material = Enum.Material.Metal
			end
		end
	end

	-- HEAD
	local headName = equip.Head
	clearVisual(character, "VisualEquip_Head")
	if headName and headName ~= "" then
		local builder = HELMET_BUILDERS[headName]
		if builder then
			createModelOnLimb(character, "Head", "VisualEquip_Head", function(model, limb)
				return builder(model, limb)
			end, true)
		else
			-- Fallback: simple block
			local offset = CFrame.new(0, 0.8, 0)
			createAttachedPart(character, "Head", "VisualEquip_Head",
				Vector3.new(1.3, 0.8, 1.3), Color3.fromRGB(180, 180, 180), offset)
		end
	end

	-- BODY (color torso + overlay parts)
	local torsoName = character:FindFirstChild("UpperTorso") and "UpperTorso" or "Torso"
	local lowerTorso = character:FindFirstChild("LowerTorso")
	local bodyParts = { torsoName }
	if lowerTorso then table.insert(bodyParts, "LowerTorso") end

	local bodyName = equip.Body
	clearBodyColors(character, bodyParts)
	clearVisual(character, "VisualEquip_BodyOverlay")
	if bodyName and bodyName ~= "" then
		local vis = BODY_VISUALS[bodyName]
		if vis then
			for _, pName in ipairs(bodyParts) do
				local part = character:FindFirstChild(pName)
				if part and part:IsA("BasePart") then
					saveOriginalColor(part)
					part.Color = vis.color
				end
			end
		end
		-- Build overlay parts
		buildBodyOverlay(character, bodyName)
	end

	-- LEGS (color legs)
	local legParts = {}
	for _, name in ipairs({"Left Leg", "Right Leg", "LeftUpperLeg", "RightUpperLeg", "LeftLowerLeg", "RightLowerLeg", "LeftFoot", "RightFoot"}) do
		if character:FindFirstChild(name) then
			table.insert(legParts, name)
		end
	end

	local legsName = equip.Legs
	clearBodyColors(character, legParts)
	if legsName and LEGS_VISUALS[legsName] then
		local vis = LEGS_VISUALS[legsName]
		for _, pName in ipairs(legParts) do
			local part = character:FindFirstChild(pName)
			if part and part:IsA("BasePart") then
				saveOriginalColor(part)
				part.Color = vis.color
			end
		end
	end

	-- SHIELD (Left Arm)
	local shieldName = equip.Shield
	clearVisual(character, "VisualEquip_Shield")
	if shieldName and shieldName ~= "" then
		local builder = SHIELD_BUILDERS[shieldName]
		if builder then
			local attachTo = character:FindFirstChild("LeftHand") and "LeftLowerArm" or "Left Arm"
			createModelOnLimb(character, attachTo, "VisualEquip_Shield", function(model, limb)
				return builder(model, limb)
			end, true)
		else
			-- Fallback
			local attachTo = character:FindFirstChild("LeftHand") and "LeftLowerArm" or "Left Arm"
			local offset = CFrame.new(-0.8, 0, 0)
			createAttachedPart(character, attachTo, "VisualEquip_Shield",
				Vector3.new(0.3, 2.2, 1.6), Color3.fromRGB(140, 90, 40), offset)
		end
	end

	-- TOOL (visual on back)
	local toolName = equip.Tool
	clearVisual(character, "VisualEquip_Tool")
	if toolName and toolName ~= "" then
		buildTool(character, toolName)
	end

	print("[VisualEquip] Applied visuals for " .. player.Name .. " | Weapon=" .. tostring(equip.Weapon) .. " Head=" .. tostring(equip.Head) .. " Shield=" .. tostring(equip.Shield))
end

--------------------------------------------------------------------------------
-- Connections
--------------------------------------------------------------------------------

local function setupPlayer(player)
	player.CharacterAdded:Connect(function(character)
		character:WaitForChild("Humanoid", 5)
		task.wait(0.5)
		applyVisuals(player)
	end)

	if player.Character then
		applyVisuals(player)
	end
end

Players.PlayerAdded:Connect(setupPlayer)
for _, player in ipairs(Players:GetPlayers()) do
	setupPlayer(player)
end

equipChanged.Event:Connect(function(player)
	if player and player:IsA("Player") then
		task.wait(0.1)
		applyVisuals(player)
	end
end)

if equipItemEvent then
	equipItemEvent.OnServerEvent:Connect(function(player)
		task.wait(0.2)
		applyVisuals(player)
	end)
end

if unequipItemEvent then
	unequipItemEvent.OnServerEvent:Connect(function(player)
		task.wait(0.2)
		applyVisuals(player)
	end)
end
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="164">
      <Properties>
        <string name="Name">WildernessManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- WildernessManager.server.lua
-- Handles PvP zone detection, full-loot death, and loot drops

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local Config = require(ReplicatedStorage.Modules.Config)

local DataManager = require(ReplicatedStorage.Modules.DataManager)

-- Track which players are in the wilderness
local playersInWilderness = {}

-- Wilderness boundary (Z < -100)
local WILDERNESS_Z = -100

-- === ZONE DETECTION ===
local function isInWilderness(position)
	return position.Z < WILDERNESS_Z
end

print("[WildernessManager] Waiting for Remotes...")
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
if not Remotes then
	warn("[WildernessManager] ERROR: Remotes folder not found!")
end
local zoneRemote = Remotes and Remotes:WaitForChild("ZoneChanged", 10)
if not zoneRemote then
	warn("[WildernessManager] ERROR: ZoneChanged remote not found!")
end
print("[WildernessManager] Remotes connected!")

-- Monitor player positions
task.spawn(function()
	while true do
		task.wait(0.5)
		for _, player in ipairs(Players:GetPlayers()) do
			local character = player.Character
			if character then
				local root = character:FindFirstChild("HumanoidRootPart")
				if root then
					local wasInWild = playersInWilderness[player.UserId]
					local isInWild = isInWilderness(root.Position)

					if isInWild and not wasInWild then
						-- Entered wilderness
						playersInWilderness[player.UserId] = true
						zoneRemote:FireClient(player, "Wilderness")
						print("[Wilderness] " .. player.Name .. " entered the Wilderness!")
					elseif not isInWild and wasInWild then
						-- Left wilderness
						playersInWilderness[player.UserId] = false
						zoneRemote:FireClient(player, "SafeZone")
						print("[Wilderness] " .. player.Name .. " returned to safety.")
					end
				end
			end
		end
	end
end)

-- === LOOT DROP SYSTEM ===

local function createLootPile(position, items, killerName)
	if #items == 0 then return end

	local lootPart = Instance.new("Part")
	lootPart.Name = "LootPile"
	lootPart.Size = Vector3.new(3, 1, 3)
	lootPart.Position = position + Vector3.new(0, 1, 0)
	lootPart.Anchored = true
	lootPart.CanCollide = false
	lootPart.BrickColor = BrickColor.new("Bright yellow")
	lootPart.Material = Enum.Material.Neon
	lootPart.Shape = Enum.PartType.Cylinder
	lootPart.Transparency = 0.3
	lootPart.Parent = Workspace

	-- Floating text
	local billboard = Instance.new("BillboardGui")
	billboard.Size = UDim2.new(4, 0, 1, 0)
	billboard.StudsOffset = Vector3.new(0, 3, 0)
	billboard.Parent = lootPart

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = "ðŸ’€ Loot Pile (" .. #items .. " items)"
	label.TextColor3 = Color3.fromRGB(255, 215, 0)
	label.TextScaled = true
	label.Font = Enum.Font.GothamBold
	label.Parent = billboard

	-- Click to loot
	local clickDetector = Instance.new("ClickDetector")
	clickDetector.MaxActivationDistance = 10
	clickDetector.Parent = lootPart

	local looted = false
	clickDetector.MouseClick:Connect(function(player)
		if looted then return end
		looted = true

		-- Give all items to the player who clicked
		local itemsGiven = 0
		for _, item in ipairs(items) do
			local added = DataManager.AddToInventory(player, item.name, item.quantity)
			if added then
				itemsGiven = itemsGiven + 1
			end
		end

		-- Update their inventory UI
		local invRemote = ReplicatedStorage.Remotes:FindFirstChild("InventoryUpdate")
		if invRemote then
			local data = DataManager:GetData(player)
			invRemote:FireClient(player, data.Inventory)
		end

		print("[Loot] " .. player.Name .. " looted " .. itemsGiven .. " items from a pile")
		lootPart:Destroy()
	end)

	-- Auto-despawn after duration
	task.delay(Config.LootDropDuration, function()
		if lootPart and lootPart.Parent then
			lootPart:Destroy()
			print("[Loot] A loot pile despawned")
		end
	end)
end

-- === PVP DEATH HANDLER ===

local function onCharacterDied(player, character)
	if not DataManager then return end

	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoid then return end

	-- Check if player died in wilderness
	local root = character:FindFirstChild("HumanoidRootPart")
	if not root then return end

	if not isInWilderness(root.Position) then
		-- Died in safe zone â€” no loot drop
		return
	end

	-- FULL LOOT DROP â€” drop everything!
	local droppedItems = DataManager.GetAndClearInventory(player)
	
	if #droppedItems > 0 then
		-- Find who killed them (for tracking)
		local killerName = "Unknown"
		-- Check the damage tag
		local tag = humanoid:FindFirstChild("creator")
		if tag and tag.Value then
			killerName = tag.Value.Name
			-- Award kill to the killer
			local killerData = DataManager:GetData(tag.Value)
			if killerData then
				killerData.TotalKills = killerData.TotalKills + 1
			end
		end

		-- Create loot pile at death location
		createLootPile(root.Position, droppedItems, killerName)
		
		print("[PvP] " .. player.Name .. " was killed by " .. killerName .. " â€” dropped " .. #droppedItems .. " item stacks!")
	end

	-- Update victim's empty inventory
	local invRemote = ReplicatedStorage.Remotes:FindFirstChild("InventoryUpdate")
	if invRemote then
		invRemote:FireClient(player, {})
	end
end

-- === PLAYER SETUP ===

Players.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function(character)
		local humanoid = character:WaitForChild("Humanoid", 5)
		humanoid.Died:Connect(function()
			onCharacterDied(player, character)
		end)
	end)
end)

-- Cleanup on leave
Players.PlayerRemoving:Connect(function(player)
	playersInWilderness[player.UserId] = nil
end)

print("[WildernessManager] Full-loot PvP system active!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="165">
      <Properties>
        <string name="Name">WoodcuttingManager</string>
        <token name="RunContext">0</token>
        <string name="Source">-- WoodcuttingManager.server.lua
-- Specialized woodcutting system with progress bars and tree respawning

print("[WoodcuttingManager] Starting...")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

-- Wait for dependencies with timeouts
local Modules = ReplicatedStorage:WaitForChild("Modules", 10)
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)

-- Load required modules
local Config = require(Modules:WaitForChild("Config", 10))
local ItemDB = require(Modules:WaitForChild("ItemDatabase", 10))
local DataManager = require(Modules:WaitForChild("DataManager", 10))

-- Get remotes
local StartWoodcutting = Remotes:WaitForChild("StartWoodcutting", 5)
local WoodcuttingProgress = Remotes:WaitForChild("WoodcuttingProgress", 5)
local WoodcuttingComplete = Remotes:WaitForChild("WoodcuttingComplete", 5)

-- Validate remotes
if not StartWoodcutting or not WoodcuttingProgress or not WoodcuttingComplete then
	warn("[WoodcuttingManager] Missing remotes!")
	return
end

-- Tree data
local TREE_DATA = {
	["Oak Tree"] = {
		level = 1,
		log = "Oak Log",
		xp = 18,
		respawnTime = 30,
		axeSpeed = {
			["Bronze Axe"] = 1.0,
			["Iron Axe"] = 1.2,
			["Steel Axe"] = 1.5,
			["Mithril Axe"] = 1.8,
			["Adamant Axe"] = 2.0,
			["Rune Axe"] = 2.5
		}
	},
	["Willow Tree"] = {
		level = 20,
		log = "Willow Log",
		xp = 40,
		respawnTime = 45,
		axeSpeed = {
			["Bronze Axe"] = 0.8,
			["Iron Axe"] = 1.0,
			["Steel Axe"] = 1.3,
			["Mithril Axe"] = 1.6,
			["Adamant Axe"] = 1.8,
			["Rune Axe"] = 2.2
		}
	},
	["Yew Tree"] = {
		level = 50,
		log = "Yew Log",
		xp = 80,
		respawnTime = 60,
		axeSpeed = {
			["Bronze Axe"] = 0.5,
			["Iron Axe"] = 0.7,
			["Steel Axe"] = 1.0,
			["Mithril Axe"] = 1.3,
			["Adamant Axe"] = 1.5,
			["Rune Axe"] = 2.0
		}
	},
	["Magic Tree"] = {
		level = 75,
		log = "Magic Log",
		xp = 150,
		respawnTime = 180,
		axeSpeed = {
			["Bronze Axe"] = 0.3,
			["Iron Axe"] = 0.5,
			["Steel Axe"] = 0.8,
			["Mithril Axe"] = 1.0,
			["Adamant Axe"] = 1.2,
			["Rune Axe"] = 1.5
		}
	}
}

-- Active woodcutting sessions
local activeSessions = {}
local treeStates = {}

-- Helper function to get player's equipped axe
local function getPlayerAxe(player)
	local equipment = DataManager.GetEquipment(player)
	if not equipment then return nil end
	
	for _, item in pairs(equipment) do
		if item and item.Type == "axe" then
			return item.Name
		end
	end
	return nil
end

-- Helper function to check if player has required level
local function hasRequiredLevel(player, treeType)
	local treeInfo = TREE_DATA[treeType]
	if not treeInfo then return false end
	
	local woodcuttingLevel = DataManager.GetSkillLevel(player, "Woodcutting")
	return woodcuttingLevel >= treeInfo.level
end

-- Helper function to calculate chop time based on axe
local function getChopTime(treeType, axeName)
	local treeInfo = TREE_DATA[treeType]
	if not treeInfo then return 3.0 end
	
	local axeSpeed = treeInfo.axeSpeed[axeName] or 1.0
	return 3.0 / axeSpeed  -- Base 3 seconds, faster axes reduce time
end

-- Start woodcutting session
StartWoodcutting.OnServerEvent:Connect(function(player, treeModel)
	if not player or not treeModel then return end
	
	local treeName = treeModel.Name
	local treeInfo = TREE_DATA[treeName]
	
	-- Check if tree exists
	if not treeInfo then
		warn("[WoodcuttingManager] Unknown tree: " .. treeName)
		return
	end
	
	-- Check if player is already woodcutting
	if activeSessions[player.UserId] then
		WoodcuttingProgress:FireClient(player, 0, "Already woodcutting!")
		return
	end
	
	-- Check level requirement
	if not hasRequiredLevel(player, treeName) then
		WoodcuttingProgress:FireClient(player, 0, "Level " .. treeInfo.level .. " Woodcutting required!")
		return
	end
	
	-- Check for axe
	local axeName = getPlayerAxe(player)
	if not axeName then
		WoodcuttingProgress:FireClient(player, 0, "Equip an axe first!")
		return
	end
	
	-- Check if tree is depleted
	if treeStates[treeModel] and treeStates[treeModel].depleted then
		WoodcuttingProgress:FireClient(player, 0, "Tree is depleted!")
		return
	end
	
	-- Calculate chop time
	local chopTime = getChopTime(treeName, axeName)
	
	-- Start session
	activeSessions[player.UserId] = {
		tree = treeModel,
		startTime = os.time(),
		chopTime = chopTime,
		treeInfo = treeInfo,
		axeName = axeName
	}
	
	-- Send initial progress
	WoodcuttingProgress:FireClient(player, 0, "Chopping...")
	
	-- Start progress loop
	task.spawn(function()
		local startTime = os.time()
		local session = activeSessions[player.UserId]
		
		while session and os.time() - startTime &lt; chopTime do
			if not activeSessions[player.UserId] then break end
			
			local elapsed = os.time() - startTime
			local progress = math.min(elapsed / chopTime, 1.0)
			
			WoodcuttingProgress:FireClient(player, progress, "Chopping...")
			task.wait(0.1)
		end
		
		-- Check if session still exists (player didn't cancel)
		if activeSessions[player.UserId] then
			-- Complete woodcutting
			completeWoodcutting(player, treeModel, treeInfo, axeName)
		end
	end)
end)

-- Complete woodcutting
local function completeWoodcutting(player, treeModel, treeInfo, axeName)
	-- Give XP
	DataManager.AddSkillXP(player, "Woodcutting", treeInfo.xp)
	
	-- Give log
	DataManager.AddItem(player, treeInfo.log, 1)
	
	-- Fire completion event
	WoodcuttingComplete:FireClient(player, treeInfo.log, treeInfo.xp)
	
	-- Deplete tree
	depleteTree(treeModel, treeInfo)
	
	-- Clear session
	activeSessions[player.UserId] = nil
end

-- Deplete tree and schedule respawn
local function depleteTree(treeModel, treeInfo)
	-- Mark as depleted
	treeStates[treeModel] = {
		depleted = true,
		depleteTime = os.time()
	}
	
	-- Hide tree
	for _, part in ipairs(treeModel:GetChildren()) do
		if part:IsA("BasePart") then
			part.Transparency = 1
			part.CanCollide = false
		end
	end
	
	-- Schedule respawn
	task.delay(treeInfo.respawnTime, function()
		if treeModel.Parent then
			-- Restore tree
			for _, part in ipairs(treeModel:GetChildren()) do
				if part:IsA("BasePart") then
					part.Transparency = 0
					part.CanCollide = true
				end
			end
			
			-- Clear depleted state
			treeStates[treeModel] = nil
		end
	end)
end

-- Cancel woodcutting if player moves away
local function onPlayerMoved(player)
	if activeSessions[player.UserId] then
		activeSessions[player.UserId] = nil
		WoodcuttingProgress:FireClient(player, 0, "Cancelled - moved away")
	end
end

-- Clean up on player leave
Players.PlayerRemoving:Connect(function(player)
	activeSessions[player.UserId] = nil
end)

print("[WoodcuttingManager] Ready!")</string>
      </Properties>
    </Item>
    <Item class="Script" referent="166">
      <Properties>
        <string name="Name">WorldAnimations</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	WorldAnimations.server.lua
	ServerScriptService

	Makes the world feel alive with ambient animations:
	- Torch flame flicker (size + brightness)
	- Water shimmer (transparency oscillation)
	- NPC idle breathing (torso scale pulse) + head turns
	- Tree canopy gentle sway
]]

local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

task.wait(6) -- let MapSetup + NPCManager finish

print("[WorldAnimations] Starting ambient animations...")

--------------------------------------------------------------------------------
-- TORCH FLICKER
--------------------------------------------------------------------------------
local function animateTorchFlames()
	local flames = {}
	-- Find all TorchFlame parts in workspace (recursive)
	for _, obj in Workspace:GetDescendants() do
		if obj:IsA("BasePart") and obj.Name == "TorchFlame" then
			table.insert(flames, obj)
		end
	end

	print("[WorldAnimations] Found " .. #flames .. " torch flames")

	for _, flame in ipairs(flames) do
		task.spawn(function()
			local baseSize = flame.Size
			local baseTransparency = flame.Transparency
			local light = flame:FindFirstChildOfClass("PointLight")
			local baseBrightness = light and light.Brightness or 2
			local baseRange = light and light.Range or 20

			while flame and flame.Parent do
				-- Random flicker target
				local scaleFactor = 0.85 + math.random() * 0.3
				local transFactor = baseTransparency + (math.random() * 0.2 - 0.05)
				local duration = 0.1 + math.random() * 0.2

				local tween = TweenService:Create(flame, TweenInfo.new(duration, Enum.EasingStyle.Sine), {
					Size = Vector3.new(
						baseSize.X * scaleFactor,
						baseSize.Y * (0.8 + math.random() * 0.4),
						baseSize.Z * scaleFactor
					),
					Transparency = math.clamp(transFactor, 0.05, 0.5),
				})
				tween:Play()

				if light then
					local lightTween = TweenService:Create(light, TweenInfo.new(duration, Enum.EasingStyle.Sine), {
						Brightness = baseBrightness * (0.7 + math.random() * 0.6),
						Range = baseRange * (0.85 + math.random() * 0.3),
					})
					lightTween:Play()
				end

				task.wait(duration + 0.02)
			end
		end)
	end
end

--------------------------------------------------------------------------------
-- FORGE FIRE FLICKER (same idea but for ForgeFire)
--------------------------------------------------------------------------------
local function animateForges()
	for _, obj in Workspace:GetDescendants() do
		if obj:IsA("BasePart") and (obj.Name == "ForgeFire" or obj.Name == "CookingRange") then
			task.spawn(function()
				local baseTransparency = obj.Transparency
				while obj and obj.Parent do
					local t = 0.15 + math.random() * 0.2
					TweenService:Create(obj, TweenInfo.new(t, Enum.EasingStyle.Sine), {
						Transparency = baseTransparency + math.random() * 0.15,
					}):Play()
					task.wait(t + 0.05)
				end
			end)
		end
	end
end

--------------------------------------------------------------------------------
-- WATER SHIMMER
--------------------------------------------------------------------------------
local function animateWater()
	local waterParts = {}
	local waterNames = {
		PondWater = true, LilyPond = true, FountainWater = true,
		FountainTopWater = true, LakeWater = true, DarkPondWater = true,
		SwampWater = true, WellWater = true, Waterfall = true,
	}

	for _, obj in Workspace:GetDescendants() do
		if obj:IsA("BasePart") and waterNames[obj.Name] then
			table.insert(waterParts, obj)
		end
	end

	print("[WorldAnimations] Found " .. #waterParts .. " water surfaces")

	for _, water in ipairs(waterParts) do
		task.spawn(function()
			local baseTransparency = water.Transparency
			local phase = math.random() * math.pi * 2

			while water and water.Parent do
				phase = phase + 0.03
				local newTrans = baseTransparency + math.sin(phase) * 0.08
				water.Transparency = math.clamp(newTrans, 0.1, 0.7)
				task.wait(0.05)
			end
		end)
	end
end

--------------------------------------------------------------------------------
-- LAVA PULSE
--------------------------------------------------------------------------------
local function animateLava()
	for _, obj in Workspace:GetDescendants() do
		if obj:IsA("BasePart") and (obj.Name == "LavaPit" or obj.Name:find("LavaRiver")) then
			task.spawn(function()
				local baseTransparency = obj.Transparency
				local phase = math.random() * math.pi * 2
				local light = obj:FindFirstChildOfClass("PointLight")

				while obj and obj.Parent do
					phase = phase + 0.04
					obj.Transparency = baseTransparency + math.sin(phase) * 0.1

					if light then
						light.Brightness = 4 + math.sin(phase * 1.3) * 1.5
					end
					task.wait(0.06)
				end
			end)
		end
	end
end

--------------------------------------------------------------------------------
-- NPC IDLE BREATHING + HEAD TURNS
--------------------------------------------------------------------------------
local function animateNPCs()
	local npcsFolder = Workspace:FindFirstChild("NPCs")
	if not npcsFolder then
		print("[WorldAnimations] No NPCs folder found, skipping NPC animations")
		return
	end

	for _, npc in npcsFolder:GetChildren() do
		if not npc:IsA("Model") then continue end

		local torso = npc:FindFirstChild("Torso")
		local head = npc:FindFirstChild("Head")

		if torso then
			-- Breathing: gentle Y-scale pulse on torso
			task.spawn(function()
				local basePos = torso.Position
				local breathPhase = math.random() * math.pi * 2

				while torso and torso.Parent do
					breathPhase = breathPhase + 0.06
					local breathOffset = math.sin(breathPhase) * 0.04
					torso.Position = Vector3.new(basePos.X, basePos.Y + breathOffset, basePos.Z)
					task.wait(0.05)
				end
			end)
		end

		if head then
			-- Occasional head turns
			task.spawn(function()
				local baseCF = head.CFrame

				while head and head.Parent do
					-- Wait 3-8 seconds between head turns
					task.wait(3 + math.random() * 5)

					if not head or not head.Parent then break end

					-- Turn head slightly left or right
					local turnAngle = (math.random() * 30 - 15)
					local targetCF = baseCF * CFrame.Angles(0, math.rad(turnAngle), 0)

					TweenService:Create(head, TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
						CFrame = targetCF,
					}):Play()

					-- Hold for a moment, then return
					task.wait(1.5 + math.random() * 2)

					if head and head.Parent then
						TweenService:Create(head, TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
							CFrame = baseCF,
						}):Play()
					end
				end
			end)
		end
	end
end

--------------------------------------------------------------------------------
-- TREE CANOPY GENTLE SWAY
--------------------------------------------------------------------------------
local function animateTreeCanopies()
	local canopyParts = {}

	-- Find leaf/canopy parts in Forest and Grove areas
	for _, obj in Workspace:GetDescendants() do
		if obj:IsA("BasePart") and (obj.Name == "SLeaf" or obj.Name == "Leaves" or obj.Name:find("AncientCanopy")) then
			table.insert(canopyParts, obj)
		end
	end

	print("[WorldAnimations] Found " .. #canopyParts .. " tree canopies to sway")

	-- Only animate a subset to keep performance reasonable
	local maxAnimated = 30
	local count = 0

	for _, leaf in ipairs(canopyParts) do
		if count >= maxAnimated then break end
		count = count + 1

		task.spawn(function()
			local basePos = leaf.Position
			local phase = math.random() * math.pi * 2
			local swayAmount = 0.15 + math.random() * 0.1
			local speed = 0.02 + math.random() * 0.01

			while leaf and leaf.Parent do
				phase = phase + speed
				local offsetX = math.sin(phase) * swayAmount
				local offsetZ = math.cos(phase * 0.7) * swayAmount * 0.6
				leaf.Position = Vector3.new(basePos.X + offsetX, basePos.Y, basePos.Z + offsetZ)
				task.wait(0.08)
			end
		end)
	end
end

--------------------------------------------------------------------------------
-- GLOWING MUSHROOM PULSE
--------------------------------------------------------------------------------
local function animateMushrooms()
	for _, obj in Workspace:GetDescendants() do
		if obj:IsA("BasePart") and (obj.Name:find("Mushroom") or obj.Name:find("BlueMushroom")) then
			task.spawn(function()
				local baseTransparency = obj.Transparency
				local light = obj:FindFirstChildOfClass("PointLight")
				local baseBrightness = light and light.Brightness or 1
				local phase = math.random() * math.pi * 2

				while obj and obj.Parent do
					phase = phase + 0.04
					obj.Transparency = baseTransparency + math.sin(phase) * 0.12

					if light then
						light.Brightness = baseBrightness + math.sin(phase) * 0.4
					end
					task.wait(0.06)
				end
			end)
		end
	end
end

--------------------------------------------------------------------------------
-- CRYSTAL FLOAT (Abyss crystals bob up and down)
--------------------------------------------------------------------------------
local function animateCrystals()
	for _, obj in Workspace:GetDescendants() do
		if obj:IsA("BasePart") and obj.Name:find("Crystal") and obj.Parent and obj.Parent.Name == "TheAbyss" then
			task.spawn(function()
				local basePos = obj.Position
				local phase = math.random() * math.pi * 2
				local bobAmount = 0.3 + math.random() * 0.4

				while obj and obj.Parent do
					phase = phase + 0.025
					obj.Position = Vector3.new(basePos.X, basePos.Y + math.sin(phase) * bobAmount, basePos.Z)
					task.wait(0.06)
				end
			end)
		end
	end
end

--------------------------------------------------------------------------------
-- CAULDRON BUBBLE (Thessaly's brew)
--------------------------------------------------------------------------------
local function animateCauldrons()
	for _, obj in Workspace:GetDescendants() do
		if obj:IsA("BasePart") and obj.Name == "Brew" then
			task.spawn(function()
				local baseTransparency = obj.Transparency
				local phase = 0

				while obj and obj.Parent do
					phase = phase + 0.08
					obj.Transparency = baseTransparency + math.sin(phase) * 0.1
					task.wait(0.05)
				end
			end)
		end
	end
end

--------------------------------------------------------------------------------
-- STAINED GLASS SHIMMER (Chapel windows)
--------------------------------------------------------------------------------
local function animateStainedGlass()
	for _, obj in Workspace:GetDescendants() do
		if obj:IsA("BasePart") and obj.Name:find("StainedGlass") then
			task.spawn(function()
				local baseTransparency = obj.Transparency
				local phase = math.random() * math.pi * 2

				while obj and obj.Parent do
					phase = phase + 0.02
					obj.Transparency = baseTransparency + math.sin(phase) * 0.08
					task.wait(0.1)
				end
			end)
		end
	end
end

--------------------------------------------------------------------------------
-- LAUNCH ALL ANIMATIONS
--------------------------------------------------------------------------------
task.spawn(animateTorchFlames)
task.spawn(animateForges)
task.spawn(animateWater)
task.spawn(animateLava)
task.spawn(animateNPCs)
task.spawn(animateTreeCanopies)
task.spawn(animateMushrooms)
task.spawn(animateCrystals)
task.spawn(animateCauldrons)
task.spawn(animateStainedGlass)

print("[WorldAnimations] All ambient animations started!")
]]></string>
      </Properties>
    </Item>
  </Item>
  <Item class="StarterGui" referent="167">
    <Properties>
      <string name="Name">StarterGui</string>
    </Properties>
  </Item>
  <Item class="StarterPlayer" referent="168">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="169">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="LocalScript" referent="170">
        <Properties>
          <string name="Name">MinimalUI</string>
          <string name="Source">--[[
	MinimalUI.client.lua
	Simple working UI - just inventory and stats.
	No complex features, just the basics that work.
]]

local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Colors
local DARK_BG = Color3.fromRGB(20, 20, 25)
local GOLD = Color3.fromRGB(218, 165, 32)
local WHITE = Color3.fromRGB(255, 255, 255)

-- Create main ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "GameUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

-- Create inventory panel (simple)
local inventoryFrame = Instance.new("Frame")
inventoryFrame.Name = "InventoryPanel"
inventoryFrame.Size = UDim2.new(0, 300, 0, 400)
inventoryFrame.Position = UDim2.new(0, 20, 0.5, -200)
inventoryFrame.BackgroundColor3 = DARK_BG
inventoryFrame.BorderSizePixel = 0
inventoryFrame.Visible = false
inventoryFrame.Parent = screenGui

-- Inventory title
local invTitle = Instance.new("TextLabel")
invTitle.Name = "Title"
invTitle.Size = UDim2.new(1, 0, 0, 40)
invTitle.Position = UDim2.new(0, 0, 0, 0)
invTitle.BackgroundColor3 = GOLD
invTitle.BorderSizePixel = 0
invTitle.Text = "INVENTORY"
invTitle.TextColor3 = DARK_BG
invTitle.TextScaled = true
invTitle.Font = Enum.Font.GothamBold
invTitle.Parent = inventoryFrame

-- Inventory content area
local invContent = Instance.new("ScrollingFrame")
invContent.Name = "Content"
invContent.Size = UDim2.new(1, -20, 1, -60)
invContent.Position = UDim2.new(0, 10, 0, 50)
invContent.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
invContent.BorderSizePixel = 0
invContent.ScrollBarThickness = 8
invContent.Parent = inventoryFrame

-- Create stats panel (simple)
local statsFrame = Instance.new("Frame")
statsFrame.Name = "StatsPanel"
statsFrame.Size = UDim2.new(0, 250, 0, 300)
statsFrame.Position = UDim2.new(1, -270, 0, 20)
statsFrame.BackgroundColor3 = DARK_BG
statsFrame.BorderSizePixel = 0
statsFrame.Visible = false
statsFrame.Parent = screenGui

-- Stats title
local statsTitle = Instance.new("TextLabel")
statsTitle.Name = "Title"
statsTitle.Size = UDim2.new(1, 0, 0, 40)
statsTitle.Position = UDim2.new(0, 0, 0, 0)
statsTitle.BackgroundColor3 = GOLD
statsTitle.BorderSizePixel = 0
statsTitle.Text = "SKILLS"
statsTitle.TextColor3 = DARK_BG
statsTitle.TextScaled = true
statsTitle.Font = Enum.Font.GothamBold
statsTitle.Parent = statsFrame

-- Stats content
local statsContent = Instance.new("ScrollingFrame")
statsContent.Name = "Content"
statsContent.Size = UDim2.new(1, -20, 1, -60)
statsContent.Position = UDim2.new(0, 10, 0, 50)
statsContent.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
statsContent.BorderSizePixel = 0
statsContent.ScrollBarThickness = 8
statsContent.Parent = statsFrame

-- Create hotbar (simple)
local hotbar = Instance.new("Frame")
hotbar.Name = "Hotbar"
hotbar.Size = UDim2.new(0, 400, 0, 60)
hotbar.Position = UDim2.new(0.5, -200, 1, -80)
hotbar.BackgroundColor3 = DARK_BG
hotbar.BorderSizePixel = 0
hotbar.Parent = screenGui

-- Hotbar slots (5 slots)
for i = 1, 5 do
	local slot = Instance.new("Frame")
	slot.Name = "Slot" .. i
	slot.Size = UDim2.new(0, 60, 0, 60)
	slot.Position = UDim2.new(0, (i-1) * 70 + 20, 0, 0)
	slot.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
	slot.BorderSizePixel = 1
	slot.BorderColor3 = GOLD
	slot.Parent = hotbar
	
	-- Slot number
	local slotNum = Instance.new("TextLabel")
	slotNum.Size = UDim2.new(1, 0, 0, 20)
	slotNum.Position = UDim2.new(0, 0, 1, -20)
	slotNum.BackgroundTransparency = 1
	slotNum.Text = tostring(i)
	slotNum.TextColor3 = GOLD
	slotNum.TextScaled = true
	slotNum.Font = Enum.Font.Gotham
	slotNum.Parent = slot
end

-- Toggle functions
local function toggleInventory()
	inventoryFrame.Visible = not inventoryFrame.Visible
end

local function toggleStats()
	statsFrame.Visible = not statsFrame.Visible
end

-- Key bindings
local UserInputService = game:GetService("UserInputService")
UserInputService.InputBegan:Connect(function(input)
	if input.KeyCode == Enum.KeyCode.I then
		toggleInventory()
	elseif input.KeyCode == Enum.KeyCode.K then
		toggleStats()
	end
end)

-- Sample data for testing
local function addSampleInventoryItems()
	for i = 1, 10 do
		local item = Instance.new("TextLabel")
		item.Size = UDim2.new(1, -10, 0, 30)
		item.Position = UDim2.new(0, 5, 0, (i-1) * 35 + 5)
		item.BackgroundColor3 = Color3.fromRGB(50, 50, 55)
		item.BorderSizePixel = 0
		item.Text = "Item " .. i .. " x" .. math.random(1, 10)
		item.TextColor3 = WHITE
		item.TextScaled = true
		item.Font = Enum.Font.Gotham
		item.Parent = invContent
	end
	invContent.CanvasSize = UDim2.new(0, 0, 0, 10 * 35 + 10)
end

local function addSampleSkills()
	local skills = {"Attack", "Defense", "Mining", "Fishing", "Cooking", "Woodcutting"}
	for i, skillName in ipairs(skills) do
		local skill = Instance.new("TextLabel")
		skill.Size = UDim2.new(1, -10, 0, 35)
		skill.Position = UDim2.new(0, 5, 0, (i-1) * 40 + 5)
		skill.BackgroundColor3 = Color3.fromRGB(50, 50, 55)
		skill.BorderSizePixel = 0
		skill.Text = skillName .. " - Level " .. math.random(1, 20)
		skill.TextColor3 = WHITE
		skill.TextScaled = true
		skill.Font = Enum.Font.Gotham
		skill.Parent = statsContent
	end
	statsContent.CanvasSize = UDim2.new(0, 0, 0, #skills * 40 + 10)
end

-- Initialize with sample data
task.wait(1)
addSampleInventoryItems()
addSampleSkills()

-- Instructions
local instructions = Instance.new("TextLabel")
instructions.Size = UDim2.new(0, 300, 0, 60)
instructions.Position = UDim2.new(0, 20, 0, 20)
instructions.BackgroundColor3 = DARK_BG
instructions.BorderSizePixel = 0
instructions.Text = "Press I for Inventory\nPress K for Skills"
instructions.TextColor3 = GOLD
instructions.TextScaled = true
instructions.Font = Enum.Font.Gotham
instructions.Parent = screenGui

-- Simple NPC Dialog System
local npcDialog = Instance.new("Frame")
npcDialog.Name = "NPCDialog"
npcDialog.Size = UDim2.new(0, 400, 0, 300)
npcDialog.Position = UDim2.new(0.5, -200, 0.5, -150)
npcDialog.BackgroundColor3 = DARK_BG
npcDialog.BorderSizePixel = 2
npcDialog.BorderColor3 = GOLD
npcDialog.Visible = false
npcDialog.Parent = screenGui

-- Dialog title
local dialogTitle = Instance.new("TextLabel")
dialogTitle.Size = UDim2.new(1, 0, 0, 40)
dialogTitle.BackgroundColor3 = GOLD
dialogTitle.Text = "NPC"
dialogTitle.TextColor3 = DARK_BG
dialogTitle.TextScaled = true
dialogTitle.Font = Enum.Font.GothamBold
dialogTitle.Parent = npcDialog

-- Dialog text
local dialogText = Instance.new("TextLabel")
dialogText.Size = UDim2.new(1, -20, 1, -80)
dialogText.Position = UDim2.new(0, 10, 0, 50)
dialogText.BackgroundTransparency = 1
dialogText.Text = "Hello there!"
dialogText.TextColor3 = WHITE
dialogText.TextScaled = true
dialogText.Font = Enum.Font.Gotham
dialogText.Parent = npcDialog

-- Close button
local closeButton = Instance.new("TextButton")
closeButton.Size = UDim2.new(0, 100, 0, 30)
closeButton.Position = UDim2.new(0.5, -50, 1, -40)
closeButton.BackgroundColor3 = GOLD
closeButton.Text = "Close"
closeButton.TextColor3 = DARK_BG
closeButton.TextScaled = true
closeButton.Font = Enum.Font.GothamBold
closeButton.Parent = npcDialog

closeButton.MouseButton1Click:Connect(function()
	npcDialog.Visible = false
end)

-- NPC Interaction Handler
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 5)
if Remotes then
	local NPCInteractEvent = Remotes:WaitForChild("NPCInteract", 5)
	if NPCInteractEvent then
		NPCInteractEvent.OnClientEvent:Connect(function(data)
			if data and data.npcName and data.dialog then
				dialogTitle.Text = data.npcName
				dialogText.Text = data.dialog
				npcDialog.Visible = true
			end
		end)
	end
end

-- Hide instructions after 5 seconds
task.wait(5)
instructions.Visible = false

print("[MinimalUI] Basic UI loaded - Press I for inventory, K for skills, click NPCs to interact")</string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="Workspace" referent="171">
    <Properties>
      <string name="Name">Workspace</string>
      <bool name="NeedsPivotMigration">false</bool>
    </Properties>
  </Item>
</roblox>