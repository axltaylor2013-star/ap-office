<roblox version="4">
  <Item class="Lighting" referent="0">
    <Properties>
      <string name="Name">Lighting</string>
    </Properties>
  </Item>
  <Item class="ReplicatedStorage" referent="1">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="2">
      <Properties>
        <string name="Name">Modules</string>
      </Properties>
      <Item class="ModuleScript" referent="3">
        <Properties>
          <string name="Name">Config</string>
          <string name="Source"><![CDATA[-- Config.lua (ModuleScript in ReplicatedStorage/Modules)
-- Game-wide constants and settings

local Config = {}

-- === SKILLS ===
Config.Skills = {
	Mining = { maxLevel = 99, baseXP = 50 },
	Woodcutting = { maxLevel = 99, baseXP = 45 },
	Fishing = { maxLevel = 99, baseXP = 40 },
	Smithing = { maxLevel = 99, baseXP = 60 },
	Cooking = { maxLevel = 99, baseXP = 55 },
	Strength = { maxLevel = 99, baseXP = 70 },
	Defense = { maxLevel = 99, baseXP = 65 },
	Ranged = { maxLevel = 99, baseXP = 65 },
	Fletching = { maxLevel = 99, baseXP = 55 },
	Prayer = { maxLevel = 99, baseXP = 60 },
}

-- === COMBAT SKILLS (used for Combat Level calculation) ===
Config.CombatSkills = {"Strength", "Defense", "Ranged", "Prayer"}

-- === XP MULTIPLIER ===
Config.XPMultiplier = 10 -- Global XP multiplier (10x)

-- XP formula: XP needed for level N = floor(N^2 * 100)
function Config.GetXPForLevel(level)
	return math.floor(level * level * 100)
end

-- Get level from total XP
function Config.GetLevelFromXP(totalXP)
	local level = 1
	while Config.GetXPForLevel(level + 1) <= totalXP and level < 99 do
		level = level + 1
	end
	return level
end

-- === INVENTORY ===
Config.MaxInventorySlots = 28 -- just like RuneScape
Config.MaxBankSlots = 100

-- === WILDERNESS ===
Config.WildernessEnabled = true
Config.SafeZoneOnDeath = true -- respawn in safe zone
Config.LootDropDuration = 60 -- seconds before loot despawns

-- === COMBAT ===
Config.BaseHealth = 100
Config.HealthPerCombatLevel = 5
Config.RespawnTime = 5 -- seconds
Config.AttackCooldown = 1.5 -- seconds between attacks

-- === RESOURCE RESPAWN ===
Config.ResourceRespawnTime = {
	Tree = 15,
	Rock = 20,
	FishingSpot = 10,
}

-- === ZONES ===
Config.Zones = {
	SafeZone = "SafeZone",
	Wilderness = "Wilderness",
}

return Config
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="4">
        <Properties>
          <string name="Name">DataManager</string>
          <string name="Source"><![CDATA[-- DataManager.lua (ModuleScript in ReplicatedStorage/Modules)
-- Handles saving/loading player data with DataStoreService

local DataStoreService = game:GetService("DataStoreService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

print("[DataManager] Loading...")
local Config = require(script.Parent:WaitForChild("Config"))
print("[DataManager] Config loaded!")

-- Check if DataStore is available (requires published place)
local dataStoreAvailable = false
local PlayerStore
pcall(function()
	PlayerStore = DataStoreService:GetDataStore("PlayerData_v1")
	dataStoreAvailable = true
end)

if not dataStoreAvailable then
	warn("[DataManager] DataStore not available (place not published) ‚Äî using in-memory storage. Data will NOT save between sessions.")
end

-- PlayerStore initialized above

local DataManager = {}
DataManager.PlayerData = {}

local function getDefaultData()
	return {
		Skills = {
			Mining = 0, Woodcutting = 0, Fishing = 0,
			Smithing = 0, Cooking = 0, Strength = 0, Defense = 0,
			Ranged = 0, Fletching = 0, Prayer = 0,
		},
		Inventory = {},
		Bank = {},
		Equipment = {Head = "", Body = "", Legs = "", Weapon = "", Shield = "", Tool = ""},
		Gold = 0,
		TotalDeaths = 0,
		TotalKills = 0,
		PlayTime = 0,
		PvPEnabled = true,
		FirstJoin = os.time(),
		LastSave = os.time(),
		Hotbar = {},
		PrayerPoints = 10, -- Base prayer points
		ActivePrayers = {}, -- Array of active prayer IDs
	}
end

function DataManager.LoadData(player)
	if dataStoreAvailable then
		local key = "Player_" .. player.UserId
		local success, data = pcall(function() return PlayerStore:GetAsync(key) end)
		if success and data then
			local defaults = getDefaultData()
			for k, v in pairs(defaults) do
				if data[k] == nil then data[k] = v end
			end
			if not data.Equipment then data.Equipment = defaults.Equipment end
			for skillName, _ in pairs(defaults.Skills) do
				if data.Skills[skillName] == nil then data.Skills[skillName] = 0 end
			end
			DataManager.PlayerData[player.UserId] = data
			print("[DataManager] Loaded saved data for " .. player.Name)
			return DataManager.PlayerData[player.UserId]
		end
	end
	-- New player or DataStore unavailable
	DataManager.PlayerData[player.UserId] = getDefaultData()
	print("[DataManager] Created fresh data for " .. player.Name)
	return DataManager.PlayerData[player.UserId]
end

function DataManager.SaveData(player)
	local data = DataManager.PlayerData[player.UserId]
	if not data then return end
	data.LastSave = os.time()
	if not dataStoreAvailable then return end -- skip save if no DataStore
	local key = "Player_" .. player.UserId
	local success, err = pcall(function() PlayerStore:SetAsync(key, data) end)
	if success then
		print("[DataManager] Saved data for " .. player.Name)
	else
		warn("[DataManager] FAILED to save for " .. player.Name .. ": " .. tostring(err))
	end
end

function DataManager.GetData(player) return DataManager.PlayerData[player.UserId] end

function DataManager.AddSkillXP(player, skillName, amount)
	local data = DataManager.PlayerData[player.UserId]
	if not data or not data.Skills[skillName] then return end
	-- Apply global XP multiplier
	amount = math.floor(amount * (Config.XPMultiplier or 1))
	local oldLevel = Config.GetLevelFromXP(data.Skills[skillName])
	data.Skills[skillName] = data.Skills[skillName] + amount
	local newLevel = Config.GetLevelFromXP(data.Skills[skillName])
	if newLevel > oldLevel then
		local remote = ReplicatedStorage.Remotes:FindFirstChild("LevelUp")
		if remote then remote:FireClient(player, skillName, newLevel) end
		print("[Skills] " .. player.Name .. " reached " .. skillName .. " level " .. newLevel)
	end
	local xpRemote = ReplicatedStorage.Remotes:FindFirstChild("XPUpdate")
	if xpRemote then xpRemote:FireClient(player, skillName, data.Skills[skillName], newLevel) end
end

function DataManager.GetSkillLevel(player, skillName)
	local data = DataManager.PlayerData[player.UserId]
	if not data or not data.Skills[skillName] then return 1 end
	return Config.GetLevelFromXP(data.Skills[skillName])
end

function DataManager.AddToInventory(player, itemName, quantity)
	local data = DataManager.PlayerData[player.UserId]
	if not data then return false end
	quantity = quantity or 1
	for _, slot in ipairs(data.Inventory) do
		if slot.name == itemName then slot.quantity = slot.quantity + quantity return true end
	end
	if #data.Inventory >= Config.MaxInventorySlots then return false end
	table.insert(data.Inventory, { name = itemName, quantity = quantity })
	return true
end

function DataManager.RemoveFromInventory(player, itemName, quantity)
	local data = DataManager.PlayerData[player.UserId]
	if not data then return false end
	quantity = quantity or 1
	for i, slot in ipairs(data.Inventory) do
		if slot.name == itemName then
			slot.quantity = slot.quantity - quantity
			if slot.quantity <= 0 then table.remove(data.Inventory, i) end
			return true
		end
	end
	return false
end

function DataManager.HasItem(player, itemName, quantity)
	local data = DataManager.PlayerData[player.UserId]
	if not data then return false end
	quantity = quantity or 1
	for _, slot in ipairs(data.Inventory) do
		if slot.name == itemName and slot.quantity >= quantity then return true end
	end
	return false
end

function DataManager.DepositToBank(player, itemName, quantity)
	local data = DataManager.PlayerData[player.UserId]
	if not data then return false end
	if not DataManager.HasItem(player, itemName, quantity) then return false end
	DataManager.RemoveFromInventory(player, itemName, quantity)
	for _, slot in ipairs(data.Bank) do
		if slot.name == itemName then slot.quantity = slot.quantity + quantity return true end
	end
	if #data.Bank >= Config.MaxBankSlots then
		DataManager.AddToInventory(player, itemName, quantity)
		return false
	end
	table.insert(data.Bank, { name = itemName, quantity = quantity })
	return true
end

function DataManager.WithdrawFromBank(player, itemName, quantity)
	local data = DataManager.PlayerData[player.UserId]
	if not data then return false end
	for i, slot in ipairs(data.Bank) do
		if slot.name == itemName and slot.quantity >= quantity then
			if #data.Inventory >= Config.MaxInventorySlots then
				local found = false
				for _, invSlot in ipairs(data.Inventory) do
					if invSlot.name == itemName then found = true break end
				end
				if not found then return false end
			end
			slot.quantity = slot.quantity - quantity
			if slot.quantity <= 0 then table.remove(data.Bank, i) end
			DataManager.AddToInventory(player, itemName, quantity)
			return true
		end
	end
	return false
end

function DataManager.GetAndClearInventory(player)
	local data = DataManager.PlayerData[player.UserId]
	if not data then return {} end
	local dropped = {}
	for _, slot in ipairs(data.Inventory) do
		table.insert(dropped, { name = slot.name, quantity = slot.quantity })
	end
	data.Inventory = {}
	data.TotalDeaths = data.TotalDeaths + 1
	return dropped
end

-- === GOLD SYSTEM ===
function DataManager.AddGold(player, amount)
	local data = DataManager.PlayerData[player.UserId]
	if not data then return false end
	data.Gold = (data.Gold or 0) + amount
	return true
end

function DataManager.RemoveGold(player, amount)
	local data = DataManager.PlayerData[player.UserId]
	if not data then return false end
	if (data.Gold or 0) < amount then return false end
	data.Gold = data.Gold - amount
	return true
end

function DataManager.GetGold(player)
	local data = DataManager.PlayerData[player.UserId]
	if not data then return 0 end
	return data.Gold or 0
end

-- === QUEST SYSTEM ===
function DataManager.GetQuests(player)
	local data = DataManager.PlayerData[player.UserId]
	if not data then return {} end
	if not data.Quests then data.Quests = {active = {}, completed = {}} end
	return data.Quests
end

function DataManager.SaveQuests(player, quests)
	local data = DataManager.PlayerData[player.UserId]
	if not data then return end
	data.Quests = quests
end

-- === COMBAT LEVEL ===
function DataManager.GetCombatLevel(player)
	local data = DataManager.PlayerData[player.UserId]
	if not data then return 1 end
	-- Combat level = average of all combat skills (Strength, Defense, Ranged, Prayer)
	local total = 0
	local count = 0
	for _, skillName in Config.CombatSkills do
		local xp = (data.Skills and data.Skills[skillName]) or 0
		total = total + Config.GetLevelFromXP(xp)
		count = count + 1
	end
	return math.max(1, math.floor(total / count))
end

-- === COMPATIBILITY ALIASES ===
function DataManager.GetInventory(player)
	local data = DataManager.PlayerData[player.UserId]
	if not data then return {} end
	return data.Inventory
end

function DataManager.ClearInventory(player)
	local data = DataManager.PlayerData[player.UserId]
	if not data then return end
	data.Inventory = {}
end

function DataManager.AddItem(player, itemName, quantity)
	return DataManager.AddToInventory(player, itemName, quantity or 1)
end

function DataManager.RemoveItem(player, itemName, quantity)
	return DataManager.RemoveFromInventory(player, itemName, quantity or 1)
end

function DataManager.GetItemCount(player, itemName)
	local data = DataManager.PlayerData[player.UserId]
	if not data then return 0 end
	for _, slot in ipairs(data.Inventory) do
		if slot.name == itemName then return slot.quantity end
	end
	return 0
end

function DataManager.RecordKill(player)
	local data = DataManager.PlayerData[player.UserId]
	if data then data.TotalKills = (data.TotalKills or 0) + 1 end
end

return DataManager
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="5">
        <Properties>
          <string name="Name">ItemDatabase</string>
          <string name="Source"><![CDATA[-- ItemDatabase.lua (ModuleScript in ReplicatedStorage/Modules)
-- Every item in the game defined here

local ItemDatabase = {}

ItemDatabase.Items = {
	-- === ORES (from Mining) ===
	["Copper Ore"] = {
		id = "copper_ore",
		type = "resource",
		rarity = "common",
		skill = "Mining",
		levelReq = 1,
		xp = 20,
		stackable = true,
		value = 5,
		description = "A chunk of copper ore.",
	},
	["Iron Ore"] = {
		id = "iron_ore",
		type = "resource",
		rarity = "uncommon",
		skill = "Mining",
		levelReq = 15,
		xp = 35,
		stackable = true,
		value = 15,
		description = "A chunk of iron ore.",
	},
	["Gold Ore"] = {
		id = "gold_ore",
		type = "resource",
		rarity = "rare",
		skill = "Mining",
		levelReq = 40,
		xp = 65,
		stackable = true,
		value = 50,
		description = "A chunk of gold ore. Valuable.",
	},
	["Runite Ore"] = {
		id = "runite_ore",
		type = "resource",
		rarity = "epic",
		skill = "Mining",
		levelReq = 70,
		xp = 125,
		stackable = true,
		value = 200,
		description = "Extremely rare ore. Only found in the Wilderness.",
		wildernessOnly = true,
	},

	-- === LOGS (from Woodcutting) ===
	["Oak Log"] = {
		id = "oak_log",
		type = "resource",
		rarity = "common",
		skill = "Woodcutting",
		levelReq = 1,
		xp = 18,
		stackable = true,
		value = 4,
		description = "A sturdy oak log.",
	},
	["Willow Log"] = {
		id = "willow_log",
		type = "resource",
		rarity = "uncommon",
		skill = "Woodcutting",
		levelReq = 20,
		xp = 40,
		stackable = true,
		value = 12,
		description = "A flexible willow log.",
	},
	["Yew Log"] = {
		id = "yew_log",
		type = "resource",
		rarity = "rare",
		skill = "Woodcutting",
		levelReq = 50,
		xp = 80,
		stackable = true,
		value = 75,
		description = "Dense yew wood. Prized by fletchers.",
	},
	["Magic Log"] = {
		id = "magic_log",
		type = "resource",
		rarity = "epic",
		skill = "Woodcutting",
		levelReq = 75,
		xp = 150,
		stackable = true,
		value = 250,
		description = "Pulsing with energy. Wilderness only.",
		wildernessOnly = true,
	},

	-- === FISH (from Fishing) ===
	["Shrimp"] = {
		id = "shrimp",
		type = "resource",
		skill = "Fishing",
		levelReq = 1,
		xp = 15,
		stackable = true,
		value = 3,
		cookable = true,
		healAmount = 5,
		description = "A small shrimp.",
	},
	["Trout"] = {
		id = "trout",
		type = "resource",
		skill = "Fishing",
		levelReq = 20,
		xp = 35,
		stackable = true,
		value = 10,
		cookable = true,
		healAmount = 15,
		description = "A fresh trout.",
	},
	["Lobster"] = {
		id = "lobster",
		type = "resource",
		skill = "Fishing",
		levelReq = 40,
		xp = 60,
		stackable = true,
		value = 40,
		cookable = true,
		healAmount = 30,
		description = "A large lobster.",
	},
	["Dark Crab"] = {
		id = "dark_crab",
		type = "resource",
		skill = "Fishing",
		levelReq = 70,
		xp = 130,
		stackable = true,
		value = 180,
		cookable = true,
		healAmount = 50,
		description = "Found only in Wilderness waters.",
		wildernessOnly = true,
	},

	-- === BARS (from Smithing) ===
	["Copper Bar"] = {
		id = "copper_bar",
		type = "crafted",
		skill = "Smithing",
		levelReq = 1,
		xp = 25,
		stackable = true,
		value = 12,
		recipe = { ["Copper Ore"] = 1 },
		description = "A smelted copper bar.",
	},
	["Iron Bar"] = {
		id = "iron_bar",
		type = "crafted",
		skill = "Smithing",
		levelReq = 15,
		xp = 45,
		stackable = true,
		value = 35,
		recipe = { ["Iron Ore"] = 1 },
		description = "A smelted iron bar.",
	},
	["Gold Bar"] = {
		id = "gold_bar",
		type = "crafted",
		skill = "Smithing",
		levelReq = 40,
		xp = 75,
		stackable = true,
		value = 120,
		recipe = { ["Gold Ore"] = 1 },
		description = "A gleaming gold bar.",
	},

	-- === WEAPONS ===
	["Copper Sword"] = {
		id = "copper_sword",
		type = "weapon",
		equipSlot = "Weapon",
		skill = "Smithing",
		levelReq = 1,
		combatReq = 1,
		xp = 50,
		stackable = false,
		value = 30,
		damage = 8,
		attackSpeed = 1.5,
		recipe = { ["Copper Bar"] = 2 },
		description = "A basic copper sword.",
	},
	["Iron Sword"] = {
		id = "iron_sword",
		type = "weapon",
		equipSlot = "Weapon",
		skill = "Smithing",
		levelReq = 20,
		combatReq = 15,
		xp = 80,
		stackable = false,
		value = 85,
		damage = 15,
		attackSpeed = 1.4,
		recipe = { ["Iron Bar"] = 2 },
		description = "A solid iron blade.",
	},
	["Gold Sword"] = {
		id = "gold_sword",
		type = "weapon",
		equipSlot = "Weapon",
		skill = "Smithing",
		levelReq = 45,
		combatReq = 40,
		xp = 120,
		stackable = false,
		value = 300,
		damage = 25,
		attackSpeed = 1.3,
		recipe = { ["Gold Bar"] = 3 },
		description = "A powerful gold sword.",
	},

	-- === COOKED FOOD ===
	["Cooked Shrimp"] = {
		id = "cooked_shrimp",
		type = "food",
		skill = "Cooking",
		levelReq = 1,
		xp = 20,
		stackable = true,
		value = 8,
		healAmount = 10,
		recipe = { ["Shrimp"] = 1 },
		description = "Heals 10 HP.",
	},
	["Cooked Trout"] = {
		id = "cooked_trout",
		type = "food",
		skill = "Cooking",
		levelReq = 20,
		xp = 40,
		stackable = true,
		value = 25,
		healAmount = 25,
		recipe = { ["Trout"] = 1 },
		description = "Heals 25 HP.",
	},
	["Cooked Lobster"] = {
		id = "cooked_lobster",
		type = "food",
		skill = "Cooking",
		levelReq = 40,
		xp = 65,
		stackable = true,
		value = 90,
		healAmount = 45,
		recipe = { ["Lobster"] = 1 },
		description = "Heals 45 HP.",
	},
	["Cooked Dark Crab"] = {
		id = "cooked_dark_crab",
		type = "food",
		skill = "Cooking",
		levelReq = 70,
		xp = 140,
		stackable = true,
		value = 350,
		healAmount = 70,
		recipe = { ["Dark Crab"] = 1 },
		description = "Heals 70 HP. The best food in the game.",
	},

	-- === MONSTER DROPS ===
	["Feather"] = {
		id = "feather",
		type = "resource",
		stackable = true,
		value = 2,
		description = "A soft feather.",
	},
	["Raw Chicken"] = {
		id = "raw_chicken",
		type = "resource",
		skill = "Cooking",
		levelReq = 1,
		xp = 15,
		cookable = true,
		healAmount = 3,
		value = 3,
		description = "Raw chicken meat.",
	},
	["Cooked Chicken"] = {
		id = "cooked_chicken",
		type = "food",
		stackable = true,
		value = 8,
		healAmount = 8,
		recipe = { ["Raw Chicken"] = 1 },
		description = "Heals 8 HP.",
	},
	["Cowhide"] = {
		id = "cowhide",
		type = "resource",
		stackable = true,
		value = 5,
		description = "Can be crafted into leather.",
	},
	["Raw Beef"] = {
		id = "raw_beef",
		type = "resource",
		skill = "Cooking",
		levelReq = 1,
		xp = 18,
		cookable = true,
		healAmount = 4,
		value = 4,
		description = "A slab of raw beef.",
	},
	["Cooked Beef"] = {
		id = "cooked_beef",
		type = "food",
		stackable = true,
		value = 12,
		healAmount = 12,
		recipe = { ["Raw Beef"] = 1 },
		description = "Heals 12 HP.",
	},
	["Goblin Mail"] = {
		id = "goblin_mail",
		type = "armor",
		equipSlot = "Body",
		combatReq = 1,
		stackable = false,
		value = 25,
		defense = 3,
		description = "Crude goblin armor.",
	},
	["Bones"] = {
		id = "bones",
		type = "resource",
		stackable = true,
		value = 3,
		description = "Can be buried for Prayer XP.",
	},
	["Dog Tag"] = {
		id = "dog_tag",
		type = "resource",
		stackable = true,
		value = 50,
		description = "A shiny dog tag. Rare collectible.",
	},
	["Rat Tail"] = {
		id = "rat_tail",
		type = "resource",
		stackable = true,
		value = 5,
		description = "Gross but useful for potions.",
	},
	["Raw Rat Meat"] = {
		id = "raw_rat_meat",
		type = "resource",
		skill = "Cooking",
		levelReq = 1,
		xp = 10,
		cookable = true,
		healAmount = 2,
		value = 2,
		description = "Not appetizing.",
	},
	["Cooked Rat Meat"] = {
		id = "cooked_rat_meat",
		type = "food",
		stackable = true,
		value = 5,
		healAmount = 5,
		recipe = { ["Raw Rat Meat"] = 1 },
		description = "Barely edible. Heals 5 HP.",
	},
	["Wizard Robe"] = {
		id = "wizard_robe",
		type = "armor",
		equipSlot = "Body",
		combatReq = 30,
		stackable = false,
		value = 200,
		defense = 12,
		description = "Enchanted wizard robes.",
	},
	["Demon Heart"] = {
		id = "demon_heart",
		type = "resource",
		stackable = true,
		value = 500,
		description = "Pulsing with dark energy.",
	},
	["Dragon Scale"] = {
		id = "dragon_scale",
		type = "resource",
		stackable = true,
		value = 1000,
		description = "Nearly indestructible.",
	},
	["Dragon Sword"] = {
		id = "dragon_sword",
		type = "weapon",
		equipSlot = "Weapon",
		combatReq = 75,
		stackable = false,
		value = 5000,
		damage = 50,
		attackSpeed = 1.1,
		description = "Forged from dragon fire.",
	},
	["Shadow Gem"] = {
		id = "shadow_gem",
		type = "resource",
		stackable = true,
		value = 2000,
		description = "Radiates shadow energy.",
	},
	["Bronze Helmet"] = {
		id = "bronze_helmet",
		type = "armor",
		equipSlot = "Head",
		combatReq = 1,
		stackable = false,
		value = 20,
		defense = 2,
		description = "A basic bronze helmet.",
	},
	-- === LEG ARMOR (full tier set) ===
	["Bronze Platelegs"] = {
		id = "bronze_platelegs", type = "armor", equipSlot = "Legs",
		combatReq = 1, stackable = false, value = 20, defense = 3,
		description = "Basic bronze leg armor.",
	},
	["Iron Platelegs"] = {
		id = "iron_platelegs", type = "armor", equipSlot = "Legs",
		combatReq = 15, stackable = false, value = 60, defense = 8,
		description = "Sturdy iron leg armor.",
	},
	["Gold Platelegs"] = {
		id = "gold_platelegs", type = "armor", equipSlot = "Legs",
		combatReq = 30, stackable = false, value = 200, defense = 14,
		description = "Ornate gold-plated leg armor.",
	},
	["Runite Platelegs"] = {
		id = "runite_platelegs", type = "armor", equipSlot = "Legs",
		combatReq = 50, stackable = false, value = 800, defense = 22,
		description = "Powerful runite leg armor.",
	},
	["Dragon Platelegs"] = {
		id = "dragon_platelegs", type = "armor", equipSlot = "Legs",
		combatReq = 70, stackable = false, value = 3000, defense = 35,
		rarity = "legendary",
		description = "Legendary dragon leg armor, forged in dragonfire.",
	},

	-- === CHEST ARMOR (full tier set) ===
	["Bronze Platebody"] = {
		id = "bronze_platebody", type = "armor", equipSlot = "Body",
		combatReq = 1, stackable = false, value = 30, defense = 5,
		description = "Basic bronze chest plate.",
	},
	["Iron Platebody"] = {
		id = "iron_platebody", type = "armor", equipSlot = "Body",
		combatReq = 15, stackable = false, value = 80, defense = 12,
		description = "Solid iron chest armor.",
	},
	["Gold Platebody"] = {
		id = "gold_platebody", type = "armor", equipSlot = "Body",
		combatReq = 30, stackable = false, value = 300, defense = 20,
		description = "A gilded gold chest plate.",
	},
	["Runite Platebody"] = {
		id = "runite_platebody", type = "armor", equipSlot = "Body",
		combatReq = 50, stackable = false, value = 1200, defense = 30,
		description = "Elite runite chest armor.",
	},
	["Dragon Platebody"] = {
		id = "dragon_platebody", type = "armor", equipSlot = "Body",
		combatReq = 70, stackable = false, value = 5000, defense = 45,
		rarity = "legendary",
		description = "Legendary dragon chest armor, nearly indestructible.",
	},

	-- === CHAINMAIL (lighter body armor, lower defense but allows ranged) ===
	["Iron Chainbody"] = {
		id = "iron_chainbody", type = "armor", equipSlot = "Body",
		combatReq = 10, stackable = false, value = 40, defense = 6,
		description = "Light iron chainmail, good for rangers.",
	},
	["Gold Chainbody"] = {
		id = "gold_chainbody", type = "armor", equipSlot = "Body",
		combatReq = 25, stackable = false, value = 150, defense = 12,
		description = "Flexible gold chainmail.",
	},
	["Runite Chainbody"] = {
		id = "runite_chainbody", type = "armor", equipSlot = "Body",
		combatReq = 45, stackable = false, value = 600, defense = 20,
		description = "Strong yet flexible runite chainmail.",
	},

	-- === LEATHER ARMOR (ranger gear) ===
	["Leather Body"] = {
		id = "leather_body", type = "armor", equipSlot = "Body",
		combatReq = 1, stackable = false, value = 15, defense = 3,
		description = "Simple leather tunic.",
	},
	["Leather Chaps"] = {
		id = "leather_chaps", type = "armor", equipSlot = "Legs",
		combatReq = 1, stackable = false, value = 12, defense = 2,
		description = "Basic leather leg protection.",
	},
	["Studded Body"] = {
		id = "studded_body", type = "armor", equipSlot = "Body",
		combatReq = 20, stackable = false, value = 80, defense = 8,
		description = "Leather armor reinforced with metal studs.",
	},
	["Studded Chaps"] = {
		id = "studded_chaps", type = "armor", equipSlot = "Legs",
		combatReq = 20, stackable = false, value = 60, defense = 6,
		description = "Studded leather leg armor.",
	},
	["Dragonhide Body"] = {
		id = "dragonhide_body", type = "armor", equipSlot = "Body",
		combatReq = 60, stackable = false, value = 2000, defense = 28,
		rarity = "epic",
		description = "Armor crafted from dragon scales, prized by rangers.",
	},
	["Dragonhide Chaps"] = {
		id = "dragonhide_chaps", type = "armor", equipSlot = "Legs",
		combatReq = 60, stackable = false, value = 1500, defense = 22,
		rarity = "epic",
		description = "Leg armor from dragon scales, light and durable.",
	},

	-- Keep old Iron Legs as alias
	["Iron Legs"] = {
		id = "iron_legs", type = "armor", equipSlot = "Legs",
		combatReq = 15, stackable = false, value = 60, defense = 8,
		description = "Sturdy iron leg armor.",
	},
	["Wooden Shield"] = {
		id = "wooden_shield",
		type = "armor",
		equipSlot = "Shield",
		combatReq = 1,
		stackable = false,
		value = 15,
		defense = 2,
		description = "A simple wooden shield.",
	},
	["Bronze Coins"] = {
		id = "bronze_coins",
		type = "currency",
		stackable = true,
		value = 1,
		description = "Standard currency.",
	},

	-- === RANGED WEAPONS ===
	["Oak Shortbow"] = {
		id = "oak_shortbow",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 6,
		rangedReq = 1,
		stackable = false,
		value = 15,
		description = "A basic oak shortbow.",
	},
	["Oak Longbow"] = {
		id = "oak_longbow",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 10,
		rangedReq = 10,
		stackable = false,
		value = 30,
		description = "A sturdy oak longbow.",
	},
	["Willow Shortbow"] = {
		id = "willow_shortbow",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 12,
		rangedReq = 20,
		stackable = false,
		value = 50,
		description = "A flexible willow shortbow.",
	},
	["Iron Crossbow"] = {
		id = "iron_crossbow",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 18,
		rangedReq = 30,
		stackable = false,
		value = 100,
		recipe = { ["Iron Bar"] = 3 },
		description = "A powerful iron crossbow.",
	},
	["Willow Longbow"] = {
		id = "willow_longbow",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 18,
		rangedReq = 40,
		stackable = false,
		value = 120,
		description = "A long willow bow with great range.",
	},
	["Yew Shortbow"] = {
		id = "yew_shortbow",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 22,
		rangedReq = 55,
		stackable = false,
		value = 200,
		description = "A yew shortbow. Fast and accurate.",
	},
	["Gold Crossbow"] = {
		id = "gold_crossbow",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 28,
		rangedReq = 65,
		stackable = false,
		value = 400,
		recipe = { ["Gold Bar"] = 3 },
		description = "A gleaming gold crossbow.",
	},
	["Yew Longbow"] = {
		id = "yew_longbow",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 30,
		rangedReq = 70,
		stackable = false,
		value = 350,
		description = "A powerful yew longbow.",
	},
	["Magic Shortbow"] = {
		id = "magic_shortbow",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 35,
		rangedReq = 85,
		stackable = false,
		value = 800,
		description = "Imbued with magical energy.",
	},
	["Dragon Crossbow"] = {
		id = "dragon_crossbow",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 45,
		rangedReq = 95,
		stackable = false,
		value = 8000,
		description = "Forged from dragonfire. The ultimate ranged weapon.",
	},

	-- === AMMUNITION ===
	["Bronze Arrows"] = {
		id = "bronze_arrows",
		type = "ammo",
		stackable = true,
		bonusDmg = 1,
		value = 1,
		description = "Basic bronze-tipped arrows.",
	},
	["Iron Arrows"] = {
		id = "iron_arrows",
		type = "ammo",
		stackable = true,
		bonusDmg = 3,
		value = 3,
		description = "Iron-tipped arrows.",
	},
	["Gold Arrows"] = {
		id = "gold_arrows",
		type = "ammo",
		stackable = true,
		bonusDmg = 6,
		value = 8,
		description = "Gold-tipped arrows.",
	},
	["Runite Arrows"] = {
		id = "runite_arrows",
		type = "ammo",
		stackable = true,
		bonusDmg = 10,
		value = 25,
		description = "Runite-tipped arrows. Devastating.",
	},
	["Iron Bolts"] = {
		id = "iron_bolts",
		type = "ammo",
		stackable = true,
		bonusDmg = 4,
		value = 4,
		description = "Iron crossbow bolts.",
	},
	["Gold Bolts"] = {
		id = "gold_bolts",
		type = "ammo",
		stackable = true,
		bonusDmg = 8,
		value = 10,
		description = "Gold crossbow bolts.",
	},
	["Runite Bolts"] = {
		id = "runite_bolts",
		type = "ammo",
		stackable = true,
		bonusDmg = 12,
		value = 30,
		description = "Runite crossbow bolts.",
	},
	["Bowstring"] = {
		id = "bowstring",
		type = "resource",
		stackable = true,
		value = 5,
		description = "Used for crafting bows.",
	},
	["Arrow Shafts"] = {
		id = "arrow_shafts",
		type = "resource",
		stackable = true,
		value = 1,
		description = "Used for crafting arrows.",
	},
	["Magic Bowstring"] = {
		id = "magic_bowstring",
		type = "resource",
		stackable = true,
		value = 500,
		rarity = "epic",
		description = "A bowstring pulsing with magical energy.",
	},

	-- === SHIELDS ===
	["Iron Shield"] = {
		id = "iron_shield",
		type = "armor",
		equipSlot = "Shield",
		defense = 10,
		combatReq = 15,
		stackable = false,
		value = 60,
		description = "A sturdy iron shield.",
	},
	["Gold Shield"] = {
		id = "gold_shield",
		type = "armor",
		equipSlot = "Shield",
		defense = 18,
		combatReq = 40,
		stackable = false,
		value = 250,
		description = "A gleaming gold shield.",
	},
	["Runite Shield"] = {
		id = "runite_shield",
		type = "armor",
		equipSlot = "Shield",
		defense = 30,
		combatReq = 70,
		stackable = false,
		value = 1500,
		description = "A nearly indestructible runite shield.",
	},
	["Dragon Shield"] = {
		id = "dragon_shield",
		type = "armor",
		equipSlot = "Shield",
		defense = 45,
		combatReq = 80,
		stackable = false,
		value = 7000,
		rarity = "legendary",
		description = "Forged from dragon scales.",
	},

	-- === MORE WEAPONS ===
	["Runite Sword"] = {
		id = "runite_sword",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 40,
		combatReq = 70,
		stackable = false,
		value = 2000,
		rarity = "epic",
		description = "A deadly runite blade.",
	},
	-- === PICKAXES ===
	["Bronze Pickaxe"] = {
		id = "bronze_pickaxe", type = "tool", equipSlot = "Tool", toolType = "pickaxe",
		levelReq = 1, skill = "Mining", gatherSpeed = 1.0, stackable = false, value = 10,
		description = "A basic bronze pickaxe.",
	},
	["Iron Pickaxe"] = {
		id = "iron_pickaxe", type = "tool", equipSlot = "Tool", toolType = "pickaxe",
		levelReq = 15, skill = "Mining", gatherSpeed = 0.8, stackable = false, value = 50,
		description = "A sturdy iron pickaxe.",
	},
	["Gold Pickaxe"] = {
		id = "gold_pickaxe", type = "tool", equipSlot = "Tool", toolType = "pickaxe",
		levelReq = 40, skill = "Mining", gatherSpeed = 0.6, stackable = false, value = 200,
		description = "A heavy gold pickaxe.",
	},
	["Runite Pickaxe"] = {
		id = "runite_pickaxe", type = "tool", equipSlot = "Tool", toolType = "pickaxe",
		levelReq = 70, skill = "Mining", gatherSpeed = 0.4, stackable = false, value = 1000,
		description = "The finest pickaxe money can buy.",
	},
	["Dragon Pickaxe"] = {
		id = "dragon_pickaxe", type = "tool", equipSlot = "Tool", toolType = "pickaxe",
		levelReq = 85, skill = "Mining", gatherSpeed = 0.3, stackable = false, value = 5000,
		rarity = "legendary", description = "Forged from dragonfire. Mines at incredible speed.",
	},

	-- === AXES (Woodcutting) ===
	["Bronze Axe"] = {
		id = "bronze_axe", type = "tool", equipSlot = "Tool", toolType = "axe",
		levelReq = 1, skill = "Woodcutting", gatherSpeed = 1.0, stackable = false, value = 10,
		description = "A basic bronze axe.",
	},
	["Iron Axe"] = {
		id = "iron_axe", type = "tool", equipSlot = "Tool", toolType = "axe",
		levelReq = 15, skill = "Woodcutting", gatherSpeed = 0.8, stackable = false, value = 50,
		description = "A sharp iron axe.",
	},
	["Gold Axe"] = {
		id = "gold_axe", type = "tool", equipSlot = "Tool", toolType = "axe",
		levelReq = 40, skill = "Woodcutting", gatherSpeed = 0.6, stackable = false, value = 200,
		description = "A gleaming gold axe.",
	},
	["Runite Axe"] = {
		id = "runite_axe", type = "tool", equipSlot = "Tool", toolType = "axe",
		levelReq = 70, skill = "Woodcutting", gatherSpeed = 0.4, stackable = false, value = 1000,
		description = "Cuts through anything.",
	},
	["Dragon Axe"] = {
		id = "dragon_axe", type = "tool", equipSlot = "Tool", toolType = "axe",
		levelReq = 85, skill = "Woodcutting", gatherSpeed = 0.3, stackable = false, value = 5000,
		rarity = "legendary", description = "The ultimate woodcutting tool.",
	},

	-- === FISHING RODS ===
	["Wooden Rod"] = {
		id = "wooden_rod", type = "tool", equipSlot = "Tool", toolType = "fishing_rod",
		levelReq = 1, skill = "Fishing", gatherSpeed = 1.0, stackable = false, value = 10,
		description = "A simple wooden fishing rod.",
	},
	["Iron Rod"] = {
		id = "iron_rod", type = "tool", equipSlot = "Tool", toolType = "fishing_rod",
		levelReq = 15, skill = "Fishing", gatherSpeed = 0.8, stackable = false, value = 50,
		description = "A rod with an iron reel.",
	},
	["Gold Rod"] = {
		id = "gold_rod", type = "tool", equipSlot = "Tool", toolType = "fishing_rod",
		levelReq = 40, skill = "Fishing", gatherSpeed = 0.6, stackable = false, value = 200,
		description = "A fine gold fishing rod.",
	},
	["Runite Rod"] = {
		id = "runite_rod", type = "tool", equipSlot = "Tool", toolType = "fishing_rod",
		levelReq = 70, skill = "Fishing", gatherSpeed = 0.4, stackable = false, value = 1000,
		description = "Fish practically leap onto this rod.",
	},
	["Dragon Rod"] = {
		id = "dragon_rod", type = "tool", equipSlot = "Tool", toolType = "fishing_rod",
		levelReq = 85, skill = "Fishing", gatherSpeed = 0.3, stackable = false, value = 5000,
		rarity = "legendary", description = "The fish don't stand a chance.",
	},

	-- === NEW BOSS DROP ITEMS ===
	-- King Rooster drops
	["Golden Feather"] = {
		id = "golden_feather",
		type = "material",
		rarity = "rare",
		stackable = true,
		value = 500,
		description = "A magnificent golden feather from the King Rooster.",
	},
	["King's Crest"] = {
		id = "kings_crest",
		type = "material",
		rarity = "uncommon",
		stackable = true,
		value = 750,
		description = "The royal crest of the chicken kingdom.",
	},

	-- Elder Treant drops
	["Heartwood"] = {
		id = "heartwood",
		type = "material",
		rarity = "rare",
		stackable = true,
		value = 1200,
		description = "The magical core wood of an ancient treant.",
	},
	["Ancient Bark"] = {
		id = "ancient_bark",
		type = "material",
		stackable = true,
		value = 200,
		description = "Bark from a millennia-old treant.",
	},
	["Elder Seed"] = {
		id = "elder_seed",
		type = "material",
		rarity = "epic",
		stackable = true,
		value = 3000,
		description = "A mystical seed that could grow into a great treant.",
	},

	-- Iron Golem drops
	["Golem Core"] = {
		id = "golem_core",
		type = "material",
		rarity = "epic",
		stackable = true,
		value = 5000,
		description = "The magical power source of an iron golem.",
	},
	["Golem Shield"] = {
		id = "golem_shield",
		type = "armor",
		equipSlot = "Shield",
		defBonus = 25,
		rarity = "rare",
		stackable = false,
		value = 2500,
		description = "A massive shield crafted from golem materials.",
	},

	-- Lake Serpent drops
	["Serpent Scale"] = {
		id = "serpent_scale",
		type = "material",
		rarity = "epic",
		stackable = true,
		value = 4000,
		description = "A shimmering scale from the legendary Lake Serpent.",
	},
	["Sea Fang"] = {
		id = "sea_fang",
		type = "weapon",
		damage = 35,
		rarity = "rare",
		stackable = false,
		value = 2000,
		description = "A sharp fang that can pierce through armor.",
	},
	["Serpent's Eye"] = {
		id = "serpents_eye",
		type = "material",
		rarity = "legendary",
		stackable = true,
		value = 10000,
		description = "The mystical eye of the Lake Serpent, pulsing with ancient magic.",
	},

	-- Corrupted Guardian drops
	["Guardian's Blessing"] = {
		id = "guardians_blessing",
		type = "material",
		rarity = "legendary",
		stackable = true,
		value = 15000,
		description = "A powerful blessing that purifies corruption and grants protection.",
	},
	["Corrupted Plate"] = {
		id = "corrupted_plate",
		type = "armor",
		equipSlot = "Body",
		defBonus = 40,
		rarity = "epic",
		stackable = false,
		value = 8000,
		description = "Heavy armor plate infused with dark magic.",
	},
	["Ancient Key"] = {
		id = "ancient_key",
		type = "material",
		rarity = "rare",
		stackable = true,
		value = 3000,
		description = "An ornate key that may unlock ancient mysteries.",
	},

	-- === NEW AREA MONSTER DROPS (MapSetup5) ===
	
	-- Pirate Ghost drops
	["Ghost Doubloon"] = {
		id = "ghost_doubloon",
		type = "currency",
		rarity = "uncommon",
		stackable = true,
		value = 25,
		description = "A spectral coin from the world beyond.",
	},
	["Pirate Cutlass"] = {
		id = "pirate_cutlass",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 22,
		combatReq = 25,
		rarity = "uncommon",
		stackable = false,
		value = 150,
		description = "A curved blade favored by ghostly pirates.",
	},
	["Spectral Cloth"] = {
		id = "spectral_cloth",
		type = "material",
		rarity = "uncommon",
		stackable = true,
		value = 40,
		description = "Ethereal fabric that phases between worlds.",
	},
	
	-- Ice Elemental drops
	["Frozen Shard"] = {
		id = "frozen_shard",
		type = "material",
		rarity = "uncommon",
		stackable = true,
		value = 30,
		description = "A shard of pure ice that never melts.",
	},
	["Ice Crystal"] = {
		id = "ice_crystal",
		type = "material",
		rarity = "rare",
		stackable = true,
		value = 120,
		description = "A perfect crystal formed in the heart of winter.",
	},
	["Frost Essence"] = {
		id = "frost_essence",
		type = "material",
		rarity = "epic",
		stackable = true,
		value = 300,
		description = "The very essence of eternal winter.",
	},
	["Permafrost Ore"] = {
		id = "permafrost_ore",
		type = "resource",
		rarity = "uncommon",
		skill = "Mining",
		levelReq = 30,
		xp = 50,
		stackable = true,
		value = 45,
		description = "Ore that remains frozen even in fire.",
	},
	
	-- Lava Golem drops
	["Magma Core"] = {
		id = "magma_core",
		type = "material",
		rarity = "epic",
		stackable = true,
		value = 400,
		description = "The molten heart of a lava golem.",
	},
	["Obsidian Shard"] = {
		id = "obsidian_shard",
		type = "material",
		rarity = "uncommon",
		stackable = true,
		value = 35,
		description = "Sharp volcanic glass formed in extreme heat.",
	},
	["Volcanic Ash"] = {
		id = "volcanic_ash",
		type = "material",
		rarity = "common",
		stackable = true,
		value = 8,
		description = "Fine ash from volcanic eruptions.",
	},
	["Lava Blade"] = {
		id = "lava_blade",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 45,
		combatReq = 55,
		rarity = "epic",
		stackable = false,
		value = 800,
		description = "A blade forged in the heart of a volcano, glowing with internal fire.",
	},
	
	-- Fairy Dragon drops
	["Fairy Dust"] = {
		id = "fairy_dust",
		type = "material",
		rarity = "uncommon",
		stackable = true,
		value = 20,
		description = "Magical dust that sparkles with rainbow colors.",
	},
	["Dragon Scale"] = {
		id = "dragon_scale",
		type = "material",
		rarity = "rare",
		stackable = true,
		value = 150,
		description = "A scale from a mighty dragon, shimmering with magic.",
	},
	["Enchanted Petal"] = {
		id = "enchanted_petal",
		type = "material",
		rarity = "uncommon",
		stackable = true,
		value = 25,
		description = "A flower petal infused with fairy magic.",
	},
	["Rainbow Gem"] = {
		id = "rainbow_gem",
		type = "material",
		rarity = "epic",
		stackable = true,
		value = 500,
		description = "A rare gem that refracts light into beautiful rainbows.",
	},
	
	-- Ancient Guardian drops
	["Ancient Relic"] = {
		id = "ancient_relic",
		type = "material",
		rarity = "epic",
		stackable = true,
		value = 600,
		description = "A mysterious artifact from a lost civilization.",
	},
	["Guardian Essence"] = {
		id = "guardian_essence",
		type = "material",
		rarity = "rare",
		stackable = true,
		value = 250,
		description = "The protective spirit of an ancient guardian.",
	},
	["Rune of Power"] = {
		id = "rune_of_power",
		type = "material",
		rarity = "legendary",
		stackable = true,
		value = 1500,
		description = "A mystical rune that pulses with ancient power.",
	},
	["Ancient Armor"] = {
		id = "ancient_armor",
		type = "armor",
		equipSlot = "Body",
		combatReq = 70,
		rarity = "legendary",
		stackable = false,
		value = 2000,
		defense = 35,
		description = "Armor forged by masters of a forgotten age.",
	},
	
	-- Frost Wyrm drops
	["Wyrm Scale"] = {
		id = "wyrm_scale",
		type = "material",
		rarity = "rare",
		stackable = true,
		value = 180,
		description = "A crystalline scale from a frost wyrm.",
	},
	["Frozen Heart"] = {
		id = "frozen_heart",
		type = "material",
		rarity = "legendary",
		stackable = true,
		value = 1200,
		description = "The still-beating heart of a frost wyrm, forever frozen.",
	},
	["Ice Fang"] = {
		id = "ice_fang",
		type = "weapon",
		equipSlot = "Weapon",
		damage = 38,
		combatReq = 60,
		rarity = "rare",
		stackable = false,
		value = 600,
		description = "A fang weapon that chills enemies to the bone.",
	},
	["Frost Armor"] = {
		id = "frost_armor",
		type = "armor",
		equipSlot = "Body",
		combatReq = 60,
		rarity = "rare",
		stackable = false,
		value = 800,
		defense = 28,
		description = "Armor that emanates a perpetual chill.",
	},
}

	-- === LICH KING MALACHAR DROPS ===
	["Lich Crown"] = {
		id = "lich_crown",
		type = "armor",
		equipSlot = "Head",
		combatReq = 85,
		rarity = "legendary",
		stackable = false,
		value = 12000,
		defense = 40,
		description = "A crown of bone and shadow, pulsing with necrotic power.",
	},
	["Soul Staff"] = {
		id = "soul_staff",
		type = "weapon",
		equipSlot = "Weapon",
		combatReq = 85,
		rarity = "legendary",
		stackable = false,
		value = 15000,
		damage = 55,
		attackSpeed = 1.0,
		description = "A staff that drains the very essence of life from its victims.",
	},
	["Dark Essence"] = {
		id = "dark_essence",
		type = "material",
		rarity = "epic",
		stackable = true,
		value = 2000,
		description = "Pure concentrated darkness, harvested from the Lich King's domain.",
	},
	["Necrotic Robe"] = {
		id = "necrotic_robe",
		type = "armor",
		equipSlot = "Body",
		combatReq = 80,
		rarity = "epic",
		stackable = false,
		value = 6000,
		defense = 32,
		description = "Robes woven from the fabric between life and death.",
	},
	["Bone Dust"] = {
		id = "bone_dust",
		type = "material",
		rarity = "uncommon",
		stackable = true,
		value = 15,
		description = "Fine powder ground from ancient bones. Used in dark rituals.",
	},

-- Auto-assign rarity based on value if not set
for name, item in pairs(ItemDatabase.Items) do
	if not item.rarity then
		local v = item.value or 0
		if v >= 1000 then
			item.rarity = "legendary"
		elseif v >= 200 then
			item.rarity = "epic"
		elseif v >= 50 then
			item.rarity = "rare"
		elseif v >= 10 then
			item.rarity = "uncommon"
		else
			item.rarity = "common"
		end
	end
end

-- Helper: get item by name
function ItemDatabase.GetItem(name)
	return ItemDatabase.Items[name]
end

-- Helper: get all items for a skill
function ItemDatabase.GetItemsBySkill(skill)
	local results = {}
	for name, item in pairs(ItemDatabase.Items) do
		if item.skill == skill then
			results[name] = item
		end
	end
	return results
end

-- Helper: get wilderness-only items
function ItemDatabase.GetWildernessItems()
	local results = {}
	for name, item in pairs(ItemDatabase.Items) do
		if item.wildernessOnly then
			results[name] = item
		end
	end
	return results
end

-- Helper: get all items matching a type (food, weapon, armor, resource, currency, crafted, etc.)
function ItemDatabase.GetItemsByType(itemType)
	local results = {}
	for name, item in pairs(ItemDatabase.Items) do
		if item.type == itemType then
			results[name] = item
		end
	end
	return results
end

return ItemDatabase
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="6">
        <Properties>
          <string name="Name">ItemVisuals</string>
          <string name="Source">-- ItemVisuals.lua (ModuleScript in ReplicatedStorage/Modules)
-- Unique visual representations for every item in the game

local ItemVisuals = {}

ItemVisuals.Items = {
	-- === ORES (Mining) ===
	["Copper Ore"] = { emoji = "ü™®", color = Color3.fromRGB(184, 115, 51), shape = "ore", glowColor = nil },
	["Iron Ore"] = { emoji = "‚õèÔ∏è", color = Color3.fromRGB(169, 169, 169), shape = "ore", glowColor = nil },
	["Gold Ore"] = { emoji = "üíé", color = Color3.fromRGB(255, 215, 0), shape = "ore", glowColor = Color3.fromRGB(255, 255, 0) },
	["Runite Ore"] = { emoji = "üí†", color = Color3.fromRGB(0, 139, 139), shape = "ore", glowColor = Color3.fromRGB(0, 255, 255) },

	-- === LOGS (Woodcutting) ===
	["Oak Log"] = { emoji = "ü™µ", color = Color3.fromRGB(139, 90, 43), shape = "log", glowColor = nil },
	["Willow Log"] = { emoji = "üåø", color = Color3.fromRGB(85, 107, 47), shape = "log", glowColor = nil },
	["Yew Log"] = { emoji = "üå≤", color = Color3.fromRGB(34, 139, 34), shape = "log", glowColor = nil },
	["Magic Log"] = { emoji = "‚ú®", color = Color3.fromRGB(138, 43, 226), shape = "log", glowColor = Color3.fromRGB(255, 0, 255) },

	-- === FISH (Fishing) ===
	["Shrimp"] = { emoji = "ü¶ê", color = Color3.fromRGB(255, 160, 122), shape = "fish", glowColor = nil },
	["Trout"] = { emoji = "üêü", color = Color3.fromRGB(105, 105, 105), shape = "fish", glowColor = nil },
	["Lobster"] = { emoji = "ü¶û", color = Color3.fromRGB(220, 20, 60), shape = "fish", glowColor = nil },
	["Dark Crab"] = { emoji = "ü¶Ä", color = Color3.fromRGB(75, 0, 130), shape = "fish", glowColor = Color3.fromRGB(138, 43, 226) },

	-- === BARS (Smithing) ===
	["Copper Bar"] = { emoji = "‚ö±Ô∏è", color = Color3.fromRGB(184, 115, 51), shape = "bar", glowColor = nil },
	["Iron Bar"] = { emoji = "üî©", color = Color3.fromRGB(169, 169, 169), shape = "bar", glowColor = nil },
	["Gold Bar"] = { emoji = "ü•á", color = Color3.fromRGB(255, 215, 0), shape = "bar", glowColor = Color3.fromRGB(255, 255, 0) },

	-- === WEAPONS ===
	["Copper Sword"] = { emoji = "‚öîÔ∏è", color = Color3.fromRGB(184, 115, 51), shape = "sword", glowColor = nil },
	["Iron Sword"] = { emoji = "‚öîÔ∏è", color = Color3.fromRGB(180, 180, 190), shape = "sword", glowColor = nil },
	["Gold Sword"] = { emoji = "üó°Ô∏è", color = Color3.fromRGB(255, 215, 0), shape = "sword", glowColor = Color3.fromRGB(255, 255, 0) },
	["Runite Sword"] = { emoji = "üó°Ô∏è", color = Color3.fromRGB(0, 139, 139), shape = "sword", glowColor = Color3.fromRGB(0, 255, 255) },
	["Dragon Sword"] = { emoji = "‚öîÔ∏è", color = Color3.fromRGB(255, 69, 0), shape = "sword", glowColor = Color3.fromRGB(255, 140, 0) },

	-- === COOKED FOOD ===
	["Cooked Shrimp"] = { emoji = "üç§", color = Color3.fromRGB(255, 182, 193), shape = "food", glowColor = nil },
	["Cooked Trout"] = { emoji = "üêü", color = Color3.fromRGB(160, 82, 45), shape = "food", glowColor = nil },
	["Cooked Lobster"] = { emoji = "ü¶û", color = Color3.fromRGB(255, 99, 71), shape = "food", glowColor = nil },
	["Cooked Dark Crab"] = { emoji = "ü¶Ä", color = Color3.fromRGB(128, 0, 128), shape = "food", glowColor = Color3.fromRGB(255, 0, 255) },

	-- === RAW FOOD ===
	["Raw Chicken"] = { emoji = "üêî", color = Color3.fromRGB(255, 182, 193), shape = "food", glowColor = nil },
	["Cooked Chicken"] = { emoji = "üçó", color = Color3.fromRGB(210, 180, 140), shape = "food", glowColor = nil },
	["Raw Beef"] = { emoji = "ü•©", color = Color3.fromRGB(139, 69, 19), shape = "food", glowColor = nil },
	["Cooked Beef"] = { emoji = "ü•©", color = Color3.fromRGB(160, 82, 45), shape = "food", glowColor = nil },
	["Raw Rat Meat"] = { emoji = "üê≠", color = Color3.fromRGB(105, 105, 105), shape = "food", glowColor = nil },
	["Cooked Rat Meat"] = { emoji = "üçñ", color = Color3.fromRGB(139, 69, 19), shape = "food", glowColor = nil },

	-- === MONSTER DROPS ===
	["Feather"] = { emoji = "ü™∂", color = Color3.fromRGB(245, 245, 220), shape = "feather", glowColor = nil },
	["Cowhide"] = { emoji = "üêÑ", color = Color3.fromRGB(160, 82, 45), shape = "misc", glowColor = nil },
	["Goblin Mail"] = { emoji = "üëï", color = Color3.fromRGB(85, 107, 47), shape = "misc", glowColor = nil },
	["Bones"] = { emoji = "üíÄ", color = Color3.fromRGB(255, 248, 220), shape = "bone", glowColor = nil },
	["Dog Tag"] = { emoji = "üè∑Ô∏è", color = Color3.fromRGB(192, 192, 192), shape = "misc", glowColor = nil },
	["Rat Tail"] = { emoji = "üêÄ", color = Color3.fromRGB(105, 105, 105), shape = "misc", glowColor = nil },
	["Wizard Robe"] = { emoji = "üßô", color = Color3.fromRGB(75, 0, 130), shape = "misc", glowColor = Color3.fromRGB(138, 43, 226) },
	["Demon Heart"] = { emoji = "üíú", color = Color3.fromRGB(139, 0, 0), shape = "gem", glowColor = Color3.fromRGB(255, 0, 0) },
	["Dragon Scale"] = { emoji = "üê≤", color = Color3.fromRGB(255, 69, 0), shape = "misc", glowColor = Color3.fromRGB(255, 140, 0) },
	["Shadow Gem"] = { emoji = "üíé", color = Color3.fromRGB(75, 0, 130), shape = "gem", glowColor = Color3.fromRGB(138, 43, 226) },
	["Bronze Coins"] = { emoji = "ü™ô", color = Color3.fromRGB(205, 127, 50), shape = "misc", glowColor = nil },

	-- === ARMOR ===
	["Bronze Helmet"] = { emoji = "‚õëÔ∏è", color = Color3.fromRGB(205, 127, 50), shape = "misc", glowColor = nil },
	["Iron Legs"] = { emoji = "ü¶µ", color = Color3.fromRGB(169, 169, 169), shape = "misc", glowColor = nil },
	["Wooden Shield"] = { emoji = "üõ°Ô∏è", color = Color3.fromRGB(160, 82, 45), shape = "shield", glowColor = nil },
	["Iron Shield"] = { emoji = "üõ°Ô∏è", color = Color3.fromRGB(169, 169, 169), shape = "shield", glowColor = nil },
	["Gold Shield"] = { emoji = "üõ°Ô∏è", color = Color3.fromRGB(255, 215, 0), shape = "shield", glowColor = Color3.fromRGB(255, 255, 0) },
	["Runite Shield"] = { emoji = "üõ°Ô∏è", color = Color3.fromRGB(0, 139, 139), shape = "shield", glowColor = Color3.fromRGB(0, 255, 255) },
	["Dragon Shield"] = { emoji = "üõ°Ô∏è", color = Color3.fromRGB(255, 69, 0), shape = "shield", glowColor = Color3.fromRGB(255, 140, 0) },

	-- === RANGED WEAPONS ===
	["Oak Shortbow"] = { emoji = "üèπ", color = Color3.fromRGB(139, 90, 43), shape = "bow", glowColor = nil },
	["Oak Longbow"] = { emoji = "üèπ", color = Color3.fromRGB(139, 90, 43), shape = "bow", glowColor = nil },
	["Willow Shortbow"] = { emoji = "üèπ", color = Color3.fromRGB(85, 107, 47), shape = "bow", glowColor = nil },
	["Iron Crossbow"] = { emoji = "üèπ", color = Color3.fromRGB(169, 169, 169), shape = "bow", glowColor = nil },
	["Willow Longbow"] = { emoji = "üèπ", color = Color3.fromRGB(85, 107, 47), shape = "bow", glowColor = nil },
	["Yew Shortbow"] = { emoji = "üèπ", color = Color3.fromRGB(34, 139, 34), shape = "bow", glowColor = nil },
	["Gold Crossbow"] = { emoji = "üèπ", color = Color3.fromRGB(255, 215, 0), shape = "bow", glowColor = Color3.fromRGB(255, 255, 0) },
	["Yew Longbow"] = { emoji = "üèπ", color = Color3.fromRGB(34, 139, 34), shape = "bow", glowColor = nil },
	["Magic Shortbow"] = { emoji = "üèπ", color = Color3.fromRGB(138, 43, 226), shape = "bow", glowColor = Color3.fromRGB(255, 0, 255) },
	["Dragon Crossbow"] = { emoji = "üèπ", color = Color3.fromRGB(255, 69, 0), shape = "bow", glowColor = Color3.fromRGB(255, 140, 0) },

	-- === AMMUNITION ===
	["Bronze Arrows"] = { emoji = "‚û§", color = Color3.fromRGB(205, 127, 50), shape = "arrow", glowColor = nil },
	["Iron Arrows"] = { emoji = "‚û§", color = Color3.fromRGB(169, 169, 169), shape = "arrow", glowColor = nil },
	["Gold Arrows"] = { emoji = "‚û§", color = Color3.fromRGB(255, 215, 0), shape = "arrow", glowColor = Color3.fromRGB(255, 255, 0) },
	["Runite Arrows"] = { emoji = "‚û§", color = Color3.fromRGB(0, 139, 139), shape = "arrow", glowColor = Color3.fromRGB(0, 255, 255) },
	["Iron Bolts"] = { emoji = "‚á®", color = Color3.fromRGB(169, 169, 169), shape = "arrow", glowColor = nil },
	["Gold Bolts"] = { emoji = "‚á®", color = Color3.fromRGB(255, 215, 0), shape = "arrow", glowColor = Color3.fromRGB(255, 255, 0) },
	["Runite Bolts"] = { emoji = "‚á®", color = Color3.fromRGB(0, 139, 139), shape = "arrow", glowColor = Color3.fromRGB(0, 255, 255) },
	["Bowstring"] = { emoji = "üßµ", color = Color3.fromRGB(245, 245, 220), shape = "misc", glowColor = nil },
	["Arrow Shafts"] = { emoji = "ü™µ", color = Color3.fromRGB(139, 90, 43), shape = "misc", glowColor = nil },
	["Magic Bowstring"] = { emoji = "‚ú®", color = Color3.fromRGB(138, 43, 226), shape = "misc", glowColor = Color3.fromRGB(255, 0, 255) },

	-- === TOOLS ===
	["Bronze Pickaxe"] = { emoji = "‚õèÔ∏è", color = Color3.fromRGB(205, 127, 50), shape = "misc", glowColor = nil },
	["Iron Pickaxe"] = { emoji = "‚õèÔ∏è", color = Color3.fromRGB(169, 169, 169), shape = "misc", glowColor = nil },
	["Gold Pickaxe"] = { emoji = "‚õèÔ∏è", color = Color3.fromRGB(255, 215, 0), shape = "misc", glowColor = Color3.fromRGB(255, 255, 0) },
	["Runite Pickaxe"] = { emoji = "‚õèÔ∏è", color = Color3.fromRGB(0, 139, 139), shape = "misc", glowColor = Color3.fromRGB(0, 255, 255) },
	["Dragon Pickaxe"] = { emoji = "‚õèÔ∏è", color = Color3.fromRGB(255, 69, 0), shape = "misc", glowColor = Color3.fromRGB(255, 140, 0) },
	["Bronze Axe"] = { emoji = "ü™ì", color = Color3.fromRGB(205, 127, 50), shape = "misc", glowColor = nil },
	["Iron Axe"] = { emoji = "ü™ì", color = Color3.fromRGB(169, 169, 169), shape = "misc", glowColor = nil },
	["Gold Axe"] = { emoji = "ü™ì", color = Color3.fromRGB(255, 215, 0), shape = "misc", glowColor = Color3.fromRGB(255, 255, 0) },
	["Runite Axe"] = { emoji = "ü™ì", color = Color3.fromRGB(0, 139, 139), shape = "misc", glowColor = Color3.fromRGB(0, 255, 255) },
	["Dragon Axe"] = { emoji = "ü™ì", color = Color3.fromRGB(255, 69, 0), shape = "misc", glowColor = Color3.fromRGB(255, 140, 0) },
	["Wooden Rod"] = { emoji = "üé£", color = Color3.fromRGB(139, 90, 43), shape = "misc", glowColor = nil },
	["Iron Rod"] = { emoji = "üé£", color = Color3.fromRGB(169, 169, 169), shape = "misc", glowColor = nil },
	["Gold Rod"] = { emoji = "üé£", color = Color3.fromRGB(255, 215, 0), shape = "misc", glowColor = Color3.fromRGB(255, 255, 0) },
	["Runite Rod"] = { emoji = "üé£", color = Color3.fromRGB(0, 139, 139), shape = "misc", glowColor = Color3.fromRGB(0, 255, 255) },
	["Dragon Rod"] = { emoji = "üé£", color = Color3.fromRGB(255, 69, 0), shape = "misc", glowColor = Color3.fromRGB(255, 140, 0) },

	-- === NEW BOSS DROP ITEMS ===
	["Golden Feather"] = { emoji = "ü™∂", color = Color3.fromRGB(255, 215, 0), shape = "feather", glowColor = Color3.fromRGB(255, 255, 0) },
	["King's Crest"] = { emoji = "üëë", color = Color3.fromRGB(255, 215, 0), shape = "gem", glowColor = Color3.fromRGB(255, 255, 0) },
	["Heartwood"] = { emoji = "üíö", color = Color3.fromRGB(34, 139, 34), shape = "misc", glowColor = Color3.fromRGB(0, 255, 0) },
	["Ancient Bark"] = { emoji = "üå≥", color = Color3.fromRGB(139, 90, 43), shape = "misc", glowColor = nil },
	["Elder Seed"] = { emoji = "üå∞", color = Color3.fromRGB(34, 139, 34), shape = "gem", glowColor = Color3.fromRGB(0, 255, 0) },
	["Golem Core"] = { emoji = "üíé", color = Color3.fromRGB(169, 169, 169), shape = "gem", glowColor = Color3.fromRGB(255, 255, 255) },
	["Golem Shield"] = { emoji = "üõ°Ô∏è", color = Color3.fromRGB(169, 169, 169), shape = "shield", glowColor = Color3.fromRGB(255, 255, 255) },
	["Serpent Scale"] = { emoji = "üêç", color = Color3.fromRGB(0, 128, 128), shape = "misc", glowColor = Color3.fromRGB(0, 255, 255) },
	["Sea Fang"] = { emoji = "ü¶∑", color = Color3.fromRGB(255, 248, 220), shape = "sword", glowColor = nil },
	["Serpent's Eye"] = { emoji = "üëÅÔ∏è", color = Color3.fromRGB(0, 128, 128), shape = "gem", glowColor = Color3.fromRGB(0, 255, 255) },
	["Guardian's Blessing"] = { emoji = "‚ú®", color = Color3.fromRGB(255, 248, 220), shape = "gem", glowColor = Color3.fromRGB(255, 255, 255) },
	["Corrupted Plate"] = { emoji = "üõ°Ô∏è", color = Color3.fromRGB(75, 0, 130), shape = "shield", glowColor = Color3.fromRGB(138, 43, 226) },
	["Ancient Key"] = { emoji = "üóùÔ∏è", color = Color3.fromRGB(255, 215, 0), shape = "misc", glowColor = Color3.fromRGB(255, 255, 0) },

	-- === PLATELEGS ===
	["Bronze Platelegs"] = { emoji = "ü¶ø", color = Color3.fromRGB(176, 141, 87), shape = "shield", glowColor = nil },
	["Iron Platelegs"] = { emoji = "ü¶ø", color = Color3.fromRGB(169, 169, 169), shape = "shield", glowColor = nil },
	["Gold Platelegs"] = { emoji = "ü¶ø", color = Color3.fromRGB(255, 215, 0), shape = "shield", glowColor = Color3.fromRGB(255, 255, 0) },
	["Runite Platelegs"] = { emoji = "ü¶ø", color = Color3.fromRGB(0, 139, 139), shape = "shield", glowColor = Color3.fromRGB(0, 255, 255) },
	["Dragon Platelegs"] = { emoji = "ü¶ø", color = Color3.fromRGB(178, 34, 34), shape = "shield", glowColor = Color3.fromRGB(255, 0, 0) },

	-- === PLATEBODIES ===
	["Bronze Platebody"] = { emoji = "üõ°Ô∏è", color = Color3.fromRGB(176, 141, 87), shape = "shield", glowColor = nil },
	["Iron Platebody"] = { emoji = "üõ°Ô∏è", color = Color3.fromRGB(169, 169, 169), shape = "shield", glowColor = nil },
	["Gold Platebody"] = { emoji = "üõ°Ô∏è", color = Color3.fromRGB(255, 215, 0), shape = "shield", glowColor = Color3.fromRGB(255, 255, 0) },
	["Runite Platebody"] = { emoji = "üõ°Ô∏è", color = Color3.fromRGB(0, 139, 139), shape = "shield", glowColor = Color3.fromRGB(0, 255, 255) },
	["Dragon Platebody"] = { emoji = "üõ°Ô∏è", color = Color3.fromRGB(178, 34, 34), shape = "shield", glowColor = Color3.fromRGB(255, 0, 0) },

	-- === CHAINMAIL ===
	["Iron Chainbody"] = { emoji = "‚õìÔ∏è", color = Color3.fromRGB(169, 169, 169), shape = "shield", glowColor = nil },
	["Gold Chainbody"] = { emoji = "‚õìÔ∏è", color = Color3.fromRGB(255, 215, 0), shape = "shield", glowColor = nil },
	["Runite Chainbody"] = { emoji = "‚õìÔ∏è", color = Color3.fromRGB(0, 139, 139), shape = "shield", glowColor = nil },

	-- === LEATHER/RANGER ARMOR ===
	["Leather Body"] = { emoji = "üëï", color = Color3.fromRGB(139, 90, 43), shape = "shield", glowColor = nil },
	["Leather Chaps"] = { emoji = "üëñ", color = Color3.fromRGB(139, 90, 43), shape = "shield", glowColor = nil },
	["Studded Body"] = { emoji = "üëï", color = Color3.fromRGB(101, 67, 33), shape = "shield", glowColor = nil },
	["Studded Chaps"] = { emoji = "üëñ", color = Color3.fromRGB(101, 67, 33), shape = "shield", glowColor = nil },
	["Dragonhide Body"] = { emoji = "üëï", color = Color3.fromRGB(0, 100, 0), shape = "shield", glowColor = Color3.fromRGB(0, 255, 0) },
	["Dragonhide Chaps"] = { emoji = "üëñ", color = Color3.fromRGB(0, 100, 0), shape = "shield", glowColor = Color3.fromRGB(0, 255, 0) },

	-- === NEW AREA MONSTER DROPS (MapSetup5) ===
	
	-- Pirate Ghost drops
	["Ghost Doubloon"] = { emoji = "üëª", color = Color3.fromRGB(200, 220, 255), shape = "misc", glowColor = Color3.fromRGB(100, 200, 255) },
	["Pirate Cutlass"] = { emoji = "‚öîÔ∏è", color = Color3.fromRGB(192, 192, 192), shape = "sword", glowColor = Color3.fromRGB(100, 200, 255) },
	["Spectral Cloth"] = { emoji = "üï∏Ô∏è", color = Color3.fromRGB(240, 248, 255), shape = "misc", glowColor = Color3.fromRGB(200, 220, 255) },
	
	-- Ice Elemental drops
	["Frozen Shard"] = { emoji = "‚ùÑÔ∏è", color = Color3.fromRGB(173, 216, 230), shape = "gem", glowColor = Color3.fromRGB(0, 255, 255) },
	["Ice Crystal"] = { emoji = "üíé", color = Color3.fromRGB(173, 216, 230), shape = "gem", glowColor = Color3.fromRGB(100, 200, 255) },
	["Frost Essence"] = { emoji = "üßä", color = Color3.fromRGB(240, 248, 255), shape = "gem", glowColor = Color3.fromRGB(200, 230, 255) },
	["Permafrost Ore"] = { emoji = "üßä", color = Color3.fromRGB(173, 216, 230), shape = "ore", glowColor = Color3.fromRGB(0, 255, 255) },
	
	-- Lava Golem drops
	["Magma Core"] = { emoji = "üåã", color = Color3.fromRGB(255, 69, 0), shape = "gem", glowColor = Color3.fromRGB(255, 140, 0) },
	["Obsidian Shard"] = { emoji = "üñ§", color = Color3.fromRGB(20, 20, 20), shape = "gem", glowColor = nil },
	["Volcanic Ash"] = { emoji = "üåã", color = Color3.fromRGB(64, 64, 64), shape = "misc", glowColor = nil },
	["Lava Blade"] = { emoji = "üî•", color = Color3.fromRGB(255, 69, 0), shape = "sword", glowColor = Color3.fromRGB(255, 140, 0) },
	
	-- Fairy Dragon drops
	["Fairy Dust"] = { emoji = "‚ú®", color = Color3.fromRGB(255, 192, 203), shape = "misc", glowColor = Color3.fromRGB(255, 20, 147) },
	["Dragon Scale"] = { emoji = "üê≤", color = Color3.fromRGB(255, 69, 0), shape = "misc", glowColor = Color3.fromRGB(255, 140, 0) },
	["Enchanted Petal"] = { emoji = "üå∏", color = Color3.fromRGB(255, 182, 193), shape = "misc", glowColor = Color3.fromRGB(255, 20, 147) },
	["Rainbow Gem"] = { emoji = "üåà", color = Color3.fromRGB(255, 255, 255), shape = "gem", glowColor = Color3.fromRGB(255, 0, 255) },
	
	-- Ancient Guardian drops
	["Ancient Relic"] = { emoji = "üè∫", color = Color3.fromRGB(139, 134, 130), shape = "misc", glowColor = Color3.fromRGB(0, 255, 0) },
	["Guardian Essence"] = { emoji = "üíö", color = Color3.fromRGB(0, 255, 0), shape = "gem", glowColor = Color3.fromRGB(50, 255, 50) },
	["Rune of Power"] = { emoji = "üîÆ", color = Color3.fromRGB(138, 43, 226), shape = "gem", glowColor = Color3.fromRGB(180, 50, 255) },
	["Ancient Armor"] = { emoji = "üõ°Ô∏è", color = Color3.fromRGB(139, 134, 130), shape = "shield", glowColor = Color3.fromRGB(0, 255, 0) },
	
	-- Frost Wyrm drops
	["Wyrm Scale"] = { emoji = "üêç", color = Color3.fromRGB(173, 216, 230), shape = "misc", glowColor = Color3.fromRGB(100, 200, 255) },
	["Frozen Heart"] = { emoji = "üíô", color = Color3.fromRGB(173, 216, 230), shape = "gem", glowColor = Color3.fromRGB(0, 255, 255) },
	["Ice Fang"] = { emoji = "üßä", color = Color3.fromRGB(240, 248, 255), shape = "sword", glowColor = Color3.fromRGB(100, 200, 255) },
	["Frost Armor"] = { emoji = "üßä", color = Color3.fromRGB(173, 216, 230), shape = "shield", glowColor = Color3.fromRGB(0, 255, 255) },

	-- === LICH KING MALACHAR DROPS ===
	["Lich Crown"] = { emoji = "üëë", color = Color3.fromRGB(200, 195, 175), shape = "default", glowColor = Color3.fromRGB(0, 255, 80) },
	["Soul Staff"] = { emoji = "üîÆ", color = Color3.fromRGB(40, 20, 15), shape = "sword", glowColor = Color3.fromRGB(0, 255, 80) },
	["Dark Essence"] = { emoji = "üíÄ", color = Color3.fromRGB(20, 20, 30), shape = "gem", glowColor = Color3.fromRGB(0, 200, 60) },
	["Necrotic Robe"] = { emoji = "üß•", color = Color3.fromRGB(15, 10, 25), shape = "default", glowColor = Color3.fromRGB(0, 180, 50) },
	["Bone Dust"] = { emoji = "üí®", color = Color3.fromRGB(220, 215, 200), shape = "default", glowColor = nil },
}

-- Helper function to get item visuals by name
function ItemVisuals.GetVisual(itemName)
	return ItemVisuals.Items[itemName] or {
		emoji = "‚ùì",
		color = Color3.fromRGB(128, 128, 128),
		shape = "misc",
		glowColor = nil
	}
end

-- Helper function to get item color
function ItemVisuals.GetColor(itemName)
	local visual = ItemVisuals.GetVisual(itemName)
	return visual.color
end

-- Helper function to get item emoji
function ItemVisuals.GetEmoji(itemName)
	local visual = ItemVisuals.GetVisual(itemName)
	return visual.emoji
end

-- Helper function to get item shape for 3D drops
function ItemVisuals.GetShape(itemName)
	local visual = ItemVisuals.GetVisual(itemName)
	return visual.shape
end

-- Helper function to get glow color (if any)
function ItemVisuals.GetGlowColor(itemName)
	local visual = ItemVisuals.GetVisual(itemName)
	return visual.glowColor
end

return ItemVisuals</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="7">
        <Properties>
          <string name="Name">MonsterDatabase</string>
          <string name="Source"><![CDATA[--[[
	MonsterDatabase.lua
	ModuleScript - ReplicatedStorage/Modules/MonsterDatabase
	
	Central registry of all monster definitions, drop tables, and visual configs.
	Drop items use DISPLAY NAMES (matching ItemDatabase keys).
]]

local MonsterDatabase = {}

MonsterDatabase.Monsters = {

	----------------------------------------------------------------------------
	-- SAFE ZONE
	----------------------------------------------------------------------------

	Chicken = {
		name        = "Chicken",
		hp          = 50,
		damage      = 3,
		level       = 1,
		xp          = 5,
		respawnTime = 15,
		zone        = "Safe",
		passive     = true,
		drops = {
			{ item = "Feather",      chance = 1.00, minQty = 1, maxQty = 2 },
			{ item = "Raw Chicken",  chance = 0.80, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(255, 250, 240),
			size = Vector3.new(1.5, 1.2, 2),
			headSize = 0.6,
			extras = {
				-- Original parts
				{ name = "Comb", shape = "Block", size = Vector3.new(0.3, 0.5, 0.6), offset = Vector3.new(0, 0.5, 0.3), color = Color3.fromRGB(220, 30, 30) },
				{ name = "Beak", shape = "Block", size = Vector3.new(0.3, 0.2, 0.5), offset = Vector3.new(0, 0, 0.6), color = Color3.fromRGB(255, 180, 50) },
				{ name = "LegL", shape = "Block", size = Vector3.new(0.2, 1, 0.2), offset = Vector3.new(-0.4, -1.1, 0), color = Color3.fromRGB(255, 180, 50), bodyRelative = true },
				{ name = "LegR", shape = "Block", size = Vector3.new(0.2, 1, 0.2), offset = Vector3.new(0.4, -1.1, 0), color = Color3.fromRGB(255, 180, 50), bodyRelative = true },
				{ name = "Tail", shape = "Block", size = Vector3.new(0.3, 1, 0.8), offset = Vector3.new(0, 0.3, -1.2), color = Color3.fromRGB(255, 250, 240), bodyRelative = true },
				-- Eyes
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.12, 0.12, 0.12), offset = Vector3.new(-0.18, 0.12, 0.32), color = Color3.fromRGB(20, 20, 20) },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.12, 0.12, 0.12), offset = Vector3.new(0.18, 0.12, 0.32), color = Color3.fromRGB(20, 20, 20) },
				-- Wattle under beak
				{ name = "Wattle", shape = "Block", size = Vector3.new(0.15, 0.3, 0.15), offset = Vector3.new(0, -0.25, 0.55), color = Color3.fromRGB(220, 30, 30) },
				-- Wing left
				{ name = "WingL", shape = "Block", size = Vector3.new(0.15, 0.7, 1.2), offset = Vector3.new(-0.85, 0.1, -0.1), color = Color3.fromRGB(245, 238, 220), bodyRelative = true },
				-- Wing right
				{ name = "WingR", shape = "Block", size = Vector3.new(0.15, 0.7, 1.2), offset = Vector3.new(0.85, 0.1, -0.1), color = Color3.fromRGB(245, 238, 220), bodyRelative = true },
				-- Wing tips (darker feathers)
				{ name = "WingTipL", shape = "Block", size = Vector3.new(0.1, 0.4, 0.6), offset = Vector3.new(-0.95, -0.15, -0.6), color = Color3.fromRGB(200, 190, 170), bodyRelative = true },
				{ name = "WingTipR", shape = "Block", size = Vector3.new(0.1, 0.4, 0.6), offset = Vector3.new(0.95, -0.15, -0.6), color = Color3.fromRGB(200, 190, 170), bodyRelative = true },
				-- Tail feather fan
				{ name = "TailFan1", shape = "Block", size = Vector3.new(0.5, 0.8, 0.1), offset = Vector3.new(0, 0.5, -1.4), color = Color3.fromRGB(240, 235, 215), bodyRelative = true },
				{ name = "TailFan2", shape = "Block", size = Vector3.new(0.4, 0.6, 0.1), offset = Vector3.new(-0.2, 0.6, -1.3), color = Color3.fromRGB(230, 225, 205), bodyRelative = true },
				-- Feet detail
				{ name = "FootL", shape = "Block", size = Vector3.new(0.4, 0.08, 0.5), offset = Vector3.new(-0.4, -1.65, 0.1), color = Color3.fromRGB(255, 180, 50), bodyRelative = true },
				{ name = "FootR", shape = "Block", size = Vector3.new(0.4, 0.08, 0.5), offset = Vector3.new(0.4, -1.65, 0.1), color = Color3.fromRGB(255, 180, 50), bodyRelative = true },
				-- Breast feather puff
				{ name = "Breast", shape = "Ball", size = Vector3.new(1.2, 0.8, 0.8), offset = Vector3.new(0, -0.2, 0.5), color = Color3.fromRGB(255, 252, 245), bodyRelative = true },
			},
		},
	},

	Cow = {
		name        = "Cow",
		hp          = 150,
		damage      = 9,
		level       = 3,
		xp          = 15,
		respawnTime = 20,
		zone        = "Safe",
		passive     = true,
		drops = {
			{ item = "Cowhide",  chance = 1.00, minQty = 1, maxQty = 1 },
			{ item = "Raw Beef", chance = 0.70, minQty = 1, maxQty = 1 },
			{ item = "Bones",    chance = 0.50, minQty = 1, maxQty = 1 },
			{ item = "Bowstring", chance = 0.10, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(180, 160, 140),
			size = Vector3.new(3, 2.5, 5),
			headSize = 1.2,
			extras = {
				-- Original parts
				{ name = "Patch1", shape = "Block", size = Vector3.new(1.5, 1, 2), offset = Vector3.new(0.5, 0.3, 0.5), color = Color3.fromRGB(60, 40, 20), bodyRelative = true },
				{ name = "Patch2", shape = "Block", size = Vector3.new(1, 0.8, 1.5), offset = Vector3.new(-0.8, -0.2, -1), color = Color3.fromRGB(255, 255, 255), bodyRelative = true },
				{ name = "HornL", shape = "Block", size = Vector3.new(0.2, 0.8, 0.2), offset = Vector3.new(-0.5, 0.8, 0), color = Color3.fromRGB(230, 220, 200) },
				{ name = "HornR", shape = "Block", size = Vector3.new(0.2, 0.8, 0.2), offset = Vector3.new(0.5, 0.8, 0), color = Color3.fromRGB(230, 220, 200) },
				{ name = "LegFL", shape = "Block", size = Vector3.new(0.5, 2, 0.5), offset = Vector3.new(-1, -2.2, 1.5), color = Color3.fromRGB(180, 160, 140), bodyRelative = true },
				{ name = "LegFR", shape = "Block", size = Vector3.new(0.5, 2, 0.5), offset = Vector3.new(1, -2.2, 1.5), color = Color3.fromRGB(180, 160, 140), bodyRelative = true },
				{ name = "LegBL", shape = "Block", size = Vector3.new(0.5, 2, 0.5), offset = Vector3.new(-1, -2.2, -1.5), color = Color3.fromRGB(180, 160, 140), bodyRelative = true },
				{ name = "LegBR", shape = "Block", size = Vector3.new(0.5, 2, 0.5), offset = Vector3.new(1, -2.2, -1.5), color = Color3.fromRGB(180, 160, 140), bodyRelative = true },
				{ name = "Tail", shape = "Block", size = Vector3.new(0.2, 0.2, 2), offset = Vector3.new(0, 0.5, -3.5), color = Color3.fromRGB(140, 120, 100), bodyRelative = true },
				-- Eyes
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.25, 0.25, 0.25), offset = Vector3.new(-0.4, 0.15, 0.55), color = Color3.fromRGB(30, 20, 10) },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.25, 0.25, 0.25), offset = Vector3.new(0.4, 0.15, 0.55), color = Color3.fromRGB(30, 20, 10) },
				-- More spots
				{ name = "Patch3", shape = "Block", size = Vector3.new(0.8, 0.6, 1.0), offset = Vector3.new(-0.3, 0.7, 1.2), color = Color3.fromRGB(60, 40, 20), bodyRelative = true },
				{ name = "Patch4", shape = "Block", size = Vector3.new(0.6, 0.5, 0.8), offset = Vector3.new(1.0, -0.5, -0.5), color = Color3.fromRGB(255, 255, 255), bodyRelative = true },
				{ name = "Patch5", shape = "Block", size = Vector3.new(0.9, 0.7, 1.2), offset = Vector3.new(-0.6, 0.5, -1.8), color = Color3.fromRGB(50, 35, 15), bodyRelative = true },
				-- Udder
				{ name = "Udder", shape = "Ball", size = Vector3.new(1.0, 0.6, 0.8), offset = Vector3.new(0, -1.4, -0.5), color = Color3.fromRGB(255, 200, 180), bodyRelative = true },
				-- Bell on neck
				{ name = "BellStrap", shape = "Block", size = Vector3.new(1.4, 0.15, 0.15), offset = Vector3.new(0, -0.3, 0.3), color = Color3.fromRGB(120, 70, 30) },
				{ name = "Bell", shape = "Ball", size = Vector3.new(0.35, 0.4, 0.35), offset = Vector3.new(0, -0.55, 0.3), color = Color3.fromRGB(210, 180, 50), material = Enum.Material.Metal },
				-- Nostrils
				{ name = "NostrilL", shape = "Ball", size = Vector3.new(0.15, 0.12, 0.1), offset = Vector3.new(-0.15, -0.2, 0.65), color = Color3.fromRGB(60, 40, 35) },
				{ name = "NostrilR", shape = "Ball", size = Vector3.new(0.15, 0.12, 0.1), offset = Vector3.new(0.15, -0.2, 0.65), color = Color3.fromRGB(60, 40, 35) },
				-- Hooves
				{ name = "HoofFL", shape = "Block", size = Vector3.new(0.55, 0.2, 0.55), offset = Vector3.new(-1, -3.3, 1.5), color = Color3.fromRGB(50, 40, 30), bodyRelative = true },
				{ name = "HoofFR", shape = "Block", size = Vector3.new(0.55, 0.2, 0.55), offset = Vector3.new(1, -3.3, 1.5), color = Color3.fromRGB(50, 40, 30), bodyRelative = true },
				{ name = "HoofBL", shape = "Block", size = Vector3.new(0.55, 0.2, 0.55), offset = Vector3.new(-1, -3.3, -1.5), color = Color3.fromRGB(50, 40, 30), bodyRelative = true },
				{ name = "HoofBR", shape = "Block", size = Vector3.new(0.55, 0.2, 0.55), offset = Vector3.new(1, -3.3, -1.5), color = Color3.fromRGB(50, 40, 30), bodyRelative = true },
				-- Ear flaps
				{ name = "EarL", shape = "Block", size = Vector3.new(0.5, 0.3, 0.15), offset = Vector3.new(-0.65, 0.3, 0), color = Color3.fromRGB(180, 160, 140) },
				{ name = "EarR", shape = "Block", size = Vector3.new(0.5, 0.3, 0.15), offset = Vector3.new(0.65, 0.3, 0), color = Color3.fromRGB(180, 160, 140) },
				-- Tail tuft
				{ name = "TailTuft", shape = "Block", size = Vector3.new(0.35, 0.5, 0.3), offset = Vector3.new(0, 0.3, -4.5), color = Color3.fromRGB(60, 40, 20), bodyRelative = true },
			},
		},
	},

	Goblin = {
		name        = "Goblin",
		hp          = 250,
		damage      = 15,
		level       = 5,
		xp          = 25,
		respawnTime = 25,
		zone        = "Safe",
		passive     = false,
		drops = {
			{ item = "Goblin Mail",   chance = 0.30, minQty = 1, maxQty = 1  },
			{ item = "Bronze Coins",  chance = 1.00, minQty = 5, maxQty = 15 },
			{ item = "Copper Sword",  chance = 0.10, minQty = 1, maxQty = 1 },
			{ item = "Bones",         chance = 0.80, minQty = 1, maxQty = 1 },
			{ item = "Bronze Arrows", chance = 0.30, minQty = 5, maxQty = 15 },
			{ item = "Oak Shortbow",  chance = 0.05, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(80, 160, 60),
			size = Vector3.new(1.8, 2.5, 1.2),
			headSize = 1.0,
			extras = {
				-- Original parts
				{ name = "EarL", shape = "Block", size = Vector3.new(0.8, 0.3, 0.2), offset = Vector3.new(-0.8, 0.2, 0), color = Color3.fromRGB(80, 160, 60) },
				{ name = "EarR", shape = "Block", size = Vector3.new(0.8, 0.3, 0.2), offset = Vector3.new(0.8, 0.2, 0), color = Color3.fromRGB(80, 160, 60) },
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(-0.25, 0.15, 0.5), color = Color3.fromRGB(255, 50, 50), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(0.25, 0.15, 0.5), color = Color3.fromRGB(255, 50, 50), material = Enum.Material.Neon },
				{ name = "Armor", shape = "Block", size = Vector3.new(2, 1.2, 1.4), offset = Vector3.new(0, 0.2, 0), color = Color3.fromRGB(100, 80, 40), bodyRelative = true, material = Enum.Material.Slate },
				{ name = "LegL", shape = "Block", size = Vector3.new(0.5, 1.5, 0.5), offset = Vector3.new(-0.4, -2, 0), color = Color3.fromRGB(80, 160, 60), bodyRelative = true },
				{ name = "LegR", shape = "Block", size = Vector3.new(0.5, 1.5, 0.5), offset = Vector3.new(0.4, -2, 0), color = Color3.fromRGB(80, 160, 60), bodyRelative = true },
				{ name = "Club", shape = "Block", size = Vector3.new(0.3, 2, 0.3), offset = Vector3.new(1.2, -0.5, 0), color = Color3.fromRGB(120, 90, 50), bodyRelative = true, material = Enum.Material.Wood },
				-- Pointed nose
				{ name = "Nose", shape = "Block", size = Vector3.new(0.2, 0.2, 0.5), offset = Vector3.new(0, -0.05, 0.65), color = Color3.fromRGB(70, 145, 50) },
				-- Pupils (small dark centers)
				{ name = "PupilL", shape = "Ball", size = Vector3.new(0.12, 0.12, 0.12), offset = Vector3.new(-0.25, 0.15, 0.63), color = Color3.fromRGB(30, 10, 10) },
				{ name = "PupilR", shape = "Ball", size = Vector3.new(0.12, 0.12, 0.12), offset = Vector3.new(0.25, 0.15, 0.63), color = Color3.fromRGB(30, 10, 10) },
				-- War paint stripes on face
				{ name = "PaintL", shape = "Block", size = Vector3.new(0.08, 0.4, 0.1), offset = Vector3.new(-0.35, -0.05, 0.48), color = Color3.fromRGB(180, 30, 30) },
				{ name = "PaintR", shape = "Block", size = Vector3.new(0.08, 0.4, 0.1), offset = Vector3.new(0.35, -0.05, 0.48), color = Color3.fromRGB(180, 30, 30) },
				{ name = "PaintC", shape = "Block", size = Vector3.new(0.06, 0.3, 0.1), offset = Vector3.new(0, 0.35, 0.48), color = Color3.fromRGB(180, 30, 30) },
				-- Loincloth
				{ name = "Loincloth", shape = "Block", size = Vector3.new(1.2, 1.0, 0.15), offset = Vector3.new(0, -1.5, -0.55), color = Color3.fromRGB(80, 60, 30), bodyRelative = true },
				{ name = "LoinclothF", shape = "Block", size = Vector3.new(1.0, 0.8, 0.15), offset = Vector3.new(0, -1.5, 0.55), color = Color3.fromRGB(80, 60, 30), bodyRelative = true },
				-- Crude shield in left hand
				{ name = "Shield", shape = "Block", size = Vector3.new(0.15, 1.2, 1.0), offset = Vector3.new(-1.3, -0.3, 0), color = Color3.fromRGB(90, 70, 35), bodyRelative = true, material = Enum.Material.Wood },
				{ name = "ShieldBoss", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(-1.4, -0.3, 0), color = Color3.fromRGB(130, 110, 70), bodyRelative = true },
				-- Club knob
				{ name = "ClubKnob", shape = "Ball", size = Vector3.new(0.5, 0.5, 0.5), offset = Vector3.new(1.2, -1.7, 0), color = Color3.fromRGB(100, 75, 40), bodyRelative = true, material = Enum.Material.Wood },
				-- Belt
				{ name = "Belt", shape = "Block", size = Vector3.new(2.1, 0.25, 1.3), offset = Vector3.new(0, -0.8, 0), color = Color3.fromRGB(70, 50, 25), bodyRelative = true },
				-- Teeth (two fangs)
				{ name = "FangL", shape = "Block", size = Vector3.new(0.08, 0.15, 0.08), offset = Vector3.new(-0.12, -0.28, 0.48), color = Color3.fromRGB(230, 220, 190) },
				{ name = "FangR", shape = "Block", size = Vector3.new(0.08, 0.15, 0.08), offset = Vector3.new(0.12, -0.28, 0.48), color = Color3.fromRGB(230, 220, 190) },
			},
		},
	},

	GuardDog = {
		name        = "Guard Dog",
		hp          = 200,
		damage      = 21,
		level       = 4,
		xp          = 20,
		respawnTime = 20,
		zone        = "Safe",
		passive     = false,
		drops = {
			{ item = "Bones",   chance = 1.00, minQty = 1, maxQty = 1 },
			{ item = "Dog Tag", chance = 0.10, minQty = 1, maxQty = 1 },
			{ item = "Raw Beef", chance = 0.30, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(139, 90, 43),
			size = Vector3.new(1.8, 1.8, 3.2),
			headSize = 0.9,
			extras = {
				-- Original parts
				{ name = "Snout", shape = "Block", size = Vector3.new(0.55, 0.45, 0.7), offset = Vector3.new(0, -0.15, 0.7), color = Color3.fromRGB(120, 75, 35) },
				{ name = "EarL", shape = "Block", size = Vector3.new(0.5, 0.6, 0.2), offset = Vector3.new(-0.5, 0.5, -0.1), color = Color3.fromRGB(100, 65, 30) },
				{ name = "EarR", shape = "Block", size = Vector3.new(0.5, 0.6, 0.2), offset = Vector3.new(0.5, 0.5, -0.1), color = Color3.fromRGB(100, 65, 30) },
				{ name = "LegFL", shape = "Block", size = Vector3.new(0.45, 1.6, 0.45), offset = Vector3.new(-0.6, -1.7, 1.1), color = Color3.fromRGB(139, 90, 43), bodyRelative = true },
				{ name = "LegFR", shape = "Block", size = Vector3.new(0.45, 1.6, 0.45), offset = Vector3.new(0.6, -1.7, 1.1), color = Color3.fromRGB(139, 90, 43), bodyRelative = true },
				{ name = "LegBL", shape = "Block", size = Vector3.new(0.45, 1.6, 0.45), offset = Vector3.new(-0.6, -1.7, -1.1), color = Color3.fromRGB(139, 90, 43), bodyRelative = true },
				{ name = "LegBR", shape = "Block", size = Vector3.new(0.45, 1.6, 0.45), offset = Vector3.new(0.6, -1.7, -1.1), color = Color3.fromRGB(139, 90, 43), bodyRelative = true },
				{ name = "Tail", shape = "Block", size = Vector3.new(0.2, 0.2, 1.5), offset = Vector3.new(0, 0.5, -2.2), color = Color3.fromRGB(139, 90, 43), bodyRelative = true },
				-- Eyes (fierce)
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.2, 0.2, 0.2), offset = Vector3.new(-0.25, 0.15, 0.4), color = Color3.fromRGB(200, 160, 30) },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.2, 0.2, 0.2), offset = Vector3.new(0.25, 0.15, 0.4), color = Color3.fromRGB(200, 160, 30) },
				{ name = "PupilL", shape = "Ball", size = Vector3.new(0.1, 0.1, 0.1), offset = Vector3.new(-0.25, 0.15, 0.48), color = Color3.fromRGB(10, 10, 10) },
				{ name = "PupilR", shape = "Ball", size = Vector3.new(0.1, 0.1, 0.1), offset = Vector3.new(0.25, 0.15, 0.48), color = Color3.fromRGB(10, 10, 10) },
				-- Nose
				{ name = "Nose", shape = "Ball", size = Vector3.new(0.2, 0.15, 0.15), offset = Vector3.new(0, -0.05, 1.05), color = Color3.fromRGB(30, 20, 15) },
				-- Teeth showing
				{ name = "ToothL", shape = "Block", size = Vector3.new(0.06, 0.12, 0.06), offset = Vector3.new(-0.12, -0.3, 0.9), color = Color3.fromRGB(240, 235, 220) },
				{ name = "ToothR", shape = "Block", size = Vector3.new(0.06, 0.12, 0.06), offset = Vector3.new(0.12, -0.3, 0.9), color = Color3.fromRGB(240, 235, 220) },
				{ name = "ToothMidL", shape = "Block", size = Vector3.new(0.05, 0.08, 0.05), offset = Vector3.new(-0.2, -0.28, 0.85), color = Color3.fromRGB(240, 235, 220) },
				{ name = "ToothMidR", shape = "Block", size = Vector3.new(0.05, 0.08, 0.05), offset = Vector3.new(0.2, -0.28, 0.85), color = Color3.fromRGB(240, 235, 220) },
				-- Collar
				{ name = "Collar", shape = "Block", size = Vector3.new(1.9, 0.25, 0.25), offset = Vector3.new(0, -0.05, 1.3), color = Color3.fromRGB(180, 30, 30), bodyRelative = true },
				{ name = "CollarTag", shape = "Ball", size = Vector3.new(0.2, 0.25, 0.1), offset = Vector3.new(0, -0.22, 1.4), color = Color3.fromRGB(210, 180, 50), bodyRelative = true, material = Enum.Material.Metal },
				-- Muscular chest
				{ name = "Chest", shape = "Ball", size = Vector3.new(1.6, 1.4, 1.0), offset = Vector3.new(0, 0.1, 0.8), color = Color3.fromRGB(150, 100, 50), bodyRelative = true },
				-- Dark muzzle markings
				{ name = "MuzzleTop", shape = "Block", size = Vector3.new(0.45, 0.1, 0.5), offset = Vector3.new(0, 0.05, 0.85), color = Color3.fromRGB(80, 50, 25) },
				-- Paws
				{ name = "PawFL", shape = "Block", size = Vector3.new(0.5, 0.15, 0.55), offset = Vector3.new(-0.6, -2.55, 1.1), color = Color3.fromRGB(110, 70, 35), bodyRelative = true },
				{ name = "PawFR", shape = "Block", size = Vector3.new(0.5, 0.15, 0.55), offset = Vector3.new(0.6, -2.55, 1.1), color = Color3.fromRGB(110, 70, 35), bodyRelative = true },
				{ name = "PawBL", shape = "Block", size = Vector3.new(0.5, 0.15, 0.55), offset = Vector3.new(-0.6, -2.55, -1.1), color = Color3.fromRGB(110, 70, 35), bodyRelative = true },
				{ name = "PawBR", shape = "Block", size = Vector3.new(0.5, 0.15, 0.55), offset = Vector3.new(0.6, -2.55, -1.1), color = Color3.fromRGB(110, 70, 35), bodyRelative = true },
			},
		},
	},

	GiantRat = {
		name        = "Giant Rat",
		hp          = 125,
		damage      = 12,
		level       = 2,
		xp          = 12,
		respawnTime = 15,
		zone        = "Safe",
		passive     = true,
		drops = {
			{ item = "Rat Tail",      chance = 0.50, minQty = 1, maxQty = 1 },
			{ item = "Raw Rat Meat",  chance = 0.80, minQty = 1, maxQty = 1 },
			{ item = "Bones",         chance = 0.30, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(100, 80, 60),
			size = Vector3.new(1.2, 1, 2.5),
			headSize = 0.6,
			extras = {
				-- Original parts
				{ name = "Nose", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(0, -0.1, 0.5), color = Color3.fromRGB(200, 100, 100) },
				{ name = "EarL", shape = "Ball", size = Vector3.new(0.5, 0.5, 0.12), offset = Vector3.new(-0.3, 0.45, 0), color = Color3.fromRGB(200, 150, 150) },
				{ name = "EarR", shape = "Ball", size = Vector3.new(0.5, 0.5, 0.12), offset = Vector3.new(0.3, 0.45, 0), color = Color3.fromRGB(200, 150, 150) },
				{ name = "Tail", shape = "Block", size = Vector3.new(0.15, 0.15, 3), offset = Vector3.new(0, 0, -2.8), color = Color3.fromRGB(180, 140, 120), bodyRelative = true },
				{ name = "LegFL", shape = "Block", size = Vector3.new(0.3, 0.8, 0.3), offset = Vector3.new(-0.4, -0.9, 0.8), color = Color3.fromRGB(100, 80, 60), bodyRelative = true },
				{ name = "LegFR", shape = "Block", size = Vector3.new(0.3, 0.8, 0.3), offset = Vector3.new(0.4, -0.9, 0.8), color = Color3.fromRGB(100, 80, 60), bodyRelative = true },
				{ name = "LegBL", shape = "Block", size = Vector3.new(0.3, 0.8, 0.3), offset = Vector3.new(-0.4, -0.9, -0.8), color = Color3.fromRGB(100, 80, 60), bodyRelative = true },
				{ name = "LegBR", shape = "Block", size = Vector3.new(0.3, 0.8, 0.3), offset = Vector3.new(0.4, -0.9, -0.8), color = Color3.fromRGB(100, 80, 60), bodyRelative = true },
				-- Eyes (beady)
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.15, 0.15, 0.15), offset = Vector3.new(-0.18, 0.1, 0.3), color = Color3.fromRGB(200, 30, 30) },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.15, 0.15, 0.15), offset = Vector3.new(0.18, 0.1, 0.3), color = Color3.fromRGB(200, 30, 30) },
				-- Whiskers
				{ name = "WhiskerL1", shape = "Block", size = Vector3.new(0.6, 0.03, 0.03), offset = Vector3.new(-0.35, -0.05, 0.45), color = Color3.fromRGB(160, 130, 110) },
				{ name = "WhiskerL2", shape = "Block", size = Vector3.new(0.55, 0.03, 0.03), offset = Vector3.new(-0.33, -0.1, 0.45), color = Color3.fromRGB(160, 130, 110) },
				{ name = "WhiskerR1", shape = "Block", size = Vector3.new(0.6, 0.03, 0.03), offset = Vector3.new(0.35, -0.05, 0.45), color = Color3.fromRGB(160, 130, 110) },
				{ name = "WhiskerR2", shape = "Block", size = Vector3.new(0.55, 0.03, 0.03), offset = Vector3.new(0.33, -0.1, 0.45), color = Color3.fromRGB(160, 130, 110) },
				-- Matted fur texture patches (Fabric material)
				{ name = "FurPatch1", shape = "Block", size = Vector3.new(0.8, 0.5, 1.2), offset = Vector3.new(0.2, 0.3, 0.3), color = Color3.fromRGB(85, 65, 45), bodyRelative = true, material = Enum.Material.Fabric },
				{ name = "FurPatch2", shape = "Block", size = Vector3.new(0.6, 0.4, 0.9), offset = Vector3.new(-0.3, 0.25, -0.6), color = Color3.fromRGB(90, 70, 50), bodyRelative = true, material = Enum.Material.Fabric },
				{ name = "FurPatch3", shape = "Block", size = Vector3.new(0.5, 0.3, 0.7), offset = Vector3.new(0.1, 0.35, -1.0), color = Color3.fromRGB(80, 60, 40), bodyRelative = true, material = Enum.Material.Fabric },
				-- Ear inner pink
				{ name = "EarInnerL", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.05), offset = Vector3.new(-0.3, 0.45, -0.04), color = Color3.fromRGB(220, 170, 170) },
				{ name = "EarInnerR", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.05), offset = Vector3.new(0.3, 0.45, -0.04), color = Color3.fromRGB(220, 170, 170) },
				-- Teeth
				{ name = "ToothL", shape = "Block", size = Vector3.new(0.05, 0.1, 0.05), offset = Vector3.new(-0.06, -0.22, 0.45), color = Color3.fromRGB(230, 220, 200) },
				{ name = "ToothR", shape = "Block", size = Vector3.new(0.05, 0.1, 0.05), offset = Vector3.new(0.06, -0.22, 0.45), color = Color3.fromRGB(230, 220, 200) },
				-- Claws on front feet
				{ name = "ClawFL", shape = "Block", size = Vector3.new(0.15, 0.05, 0.15), offset = Vector3.new(-0.4, -1.35, 0.95), color = Color3.fromRGB(60, 45, 30), bodyRelative = true },
				{ name = "ClawFR", shape = "Block", size = Vector3.new(0.15, 0.05, 0.15), offset = Vector3.new(0.4, -1.35, 0.95), color = Color3.fromRGB(60, 45, 30), bodyRelative = true },
			},
		},
	},

	TrainingDummy = {
		name        = "Training Dummy",
		hp          = 999999,
		damage      = 0,
		level       = 0,
		xp          = 2,
		respawnTime = 5,
		zone        = "Safe",
		passive     = true,
		stationary  = true,
		immortal    = true,
		drops       = {},
		model = {
			bodyColor = Color3.fromRGB(180, 140, 80),
			size = Vector3.new(2, 4, 1),
			headSize = 1.0,
			extras = {
				-- Original parts
				{ name = "Arms", shape = "Block", size = Vector3.new(5, 0.5, 0.5), offset = Vector3.new(0, 0.5, 0), color = Color3.fromRGB(180, 140, 80), bodyRelative = true, material = Enum.Material.Wood },
				{ name = "Target", shape = "Block", size = Vector3.new(1.5, 1.5, 0.3), offset = Vector3.new(0, 0.5, 0.5), color = Color3.fromRGB(200, 50, 50), bodyRelative = true },
				{ name = "Post", shape = "Block", size = Vector3.new(0.5, 2, 0.5), offset = Vector3.new(0, -3, 0), color = Color3.fromRGB(120, 90, 50), bodyRelative = true, material = Enum.Material.Wood },
				-- Eyes (painted on - flat circles)
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.2, 0.2, 0.1), offset = Vector3.new(-0.25, 0.1, 0.48), color = Color3.fromRGB(30, 30, 30) },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.2, 0.2, 0.1), offset = Vector3.new(0.25, 0.1, 0.48), color = Color3.fromRGB(30, 30, 30) },
				-- X mouth (painted)
				{ name = "MouthX1", shape = "Block", size = Vector3.new(0.3, 0.05, 0.05), offset = Vector3.new(0, -0.15, 0.5), color = Color3.fromRGB(30, 30, 30), rotation = Vector3.new(0, 0, 30) },
				{ name = "MouthX2", shape = "Block", size = Vector3.new(0.3, 0.05, 0.05), offset = Vector3.new(0, -0.15, 0.5), color = Color3.fromRGB(30, 30, 30), rotation = Vector3.new(0, 0, -30) },
				-- Target ring
				{ name = "TargetRing", shape = "Block", size = Vector3.new(0.8, 0.8, 0.32), offset = Vector3.new(0, 0.5, 0.5), color = Color3.fromRGB(240, 240, 220), bodyRelative = true },
				{ name = "TargetBull", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.15), offset = Vector3.new(0, 0.5, 0.52), color = Color3.fromRGB(200, 50, 50), bodyRelative = true },
				-- Straw stuffing poking out
				{ name = "StrawTop", shape = "Block", size = Vector3.new(0.4, 0.6, 0.3), offset = Vector3.new(0.3, 2.1, 0.1), color = Color3.fromRGB(220, 200, 100), bodyRelative = true },
				{ name = "StrawL", shape = "Block", size = Vector3.new(0.3, 0.5, 0.2), offset = Vector3.new(-1.1, 0.7, 0.2), color = Color3.fromRGB(220, 200, 100), bodyRelative = true },
				{ name = "StrawR", shape = "Block", size = Vector3.new(0.3, 0.5, 0.2), offset = Vector3.new(1.1, 0.7, 0.2), color = Color3.fromRGB(220, 200, 100), bodyRelative = true },
				{ name = "StrawMid", shape = "Block", size = Vector3.new(0.2, 0.4, 0.3), offset = Vector3.new(-0.2, -0.5, 0.4), color = Color3.fromRGB(210, 190, 90), bodyRelative = true },
				-- Rope bindings
				{ name = "RopeTop", shape = "Block", size = Vector3.new(2.2, 0.15, 1.15), offset = Vector3.new(0, 1.3, 0), color = Color3.fromRGB(160, 130, 80), bodyRelative = true },
				{ name = "RopeMid", shape = "Block", size = Vector3.new(2.2, 0.15, 1.15), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(160, 130, 80), bodyRelative = true },
				{ name = "RopeBot", shape = "Block", size = Vector3.new(2.2, 0.15, 1.15), offset = Vector3.new(0, -1.2, 0), color = Color3.fromRGB(160, 130, 80), bodyRelative = true },
				-- Wear marks (darker scratches)
				{ name = "Scratch1", shape = "Block", size = Vector3.new(0.08, 1.2, 0.05), offset = Vector3.new(0.4, 0, 0.52), color = Color3.fromRGB(100, 70, 35), bodyRelative = true },
				{ name = "Scratch2", shape = "Block", size = Vector3.new(0.08, 0.8, 0.05), offset = Vector3.new(-0.3, 0.3, 0.52), color = Color3.fromRGB(100, 70, 35), bodyRelative = true },
				{ name = "Scratch3", shape = "Block", size = Vector3.new(0.06, 0.6, 0.05), offset = Vector3.new(0.1, -0.5, 0.52), color = Color3.fromRGB(110, 75, 40), bodyRelative = true },
				-- Wooden body texture
				{ name = "WoodGrain1", shape = "Block", size = Vector3.new(0.04, 3.5, 0.05), offset = Vector3.new(-0.5, 0, -0.52), color = Color3.fromRGB(160, 120, 65), bodyRelative = true },
				{ name = "WoodGrain2", shape = "Block", size = Vector3.new(0.04, 3.5, 0.05), offset = Vector3.new(0.5, 0, -0.52), color = Color3.fromRGB(160, 120, 65), bodyRelative = true },
				-- Post base
				{ name = "PostBase", shape = "Block", size = Vector3.new(1.5, 0.3, 1.5), offset = Vector3.new(0, -4.1, 0), color = Color3.fromRGB(100, 75, 40), bodyRelative = true, material = Enum.Material.Wood },
			},
		},
	},

	----------------------------------------------------------------------------
	-- WILDERNESS
	----------------------------------------------------------------------------

	Skeleton = {
		name        = "Skeleton",
		hp          = 400,
		damage      = 36,
		level       = 20,
		xp          = 50,
		respawnTime = 40,
		zone        = "Wilderness",
		passive     = false,
		drops = {
			{ item = "Bones",      chance = 1.00, minQty = 1, maxQty = 2 },
			{ item = "Iron Sword", chance = 0.08, minQty = 1, maxQty = 1 },
			{ item = "Iron Ore",   chance = 0.30, minQty = 1, maxQty = 3 },
			{ item = "Copper Sword", chance = 0.15, minQty = 1, maxQty = 1 },
			{ item = "Iron Arrows",  chance = 0.25, minQty = 10, maxQty = 20 },
			{ item = "Iron Crossbow", chance = 0.05, minQty = 1, maxQty = 1 },
			{ item = "Iron Shield",  chance = 0.08, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(230, 225, 210),
			size = Vector3.new(1.5, 4, 1),
			headSize = 1.0,
			extras = {
				-- Original parts
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.25, 0.25, 0.25), offset = Vector3.new(-0.25, 0.1, 0.45), color = Color3.fromRGB(255, 50, 50), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.25, 0.25, 0.25), offset = Vector3.new(0.25, 0.1, 0.45), color = Color3.fromRGB(255, 50, 50), material = Enum.Material.Neon },
				{ name = "Rib1", shape = "Block", size = Vector3.new(2, 0.15, 0.8), offset = Vector3.new(0, 0.8, 0), color = Color3.fromRGB(220, 215, 200), bodyRelative = true },
				{ name = "Rib2", shape = "Block", size = Vector3.new(2, 0.15, 0.8), offset = Vector3.new(0, 0.4, 0), color = Color3.fromRGB(220, 215, 200), bodyRelative = true },
				{ name = "Rib3", shape = "Block", size = Vector3.new(2, 0.15, 0.8), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(220, 215, 200), bodyRelative = true },
				{ name = "ArmL", shape = "Block", size = Vector3.new(0.3, 3, 0.3), offset = Vector3.new(-1.1, -0.5, 0), color = Color3.fromRGB(230, 225, 210), bodyRelative = true },
				{ name = "ArmR", shape = "Block", size = Vector3.new(0.3, 3, 0.3), offset = Vector3.new(1.1, -0.5, 0), color = Color3.fromRGB(230, 225, 210), bodyRelative = true },
				{ name = "Sword", shape = "Block", size = Vector3.new(0.2, 3, 0.5), offset = Vector3.new(1.5, -1.5, 0), color = Color3.fromRGB(180, 180, 180), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "LegL", shape = "Block", size = Vector3.new(0.4, 2.5, 0.4), offset = Vector3.new(-0.4, -3.2, 0), color = Color3.fromRGB(230, 225, 210), bodyRelative = true },
				{ name = "LegR", shape = "Block", size = Vector3.new(0.4, 2.5, 0.4), offset = Vector3.new(0.4, -3.2, 0), color = Color3.fromRGB(230, 225, 210), bodyRelative = true },
				-- Jaw (separate mandible)
				{ name = "Jaw", shape = "Block", size = Vector3.new(0.7, 0.2, 0.6), offset = Vector3.new(0, -0.35, 0.1), color = Color3.fromRGB(220, 215, 200) },
				-- Teeth
				{ name = "TeethUpper", shape = "Block", size = Vector3.new(0.5, 0.1, 0.08), offset = Vector3.new(0, -0.18, 0.5), color = Color3.fromRGB(210, 205, 190) },
				{ name = "TeethLower", shape = "Block", size = Vector3.new(0.5, 0.1, 0.08), offset = Vector3.new(0, -0.3, 0.5), color = Color3.fromRGB(210, 205, 190) },
				-- Nose cavity
				{ name = "NoseCavity", shape = "Block", size = Vector3.new(0.15, 0.15, 0.1), offset = Vector3.new(0, -0.05, 0.48), color = Color3.fromRGB(50, 40, 35) },
				-- Shield in left hand
				{ name = "Shield", shape = "Block", size = Vector3.new(0.15, 1.8, 1.4), offset = Vector3.new(-1.5, -0.8, 0), color = Color3.fromRGB(100, 90, 80), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "ShieldBoss", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(-1.6, -0.8, 0), color = Color3.fromRGB(140, 130, 110), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "ShieldRim", shape = "Block", size = Vector3.new(0.18, 1.9, 0.15), offset = Vector3.new(-1.5, -0.8, 0.7), color = Color3.fromRGB(120, 110, 100), bodyRelative = true, material = Enum.Material.Metal },
				-- Tattered cloth on shoulders
				{ name = "ClothL", shape = "Block", size = Vector3.new(0.8, 1.5, 0.6), offset = Vector3.new(-0.5, 1.2, 0), color = Color3.fromRGB(80, 70, 55), bodyRelative = true, material = Enum.Material.Fabric, transparency = 0.2 },
				{ name = "ClothR", shape = "Block", size = Vector3.new(0.6, 1.0, 0.5), offset = Vector3.new(0.5, 1.0, 0), color = Color3.fromRGB(75, 65, 50), bodyRelative = true, material = Enum.Material.Fabric, transparency = 0.3 },
				-- Bone crown
				{ name = "CrownBase", shape = "Block", size = Vector3.new(1.1, 0.15, 1.1), offset = Vector3.new(0, 0.5, 0), color = Color3.fromRGB(210, 200, 180) },
				{ name = "CrownSpike1", shape = "Block", size = Vector3.new(0.1, 0.4, 0.1), offset = Vector3.new(0, 0.75, 0.4), color = Color3.fromRGB(210, 200, 180) },
				{ name = "CrownSpike2", shape = "Block", size = Vector3.new(0.1, 0.35, 0.1), offset = Vector3.new(0.35, 0.7, 0.2), color = Color3.fromRGB(210, 200, 180) },
				{ name = "CrownSpike3", shape = "Block", size = Vector3.new(0.1, 0.3, 0.1), offset = Vector3.new(-0.35, 0.7, 0.2), color = Color3.fromRGB(210, 200, 180) },
				-- Spectral wisps
				{ name = "Wisp1", shape = "Ball", size = Vector3.new(0.5, 0.8, 0.5), offset = Vector3.new(0.7, 0.5, 0.5), color = Color3.fromRGB(100, 200, 150), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.6 },
				{ name = "Wisp2", shape = "Ball", size = Vector3.new(0.4, 0.6, 0.4), offset = Vector3.new(-0.8, -0.3, -0.3), color = Color3.fromRGB(100, 200, 150), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.7 },
				{ name = "Wisp3", shape = "Ball", size = Vector3.new(0.3, 0.5, 0.3), offset = Vector3.new(0.2, -2.5, 0.4), color = Color3.fromRGB(120, 220, 170), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.65 },
				-- Sword crossguard
				{ name = "SwordGuard", shape = "Block", size = Vector3.new(0.1, 0.15, 0.8), offset = Vector3.new(1.5, 0, 0), color = Color3.fromRGB(140, 130, 110), bodyRelative = true, material = Enum.Material.Metal },
				-- Hand bones (knuckles)
				{ name = "HandL", shape = "Block", size = Vector3.new(0.35, 0.3, 0.35), offset = Vector3.new(-1.1, -2.2, 0), color = Color3.fromRGB(225, 220, 205), bodyRelative = true },
				{ name = "HandR", shape = "Block", size = Vector3.new(0.35, 0.3, 0.35), offset = Vector3.new(1.1, -2.2, 0), color = Color3.fromRGB(225, 220, 205), bodyRelative = true },
				-- Foot bones
				{ name = "FootL", shape = "Block", size = Vector3.new(0.5, 0.15, 0.6), offset = Vector3.new(-0.4, -4.5, 0.1), color = Color3.fromRGB(225, 220, 205), bodyRelative = true },
				{ name = "FootR", shape = "Block", size = Vector3.new(0.5, 0.15, 0.6), offset = Vector3.new(0.4, -4.5, 0.1), color = Color3.fromRGB(225, 220, 205), bodyRelative = true },
				-- Pelvis
				{ name = "Pelvis", shape = "Block", size = Vector3.new(1.3, 0.4, 0.8), offset = Vector3.new(0, -1.5, 0), color = Color3.fromRGB(225, 220, 205), bodyRelative = true },
			},
		},
	},

	DarkWizard = {
		name        = "Dark Wizard",
		hp          = 600,
		damage      = 54,
		level       = 35,
		xp          = 80,
		respawnTime = 50,
		zone        = "Wilderness",
		passive     = false,
		drops = {
			{ item = "Wizard Robe", chance = 0.10, minQty = 1, maxQty = 1 },
			{ item = "Magic Log",   chance = 0.20, minQty = 1, maxQty = 1 },
			{ item = "Gold Ore",    chance = 0.40, minQty = 2, maxQty = 4 },
			{ item = "Iron Sword",  chance = 0.12, minQty = 1, maxQty = 1 },
			{ item = "Gold Sword",  chance = 0.03, minQty = 1, maxQty = 1 },
			{ item = "Yew Shortbow", chance = 0.05, minQty = 1, maxQty = 1 },
			{ item = "Gold Arrows", chance = 0.15, minQty = 10, maxQty = 25 },
		},
		model = {
			bodyColor = Color3.fromRGB(40, 15, 70),
			size = Vector3.new(2, 5, 1.5),
			headSize = 1.0,
			extras = {
				-- Original parts
				{ name = "Hood", shape = "Block", size = Vector3.new(1.4, 0.8, 1.4), offset = Vector3.new(0, 0.6, -0.1), color = Color3.fromRGB(30, 10, 55) },
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.2, 0.2, 0.2), offset = Vector3.new(-0.2, 0.1, 0.45), color = Color3.fromRGB(180, 50, 255), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.2, 0.2, 0.2), offset = Vector3.new(0.2, 0.1, 0.45), color = Color3.fromRGB(180, 50, 255), material = Enum.Material.Neon },
				{ name = "Robe", shape = "Block", size = Vector3.new(2.5, 3, 2), offset = Vector3.new(0, -1.5, 0), color = Color3.fromRGB(40, 15, 70), bodyRelative = true },
				{ name = "Staff", shape = "Block", size = Vector3.new(0.3, 6, 0.3), offset = Vector3.new(1.5, 0, 0), color = Color3.fromRGB(80, 50, 30), bodyRelative = true, material = Enum.Material.Wood },
				{ name = "StaffOrb", shape = "Ball", size = Vector3.new(0.8, 0.8, 0.8), offset = Vector3.new(1.5, 3.2, 0), color = Color3.fromRGB(180, 50, 255), bodyRelative = true, material = Enum.Material.Neon },
				{ name = "HandL", shape = "Ball", size = Vector3.new(0.5, 0.5, 0.5), offset = Vector3.new(-1.3, 0, 0.5), color = Color3.fromRGB(150, 40, 200), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.3 },
				-- Longer robe skirt
				{ name = "RobeSkirt", shape = "Block", size = Vector3.new(2.8, 2, 2.3), offset = Vector3.new(0, -3.2, 0), color = Color3.fromRGB(35, 12, 60), bodyRelative = true },
				{ name = "RobeHem", shape = "Block", size = Vector3.new(3.0, 0.2, 2.5), offset = Vector3.new(0, -4.2, 0), color = Color3.fromRGB(25, 8, 45), bodyRelative = true },
				-- Hood peak (taller hood)
				{ name = "HoodPeak", shape = "Block", size = Vector3.new(0.8, 0.6, 0.8), offset = Vector3.new(0, 1.1, -0.2), color = Color3.fromRGB(25, 8, 50) },
				-- Spell book in left hand
				{ name = "Book", shape = "Block", size = Vector3.new(0.6, 0.8, 0.15), offset = Vector3.new(-1.5, -0.5, 0.4), color = Color3.fromRGB(60, 20, 20), bodyRelative = true },
				{ name = "BookPages", shape = "Block", size = Vector3.new(0.55, 0.75, 0.08), offset = Vector3.new(-1.5, -0.5, 0.48), color = Color3.fromRGB(230, 220, 180), bodyRelative = true },
				{ name = "BookClasp", shape = "Block", size = Vector3.new(0.1, 0.1, 0.18), offset = Vector3.new(-1.5, -0.15, 0.4), color = Color3.fromRGB(180, 150, 50), bodyRelative = true, material = Enum.Material.Metal },
				-- Floating magic orbs
				{ name = "FloatOrb1", shape = "Ball", size = Vector3.new(0.35, 0.35, 0.35), offset = Vector3.new(-0.8, 2.5, -0.5), color = Color3.fromRGB(160, 40, 220), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.3 },
				{ name = "FloatOrb2", shape = "Ball", size = Vector3.new(0.25, 0.25, 0.25), offset = Vector3.new(0.5, 2.8, 0.3), color = Color3.fromRGB(140, 30, 200), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
				{ name = "FloatOrb3", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(-0.3, 3.0, 0.6), color = Color3.fromRGB(170, 60, 240), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.35 },
				-- Rune circle at feet
				{ name = "RuneCircle", shape = "Block", size = Vector3.new(4, 0.05, 4), offset = Vector3.new(0, -4.5, 0), color = Color3.fromRGB(120, 30, 180), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.5 },
				{ name = "RuneInner", shape = "Ball", size = Vector3.new(2.5, 0.08, 2.5), offset = Vector3.new(0, -4.48, 0), color = Color3.fromRGB(100, 20, 160), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.6 },
				-- Rune symbols floating
				{ name = "RuneFloat1", shape = "Block", size = Vector3.new(0.3, 0.3, 0.05), offset = Vector3.new(1.5, -4.3, 1.5), color = Color3.fromRGB(180, 50, 255), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
				{ name = "RuneFloat2", shape = "Block", size = Vector3.new(0.3, 0.3, 0.05), offset = Vector3.new(-1.5, -4.3, -1.5), color = Color3.fromRGB(180, 50, 255), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
				{ name = "RuneFloat3", shape = "Block", size = Vector3.new(0.3, 0.3, 0.05), offset = Vector3.new(-1.5, -4.3, 1.5), color = Color3.fromRGB(180, 50, 255), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
				{ name = "RuneFloat4", shape = "Block", size = Vector3.new(0.3, 0.3, 0.05), offset = Vector3.new(1.5, -4.3, -1.5), color = Color3.fromRGB(180, 50, 255), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
				-- Belt/sash
				{ name = "Sash", shape = "Block", size = Vector3.new(2.3, 0.2, 1.6), offset = Vector3.new(0, -0.3, 0), color = Color3.fromRGB(80, 30, 120), bodyRelative = true },
				-- Robe trim
				{ name = "TrimFront", shape = "Block", size = Vector3.new(0.15, 4.5, 0.1), offset = Vector3.new(0, -1.5, -1.0), color = Color3.fromRGB(100, 40, 150), bodyRelative = true },
				-- Staff glow ring
				{ name = "StaffRing", shape = "Block", size = Vector3.new(0.5, 0.1, 0.5), offset = Vector3.new(1.5, 2.6, 0), color = Color3.fromRGB(150, 40, 220), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.3 },
				-- Dark energy hand glow (right)
				{ name = "HandR", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(1.3, 0, 0.5), color = Color3.fromRGB(150, 40, 200), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
			},
		},
	},

	Demon = {
		name        = "Demon",
		hp          = 1000,
		damage      = 75,
		level       = 50,
		xp          = 150,
		respawnTime = 70,
		zone        = "Wilderness",
		passive     = false,
		drops = {
			{ item = "Demon Heart",  chance = 0.15, minQty = 1, maxQty = 1 },
			{ item = "Gold Sword",   chance = 0.05, minQty = 1, maxQty = 1 },
			{ item = "Runite Ore",   chance = 0.25, minQty = 1, maxQty = 3 },
			{ item = "Gold Ore",     chance = 0.40, minQty = 2, maxQty = 5 },
			{ item = "Bones",        chance = 1.00, minQty = 2, maxQty = 3 },
			{ item = "Gold Crossbow", chance = 0.04, minQty = 1, maxQty = 1 },
			{ item = "Runite Arrows", chance = 0.10, minQty = 5, maxQty = 15 },
			{ item = "Gold Shield",  chance = 0.08, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(180, 30, 30),
			size = Vector3.new(3, 5, 2.5),
			headSize = 1.4,
			extras = {
				-- Original parts
				{ name = "HornL", shape = "Block", size = Vector3.new(0.3, 1.5, 0.3), offset = Vector3.new(-0.6, 1, 0), color = Color3.fromRGB(50, 10, 10), rotation = Vector3.new(0, 0, -20) },
				{ name = "HornR", shape = "Block", size = Vector3.new(0.3, 1.5, 0.3), offset = Vector3.new(0.6, 1, 0), color = Color3.fromRGB(50, 10, 10), rotation = Vector3.new(0, 0, 20) },
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.35, 0.35, 0.35), offset = Vector3.new(-0.35, 0.15, 0.6), color = Color3.fromRGB(255, 200, 0), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.35, 0.35, 0.35), offset = Vector3.new(0.35, 0.15, 0.6), color = Color3.fromRGB(255, 200, 0), material = Enum.Material.Neon },
				{ name = "ChestGlow", shape = "Block", size = Vector3.new(1.5, 1.5, 0.3), offset = Vector3.new(0, 0.5, 1.3), color = Color3.fromRGB(255, 80, 20), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.3 },
				{ name = "WingL", shape = "Block", size = Vector3.new(0.2, 4, 3), offset = Vector3.new(-2, 1, -1), color = Color3.fromRGB(100, 15, 15), bodyRelative = true },
				{ name = "WingR", shape = "Block", size = Vector3.new(0.2, 4, 3), offset = Vector3.new(2, 1, -1), color = Color3.fromRGB(100, 15, 15), bodyRelative = true },
				{ name = "ArmL", shape = "Block", size = Vector3.new(0.6, 4, 0.6), offset = Vector3.new(-2, -0.5, 0), color = Color3.fromRGB(180, 30, 30), bodyRelative = true },
				{ name = "ArmR", shape = "Block", size = Vector3.new(0.6, 4, 0.6), offset = Vector3.new(2, -0.5, 0), color = Color3.fromRGB(180, 30, 30), bodyRelative = true },
				{ name = "ClawL", shape = "Block", size = Vector3.new(0.8, 0.3, 0.8), offset = Vector3.new(-2, -2.8, 0), color = Color3.fromRGB(50, 10, 10), bodyRelative = true },
				{ name = "ClawR", shape = "Block", size = Vector3.new(0.8, 0.3, 0.8), offset = Vector3.new(2, -2.8, 0), color = Color3.fromRGB(50, 10, 10), bodyRelative = true },
				{ name = "Tail", shape = "Block", size = Vector3.new(0.3, 0.3, 4), offset = Vector3.new(0, -1, -3.5), color = Color3.fromRGB(150, 25, 25), bodyRelative = true },
				{ name = "LegL", shape = "Block", size = Vector3.new(0.7, 3, 0.7), offset = Vector3.new(-0.8, -4, 0), color = Color3.fromRGB(180, 30, 30), bodyRelative = true },
				{ name = "LegR", shape = "Block", size = Vector3.new(0.7, 3, 0.7), offset = Vector3.new(0.8, -4, 0), color = Color3.fromRGB(180, 30, 30), bodyRelative = true },
				-- Jaw with fangs
				{ name = "Jaw", shape = "Block", size = Vector3.new(0.9, 0.3, 0.7), offset = Vector3.new(0, -0.5, 0.2), color = Color3.fromRGB(160, 25, 25) },
				{ name = "FangL", shape = "Block", size = Vector3.new(0.1, 0.3, 0.1), offset = Vector3.new(-0.25, -0.55, 0.5), color = Color3.fromRGB(240, 230, 200) },
				{ name = "FangR", shape = "Block", size = Vector3.new(0.1, 0.3, 0.1), offset = Vector3.new(0.25, -0.55, 0.5), color = Color3.fromRGB(240, 230, 200) },
				{ name = "FangMidL", shape = "Block", size = Vector3.new(0.08, 0.2, 0.08), offset = Vector3.new(-0.1, -0.5, 0.55), color = Color3.fromRGB(240, 230, 200) },
				{ name = "FangMidR", shape = "Block", size = Vector3.new(0.08, 0.2, 0.08), offset = Vector3.new(0.1, -0.5, 0.55), color = Color3.fromRGB(240, 230, 200) },
				-- Pupils (slitted)
				{ name = "PupilL", shape = "Block", size = Vector3.new(0.08, 0.25, 0.08), offset = Vector3.new(-0.35, 0.15, 0.75), color = Color3.fromRGB(20, 5, 5) },
				{ name = "PupilR", shape = "Block", size = Vector3.new(0.08, 0.25, 0.08), offset = Vector3.new(0.35, 0.15, 0.75), color = Color3.fromRGB(20, 5, 5) },
				-- Fire effects on hands
				{ name = "FireHandL", shape = "Ball", size = Vector3.new(0.9, 1.2, 0.9), offset = Vector3.new(-2, -2.8, 0), color = Color3.fromRGB(255, 120, 20), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
				{ name = "FireHandR", shape = "Ball", size = Vector3.new(0.9, 1.2, 0.9), offset = Vector3.new(2, -2.8, 0), color = Color3.fromRGB(255, 120, 20), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
				{ name = "FireInnerL", shape = "Ball", size = Vector3.new(0.5, 0.8, 0.5), offset = Vector3.new(-2, -2.5, 0), color = Color3.fromRGB(255, 220, 50), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.3 },
				{ name = "FireInnerR", shape = "Ball", size = Vector3.new(0.5, 0.8, 0.5), offset = Vector3.new(2, -2.5, 0), color = Color3.fromRGB(255, 220, 50), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.3 },
				-- Chest cavity glow (deeper)
				{ name = "ChestCavity", shape = "Block", size = Vector3.new(1.0, 1.0, 0.5), offset = Vector3.new(0, 0.5, 1.0), color = Color3.fromRGB(255, 50, 10), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.5 },
				{ name = "ChestCrack1", shape = "Block", size = Vector3.new(0.08, 1.2, 0.1), offset = Vector3.new(-0.4, 0.5, 1.28), color = Color3.fromRGB(255, 100, 30), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
				{ name = "ChestCrack2", shape = "Block", size = Vector3.new(0.08, 0.9, 0.1), offset = Vector3.new(0.3, 0.6, 1.28), color = Color3.fromRGB(255, 100, 30), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
				-- Barbed tail tip
				{ name = "TailBarb", shape = "Block", size = Vector3.new(0.6, 0.6, 0.5), offset = Vector3.new(0, -1, -5.8), color = Color3.fromRGB(50, 10, 10), bodyRelative = true, rotation = Vector3.new(0, 0, 45) },
				{ name = "TailBarbTip", shape = "Block", size = Vector3.new(0.3, 0.3, 0.4), offset = Vector3.new(0, -1, -6.2), color = Color3.fromRGB(40, 5, 5), bodyRelative = true },
				-- Wing membrane detail (veins)
				{ name = "WingVeinL1", shape = "Block", size = Vector3.new(0.05, 3.5, 0.1), offset = Vector3.new(-2.5, 1, -0.5), color = Color3.fromRGB(70, 10, 10), bodyRelative = true },
				{ name = "WingVeinL2", shape = "Block", size = Vector3.new(0.05, 3.0, 0.1), offset = Vector3.new(-3.2, 1, -1.5), color = Color3.fromRGB(70, 10, 10), bodyRelative = true },
				{ name = "WingVeinR1", shape = "Block", size = Vector3.new(0.05, 3.5, 0.1), offset = Vector3.new(2.5, 1, -0.5), color = Color3.fromRGB(70, 10, 10), bodyRelative = true },
				{ name = "WingVeinR2", shape = "Block", size = Vector3.new(0.05, 3.0, 0.1), offset = Vector3.new(3.2, 1, -1.5), color = Color3.fromRGB(70, 10, 10), bodyRelative = true },
				-- Wing tips (claws at top)
				{ name = "WingClawL", shape = "Block", size = Vector3.new(0.15, 0.5, 0.15), offset = Vector3.new(-2, 3.2, -1), color = Color3.fromRGB(40, 8, 8), bodyRelative = true },
				{ name = "WingClawR", shape = "Block", size = Vector3.new(0.15, 0.5, 0.15), offset = Vector3.new(2, 3.2, -1), color = Color3.fromRGB(40, 8, 8), bodyRelative = true },
				-- Horn ridges
				{ name = "HornRidgeL", shape = "Block", size = Vector3.new(0.35, 0.1, 0.35), offset = Vector3.new(-0.6, 0.5, 0), color = Color3.fromRGB(60, 15, 15) },
				{ name = "HornRidgeR", shape = "Block", size = Vector3.new(0.35, 0.1, 0.35), offset = Vector3.new(0.6, 0.5, 0), color = Color3.fromRGB(60, 15, 15) },
				-- Brow ridge
				{ name = "BrowRidge", shape = "Block", size = Vector3.new(1.0, 0.15, 0.3), offset = Vector3.new(0, 0.35, 0.55), color = Color3.fromRGB(140, 20, 20) },
				-- Hooved feet
				{ name = "HoofL", shape = "Block", size = Vector3.new(0.8, 0.25, 0.9), offset = Vector3.new(-0.8, -5.6, 0), color = Color3.fromRGB(30, 8, 8), bodyRelative = true },
				{ name = "HoofR", shape = "Block", size = Vector3.new(0.8, 0.25, 0.9), offset = Vector3.new(0.8, -5.6, 0), color = Color3.fromRGB(30, 8, 8), bodyRelative = true },
				-- Shoulder spikes
				{ name = "ShoulderSpikeL", shape = "Block", size = Vector3.new(0.2, 0.8, 0.2), offset = Vector3.new(-1.8, 2.2, 0), color = Color3.fromRGB(50, 10, 10), bodyRelative = true, rotation = Vector3.new(0, 0, -25) },
				{ name = "ShoulderSpikeR", shape = "Block", size = Vector3.new(0.2, 0.8, 0.2), offset = Vector3.new(1.8, 2.2, 0), color = Color3.fromRGB(50, 10, 10), bodyRelative = true, rotation = Vector3.new(0, 0, 25) },
			},
		},
	},

	ShadowDragon = {
		name        = "Shadow Dragon",
		hp          = 5000,
		damage      = 120,
		level       = 80,
		xp          = 500,
		respawnTime = 180,
		zone        = "Wilderness",
		passive     = false,
		boss        = true,
		drops = {
			{ item = "Dragon Scale",  chance = 1.00, minQty = 1, maxQty = 3 },
			{ item = "Dragon Sword",  chance = 0.05, minQty = 1, maxQty = 1 },
			{ item = "Shadow Gem",    chance = 0.10, minQty = 1, maxQty = 1 },
			{ item = "Runite Ore",    chance = 0.50, minQty = 3, maxQty = 5 },
			{ item = "Gold Sword",    chance = 0.15, minQty = 1, maxQty = 1 },
			{ item = "Demon Heart",   chance = 0.20, minQty = 1, maxQty = 1 },
			{ item = "Dragon Crossbow", chance = 0.02, minQty = 1, maxQty = 1 },
			{ item = "Dragon Shield", chance = 0.03, minQty = 1, maxQty = 1 },
			{ item = "Magic Bowstring", chance = 0.15, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(15, 3, 35),
			size = Vector3.new(8, 6, 14),
			headSize = 3.0,
			extras = {
				-- === MASSIVE MULTI-PART SHADOW DRAGON (40+ parts) ===
				-- HEAD: Snout, jaw, fangs, brow ridges
				{ name = "Snout", shape = "Block", size = Vector3.new(2.0, 1.4, 3.0), offset = Vector3.new(0, -0.4, 2.5), color = Color3.fromRGB(15, 3, 35) },
				{ name = "Jaw", shape = "Block", size = Vector3.new(1.8, 0.6, 2.5), offset = Vector3.new(0, -1.2, 2.0), color = Color3.fromRGB(12, 2, 28) },
				{ name = "BrowL", shape = "Block", size = Vector3.new(0.8, 0.3, 0.6), offset = Vector3.new(-0.9, 0.8, 1.2), color = Color3.fromRGB(10, 2, 25) },
				{ name = "BrowR", shape = "Block", size = Vector3.new(0.8, 0.3, 0.6), offset = Vector3.new(0.9, 0.8, 1.2), color = Color3.fromRGB(10, 2, 25) },
				-- EYES: Massive glowing purple eyes with slit pupils
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.7, 0.7, 0.7), offset = Vector3.new(-0.9, 0.5, 1.2), color = Color3.fromRGB(200, 50, 255), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.7, 0.7, 0.7), offset = Vector3.new(0.9, 0.5, 1.2), color = Color3.fromRGB(200, 50, 255), material = Enum.Material.Neon },
				{ name = "PupilL", shape = "Block", size = Vector3.new(0.1, 0.5, 0.1), offset = Vector3.new(-0.9, 0.5, 1.55), color = Color3.fromRGB(10, 0, 15) },
				{ name = "PupilR", shape = "Block", size = Vector3.new(0.1, 0.5, 0.1), offset = Vector3.new(0.9, 0.5, 1.55), color = Color3.fromRGB(10, 0, 15) },
				-- HORNS: Massive curved horns
				{ name = "HornL1", shape = "Block", size = Vector3.new(0.5, 2.5, 0.5), offset = Vector3.new(-1.0, 2.0, -0.5), color = Color3.fromRGB(60, 15, 80), rotation = Vector3.new(0, 0, -15) },
				{ name = "HornL2", shape = "Block", size = Vector3.new(0.35, 1.5, 0.35), offset = Vector3.new(-1.3, 3.5, -1.0), color = Color3.fromRGB(80, 20, 100) },
				{ name = "HornR1", shape = "Block", size = Vector3.new(0.5, 2.5, 0.5), offset = Vector3.new(1.0, 2.0, -0.5), color = Color3.fromRGB(60, 15, 80), rotation = Vector3.new(0, 0, 15) },
				{ name = "HornR2", shape = "Block", size = Vector3.new(0.35, 1.5, 0.35), offset = Vector3.new(1.3, 3.5, -1.0), color = Color3.fromRGB(80, 20, 100) },
				-- FANGS: Huge dripping teeth
				{ name = "FangL", shape = "Block", size = Vector3.new(0.2, 0.6, 0.2), offset = Vector3.new(-0.6, -1.0, 3.2), color = Color3.fromRGB(230, 220, 200) },
				{ name = "FangR", shape = "Block", size = Vector3.new(0.2, 0.6, 0.2), offset = Vector3.new(0.6, -1.0, 3.2), color = Color3.fromRGB(230, 220, 200) },
				{ name = "FangMidL", shape = "Block", size = Vector3.new(0.15, 0.4, 0.15), offset = Vector3.new(-0.3, -0.9, 3.5), color = Color3.fromRGB(220, 210, 190) },
				{ name = "FangMidR", shape = "Block", size = Vector3.new(0.15, 0.4, 0.15), offset = Vector3.new(0.3, -0.9, 3.5), color = Color3.fromRGB(220, 210, 190) },
				-- NOSTRILS: Smoking
				{ name = "NostrilL", shape = "Ball", size = Vector3.new(0.4, 0.3, 0.3), offset = Vector3.new(-0.5, -0.1, 3.8), color = Color3.fromRGB(10, 2, 20) },
				{ name = "NostrilR", shape = "Ball", size = Vector3.new(0.4, 0.3, 0.3), offset = Vector3.new(0.5, -0.1, 3.8), color = Color3.fromRGB(10, 2, 20) },
				-- HEAD RUNE: Glowing arcane symbol
				{ name = "HeadRune", shape = "Ball", size = Vector3.new(0.6, 0.6, 0.15), offset = Vector3.new(0, 1.0, 1.5), color = Color3.fromRGB(180, 40, 255), material = Enum.Material.Neon, transparency = 0.2 },
				-- NECK SPINES: Ridge of spines down the neck
				{ name = "NeckSpine1", shape = "Block", size = Vector3.new(0.5, 2.0, 0.5), offset = Vector3.new(0, 1.6, 0.5), color = Color3.fromRGB(50, 10, 70) },
				{ name = "NeckSpine2", shape = "Block", size = Vector3.new(0.45, 1.7, 0.45), offset = Vector3.new(0, 1.5, -0.3), color = Color3.fromRGB(50, 10, 70) },
				{ name = "NeckSpine3", shape = "Block", size = Vector3.new(0.4, 1.4, 0.4), offset = Vector3.new(0, 1.4, -1.0), color = Color3.fromRGB(50, 10, 70) },
				-- WINGS: Massive bat-like wings with bone struts and membrane
				{ name = "WingBoneL", shape = "Block", size = Vector3.new(0.4, 8, 10), offset = Vector3.new(-6, 3, -3), color = Color3.fromRGB(30, 6, 50), bodyRelative = true },
				{ name = "WingBoneR", shape = "Block", size = Vector3.new(0.4, 8, 10), offset = Vector3.new(6, 3, -3), color = Color3.fromRGB(30, 6, 50), bodyRelative = true },
				{ name = "WingStrutL1", shape = "Block", size = Vector3.new(0.12, 7.0, 0.2), offset = Vector3.new(-7, 3, 0), color = Color3.fromRGB(25, 5, 45), bodyRelative = true },
				{ name = "WingStrutL2", shape = "Block", size = Vector3.new(0.12, 6.0, 0.2), offset = Vector3.new(-8, 3, -3), color = Color3.fromRGB(25, 5, 45), bodyRelative = true },
				{ name = "WingStrutL3", shape = "Block", size = Vector3.new(0.12, 5.0, 0.2), offset = Vector3.new(-8.5, 3, -5.5), color = Color3.fromRGB(25, 5, 45), bodyRelative = true },
				{ name = "WingStrutR1", shape = "Block", size = Vector3.new(0.12, 7.0, 0.2), offset = Vector3.new(7, 3, 0), color = Color3.fromRGB(25, 5, 45), bodyRelative = true },
				{ name = "WingStrutR2", shape = "Block", size = Vector3.new(0.12, 6.0, 0.2), offset = Vector3.new(8, 3, -3), color = Color3.fromRGB(25, 5, 45), bodyRelative = true },
				{ name = "WingStrutR3", shape = "Block", size = Vector3.new(0.12, 5.0, 0.2), offset = Vector3.new(8.5, 3, -5.5), color = Color3.fromRGB(25, 5, 45), bodyRelative = true },
				{ name = "WingMemL", shape = "Block", size = Vector3.new(0.08, 5, 4), offset = Vector3.new(-7.5, 3, -2), color = Color3.fromRGB(25, 5, 40), bodyRelative = true, transparency = 0.15 },
				{ name = "WingMemR", shape = "Block", size = Vector3.new(0.08, 5, 4), offset = Vector3.new(7.5, 3, -2), color = Color3.fromRGB(25, 5, 40), bodyRelative = true, transparency = 0.15 },
				{ name = "WingClawL", shape = "Block", size = Vector3.new(0.2, 0.8, 0.2), offset = Vector3.new(-6, 7.5, -1), color = Color3.fromRGB(10, 2, 20), bodyRelative = true },
				{ name = "WingClawR", shape = "Block", size = Vector3.new(0.2, 0.8, 0.2), offset = Vector3.new(6, 7.5, -1), color = Color3.fromRGB(10, 2, 20), bodyRelative = true },
				-- BACK SPINES: Armored ridge down the back
				{ name = "BackSpine1", shape = "Block", size = Vector3.new(0.6, 2.5, 0.6), offset = Vector3.new(0, 4.0, -1), color = Color3.fromRGB(55, 12, 75), bodyRelative = true },
				{ name = "BackSpine2", shape = "Block", size = Vector3.new(0.55, 2.2, 0.55), offset = Vector3.new(0, 3.8, -3), color = Color3.fromRGB(55, 12, 75), bodyRelative = true },
				{ name = "BackSpine3", shape = "Block", size = Vector3.new(0.5, 2.0, 0.5), offset = Vector3.new(0, 3.5, -5), color = Color3.fromRGB(55, 12, 75), bodyRelative = true },
				{ name = "BackSpine4", shape = "Block", size = Vector3.new(0.45, 1.8, 0.45), offset = Vector3.new(0, 3.3, -7), color = Color3.fromRGB(55, 12, 75), bodyRelative = true },
				{ name = "BackSpine5", shape = "Block", size = Vector3.new(0.4, 1.5, 0.4), offset = Vector3.new(0, 3.0, -9), color = Color3.fromRGB(55, 12, 75), bodyRelative = true },
				-- ARMORED SCALE PLATES: Down the chest and sides
				{ name = "ChestPlate1", shape = "Block", size = Vector3.new(6, 0.3, 3), offset = Vector3.new(0, -3.0, 4), color = Color3.fromRGB(35, 8, 55), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "ChestPlate2", shape = "Block", size = Vector3.new(5.5, 0.3, 3), offset = Vector3.new(0, -3.0, 1), color = Color3.fromRGB(35, 8, 55), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "ChestPlate3", shape = "Block", size = Vector3.new(5, 0.3, 3), offset = Vector3.new(0, -3.0, -2), color = Color3.fromRGB(35, 8, 55), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "ChestPlate4", shape = "Block", size = Vector3.new(4, 0.3, 3), offset = Vector3.new(0, -3.0, -5), color = Color3.fromRGB(35, 8, 55), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "SideScaleL", shape = "Block", size = Vector3.new(0.3, 4, 8), offset = Vector3.new(-4.2, 0, 0), color = Color3.fromRGB(20, 4, 38), bodyRelative = true, material = Enum.Material.Slate },
				{ name = "SideScaleR", shape = "Block", size = Vector3.new(0.3, 4, 8), offset = Vector3.new(4.2, 0, 0), color = Color3.fromRGB(20, 4, 38), bodyRelative = true, material = Enum.Material.Slate },
				-- LEGS: Massive muscular legs with claws
				{ name = "LegFL", shape = "Block", size = Vector3.new(1.5, 5, 1.5), offset = Vector3.new(-3, -5.5, 5), color = Color3.fromRGB(15, 3, 35), bodyRelative = true },
				{ name = "LegFR", shape = "Block", size = Vector3.new(1.5, 5, 1.5), offset = Vector3.new(3, -5.5, 5), color = Color3.fromRGB(15, 3, 35), bodyRelative = true },
				{ name = "LegBL", shape = "Block", size = Vector3.new(1.5, 5, 1.5), offset = Vector3.new(-3, -5.5, -5), color = Color3.fromRGB(15, 3, 35), bodyRelative = true },
				{ name = "LegBR", shape = "Block", size = Vector3.new(1.5, 5, 1.5), offset = Vector3.new(3, -5.5, -5), color = Color3.fromRGB(15, 3, 35), bodyRelative = true },
				-- CLAWS: Razor sharp
				{ name = "ClawFL1", shape = "Block", size = Vector3.new(0.25, 0.7, 0.7), offset = Vector3.new(-3.5, -8.2, 5.5), color = Color3.fromRGB(8, 1, 15), bodyRelative = true },
				{ name = "ClawFL2", shape = "Block", size = Vector3.new(0.25, 0.7, 0.7), offset = Vector3.new(-2.5, -8.2, 5.5), color = Color3.fromRGB(8, 1, 15), bodyRelative = true },
				{ name = "ClawFR1", shape = "Block", size = Vector3.new(0.25, 0.7, 0.7), offset = Vector3.new(3.5, -8.2, 5.5), color = Color3.fromRGB(8, 1, 15), bodyRelative = true },
				{ name = "ClawFR2", shape = "Block", size = Vector3.new(0.25, 0.7, 0.7), offset = Vector3.new(2.5, -8.2, 5.5), color = Color3.fromRGB(8, 1, 15), bodyRelative = true },
				{ name = "ClawBL1", shape = "Block", size = Vector3.new(0.25, 0.7, 0.7), offset = Vector3.new(-3.5, -8.2, -4.5), color = Color3.fromRGB(8, 1, 15), bodyRelative = true },
				{ name = "ClawBR1", shape = "Block", size = Vector3.new(0.25, 0.7, 0.7), offset = Vector3.new(3.5, -8.2, -4.5), color = Color3.fromRGB(8, 1, 15), bodyRelative = true },
				-- TAIL: Long segmented tail with spikes and glowing tip
				{ name = "Tail1", shape = "Block", size = Vector3.new(1.5, 1.5, 6), offset = Vector3.new(0, 0, -10), color = Color3.fromRGB(15, 3, 35), bodyRelative = true },
				{ name = "Tail2", shape = "Block", size = Vector3.new(1.2, 1.2, 5), offset = Vector3.new(0, 0, -15.5), color = Color3.fromRGB(12, 2, 30), bodyRelative = true },
				{ name = "Tail3", shape = "Block", size = Vector3.new(0.8, 0.8, 4), offset = Vector3.new(0, 0, -20), color = Color3.fromRGB(10, 2, 25), bodyRelative = true },
				{ name = "TailSpike1", shape = "Block", size = Vector3.new(0.3, 0.8, 0.3), offset = Vector3.new(0, 1.0, -11), color = Color3.fromRGB(55, 12, 75), bodyRelative = true },
				{ name = "TailSpike2", shape = "Block", size = Vector3.new(0.25, 0.7, 0.25), offset = Vector3.new(0, 0.9, -14), color = Color3.fromRGB(55, 12, 75), bodyRelative = true },
				{ name = "TailSpike3", shape = "Block", size = Vector3.new(0.2, 0.6, 0.2), offset = Vector3.new(0, 0.7, -17), color = Color3.fromRGB(55, 12, 75), bodyRelative = true },
				{ name = "TailBlade", shape = "Block", size = Vector3.new(2.0, 0.6, 3.0), offset = Vector3.new(0, 0, -23), color = Color3.fromRGB(150, 40, 200), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.2 },
				-- FIRE BREATH PARTICLES: Shadow/purple fire emanating from mouth
				{ name = "BreathFire1", shape = "Ball", size = Vector3.new(1.5, 1.0, 1.5), offset = Vector3.new(0, -0.8, 4.5), color = Color3.fromRGB(150, 30, 200), material = Enum.Material.Neon, transparency = 0.4 },
				{ name = "BreathFire2", shape = "Ball", size = Vector3.new(2.0, 1.5, 2.0), offset = Vector3.new(0, -0.9, 5.5), color = Color3.fromRGB(120, 20, 180), material = Enum.Material.Neon, transparency = 0.5 },
				{ name = "BreathFire3", shape = "Ball", size = Vector3.new(2.5, 2.0, 2.5), offset = Vector3.new(0, -1.0, 7.0), color = Color3.fromRGB(80, 10, 140), material = Enum.Material.Neon, transparency = 0.65 },
				{ name = "BreathEmber1", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(-0.5, -0.5, 6.0), color = Color3.fromRGB(255, 100, 255), material = Enum.Material.Neon, transparency = 0.3 },
				{ name = "BreathEmber2", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(0.6, -0.3, 6.5), color = Color3.fromRGB(255, 80, 220), material = Enum.Material.Neon, transparency = 0.4 },
				-- SHADOW AURA: Massive dark energy field around the dragon
				{ name = "ShadowAura1", shape = "Ball", size = Vector3.new(12, 4, 18), offset = Vector3.new(0, -1, -2), color = Color3.fromRGB(10, 2, 20), bodyRelative = true, transparency = 0.7 },
				{ name = "ShadowAura2", shape = "Ball", size = Vector3.new(8, 3, 12), offset = Vector3.new(0, -2, -8), color = Color3.fromRGB(5, 1, 15), bodyRelative = true, transparency = 0.75 },
				{ name = "ShadowWisp1", shape = "Ball", size = Vector3.new(1.5, 2.0, 1.5), offset = Vector3.new(-3, 1, 2), color = Color3.fromRGB(80, 20, 120), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.6 },
				{ name = "ShadowWisp2", shape = "Ball", size = Vector3.new(1.2, 1.8, 1.2), offset = Vector3.new(4, 2, -3), color = Color3.fromRGB(100, 30, 150), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.65 },
				{ name = "ShadowWisp3", shape = "Ball", size = Vector3.new(1.0, 1.5, 1.0), offset = Vector3.new(-2, -1, -10), color = Color3.fromRGB(60, 15, 100), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.7 },
				-- SHOULDER ARMOR: Heavy plated shoulders
				{ name = "ShoulderL", shape = "Block", size = Vector3.new(2.0, 1.5, 2.0), offset = Vector3.new(-4.5, 3.5, 2), color = Color3.fromRGB(25, 6, 40), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "ShoulderR", shape = "Block", size = Vector3.new(2.0, 1.5, 2.0), offset = Vector3.new(4.5, 3.5, 2), color = Color3.fromRGB(25, 6, 40), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "ShoulderSpikeL", shape = "Block", size = Vector3.new(0.3, 1.2, 0.3), offset = Vector3.new(-4.5, 4.8, 2), color = Color3.fromRGB(60, 15, 80), bodyRelative = true },
				{ name = "ShoulderSpikeR", shape = "Block", size = Vector3.new(0.3, 1.2, 0.3), offset = Vector3.new(4.5, 4.8, 2), color = Color3.fromRGB(60, 15, 80), bodyRelative = true },
			},
		},
	},

	-- NEW SAFE ZONE BOSSES --
	["King Rooster"] = {
		name        = "King Rooster",
		hp          = 300,
		damage      = 15,
		level       = 20,
		xp          = 300, -- level * 15
		respawnTime = 120,
		zone        = "Safe",
		passive     = false,
		boss        = true,
		drops = {
			{ item = "Golden Feather", chance = 0.80, minQty = 1, maxQty = 1 },
			{ item = "King's Crest", chance = 0.60, minQty = 1, maxQty = 1 },
			{ item = "Raw Chicken", chance = 1.00, minQty = 3, maxQty = 3 },
		},
		model = {
			bodyColor = Color3.fromRGB(220, 180, 50),
			size = Vector3.new(3.5, 2.8, 4), -- larger than regular chicken
			headSize = 1.2,
			extras = {
				-- Giant golden comb
				{ name = "KingComb", shape = "Block", size = Vector3.new(0.8, 1.5, 1.2), offset = Vector3.new(0, 1.0, 0.6), color = Color3.fromRGB(255, 215, 0) },
				-- Large beak
				{ name = "KingBeak", shape = "Block", size = Vector3.new(0.6, 0.4, 1.0), offset = Vector3.new(0, 0, 1.2), color = Color3.fromRGB(255, 180, 0) },
				-- Thick legs
				{ name = "LegL", shape = "Block", size = Vector3.new(0.4, 2.0, 0.4), offset = Vector3.new(-0.8, -2.4, 0), color = Color3.fromRGB(255, 180, 0), bodyRelative = true },
				{ name = "LegR", shape = "Block", size = Vector3.new(0.4, 2.0, 0.4), offset = Vector3.new(0.8, -2.4, 0), color = Color3.fromRGB(255, 180, 0), bodyRelative = true },
				-- Majestic tail feathers
				{ name = "TailMain", shape = "Block", size = Vector3.new(0.6, 2.5, 1.8), offset = Vector3.new(0, 0.8, -2.5), color = Color3.fromRGB(200, 150, 30), bodyRelative = true },
				-- Eyes - fierce red
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.25, 0.25, 0.25), offset = Vector3.new(-0.35, 0.2, 0.6), color = Color3.fromRGB(200, 20, 20) },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.25, 0.25, 0.25), offset = Vector3.new(0.35, 0.2, 0.6), color = Color3.fromRGB(200, 20, 20) },
				-- Golden wattle
				{ name = "KingWattle", shape = "Block", size = Vector3.new(0.3, 0.6, 0.3), offset = Vector3.new(0, -0.4, 1.1), color = Color3.fromRGB(255, 215, 0) },
				-- Large wings
				{ name = "WingL", shape = "Block", size = Vector3.new(0.3, 1.4, 2.8), offset = Vector3.new(-2.0, 0.2, -0.2), color = Color3.fromRGB(200, 160, 40), bodyRelative = true },
				{ name = "WingR", shape = "Block", size = Vector3.new(0.3, 1.4, 2.8), offset = Vector3.new(2.0, 0.2, -0.2), color = Color3.fromRGB(200, 160, 40), bodyRelative = true },
			},
		},
	},

	["Elder Treant"] = {
		name        = "Elder Treant",
		hp          = 600,
		damage      = 25,
		level       = 35,
		xp          = 525, -- level * 15
		respawnTime = 180,
		zone        = "Safe",
		passive     = false,
		boss        = true,
		drops = {
			{ item = "Heartwood", chance = 0.70, minQty = 1, maxQty = 1 },
			{ item = "Ancient Bark", chance = 1.00, minQty = 5, maxQty = 5 },
			{ item = "Magic Logs", chance = 0.90, minQty = 3, maxQty = 3 },
			{ item = "Elder Seed", chance = 0.40, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(101, 67, 33),
			size = Vector3.new(4, 5, 4), -- massive tree trunk
			headSize = 1.5,
			extras = {
				-- Tree bark texture blocks
				{ name = "BarkLayer1", shape = "Block", size = Vector3.new(4.2, 5.2, 4.2), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(85, 55, 25), bodyRelative = true, material = Enum.Material.Wood },
				-- Branch arms (thick)
				{ name = "BranchL", shape = "Block", size = Vector3.new(1.2, 0.8, 3.5), offset = Vector3.new(-3.0, 1.5, 0), color = Color3.fromRGB(90, 60, 30), bodyRelative = true },
				{ name = "BranchR", shape = "Block", size = Vector3.new(1.2, 0.8, 3.5), offset = Vector3.new(3.0, 1.5, 0), color = Color3.fromRGB(90, 60, 30), bodyRelative = true },
				-- Root legs
				{ name = "RootL", shape = "Block", size = Vector3.new(1.0, 3.0, 1.0), offset = Vector3.new(-1.5, -4.0, 0), color = Color3.fromRGB(80, 50, 25), bodyRelative = true },
				{ name = "RootR", shape = "Block", size = Vector3.new(1.0, 3.0, 1.0), offset = Vector3.new(1.5, -4.0, 0), color = Color3.fromRGB(80, 50, 25), bodyRelative = true },
				-- Glowing eyes in bark
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(-0.5, 0.3, 0.8), color = Color3.fromRGB(0, 255, 100), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(0.5, 0.3, 0.8), color = Color3.fromRGB(0, 255, 100), material = Enum.Material.Neon },
				-- Leaves on top
				{ name = "LeafCanopy", shape = "Ball", size = Vector3.new(6, 3, 6), offset = Vector3.new(0, 4.0, 0), color = Color3.fromRGB(34, 139, 34), bodyRelative = true },
				-- Moss patches
				{ name = "Moss1", shape = "Block", size = Vector3.new(1.0, 0.8, 0.2), offset = Vector3.new(1.5, 0.5, 2.2), color = Color3.fromRGB(107, 142, 35), bodyRelative = true },
				{ name = "Moss2", shape = "Block", size = Vector3.new(0.8, 1.2, 0.2), offset = Vector3.new(-1.8, -0.5, 2.2), color = Color3.fromRGB(107, 142, 35), bodyRelative = true },
			},
		},
	},

	["Iron Golem"] = {
		name        = "Iron Golem",
		hp          = 1000,
		damage      = 35,
		level       = 50,
		xp          = 750, -- level * 15
		respawnTime = 240,
		zone        = "Safe",
		passive     = false,
		boss        = true,
		drops = {
			{ item = "Golem Core", chance = 0.50, minQty = 1, maxQty = 1 },
			{ item = "Iron Bar", chance = 1.00, minQty = 10, maxQty = 10 },
			{ item = "Runite Ore", chance = 0.80, minQty = 3, maxQty = 3 },
			{ item = "Golem Shield", chance = 0.60, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(105, 105, 105),
			size = Vector3.new(4, 6, 3), -- massive iron body
			headSize = 1.8,
			extras = {
				-- Iron plating
				{ name = "ChestPlate", shape = "Block", size = Vector3.new(4.2, 3, 3.2), offset = Vector3.new(0, 1.5, 0), color = Color3.fromRGB(95, 95, 95), bodyRelative = true, material = Enum.Material.Metal },
				-- Massive arms
				{ name = "ArmL", shape = "Block", size = Vector3.new(1.5, 1.2, 4.5), offset = Vector3.new(-3.5, 2.0, 0), color = Color3.fromRGB(100, 100, 100), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "ArmR", shape = "Block", size = Vector3.new(1.5, 1.2, 4.5), offset = Vector3.new(3.5, 2.0, 0), color = Color3.fromRGB(100, 100, 100), bodyRelative = true, material = Enum.Material.Metal },
				-- Iron legs
				{ name = "LegL", shape = "Block", size = Vector3.new(1.2, 4.0, 1.2), offset = Vector3.new(-1.0, -5.0, 0), color = Color3.fromRGB(90, 90, 90), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "LegR", shape = "Block", size = Vector3.new(1.2, 4.0, 1.2), offset = Vector3.new(1.0, -5.0, 0), color = Color3.fromRGB(90, 90, 90), bodyRelative = true, material = Enum.Material.Metal },
				-- Glowing core in chest
				{ name = "Core", shape = "Ball", size = Vector3.new(0.8, 0.8, 0.8), offset = Vector3.new(0, 1.0, 1.8), color = Color3.fromRGB(255, 100, 0), material = Enum.Material.Neon, bodyRelative = true },
				-- Glowing eyes
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.35, 0.35, 0.35), offset = Vector3.new(-0.6, 0.4, 1.0), color = Color3.fromRGB(255, 0, 0), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.35, 0.35, 0.35), offset = Vector3.new(0.6, 0.4, 1.0), color = Color3.fromRGB(255, 0, 0), material = Enum.Material.Neon },
				-- Shoulder spikes
				{ name = "SpikeL", shape = "Block", size = Vector3.new(0.4, 1.0, 0.4), offset = Vector3.new(-2.5, 3.5, 0), color = Color3.fromRGB(80, 80, 80), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "SpikeR", shape = "Block", size = Vector3.new(0.4, 1.0, 0.4), offset = Vector3.new(2.5, 3.5, 0), color = Color3.fromRGB(80, 80, 80), bodyRelative = true, material = Enum.Material.Metal },
			},
		},
	},

	["Lake Serpent"] = {
		name        = "Lake Serpent",
		hp          = 1500,
		damage      = 45,
		level       = 65,
		xp          = 975, -- level * 15
		respawnTime = 270,
		zone        = "Safe",
		passive     = false,
		boss        = true,
		drops = {
			{ item = "Serpent Scale", chance = 0.60, minQty = 1, maxQty = 1 },
			{ item = "Sea Fang", chance = 0.50, minQty = 1, maxQty = 1 },
			{ item = "Raw Swordfish", chance = 1.00, minQty = 5, maxQty = 5 },
			{ item = "Serpent's Eye", chance = 0.30, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(0, 100, 120),
			size = Vector3.new(3, 2.5, 8), -- long serpentine body
			headSize = 2.0,
			extras = {
				-- Serpent scales
				{ name = "ScaleLayer", shape = "Block", size = Vector3.new(3.2, 2.7, 8.2), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(0, 85, 100), bodyRelative = true, material = Enum.Material.SmoothPlastic },
				-- Long tail
				{ name = "Tail1", shape = "Block", size = Vector3.new(2.5, 2.0, 6), offset = Vector3.new(0, 0, -7.0), color = Color3.fromRGB(0, 95, 110), bodyRelative = true },
				{ name = "Tail2", shape = "Block", size = Vector3.new(2.0, 1.5, 4), offset = Vector3.new(0, 0, -11.0), color = Color3.fromRGB(0, 90, 105), bodyRelative = true },
				{ name = "TailEnd", shape = "Block", size = Vector3.new(1.5, 1.0, 2), offset = Vector3.new(0, 0, -13.5), color = Color3.fromRGB(0, 85, 100), bodyRelative = true },
				-- Fins
				{ name = "FinL", shape = "Block", size = Vector3.new(0.2, 1.5, 3.0), offset = Vector3.new(-1.8, 0, -2.0), color = Color3.fromRGB(0, 120, 140), bodyRelative = true },
				{ name = "FinR", shape = "Block", size = Vector3.new(0.2, 1.5, 3.0), offset = Vector3.new(1.8, 0, -2.0), color = Color3.fromRGB(0, 120, 140), bodyRelative = true },
				-- Large serpent eyes
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.6, 0.6, 0.6), offset = Vector3.new(-0.8, 0.5, 1.2), color = Color3.fromRGB(255, 255, 0), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.6, 0.6, 0.6), offset = Vector3.new(0.8, 0.5, 1.2), color = Color3.fromRGB(255, 255, 0), material = Enum.Material.Neon },
				-- Fangs
				{ name = "FangL", shape = "Block", size = Vector3.new(0.15, 0.8, 0.15), offset = Vector3.new(-0.4, -0.3, 1.8), color = Color3.fromRGB(245, 245, 245) },
				{ name = "FangR", shape = "Block", size = Vector3.new(0.15, 0.8, 0.15), offset = Vector3.new(0.4, -0.3, 1.8), color = Color3.fromRGB(245, 245, 245) },
				-- Dorsal spines
				{ name = "Spine1", shape = "Block", size = Vector3.new(0.3, 1.0, 0.3), offset = Vector3.new(0, 1.5, 2.0), color = Color3.fromRGB(0, 70, 90), bodyRelative = true },
				{ name = "Spine2", shape = "Block", size = Vector3.new(0.3, 1.2, 0.3), offset = Vector3.new(0, 1.6, 0), color = Color3.fromRGB(0, 70, 90), bodyRelative = true },
				{ name = "Spine3", shape = "Block", size = Vector3.new(0.3, 1.0, 0.3), offset = Vector3.new(0, 1.5, -2.0), color = Color3.fromRGB(0, 70, 90), bodyRelative = true },
			},
		},
	},

	["Corrupted Guardian"] = {
		name        = "Corrupted Guardian",
		hp          = 2500,
		damage      = 60,
		level       = 80,
		xp          = 1200, -- level * 15
		respawnTime = 300,
		zone        = "Safe",
		passive     = false,
		boss        = true,
		drops = {
			{ item = "Guardian's Blessing", chance = 0.25, minQty = 1, maxQty = 1 },
			{ item = "Corrupted Plate", chance = 0.40, minQty = 1, maxQty = 1 },
			{ item = "Gold Bar", chance = 1.00, minQty = 10, maxQty = 10 },
			{ item = "Ancient Key", chance = 0.50, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(60, 60, 80),
			size = Vector3.new(4.5, 7, 3.5), -- massive corrupted guardian
			headSize = 2.2,
			extras = {
				-- Corrupted armor plating
				{ name = "CorruptedPlate", shape = "Block", size = Vector3.new(4.7, 4, 3.7), offset = Vector3.new(0, 1.5, 0), color = Color3.fromRGB(45, 45, 65), bodyRelative = true, material = Enum.Material.Metal },
				-- Massive corrupted arms
				{ name = "ArmL", shape = "Block", size = Vector3.new(1.8, 1.5, 5.5), offset = Vector3.new(-4.0, 2.5, 0), color = Color3.fromRGB(50, 50, 70), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "ArmR", shape = "Block", size = Vector3.new(1.8, 1.5, 5.5), offset = Vector3.new(4.0, 2.5, 0), color = Color3.fromRGB(50, 50, 70), bodyRelative = true, material = Enum.Material.Metal },
				-- Corrupted legs
				{ name = "LegL", shape = "Block", size = Vector3.new(1.5, 5.0, 1.5), offset = Vector3.new(-1.2, -6.0, 0), color = Color3.fromRGB(40, 40, 60), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "LegR", shape = "Block", size = Vector3.new(1.5, 5.0, 1.5), offset = Vector3.new(1.2, -6.0, 0), color = Color3.fromRGB(40, 40, 60), bodyRelative = true, material = Enum.Material.Metal },
				-- Corrupted glow core
				{ name = "CorruptedCore", shape = "Ball", size = Vector3.new(1.2, 1.2, 1.2), offset = Vector3.new(0, 1.5, 2.0), color = Color3.fromRGB(120, 0, 120), material = Enum.Material.Neon, bodyRelative = true },
				-- Glowing corrupted eyes
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(-0.7, 0.6, 1.2), color = Color3.fromRGB(120, 0, 120), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(0.7, 0.6, 1.2), color = Color3.fromRGB(120, 0, 120), material = Enum.Material.Neon },
				-- Shoulder corruption spikes
				{ name = "CorruptSpikeL", shape = "Block", size = Vector3.new(0.5, 1.5, 0.5), offset = Vector3.new(-3.0, 4.0, 0), color = Color3.fromRGB(30, 0, 30), bodyRelative = true, material = Enum.Material.Neon },
				{ name = "CorruptSpikeR", shape = "Block", size = Vector3.new(0.5, 1.5, 0.5), offset = Vector3.new(3.0, 4.0, 0), color = Color3.fromRGB(30, 0, 30), bodyRelative = true, material = Enum.Material.Neon },
				-- Corrupted energy tendrils
				{ name = "Tendril1", shape = "Ball", size = Vector3.new(0.8, 0.3, 1.5), offset = Vector3.new(2.0, 0.5, 0), color = Color3.fromRGB(80, 0, 80), material = Enum.Material.Neon, transparency = 0.4, bodyRelative = true },
				{ name = "Tendril2", shape = "Ball", size = Vector3.new(0.6, 0.4, 1.2), offset = Vector3.new(-2.2, 0.8, 0), color = Color3.fromRGB(80, 0, 80), material = Enum.Material.Neon, transparency = 0.4, bodyRelative = true },
			},
		},
	},

	----------------------------------------------------------------------------
	-- NEW AREA MONSTERS (MapSetup5)
	----------------------------------------------------------------------------

	["Pirate Ghost"] = {
		name        = "Pirate Ghost",
		hp          = 200,
		damage      = 18,
		level       = 25,
		xp          = 150,
		respawnTime = 30,
		zone        = "Safe",
		passive     = false,
		drops = {
			{ item = "Ghost Doubloon", chance = 0.30, minQty = 1, maxQty = 3 },
			{ item = "Pirate Cutlass", chance = 0.05, minQty = 1, maxQty = 1 },
			{ item = "Spectral Cloth", chance = 0.20, minQty = 1, maxQty = 2 },
		},
		model = {
			bodyColor = Color3.fromRGB(200, 220, 255),
			size = Vector3.new(2, 4, 1.5),
			headSize = 1.2,
			extras = {
				-- Ghostly transparency
				{ name = "GhostAura", shape = "Block", size = Vector3.new(2.2, 4.2, 1.7), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(180, 200, 255), bodyRelative = true, transparency = 0.4, material = Enum.Material.ForceField },
				-- Tricorn hat
				{ name = "TricornHat", shape = "Block", size = Vector3.new(2, 0.5, 2), offset = Vector3.new(0, 0.8, 0), color = Color3.fromRGB(40, 40, 40), transparency = 0.3 },
				{ name = "HatBrim", shape = "Block", size = Vector3.new(2.5, 0.2, 2.5), offset = Vector3.new(0, 0.5, 0), color = Color3.fromRGB(30, 30, 30), transparency = 0.3 },
				-- Sword arm (right)
				{ name = "SwordArm", shape = "Block", size = Vector3.new(0.6, 0.6, 3), offset = Vector3.new(1.5, 0.5, 0), color = Color3.fromRGB(180, 180, 180), bodyRelative = true, transparency = 0.2, material = Enum.Material.Metal },
				{ name = "SwordBlade", shape = "Block", size = Vector3.new(0.3, 0.3, 4), offset = Vector3.new(1.5, 0.5, 2), color = Color3.fromRGB(200, 200, 200), bodyRelative = true, transparency = 0.1, material = Enum.Material.Metal },
				-- Glowing eyes
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.2, 0.2, 0.2), offset = Vector3.new(-0.25, 0.15, 0.65), color = Color3.fromRGB(100, 200, 255), material = Enum.Material.Neon, transparency = 0.2 },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.2, 0.2, 0.2), offset = Vector3.new(0.25, 0.15, 0.65), color = Color3.fromRGB(100, 200, 255), material = Enum.Material.Neon, transparency = 0.2 },
				-- Ghostly coat
				{ name = "PirateCoat", shape = "Block", size = Vector3.new(2.2, 3, 1.6), offset = Vector3.new(0, -0.5, 0), color = Color3.fromRGB(60, 40, 80), bodyRelative = true, transparency = 0.5 },
				-- Belt with skull buckle
				{ name = "PirateBelt", shape = "Block", size = Vector3.new(2.3, 0.3, 1.7), offset = Vector3.new(0, -0.5, 0), color = Color3.fromRGB(80, 60, 40), bodyRelative = true, transparency = 0.3 },
				{ name = "SkullBuckle", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.2), offset = Vector3.new(0, -0.5, 0.9), color = Color3.fromRGB(220, 220, 200), bodyRelative = true, transparency = 0.2 },
				-- Ghostly beard
				{ name = "GhostBeard", shape = "Block", size = Vector3.new(0.8, 0.6, 0.4), offset = Vector3.new(0, -0.3, 0.5), color = Color3.fromRGB(150, 150, 150), transparency = 0.5 },
				-- Spectral particles
				{ name = "SpectralMist1", shape = "Ball", size = Vector3.new(0.8, 0.8, 0.8), offset = Vector3.new(-0.5, -2, -0.3), color = Color3.fromRGB(120, 180, 255), bodyRelative = true, transparency = 0.7, material = Enum.Material.Neon },
				{ name = "SpectralMist2", shape = "Ball", size = Vector3.new(0.6, 0.6, 0.6), offset = Vector3.new(0.7, -1.5, 0.2), color = Color3.fromRGB(100, 160, 235), bodyRelative = true, transparency = 0.8, material = Enum.Material.Neon },
			},
		},
	},

	["Ice Elemental"] = {
		name        = "Ice Elemental",
		hp          = 500,
		damage      = 28,
		level       = 40,
		xp          = 300,
		respawnTime = 45,
		zone        = "Safe",
		passive     = false,
		drops = {
			{ item = "Frozen Shard", chance = 0.40, minQty = 1, maxQty = 3 },
			{ item = "Ice Crystal", chance = 0.15, minQty = 1, maxQty = 1 },
			{ item = "Frost Essence", chance = 0.10, minQty = 1, maxQty = 1 },
			{ item = "Permafrost Ore", chance = 0.25, minQty = 1, maxQty = 2 },
		},
		model = {
			bodyColor = Color3.fromRGB(173, 216, 230),
			size = Vector3.new(2.5, 4, 2.5),
			headSize = 1.3,
			extras = {
				-- Crystalline body
				{ name = "CrystalCore", shape = "Block", size = Vector3.new(2.7, 4.2, 2.7), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(150, 200, 255), bodyRelative = true, transparency = 0.3, material = Enum.Material.Ice },
				-- Ice shards orbiting (small neon cyan parts)
				{ name = "IceShard1", shape = "Block", size = Vector3.new(0.4, 1.2, 0.4), offset = Vector3.new(2.5, 1, 0), color = Color3.fromRGB(0, 255, 255), bodyRelative = true, transparency = 0.2, material = Enum.Material.Neon },
				{ name = "IceShard2", shape = "Block", size = Vector3.new(0.4, 1, 0.4), offset = Vector3.new(-2.3, 0.5, 1), color = Color3.fromRGB(100, 255, 255), bodyRelative = true, transparency = 0.2, material = Enum.Material.Neon },
				{ name = "IceShard3", shape = "Block", size = Vector3.new(0.4, 1.1, 0.4), offset = Vector3.new(1, 2, 2.2), color = Color3.fromRGB(50, 255, 255), bodyRelative = true, transparency = 0.2, material = Enum.Material.Neon },
				{ name = "IceShard4", shape = "Block", size = Vector3.new(0.4, 0.9, 0.4), offset = Vector3.new(-1.5, -1, -2.5), color = Color3.fromRGB(0, 200, 255), bodyRelative = true, transparency = 0.2, material = Enum.Material.Neon },
				{ name = "IceShard5", shape = "Block", size = Vector3.new(0.4, 1.3, 0.4), offset = Vector3.new(0.5, -2, 1.8), color = Color3.fromRGB(70, 220, 255), bodyRelative = true, transparency = 0.2, material = Enum.Material.Neon },
				-- Cold mist base
				{ name = "ColdMist", shape = "Ball", size = Vector3.new(4, 1, 4), offset = Vector3.new(0, -2.2, 0), color = Color3.fromRGB(200, 230, 255), bodyRelative = true, transparency = 0.6, material = Enum.Material.ForceField },
				-- Jagged ice crown
				{ name = "IceCrown", shape = "Block", size = Vector3.new(1.8, 1.5, 1.8), offset = Vector3.new(0, 1, 0), color = Color3.fromRGB(180, 220, 255), transparency = 0.2, material = Enum.Material.Ice },
				{ name = "CrownSpike1", shape = "Block", size = Vector3.new(0.3, 1, 0.3), offset = Vector3.new(0, 1.8, 0.6), color = Color3.fromRGB(150, 200, 255), transparency = 0.1 },
				{ name = "CrownSpike2", shape = "Block", size = Vector3.new(0.3, 0.8, 0.3), offset = Vector3.new(-0.5, 1.7, 0.3), color = Color3.fromRGB(150, 200, 255), transparency = 0.1 },
				{ name = "CrownSpike3", shape = "Block", size = Vector3.new(0.3, 0.9, 0.3), offset = Vector3.new(0.5, 1.7, 0.3), color = Color3.fromRGB(150, 200, 255), transparency = 0.1 },
				-- Glowing eyes
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(-0.3, 0.2, 0.7), color = Color3.fromRGB(0, 255, 255), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(0.3, 0.2, 0.7), color = Color3.fromRGB(0, 255, 255), material = Enum.Material.Neon },
			},
		},
	},

	["Lava Golem"] = {
		name        = "Lava Golem",
		hp          = 900,
		damage      = 38,
		level       = 55,
		xp          = 500,
		respawnTime = 60,
		zone        = "Wilderness",
		passive     = false,
		drops = {
			{ item = "Magma Core", chance = 0.20, minQty = 1, maxQty = 1 },
			{ item = "Obsidian Shard", chance = 0.35, minQty = 1, maxQty = 3 },
			{ item = "Volcanic Ash", chance = 0.50, minQty = 2, maxQty = 5 },
			{ item = "Lava Blade", chance = 0.03, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(80, 40, 40),
			size = Vector3.new(3.5, 5, 3),
			headSize = 1.8,
			extras = {
				-- Large dark rock body
				{ name = "RockBody", shape = "Block", size = Vector3.new(3.7, 5.2, 3.2), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(60, 30, 30), bodyRelative = true, material = Enum.Material.Rock },
				-- Lava cracks (neon orange lines/parts)
				{ name = "LavaCrack1", shape = "Block", size = Vector3.new(0.2, 4, 0.2), offset = Vector3.new(1, 0, 1.7), color = Color3.fromRGB(255, 100, 0), bodyRelative = true, transparency = 0.2, material = Enum.Material.Neon },
				{ name = "LavaCrack2", shape = "Block", size = Vector3.new(0.2, 3.5, 0.2), offset = Vector3.new(-0.8, 0.5, 1.7), color = Color3.fromRGB(255, 69, 0), bodyRelative = true, transparency = 0.2, material = Enum.Material.Neon },
				{ name = "LavaCrack3", shape = "Block", size = Vector3.new(3.2, 0.2, 0.2), offset = Vector3.new(0, -1, 1.7), color = Color3.fromRGB(255, 140, 0), bodyRelative = true, transparency = 0.3, material = Enum.Material.Neon },
				{ name = "LavaCrack4", shape = "Block", size = Vector3.new(2.8, 0.2, 0.2), offset = Vector3.new(0, 1.5, 1.7), color = Color3.fromRGB(255, 100, 0), bodyRelative = true, transparency = 0.2, material = Enum.Material.Neon },
				-- Magma dripping arms
				{ name = "ArmL", shape = "Block", size = Vector3.new(1.2, 4, 1.2), offset = Vector3.new(-3, -0.5, 0), color = Color3.fromRGB(70, 35, 35), bodyRelative = true, material = Enum.Material.Rock },
				{ name = "ArmR", shape = "Block", size = Vector3.new(1.2, 4, 1.2), offset = Vector3.new(3, -0.5, 0), color = Color3.fromRGB(70, 35, 35), bodyRelative = true, material = Enum.Material.Rock },
				{ name = "MagmaDripL", shape = "Ball", size = Vector3.new(0.6, 0.8, 0.6), offset = Vector3.new(-3, -2.8, 0), color = Color3.fromRGB(255, 69, 0), bodyRelative = true, transparency = 0.3, material = Enum.Material.Neon },
				{ name = "MagmaDripR", shape = "Ball", size = Vector3.new(0.6, 0.8, 0.6), offset = Vector3.new(3, -2.8, 0), color = Color3.fromRGB(255, 69, 0), bodyRelative = true, transparency = 0.3, material = Enum.Material.Neon },
				-- Fire eyes
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(-0.4, 0.3, 1.0), color = Color3.fromRGB(255, 50, 0), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(0.4, 0.3, 1.0), color = Color3.fromRGB(255, 50, 0), material = Enum.Material.Neon },
				-- Obsidian horns
				{ name = "HornL", shape = "Block", size = Vector3.new(0.4, 1.5, 0.4), offset = Vector3.new(-0.6, 1.2, 0), color = Color3.fromRGB(20, 20, 20), material = Enum.Material.Glass },
				{ name = "HornR", shape = "Block", size = Vector3.new(0.4, 1.5, 0.4), offset = Vector3.new(0.6, 1.2, 0), color = Color3.fromRGB(20, 20, 20), material = Enum.Material.Glass },
				-- Legs
				{ name = "LegL", shape = "Block", size = Vector3.new(1.5, 3, 1.5), offset = Vector3.new(-1, -4, 0), color = Color3.fromRGB(60, 30, 30), bodyRelative = true, material = Enum.Material.Rock },
				{ name = "LegR", shape = "Block", size = Vector3.new(1.5, 3, 1.5), offset = Vector3.new(1, -4, 0), color = Color3.fromRGB(60, 30, 30), bodyRelative = true, material = Enum.Material.Rock },
			},
		},
	},

	["Fairy Dragon"] = {
		name        = "Fairy Dragon",
		hp          = 350,
		damage      = 20,
		level       = 30,
		xp          = 200,
		respawnTime = 35,
		zone        = "Safe",
		passive     = false,
		drops = {
			{ item = "Fairy Dust", chance = 0.40, minQty = 1, maxQty = 5 },
			{ item = "Dragon Scale", chance = 0.15, minQty = 1, maxQty = 1 },
			{ item = "Enchanted Petal", chance = 0.30, minQty = 1, maxQty = 3 },
			{ item = "Rainbow Gem", chance = 0.05, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(255, 20, 147),
			size = Vector3.new(2, 3, 4),
			headSize = 1.0,
			extras = {
				-- Small colorful body (pink/purple)
				{ name = "FairyBody", shape = "Block", size = Vector3.new(2.2, 3.2, 4.2), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(238, 130, 238), bodyRelative = true },
				-- Butterfly wings (thin transparent rainbow parts)
				{ name = "WingLUpper", shape = "Block", size = Vector3.new(0.1, 2.5, 3), offset = Vector3.new(-2.2, 0.5, -1), color = Color3.fromRGB(255, 0, 255), bodyRelative = true, transparency = 0.3, material = Enum.Material.Neon },
				{ name = "WingRUpper", shape = "Block", size = Vector3.new(0.1, 2.5, 3), offset = Vector3.new(2.2, 0.5, -1), color = Color3.fromRGB(255, 0, 255), bodyRelative = true, transparency = 0.3, material = Enum.Material.Neon },
				{ name = "WingLLower", shape = "Block", size = Vector3.new(0.1, 1.8, 2), offset = Vector3.new(-2.0, -1, -0.5), color = Color3.fromRGB(0, 255, 255), bodyRelative = true, transparency = 0.3, material = Enum.Material.Neon },
				{ name = "WingRLower", shape = "Block", size = Vector3.new(0.1, 1.8, 2), offset = Vector3.new(2.0, -1, -0.5), color = Color3.fromRGB(0, 255, 255), bodyRelative = true, transparency = 0.3, material = Enum.Material.Neon },
				-- Sparkle trail
				{ name = "Sparkle1", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(-0.5, 0.5, -2.5), color = Color3.fromRGB(255, 255, 0), bodyRelative = true, transparency = 0.2, material = Enum.Material.Neon },
				{ name = "Sparkle2", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(0.3, -0.3, -3), color = Color3.fromRGB(255, 0, 255), bodyRelative = true, transparency = 0.3, material = Enum.Material.Neon },
				{ name = "Sparkle3", shape = "Ball", size = Vector3.new(0.2, 0.2, 0.2), offset = Vector3.new(0, 1, -2), color = Color3.fromRGB(0, 255, 255), bodyRelative = true, transparency = 0.4, material = Enum.Material.Neon },
				-- Cute face
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(-0.25, 0.2, 0.6), color = Color3.fromRGB(0, 255, 0), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(0.25, 0.2, 0.6), color = Color3.fromRGB(0, 255, 0), material = Enum.Material.Neon },
				-- Small horns
				{ name = "HornL", shape = "Block", size = Vector3.new(0.2, 0.6, 0.2), offset = Vector3.new(-0.3, 0.7, 0.2), color = Color3.fromRGB(255, 215, 0) },
				{ name = "HornR", shape = "Block", size = Vector3.new(0.2, 0.6, 0.2), offset = Vector3.new(0.3, 0.7, 0.2), color = Color3.fromRGB(255, 215, 0) },
				-- Tail
				{ name = "Tail", shape = "Block", size = Vector3.new(0.8, 0.8, 3), offset = Vector3.new(0, 0, -3.5), color = Color3.fromRGB(255, 105, 180), bodyRelative = true },
				{ name = "TailTip", shape = "Ball", size = Vector3.new(0.6, 0.6, 0.6), offset = Vector3.new(0, 0, -5.2), color = Color3.fromRGB(255, 255, 0), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.2 },
			},
		},
	},

	["Ancient Guardian"] = {
		name        = "Ancient Guardian",
		hp          = 2000,
		damage      = 50,
		level       = 70,
		xp          = 800,
		respawnTime = 90,
		zone        = "Wilderness",
		passive     = false,
		boss        = true,
		drops = {
			{ item = "Ancient Relic", chance = 0.25, minQty = 1, maxQty = 1 },
			{ item = "Guardian Essence", chance = 0.15, minQty = 1, maxQty = 1 },
			{ item = "Rune of Power", chance = 0.05, minQty = 1, maxQty = 1 },
			{ item = "Ancient Armor", chance = 0.03, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(105, 105, 105),
			size = Vector3.new(6, 8, 4), -- MASSIVE size (4x normal)
			headSize = 2.5,
			extras = {
				-- MASSIVE stone construct
				{ name = "StoneBody", shape = "Block", size = Vector3.new(6.5, 8.5, 4.5), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(85, 85, 85), bodyRelative = true, material = Enum.Material.Cobblestone },
				-- Glowing rune eyes (neon green)
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.8, 0.8, 0.8), offset = Vector3.new(-0.8, 0.5, 1.4), color = Color3.fromRGB(0, 255, 0), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.8, 0.8, 0.8), offset = Vector3.new(0.8, 0.5, 1.4), color = Color3.fromRGB(0, 255, 0), material = Enum.Material.Neon },
				-- Cracked stone texture
				{ name = "Crack1", shape = "Block", size = Vector3.new(0.3, 6, 0.3), offset = Vector3.new(1.5, 0, 2.4), color = Color3.fromRGB(40, 40, 40), bodyRelative = true },
				{ name = "Crack2", shape = "Block", size = Vector3.new(5, 0.3, 0.3), offset = Vector3.new(0, 2, 2.4), color = Color3.fromRGB(40, 40, 40), bodyRelative = true },
				{ name = "Crack3", shape = "Block", size = Vector3.new(0.3, 5, 0.3), offset = Vector3.new(-2, -1, 2.4), color = Color3.fromRGB(40, 40, 40), bodyRelative = true },
				-- Floating stone pieces orbiting
				{ name = "FloatStone1", shape = "Ball", size = Vector3.new(1.2, 1.2, 1.2), offset = Vector3.new(4, 2, 1), color = Color3.fromRGB(120, 120, 120), bodyRelative = true, material = Enum.Material.Rock, transparency = 0.1 },
				{ name = "FloatStone2", shape = "Ball", size = Vector3.new(1, 1, 1), offset = Vector3.new(-4.5, 1, -1), color = Color3.fromRGB(110, 110, 110), bodyRelative = true, material = Enum.Material.Rock, transparency = 0.1 },
				{ name = "FloatStone3", shape = "Ball", size = Vector3.new(0.8, 0.8, 0.8), offset = Vector3.new(2, 4, -2), color = Color3.fromRGB(100, 100, 100), bodyRelative = true, material = Enum.Material.Rock, transparency = 0.1 },
				{ name = "FloatStone4", shape = "Ball", size = Vector3.new(1.1, 1.1, 1.1), offset = Vector3.new(-3, -3, 2), color = Color3.fromRGB(130, 130, 130), bodyRelative = true, material = Enum.Material.Rock, transparency = 0.1 },
				-- Ancient weapon arms
				{ name = "WeaponArmL", shape = "Block", size = Vector3.new(1.8, 1.8, 6), offset = Vector3.new(-4.5, 1, 0), color = Color3.fromRGB(80, 80, 80), bodyRelative = true, material = Enum.Material.Cobblestone },
				{ name = "WeaponArmR", shape = "Block", size = Vector3.new(1.8, 1.8, 6), offset = Vector3.new(4.5, 1, 0), color = Color3.fromRGB(80, 80, 80), bodyRelative = true, material = Enum.Material.Cobblestone },
				{ name = "AncientMaceL", shape = "Ball", size = Vector3.new(2.5, 2.5, 2.5), offset = Vector3.new(-4.5, 1, 4), color = Color3.fromRGB(60, 60, 60), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "AncientMaceR", shape = "Ball", size = Vector3.new(2.5, 2.5, 2.5), offset = Vector3.new(4.5, 1, 4), color = Color3.fromRGB(60, 60, 60), bodyRelative = true, material = Enum.Material.Metal },
				-- Ancient legs
				{ name = "LegL", shape = "Block", size = Vector3.new(2, 6, 2), offset = Vector3.new(-1.5, -7, 0), color = Color3.fromRGB(90, 90, 90), bodyRelative = true, material = Enum.Material.Cobblestone },
				{ name = "LegR", shape = "Block", size = Vector3.new(2, 6, 2), offset = Vector3.new(1.5, -7, 0), color = Color3.fromRGB(90, 90, 90), bodyRelative = true, material = Enum.Material.Cobblestone },
				-- Runes on body
				{ name = "BodyRune1", shape = "Block", size = Vector3.new(1, 1, 0.2), offset = Vector3.new(0, 1, 2.4), color = Color3.fromRGB(0, 255, 0), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.3 },
				{ name = "BodyRune2", shape = "Block", size = Vector3.new(0.8, 0.8, 0.2), offset = Vector3.new(-1.5, -1, 2.4), color = Color3.fromRGB(0, 200, 0), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
				{ name = "BodyRune3", shape = "Ball", size = Vector3.new(1.2, 1.2, 0.2), offset = Vector3.new(1.8, 0, 2.4), color = Color3.fromRGB(50, 255, 50), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.2 },
			},
		},
	},

	["Frost Wyrm"] = {
		name        = "Frost Wyrm",
		hp          = 1200,
		damage      = 42,
		level       = 60,
		xp          = 600,
		respawnTime = 80,
		zone        = "Safe",
		passive     = false,
		boss        = true,
		drops = {
			{ item = "Wyrm Scale", chance = 0.30, minQty = 1, maxQty = 3 },
			{ item = "Frozen Heart", chance = 0.10, minQty = 1, maxQty = 1 },
			{ name = "Ice Fang", chance = 0.05, minQty = 1, maxQty = 1 },
			{ item = "Frost Armor", chance = 0.08, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(173, 216, 230),
			size = Vector3.new(3, 3, 8), -- long serpentine body
			headSize = 1.8,
			extras = {
				-- Long serpentine body (multiple connected light blue parts)
				{ name = "WyrmSegment1", shape = "Block", size = Vector3.new(2.8, 2.8, 6), offset = Vector3.new(0, 0, -7), color = Color3.fromRGB(150, 200, 255), bodyRelative = true, material = Enum.Material.Ice, transparency = 0.1 },
				{ name = "WyrmSegment2", shape = "Block", size = Vector3.new(2.5, 2.5, 5), offset = Vector3.new(0, 0, -12.5), color = Color3.fromRGB(140, 190, 245), bodyRelative = true, material = Enum.Material.Ice, transparency = 0.1 },
				{ name = "WyrmSegment3", shape = "Block", size = Vector3.new(2.2, 2.2, 4), offset = Vector3.new(0, 0, -17), color = Color3.fromRGB(130, 180, 235), bodyRelative = true, material = Enum.Material.Ice, transparency = 0.1 },
				{ name = "WyrmTail", shape = "Block", size = Vector3.new(1.8, 1.8, 3), offset = Vector3.new(0, 0, -20.5), color = Color3.fromRGB(120, 170, 225), bodyRelative = true, material = Enum.Material.Ice, transparency = 0.1 },
				-- Ice horns
				{ name = "IceHornL", shape = "Block", size = Vector3.new(0.5, 2, 0.5), offset = Vector3.new(-0.7, 1.5, 0.3), color = Color3.fromRGB(200, 230, 255), material = Enum.Material.Ice, transparency = 0.1 },
				{ name = "IceHornR", shape = "Block", size = Vector3.new(0.5, 2, 0.5), offset = Vector3.new(0.7, 1.5, 0.3), color = Color3.fromRGB(200, 230, 255), material = Enum.Material.Ice, transparency = 0.1 },
				-- Frost breath particles
				{ name = "FrostBreath1", shape = "Ball", size = Vector3.new(1.5, 1, 1.5), offset = Vector3.new(-0.3, -0.2, 2.5), color = Color3.fromRGB(220, 240, 255), material = Enum.Material.Neon, transparency = 0.5 },
				{ name = "FrostBreath2", shape = "Ball", size = Vector3.new(1.2, 0.8, 1.2), offset = Vector3.new(0.2, 0.1, 3.2), color = Color3.fromRGB(200, 220, 255), material = Enum.Material.Neon, transparency = 0.6 },
				{ name = "FrostBreath3", shape = "Ball", size = Vector3.new(0.8, 0.6, 0.8), offset = Vector3.new(0, -0.3, 4), color = Color3.fromRGB(180, 200, 255), material = Enum.Material.Neon, transparency = 0.7 },
				-- Crystal scales
				{ name = "CrystalScale1", shape = "Block", size = Vector3.new(0.6, 0.6, 0.3), offset = Vector3.new(1.2, 0.8, 1), color = Color3.fromRGB(180, 220, 255), material = Enum.Material.Ice, transparency = 0.2 },
				{ name = "CrystalScale2", shape = "Block", size = Vector3.new(0.5, 0.5, 0.3), offset = Vector3.new(-1.3, 0.9, -1), color = Color3.fromRGB(170, 210, 245), material = Enum.Material.Ice, transparency = 0.2 },
				{ name = "CrystalScale3", shape = "Block", size = Vector3.new(0.7, 0.7, 0.3), offset = Vector3.new(0, 1.2, -3), color = Color3.fromRGB(190, 230, 255), material = Enum.Material.Ice, transparency = 0.2 },
				-- Ice tail spike
				{ name = "TailSpike", shape = "Block", size = Vector3.new(1, 1, 2.5), offset = Vector3.new(0, 0, -22.7), color = Color3.fromRGB(150, 190, 230), bodyRelative = true, material = Enum.Material.Ice, transparency = 0.1 },
				-- Glowing eyes
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(-0.5, 0.3, 1.0), color = Color3.fromRGB(100, 200, 255), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.4, 0.4, 0.4), offset = Vector3.new(0.5, 0.3, 1.0), color = Color3.fromRGB(100, 200, 255), material = Enum.Material.Neon },
			},
		},
	},
	["Lich King Malachar"] = {
		name        = "Lich King Malachar",
		hp          = 4000,
		damage      = 75,
		level       = 90,
		xp          = 1350,
		respawnTime = 600,
		zone        = "Wilderness",
		passive     = false,
		boss        = true,
		drops = {
			{ item = "Lich Crown",     chance = 0.03, minQty = 1, maxQty = 1 },
			{ item = "Soul Staff",     chance = 0.02, minQty = 1, maxQty = 1 },
			{ item = "Dark Essence",   chance = 0.15, minQty = 1, maxQty = 1 },
			{ item = "Necrotic Robe",  chance = 0.05, minQty = 1, maxQty = 1 },
			{ item = "Bone Dust",      chance = 0.40, minQty = 5, maxQty = 5 },
			{ item = "Shadow Gem",     chance = 0.10, minQty = 1, maxQty = 1 },
		},
		model = {
			bodyColor = Color3.fromRGB(20, 20, 30),
			size = Vector3.new(3, 6, 2),
			headSize = 1.5,
			extras = {
				-- SKELETAL BODY: Gaunt undead form visible through robes
				{ name = "Ribcage", shape = "Block", size = Vector3.new(2.5, 3, 1.5), offset = Vector3.new(0, 1, 0), color = Color3.fromRGB(200, 195, 180), bodyRelative = true },
				{ name = "Rib1", shape = "Block", size = Vector3.new(2.8, 0.12, 0.8), offset = Vector3.new(0, 2.0, 0), color = Color3.fromRGB(210, 205, 190), bodyRelative = true },
				{ name = "Rib2", shape = "Block", size = Vector3.new(2.8, 0.12, 0.8), offset = Vector3.new(0, 1.5, 0), color = Color3.fromRGB(210, 205, 190), bodyRelative = true },
				{ name = "Rib3", shape = "Block", size = Vector3.new(2.8, 0.12, 0.8), offset = Vector3.new(0, 1.0, 0), color = Color3.fromRGB(210, 205, 190), bodyRelative = true },
				{ name = "Spine", shape = "Block", size = Vector3.new(0.4, 5, 0.4), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(200, 195, 180), bodyRelative = true },
				-- DARK ROBES: Flowing tattered robes
				{ name = "RobeUpper", shape = "Block", size = Vector3.new(3.5, 4, 2.5), offset = Vector3.new(0, 0, 0), color = Color3.fromRGB(15, 10, 25), bodyRelative = true, material = Enum.Material.Fabric },
				{ name = "RobeSkirt", shape = "Block", size = Vector3.new(4, 3, 3), offset = Vector3.new(0, -3.5, 0), color = Color3.fromRGB(12, 8, 20), bodyRelative = true, material = Enum.Material.Fabric },
				{ name = "RobeHem", shape = "Block", size = Vector3.new(4.5, 0.3, 3.5), offset = Vector3.new(0, -5, 0), color = Color3.fromRGB(8, 5, 15), bodyRelative = true, material = Enum.Material.Fabric },
				{ name = "RobeTrim", shape = "Block", size = Vector3.new(0.15, 5, 0.1), offset = Vector3.new(0, -2, 1.3), color = Color3.fromRGB(60, 0, 80), bodyRelative = true },
				-- HOOD: Oversized dark hood
				{ name = "Hood", shape = "Block", size = Vector3.new(2.0, 1.2, 1.8), offset = Vector3.new(0, 0.8, -0.2), color = Color3.fromRGB(12, 8, 22) },
				{ name = "HoodPeak", shape = "Block", size = Vector3.new(1.2, 0.8, 1.0), offset = Vector3.new(0, 1.5, -0.3), color = Color3.fromRGB(8, 5, 18) },
				-- SKULL FACE: Skeletal head with glowing green eyes
				{ name = "SkullFace", shape = "Block", size = Vector3.new(1.0, 1.0, 0.6), offset = Vector3.new(0, 0, 0.5), color = Color3.fromRGB(220, 215, 200) },
				{ name = "EyeL", shape = "Ball", size = Vector3.new(0.35, 0.35, 0.35), offset = Vector3.new(-0.3, 0.2, 0.8), color = Color3.fromRGB(0, 255, 80), material = Enum.Material.Neon },
				{ name = "EyeR", shape = "Ball", size = Vector3.new(0.35, 0.35, 0.35), offset = Vector3.new(0.3, 0.2, 0.8), color = Color3.fromRGB(0, 255, 80), material = Enum.Material.Neon },
				{ name = "JawBone", shape = "Block", size = Vector3.new(0.8, 0.25, 0.5), offset = Vector3.new(0, -0.4, 0.5), color = Color3.fromRGB(210, 205, 190) },
				-- CROWN OF BONES: Jagged bone crown
				{ name = "CrownBase", shape = "Block", size = Vector3.new(1.6, 0.2, 1.6), offset = Vector3.new(0, 0.6, 0), color = Color3.fromRGB(200, 195, 175) },
				{ name = "CrownSpike1", shape = "Block", size = Vector3.new(0.12, 0.8, 0.12), offset = Vector3.new(0, 1.1, 0.6), color = Color3.fromRGB(200, 195, 175) },
				{ name = "CrownSpike2", shape = "Block", size = Vector3.new(0.12, 1.0, 0.12), offset = Vector3.new(0.5, 1.2, 0.3), color = Color3.fromRGB(200, 195, 175) },
				{ name = "CrownSpike3", shape = "Block", size = Vector3.new(0.12, 0.9, 0.12), offset = Vector3.new(-0.5, 1.15, 0.3), color = Color3.fromRGB(200, 195, 175) },
				{ name = "CrownSpike4", shape = "Block", size = Vector3.new(0.12, 0.7, 0.12), offset = Vector3.new(0.5, 1.0, -0.3), color = Color3.fromRGB(200, 195, 175) },
				{ name = "CrownSpike5", shape = "Block", size = Vector3.new(0.12, 0.85, 0.12), offset = Vector3.new(-0.5, 1.1, -0.3), color = Color3.fromRGB(200, 195, 175) },
				{ name = "CrownGem", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(0, 1.15, 0.65), color = Color3.fromRGB(0, 255, 80), material = Enum.Material.Neon },
				-- STAFF WITH SKULL: Held in right hand
				{ name = "Staff", shape = "Block", size = Vector3.new(0.3, 7, 0.3), offset = Vector3.new(2.0, 0.5, 0), color = Color3.fromRGB(40, 20, 15), bodyRelative = true, material = Enum.Material.Wood },
				{ name = "StaffSkull", shape = "Ball", size = Vector3.new(0.8, 0.8, 0.8), offset = Vector3.new(2.0, 4.3, 0), color = Color3.fromRGB(220, 215, 200), bodyRelative = true },
				{ name = "StaffSkullGlow", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.3), offset = Vector3.new(2.0, 4.3, 0.4), color = Color3.fromRGB(0, 255, 80), bodyRelative = true, material = Enum.Material.Neon },
				{ name = "StaffRing1", shape = "Block", size = Vector3.new(0.5, 0.1, 0.5), offset = Vector3.new(2.0, 3.5, 0), color = Color3.fromRGB(80, 60, 30), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "StaffRing2", shape = "Block", size = Vector3.new(0.5, 0.1, 0.5), offset = Vector3.new(2.0, 2.5, 0), color = Color3.fromRGB(80, 60, 30), bodyRelative = true, material = Enum.Material.Metal },
				-- FLOATING SPELL BOOK: In left hand, open and glowing
				{ name = "SpellBookL", shape = "Block", size = Vector3.new(0.08, 1.0, 0.8), offset = Vector3.new(-2.0, 0.5, 0.5), color = Color3.fromRGB(40, 15, 15), bodyRelative = true },
				{ name = "SpellBookR", shape = "Block", size = Vector3.new(0.08, 1.0, 0.8), offset = Vector3.new(-1.85, 0.5, 0.5), color = Color3.fromRGB(40, 15, 15), bodyRelative = true },
				{ name = "SpellBookPages", shape = "Block", size = Vector3.new(0.03, 0.9, 0.75), offset = Vector3.new(-1.93, 0.5, 0.5), color = Color3.fromRGB(0, 200, 60), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.3 },
				-- SOUL ORBS: 3 orbiting spectral green orbs
				{ name = "SoulOrb1", shape = "Ball", size = Vector3.new(0.7, 0.7, 0.7), offset = Vector3.new(2.5, 3, 1.5), color = Color3.fromRGB(0, 255, 80), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.3 },
				{ name = "SoulOrb2", shape = "Ball", size = Vector3.new(0.6, 0.6, 0.6), offset = Vector3.new(-2.8, 2, -1), color = Color3.fromRGB(0, 220, 60), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.35 },
				{ name = "SoulOrb3", shape = "Ball", size = Vector3.new(0.5, 0.5, 0.5), offset = Vector3.new(0.5, 4, -0.5), color = Color3.fromRGB(0, 200, 50), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
				{ name = "SoulTrail1", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.8), offset = Vector3.new(2.0, 2.8, 1.0), color = Color3.fromRGB(0, 180, 50), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.6 },
				{ name = "SoulTrail2", shape = "Ball", size = Vector3.new(0.3, 0.3, 0.6), offset = Vector3.new(-2.3, 1.8, -0.5), color = Color3.fromRGB(0, 180, 50), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.65 },
				-- SKELETAL ARMS: Bony arms reaching from robes
				{ name = "ArmL", shape = "Block", size = Vector3.new(0.3, 3.5, 0.3), offset = Vector3.new(-1.8, -0.5, 0), color = Color3.fromRGB(200, 195, 180), bodyRelative = true },
				{ name = "ArmR", shape = "Block", size = Vector3.new(0.3, 3.5, 0.3), offset = Vector3.new(1.8, -0.5, 0), color = Color3.fromRGB(200, 195, 180), bodyRelative = true },
				{ name = "HandL", shape = "Block", size = Vector3.new(0.4, 0.3, 0.4), offset = Vector3.new(-1.8, -2.5, 0.3), color = Color3.fromRGB(200, 195, 180), bodyRelative = true },
				{ name = "HandR", shape = "Block", size = Vector3.new(0.4, 0.3, 0.4), offset = Vector3.new(1.8, -2.5, 0.3), color = Color3.fromRGB(200, 195, 180), bodyRelative = true },
				-- NECROTIC ENERGY: Green magic circle at feet
				{ name = "MagicCircle", shape = "Block", size = Vector3.new(6, 0.05, 6), offset = Vector3.new(0, -5.2, 0), color = Color3.fromRGB(0, 180, 50), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.4 },
				{ name = "MagicInner", shape = "Ball", size = Vector3.new(4, 0.08, 4), offset = Vector3.new(0, -5.18, 0), color = Color3.fromRGB(0, 150, 40), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.5 },
				-- DEATH MIST: Swirling dark green fog
				{ name = "DeathMist1", shape = "Ball", size = Vector3.new(3, 1.5, 3), offset = Vector3.new(1, -4, 1), color = Color3.fromRGB(0, 80, 30), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.7 },
				{ name = "DeathMist2", shape = "Ball", size = Vector3.new(2.5, 1, 2.5), offset = Vector3.new(-1.5, -4.5, -1), color = Color3.fromRGB(0, 60, 20), bodyRelative = true, material = Enum.Material.Neon, transparency = 0.75 },
				-- SHOULDER PAULDRONS: Dark armor on shoulders
				{ name = "PauldronL", shape = "Block", size = Vector3.new(1.2, 0.6, 1.2), offset = Vector3.new(-2.2, 2.5, 0), color = Color3.fromRGB(30, 20, 40), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "PauldronR", shape = "Block", size = Vector3.new(1.2, 0.6, 1.2), offset = Vector3.new(2.2, 2.5, 0), color = Color3.fromRGB(30, 20, 40), bodyRelative = true, material = Enum.Material.Metal },
				{ name = "PauldronSpikeL", shape = "Block", size = Vector3.new(0.15, 0.6, 0.15), offset = Vector3.new(-2.2, 3.2, 0), color = Color3.fromRGB(200, 195, 175), bodyRelative = true },
				{ name = "PauldronSpikeR", shape = "Block", size = Vector3.new(0.15, 0.6, 0.15), offset = Vector3.new(2.2, 3.2, 0), color = Color3.fromRGB(200, 195, 175), bodyRelative = true },
			},
		},
	},
}

return MonsterDatabase
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="8">
        <Properties>
          <string name="Name">QuestDatabase</string>
          <string name="Source"><![CDATA[local QuestDatabase = {}

QuestDatabase.Quests = {
	{
		id = "quest_01",
		name = "A New Arrival",
		giver = "Aldric",
		level = 1,
		description = "Prove your worth by gathering basic supplies for the village of Thornhold.",
		objectives = {
			{ type = "gather", item = "Copper Ore", amount = 5, label = "Mine 5 Copper Ore" },
			{ type = "gather", item = "Oak Log", amount = 5, label = "Chop 5 Oak Logs" },
			{ type = "gather", item = "Raw Shrimp", amount = 5, label = "Catch 5 Shrimp" },
		},
		rewards = {
			xp = {
				Mining = 600,
				Woodcutting = 600,
				Fishing = 600,
			},
			gold = 500,
			items = { "Copper Sword", "Bronze Helmet" },
		},
		nextQuest = "quest_02",
		choices = nil,
		dialog = {
			start = "Welcome to Thornhold, stranger. We could use an extra pair of hands. Bring me some copper ore, oak logs, and shrimp ‚Äî prove you can pull your weight around here.",
			progress = "Still working on those supplies? We need all five of each before I can trust you with anything bigger.",
			complete = "Well done! You've got grit. Take this sword and helmet ‚Äî you've earned them. Speak with Brother Elden at the chapel when you're ready for more.",
		},
	},

	{
		id = "quest_02",
		name = "The Restless Dead",
		giver = "Brother Elden",
		level = 5,
		description = "Skeletons have risen in the old cemetery. Put them to rest and consult the hermit Morath.",
		objectives = {
			{ type = "kill", target = "Skeleton", amount = 10, label = "Destroy 10 Skeletons" },
			{ type = "talk", target = "Morath", label = "Speak with Morath the Hermit" },
		},
		rewards = {
			xp = {
				Strength = 1500,
				Defense = 600,
			},
			gold = 1000,
			items = {},
		},
		nextQuest = "quest_03",
		choices = nil,
		dialog = {
			start = "The dead do not sleep, friend. Skeletons claw their way from the cemetery each night. Destroy ten of them, then seek out Morath in his cave ‚Äî he may know the source of this darkness.",
			progress = "The bones still rattle in the night. Finish the job and find Morath.",
			complete = "Morath spoke of a dark energy seeping from the wilderness. Thank the Light you're here. Take this gold and steel yourself for what lies ahead.",
		},
	},

	{
		id = "quest_03",
		name = "Into the Wilderness",
		giver = "Scout Wren",
		level = 10,
		description = "Scout the dangerous wilderness beyond Thornhold and deal with the goblin menace.",
		objectives = {
			{ type = "visit", location = "Darkwood Clearing", label = "Visit Darkwood Clearing" },
			{ type = "visit", location = "Broken Bridge", label = "Visit the Broken Bridge" },
			{ type = "visit", location = "Goblin Camp", label = "Visit the Goblin Camp" },
			{ type = "kill", target = "Goblin", amount = 5, label = "Kill 5 Goblins" },
		},
		rewards = {
			xp = {
				Strength = 1200,
				Defense = 900,
			},
			gold = 1500,
			items = { "Wooden Shield" },
		},
		nextQuest = "quest_04",
		choices = nil,
		dialog = {
			start = "The wilderness is crawling with goblins and worse. I need you to scout three key locations and thin out their numbers. Take this shield when you're done ‚Äî you'll need it.",
			progress = "You haven't finished scouting yet. Check all three locations and clear those goblins.",
			complete = "Excellent report. The goblins are more organized than I feared. Take this shield ‚Äî a witch in the swamp may know more about what's stirring them up.",
		},
	},

	{
		id = "quest_04",
		name = "The Witch's Bargain",
		giver = "Witch Thessaly",
		level = 15,
		description = "The swamp witch Thessaly demands rare ingredients in exchange for crucial information.",
		objectives = {
			{ type = "gather", item = "Moonpetal", amount = 3, label = "Gather 3 Moonpetals" },
			{ type = "gather", item = "Swamp Fungus", amount = 5, label = "Gather 5 Swamp Fungus" },
			{ type = "gather", item = "Serpent Scale", amount = 2, label = "Collect 2 Serpent Scales" },
		},
		rewards = {
			xp = {
				Cooking = 1500,
				Fletching = 900,
			},
			gold = 2000,
			items = {},
		},
		nextQuest = "quest_05",
		choices = nil,
		dialog = {
			start = "Oh, a visitor! How delightful. You want answers? Nothing is free, dearie. Bring me moonpetals, swamp fungus, and serpent scales. Then we'll talk.",
			progress = "Incomplete ingredients make for incomplete potions. And incomplete answers. Hurry along now.",
			complete = "Mmm, perfect. Now listen closely ‚Äî bandits on the north road are working for something far darker than greed. Speak with Captain Aldric. And take this gold... you'll need supplies.",
		},
	},

	{
		id = "quest_05",
		name = "The Bandit Problem",
		giver = "Captain Aldric",
		level = 20,
		description = "Bandits block the northern trade route. Choose how to resolve the crisis.",
		objectives = {
			{ type = "travel", location = "Bandit Fortress", label = "Reach the Bandit Fortress" },
			{ type = "choice", label = "Decide: Fight or Negotiate" },
		},
		rewards = {
			gold = 3000,
			items = {},
		},
		nextQuest = "quest_06",
		choices = {
			{
				id = "fight",
				label = "Storm the Fortress",
				description = "Lead an assault on the bandit fortress. A direct approach for the strong.",
				objectives = {
					{ type = "kill", target = "Bandit", amount = 15, label = "Defeat 15 Bandits" },
					{ type = "kill", target = "Bandit Chief", amount = 1, label = "Defeat the Bandit Chief" },
				},
				rewards = {
					xp = {
						Strength = 3000,
					},
				},
			},
			{
				id = "negotiate",
				label = "Negotiate a Truce",
				description = "Use cunning and diplomacy to turn the bandits into allies.",
				objectives = {
					{ type = "gather", item = "Trade Goods", amount = 10, label = "Acquire 10 Trade Goods" },
					{ type = "talk", target = "Bandit Chief", label = "Negotiate with the Bandit Chief" },
				},
				rewards = {
					xp = {
						Defense = 2400,
						Ranged = 1200,
					},
				},
			},
		},
		dialog = {
			start = "The bandits have fortified the northern pass. We can storm the fortress or try to negotiate. Your call, adventurer ‚Äî but either way, that road must open.",
			progress = "The north road remains blocked. Finish what you started.",
			complete = "The road is open again. You've done Thornhold a great service. Now, there's a ghost haunting the old ruins south of here...",
		},
	},

	{
		id = "quest_06",
		name = "Echoes of Sir Aldren",
		giver = "Ghost of Sir Aldren",
		level = 25,
		description = "The restless spirit of a fallen knight begs for release ‚Äî or offers forbidden power.",
		objectives = {
			{ type = "travel", location = "Aldren's Tomb", label = "Enter Aldren's Tomb" },
			{ type = "gather", item = "Soul Fragment", amount = 3, label = "Collect 3 Soul Fragments" },
			{ type = "choice", label = "Decide the knight's fate" },
		},
		rewards = {
			gold = 2000,
			items = {},
		},
		nextQuest = "quest_07",
		choices = {
			{
				id = "free",
				label = "Free the Spirit",
				description = "Reunite the soul fragments and release Sir Aldren to the afterlife.",
				objectives = {
					{ type = "interact", target = "Altar of Light", label = "Use the Altar of Light" },
				},
				rewards = {
					xp = {
						Defense = 2400,
						Smithing = 1500,
					},
				},
			},
			{
				id = "bind",
				label = "Bind His Power",
				description = "Absorb the knight's essence and claim his dark strength.",
				objectives = {
					{ type = "interact", target = "Shadow Obelisk", label = "Use the Shadow Obelisk" },
				},
				rewards = {
					xp = {
						Ranged = 2400,
						Strength = 1500,
					},
				},
			},
		},
		dialog = {
			start = "Please... I have been trapped here for centuries. My soul is shattered across this tomb. Gather the fragments and choose ‚Äî set me free, or take my power for yourself.",
			progress = "The fragments... find them all. Then decide my fate.",
			complete = "It is done. Whatever you chose, the echoes have faded. Seek the Oracle in the eastern mountains ‚Äî she foresaw your coming.",
		},
	},

	{
		id = "quest_07",
		name = "The Oracle's Vision",
		giver = "The Oracle",
		level = 30,
		description = "The Oracle has foreseen a great darkness. Retrieve a vision crystal and prove your strength against shadow wraiths.",
		objectives = {
			{ type = "gather", item = "Vision Crystal", amount = 1, label = "Retrieve the Vision Crystal" },
			{ type = "kill", target = "Shadow Wraith", amount = 8, label = "Destroy 8 Shadow Wraiths" },
			{ type = "talk", target = "The Oracle", label = "Return to the Oracle" },
		},
		rewards = {
			xp = {
				Ranged = 1800,
				Defense = 1200,
				Strength = 1500,
			},
			gold = 3000,
			items = {},
		},
		nextQuest = "quest_08",
		choices = nil,
		dialog = {
			start = "I have seen you in my visions, child. A dragon stirs beneath the mountain. Bring me a vision crystal from the Whispering Caves and cleanse the wraiths that guard it.",
			progress = "The shadows grow restless. You must hurry.",
			complete = "The crystal confirms my fears. A dragon wakes, and a necromancer feeds it souls. You must cross the Dark Waters to reach the Dragon's Spine. Seek the ferryman Charon.",
		},
	},

	{
		id = "quest_08",
		name = "Crossing the Dark Waters",
		giver = "Charon",
		level = 35,
		description = "Pay the ferryman and survive the crossing of the cursed sea.",
		objectives = {
			{ type = "pay", amount = 5000, label = "Pay Charon 5,000 Gold" },
			{ type = "kill", target = "Sea Serpent", amount = 1, label = "Slay the Sea Serpent" },
		},
		rewards = {
			xp = {
				Strength = 2400,
				Fishing = 1200,
			},
			gold = 4000,
			items = {},
		},
		nextQuest = "quest_09",
		choices = nil,
		dialog = {
			start = "You wish to cross? The waters are cursed, and a serpent guards the passage. Pay my fee of five thousand gold, and I will ferry you ‚Äî but you must deal with the beast yourself.",
			progress = "The serpent still lives. I won't move this boat until the waters are safe.",
			complete = "Impressive. The serpent is slain and the crossing is clear. The Dragon's Spine awaits you on the far shore. Seek the ranger Lyra ‚Äî she knows the mountain paths.",
		},
	},

	{
		id = "quest_09",
		name = "The Dragon's Spine",
		giver = "Lyra",
		level = 40,
		description = "Climb the treacherous Dragon's Spine mountain and defeat the necromancer who feeds the dragon.",
		objectives = {
			{ type = "visit", location = "Lower Ridge", label = "Reach the Lower Ridge" },
			{ type = "visit", location = "Frozen Pass", label = "Cross the Frozen Pass" },
			{ type = "visit", location = "Summit Plateau", label = "Reach the Summit" },
			{ type = "kill", target = "Necromancer Valkor", amount = 1, label = "Defeat Necromancer Valkor" },
		},
		rewards = {
			xp = {
				Strength = 4500,
				Smithing = 1500,
				Ranged = 1500,
			},
			gold = 8000,
			items = {},
		},
		nextQuest = "quest_10",
		choices = nil,
		dialog = {
			start = "The necromancer Valkor sits atop the Dragon's Spine, channeling souls into the sleeping dragon. We must climb the mountain and stop him before the ritual completes.",
			progress = "Keep climbing. Valkor must be stopped before the dragon fully wakes.",
			complete = "Valkor is dead, but we're too late ‚Äî the dragon stirs. This is it, adventurer. The final battle. Are you ready?",
		},
	},

	{
		id = "quest_10",
		name = "The Dragon Awakens",
		giver = "Lyra",
		level = 45,
		description = "The ancient dragon has awakened. Face it and decide the fate of the realm.",
		objectives = {
			{ type = "travel", location = "Dragon's Lair", label = "Enter the Dragon's Lair" },
			{ type = "choice", label = "Choose your destiny" },
		},
		rewards = {
			gold = 25000,
			items = {},
		},
		nextQuest = nil,
		choices = {
			{
				id = "slay",
				label = "Slay the Dragon",
				description = "End the dragon's threat forever with blade and fury.",
				objectives = {
					{ type = "kill", target = "Ancient Dragon", amount = 1, label = "Slay the Ancient Dragon" },
				},
				rewards = {
					xp = {
						Strength = 15000,
					},
				},
			},
			{
				id = "bond",
				label = "Bond with the Dragon",
				description = "Forge a soul-bond with the dragon, turning ancient fury into an eternal alliance.",
				objectives = {
					{ type = "interact", target = "Dragon Soul Altar", label = "Perform the Bonding Ritual" },
					{ type = "kill", target = "Shadow Echo", amount = 5, label = "Defeat 5 Shadow Echoes" },
				},
				rewards = {
					xp = {
						Ranged = 9000,
						Defense = 6000,
					},
				},
			},
		},
		dialog = {
			start = "This is it. The dragon is awake, and only you can face it. You can try to slay the beast... or there is an ancient ritual that could bond your soul to it. Either path will decide the fate of the realm.",
			progress = "The dragon waits. There is no turning back now.",
			complete = "It's over. Whatever you chose, the realm will never forget what you've done. You are a legend now, adventurer. Welcome to the end of your story ‚Äî and the beginning of your legacy.",
		},
	},
}

-- Build lookup by quest id
QuestDatabase.ById = {}
for _, quest in QuestDatabase.Quests do
	QuestDatabase.ById[quest.id] = quest
end

return QuestDatabase
]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="9">
      <Properties>
        <string name="Name">Remotes</string>
      </Properties>
      <Item class="RemoteEvent" referent="10">
        <Properties>
          <string name="Name">Attack</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="11">
        <Properties>
          <string name="Name">AttackVisual</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="12">
        <Properties>
          <string name="Name">BuryBones</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="13">
        <Properties>
          <string name="Name">BuyItem</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="14">
        <Properties>
          <string name="Name">DamageDealt</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="15">
        <Properties>
          <string name="Name">DropItem</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="16">
        <Properties>
          <string name="Name">EatFood</string>
        </Properties>
      </Item>
      <Item class="RemoteFunction" referent="17">
        <Properties>
          <string name="Name">GetPrayerData</string>
        </Properties>
      </Item>
      <Item class="RemoteFunction" referent="18">
        <Properties>
          <string name="Name">GetSkillData</string>
        </Properties>
      </Item>
      <Item class="RemoteFunction" referent="19">
        <Properties>
          <string name="Name">GetStatsPanel</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="20">
        <Properties>
          <string name="Name">HitEffect</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="21">
        <Properties>
          <string name="Name">InventoryUpdate</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="22">
        <Properties>
          <string name="Name">LevelUp</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="23">
        <Properties>
          <string name="Name">MonsterAttackVisual</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="24">
        <Properties>
          <string name="Name">NPCInteract</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="25">
        <Properties>
          <string name="Name">PrayerUpdate</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="26">
        <Properties>
          <string name="Name">SellItem</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="27">
        <Properties>
          <string name="Name">TogglePrayer</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="28">
        <Properties>
          <string name="Name">UseItem</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="29">
        <Properties>
          <string name="Name">XPUpdate</string>
        </Properties>
      </Item>
      <Item class="RemoteEvent" referent="30">
        <Properties>
          <string name="Name">ZoneChanged</string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="31">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Script" referent="32">
      <Properties>
        <string name="Name">AttackVisualHandler</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	AttackVisualHandler.server.lua
	ServerScriptService

	Bridges combat events between server and all clients.
	- Broadcasts player attack visuals to nearby clients
	- Broadcasts monster attack visuals when monsters attack
	- Sends hit effect events for damage numbers, blocks, etc.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--------------------------------------------------------------------------------
-- REMOTE EVENTS (create if missing)
--------------------------------------------------------------------------------
local function getOrCreateRemote(name)
	local existing = ReplicatedStorage:FindFirstChild(name)
	if existing then return existing end
	local re = Instance.new("RemoteEvent")
	re.Name = name
	re.Parent = ReplicatedStorage
	return re
end

local AttackVisualEvent = getOrCreateRemote("AttackVisual")
local HitEffectEvent = getOrCreateRemote("HitEffect")
local MonsterAttackVisualEvent = getOrCreateRemote("MonsterAttackVisual")

-- These already exist from MonsterManager:
local MonsterDamageEvent = getOrCreateRemote("MonsterDamage")
local MonsterDeathEvent = getOrCreateRemote("MonsterDeath")

--------------------------------------------------------------------------------
-- BROADCAST RADIUS
--------------------------------------------------------------------------------
local BROADCAST_RADIUS = 100

local function getNearbyPlayers(position, radius)
	local result = {}
	for _, p in Players:GetPlayers() do
		local char = p.Character
		if char then
			local hrp = char:FindFirstChild("HumanoidRootPart")
			if hrp then
				local dist = (hrp.Position - position).Magnitude
				if dist <= radius then
					table.insert(result, p)
				end
			end
		end
	end
	return result
end

--------------------------------------------------------------------------------
-- PLAYER ATTACK BROADCAST
-- When a player attacks, broadcast the visual to nearby clients
--------------------------------------------------------------------------------
local Remotes = ReplicatedStorage:FindFirstChild("Remotes")
if Remotes then
	local attack = Remotes:FindFirstChild("Attack")
	if attack then
		-- We listen to DamageDealt to broadcast visuals
		-- But attack visuals are better triggered client-side per-attacker
		-- This handler is for OTHER players to see the attack animation
	end
end

-- Expose a function for MonsterManager to call when monsters attack
shared.AttackVisualHandler = {
	-- Call this when a monster attacks a player
	BroadcastMonsterAttack = function(monsterModel, targetPlayer, monsterName)
		if not monsterModel or not monsterModel.PrimaryPart then return end
		local pos = monsterModel.PrimaryPart.Position
		local nearby = getNearbyPlayers(pos, BROADCAST_RADIUS)
		for _, p in nearby do
			MonsterAttackVisualEvent:FireClient(p, monsterModel, targetPlayer, monsterName)
		end
	end,

	-- Call this when a player takes damage (from monster or PvP)
	BroadcastHitEffect = function(position, damage, effectType, isCritical, targetPlayer)
		if targetPlayer then
			HitEffectEvent:FireClient(targetPlayer, position, damage, effectType, isCritical)
		end
	end,

	-- Broadcast a player's attack animation to other nearby players
	BroadcastPlayerAttack = function(attackerPlayer, targetModel, weaponType, isCritical)
		local char = attackerPlayer.Character
		if not char then return end
		local hrp = char:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		local nearby = getNearbyPlayers(hrp.Position, BROADCAST_RADIUS)
		for _, p in nearby do
			if p ~= attackerPlayer then
				AttackVisualEvent:FireClient(p, attackerPlayer, targetModel, weaponType, isCritical)
			end
		end
	end,
}

print("[AttackVisualHandler] Visual handler loaded!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="33">
      <Properties>
        <string name="Name">BankManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- BankManager.server.lua
-- Bank NPC + deposit/withdraw system

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local DataManager = require(ReplicatedStorage.Modules.DataManager)
local Config = require(ReplicatedStorage.Modules.Config)

local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)

-- Create bank remotes
local bankOpenRemote = Instance.new("RemoteEvent")
bankOpenRemote.Name = "BankOpen"
bankOpenRemote.Parent = Remotes

local bankActionRemote = Instance.new("RemoteEvent")
bankActionRemote.Name = "BankAction"
bankActionRemote.Parent = Remotes

local bankUpdateRemote = Instance.new("RemoteEvent")
bankUpdateRemote.Name = "BankUpdate"
bankUpdateRemote.Parent = Remotes

-- === CREATE BANK NPC ===
task.wait(3) -- wait for MapSetup

local function createBankNPC()
	local safeZone = Workspace:FindFirstChild("SafeZone")
	if not safeZone then
		safeZone = Instance.new("Folder")
		safeZone.Name = "SafeZone"
		safeZone.Parent = Workspace
	end

	-- NPC body (positioned inside bank building at x=20, z=20)
	local npcModel = Instance.new("Model")
	npcModel.Name = "BankNPC"
	npcModel.Parent = safeZone

	-- Torso (main body)
	local torso = Instance.new("Part")
	torso.Name = "HumanoidRootPart"
	torso.Size = Vector3.new(2, 2, 1)
	torso.Position = Vector3.new(35, 1.5, 50)
	torso.Anchored = true
	torso.CanCollide = true
	torso.BrickColor = BrickColor.new("Bright blue")
	torso.Material = Enum.Material.SmoothPlastic
	torso.Parent = npcModel

	-- Head
	local head = Instance.new("Part")
	head.Name = "Head"
	head.Shape = Enum.PartType.Ball
	head.Size = Vector3.new(1.5, 1.5, 1.5)
	head.Position = Vector3.new(35, 3, 50)
	head.Anchored = true
	head.CanCollide = false
	head.BrickColor = BrickColor.new("Light orange")
	head.Material = Enum.Material.SmoothPlastic
	head.Parent = npcModel

	-- Hat (banker hat)
	local hat = Instance.new("Part")
	hat.Name = "Hat"
	hat.Size = Vector3.new(2, 0.5, 2)
	hat.Position = Vector3.new(35, 3.8, 50)
	hat.Anchored = true
	hat.CanCollide = false
	hat.BrickColor = BrickColor.new("Dark stone grey")
	hat.Material = Enum.Material.SmoothPlastic
	hat.Parent = npcModel

	-- Legs
	local leftLeg = Instance.new("Part")
	leftLeg.Name = "LeftLeg"
	leftLeg.Size = Vector3.new(0.8, 1, 0.8)
	leftLeg.Position = Vector3.new(19.5, 0.25, 20)
	leftLeg.Anchored = true
	leftLeg.CanCollide = false
	leftLeg.BrickColor = BrickColor.new("Dark stone grey")
	leftLeg.Material = Enum.Material.SmoothPlastic
	leftLeg.Parent = npcModel

	local rightLeg = Instance.new("Part")
	rightLeg.Name = "RightLeg"
	rightLeg.Size = Vector3.new(0.8, 1, 0.8)
	rightLeg.Position = Vector3.new(20.5, 0.25, 20)
	rightLeg.Anchored = true
	rightLeg.CanCollide = false
	rightLeg.BrickColor = BrickColor.new("Dark stone grey")
	rightLeg.Material = Enum.Material.SmoothPlastic
	rightLeg.Parent = npcModel

	-- Arms
	local leftArm = Instance.new("Part")
	leftArm.Name = "LeftArm"
	leftArm.Size = Vector3.new(0.6, 1.8, 0.6)
	leftArm.Position = Vector3.new(18.7, 1.5, 20)
	leftArm.Anchored = true
	leftArm.CanCollide = false
	leftArm.BrickColor = BrickColor.new("Bright blue")
	leftArm.Material = Enum.Material.SmoothPlastic
	leftArm.Parent = npcModel

	local rightArm = Instance.new("Part")
	rightArm.Name = "RightArm"
	rightArm.Size = Vector3.new(0.6, 1.8, 0.6)
	rightArm.Position = Vector3.new(21.3, 1.5, 20)
	rightArm.Anchored = true
	rightArm.CanCollide = false
	rightArm.BrickColor = BrickColor.new("Bright blue")
	rightArm.Material = Enum.Material.SmoothPlastic
	rightArm.Parent = npcModel

	-- Bank booth (counter)
	local counter = Instance.new("Part")
	counter.Name = "BankCounter"
	counter.Size = Vector3.new(6, 3, 2)
	counter.Position = Vector3.new(35, 1.5, 48)
	counter.Anchored = true
	counter.CanCollide = true
	counter.BrickColor = BrickColor.new("Reddish brown")
	counter.Material = Enum.Material.Wood
	counter.Parent = safeZone

	-- Counter top
	local counterTop = Instance.new("Part")
	counterTop.Name = "CounterTop"
	counterTop.Size = Vector3.new(6.5, 0.3, 2.5)
	counterTop.Position = Vector3.new(35, 3.15, 48)
	counterTop.Anchored = true
	counterTop.CanCollide = true
	counterTop.BrickColor = BrickColor.new("Dark stone grey")
	counterTop.Material = Enum.Material.Marble
	counterTop.Parent = safeZone

	-- Gold bars on counter (decoration)
	local goldStack = Instance.new("Part")
	goldStack.Name = "GoldBars"
	goldStack.Size = Vector3.new(1, 0.5, 0.5)
	goldStack.Position = Vector3.new(36.5, 3.55, 48)
	goldStack.Anchored = true
	goldStack.CanCollide = false
	goldStack.BrickColor = BrickColor.new("Bright yellow")
	goldStack.Material = Enum.Material.Neon
	goldStack.Transparency = 0.1
	goldStack.Parent = safeZone

	-- NPC Name billboard
	local nameBillboard = Instance.new("BillboardGui")
	nameBillboard.Size = UDim2.new(6, 0, 1.5, 0)
	nameBillboard.StudsOffset = Vector3.new(0, 3, 0)
	nameBillboard.Parent = head

	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
	nameLabel.Position = UDim2.new(0, 0, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = "√∞≈∏¬è¬¶ Banker"
	nameLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
	nameLabel.TextScaled = true
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.TextStrokeTransparency = 0.5
	nameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	nameLabel.Parent = nameBillboard

	local subLabel = Instance.new("TextLabel")
	subLabel.Size = UDim2.new(1, 0, 0.4, 0)
	subLabel.Position = UDim2.new(0, 0, 0.55, 0)
	subLabel.BackgroundTransparency = 1
	subLabel.Text = "Click to open bank"
	subLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	subLabel.TextScaled = true
	subLabel.Font = Enum.Font.Gotham
	subLabel.TextStrokeTransparency = 0.7
	subLabel.Parent = nameBillboard

	-- Click detector on torso
	local clickDetector = Instance.new("ClickDetector")
	clickDetector.MaxActivationDistance = 12
	clickDetector.Parent = torso

	-- Also add click detector to head for easier clicking
	local headClick = Instance.new("ClickDetector")
	headClick.MaxActivationDistance = 12
	headClick.Parent = head

	local function onBankClick(player)
		-- Only allow in safe zone
		local character = player.Character
		if character then
			local root = character:FindFirstChild("HumanoidRootPart")
			if root and root.Position.Z < -100 then
				-- In wilderness, can't use bank
				return
			end
		end

		local data = DataManager.GetData(player)
		if not data then return end

		-- Send bank data to client
		bankOpenRemote:FireClient(player, data.Bank, data.Inventory)
		print("[Bank] " .. player.Name .. " opened the bank")
	end

	clickDetector.MouseClick:Connect(onBankClick)
	headClick.MouseClick:Connect(onBankClick)

	print("[BankManager] Bank NPC created at safe zone")
	return npcModel
end

-- === HANDLE BANK ACTIONS ===
bankActionRemote.OnServerEvent:Connect(function(player, action, itemName, quantity)
	if not player or not action or not itemName then return end
	quantity = tonumber(quantity) or 1
	if quantity < 1 then return end

	local data = DataManager.GetData(player)
	if not data then return end

	local success = false

	if action == "deposit" then
		success = DataManager.DepositToBank(player, itemName, quantity)
		if success then
			print("[Bank] " .. player.Name .. " deposited " .. quantity .. "x " .. itemName)
		end
	elseif action == "withdraw" then
		success = DataManager.WithdrawFromBank(player, itemName, quantity)
		if success then
			print("[Bank] " .. player.Name .. " withdrew " .. quantity .. "x " .. itemName)
		end
	elseif action == "deposit_all" then
		-- Deposit entire inventory
		local deposited = 0
		-- Make a copy of inventory since we're modifying it
		local invCopy = {}
		for _, slot in ipairs(data.Inventory) do
			table.insert(invCopy, { name = slot.name, quantity = slot.quantity })
		end
		for _, slot in ipairs(invCopy) do
			if DataManager.DepositToBank(player, slot.name, slot.quantity) then
				deposited = deposited + slot.quantity
			end
		end
		success = deposited > 0
		if success then
			print("[Bank] " .. player.Name .. " deposited all (" .. deposited .. " items)")
		end
	end

	-- Send updated bank + inventory data back
	local updatedData = DataManager.GetData(player)
	bankUpdateRemote:FireClient(player, updatedData.Bank, updatedData.Inventory, success, action)

	-- Also update inventory UI
	local invRemote = Remotes:FindFirstChild("InventoryUpdate")
	if invRemote then
		invRemote:FireClient(player, updatedData.Inventory)
	end
end)

-- Create the NPC
createBankNPC()

print("[BankManager] Bank system active!")




]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="34">
      <Properties>
        <string name="Name">CombatManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- CombatManager.server.lua
-- Server-authoritative combat system for PvP

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Config = require(ReplicatedStorage.Modules.Config)
local ItemDB = require(ReplicatedStorage.Modules.ItemDatabase)

local DataManager = require(ReplicatedStorage.Modules.DataManager)

-- Track attack cooldowns
local attackCooldowns = {}

-- Wilderness check
local WILDERNESS_Z = -100
local function isInWilderness(position)
	return position.Z < WILDERNESS_Z
end

local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local attackRemote = Remotes:WaitForChild("Attack")
local damageRemote = Remotes:WaitForChild("DamageDealt")

-- Get player's equipped weapon damage
local function getPlayerDamage(player)
	local data = DataManager.GetData(player)
	if not data then return 5 end

	-- Find best weapon in inventory
	local bestDamage = 5 -- fist damage
	for _, slot in ipairs(data.Inventory) do
		local item = ItemDB.GetItem(slot.name)
		if item and item.type == "weapon" then
			local strLevel = DataManager.GetSkillLevel(player, "Strength")
			if strLevel >= (item.combatReq or 1) then
				if item.damage > bestDamage then
					bestDamage = item.damage
				end
			end
		end
	end

	-- Add strength level bonus
	local strLevel = DataManager.GetSkillLevel(player, "Strength")
	bestDamage = bestDamage + math.floor(strLevel * 0.5)

	return bestDamage
end

-- Get player's max health based on defense level
local function getPlayerMaxHealth(player)
	local defLevel = DataManager.GetSkillLevel(player, "Defense")
	return Config.BaseHealth + (defLevel * Config.HealthPerCombatLevel)
end

-- Set up player health on spawn
local function setupPlayerHealth(player, character)
	local humanoid = character:WaitForChild("Humanoid")
	local maxHP = getPlayerMaxHealth(player)
	humanoid.MaxHealth = maxHP
	humanoid.Health = maxHP
end

-- Handle attack request from client
attackRemote.OnServerEvent:Connect(function(attacker, targetPlayer)
	-- Validate target
	if not targetPlayer or not targetPlayer:IsA("Player") then return end
	if targetPlayer == attacker then return end

	-- Cooldown check
	local now = tick()
	if attackCooldowns[attacker.UserId] and (now - attackCooldowns[attacker.UserId]) < Config.AttackCooldown then
		return -- still on cooldown
	end
	attackCooldowns[attacker.UserId] = now

	-- Both players must have characters
	local attackerChar = attacker.Character
	local targetChar = targetPlayer.Character
	if not attackerChar or not targetChar then return end

	local attackerRoot = attackerChar:FindFirstChild("HumanoidRootPart")
	local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
	if not attackerRoot or not targetRoot then return end

	-- Range check (must be within 14 studs)
	local distance = (attackerRoot.Position - targetRoot.Position).Magnitude
	if distance > 14 then return end

	-- PvP zone check ‚Äî both must be in wilderness
	if not isInWilderness(attackerRoot.Position) or not isInWilderness(targetRoot.Position) then
		return -- can't PvP in safe zone
	end

	-- Calculate damage
	local damage = getPlayerDamage(attacker)

	-- Apply some randomness (80%-120%)
	local multiplier = 0.8 + (math.random() * 0.4)
	damage = math.floor(damage * multiplier)

	-- Apply damage
	local targetHumanoid = targetChar:FindFirstChild("Humanoid")
	if not targetHumanoid or targetHumanoid.Health <= 0 then return end

	-- Tag the kill (so WildernessManager knows who killed them)
	local tag = targetHumanoid:FindFirstChild("creator")
	if not tag then
		tag = Instance.new("ObjectValue")
		tag.Name = "creator"
		tag.Parent = targetHumanoid
	end
	tag.Value = attacker

	-- Clear tag after 5 seconds
	task.delay(5, function()
		if tag and tag.Parent then
			tag:Destroy()
		end
	end)

	targetHumanoid:TakeDamage(damage)

	-- Award XP: Strength for attacking, Defense for taking hits
	local xpGain = math.floor(damage * 1.5)
	DataManager.AddSkillXP(attacker, "Strength", xpGain)
	DataManager.AddSkillXP(targetPlayer, "Defense", math.floor(damage * 0.8))

	-- Notify both players
	damageRemote:FireClient(attacker, "dealt", damage, targetPlayer.Name)
	damageRemote:FireClient(targetPlayer, "received", damage, attacker.Name)

	print("[Combat] " .. attacker.Name .. " hit " .. targetPlayer.Name .. " for " .. damage .. " damage")
end)

-- === EAT FOOD (healing) ===
local eatRemote = Remotes:WaitForChild("EatFood")

eatRemote.OnServerEvent:Connect(function(player, itemName)
	local item = ItemDB.GetItem(itemName)
	if not item or item.type ~= "food" then return end

	-- Must have the food
	if not DataManager.HasItem(player, itemName, 1) then return end

	local character = player.Character
	if not character then return end
	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoid or humanoid.Health <= 0 then return end

	-- Already full health?
	if humanoid.Health >= humanoid.MaxHealth then return end

	-- Eat it!
	DataManager.RemoveFromInventory(player, itemName, 1)
	humanoid.Health = math.min(humanoid.Health + item.healAmount, humanoid.MaxHealth)

	-- Update inventory
	local invRemote = ReplicatedStorage.Remotes:FindFirstChild("InventoryUpdate")
	if invRemote then
		local data = DataManager.GetData(player)
		invRemote:FireClient(player, data.Inventory)
	end

	print("[Combat] " .. player.Name .. " ate " .. itemName .. " and healed " .. item.healAmount .. " HP")
end)

-- === PLAYER SETUP ===
Players.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function(character)
		task.wait(0.5) -- wait for DataManager to load
		setupPlayerHealth(player, character)
	end)
end)

Players.PlayerRemoving:Connect(function(player)
	attackCooldowns[player.UserId] = nil
end)

print("[CombatManager] PvP combat system active!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="35">
      <Properties>
        <string name="Name">CookingManager</string>
        <token name="RunContext">0</token>
        <string name="Source">--[[
	CookingManager.server.lua
	Server-side cooking system for the Wilderness MMO.
	Cook raw fish at fires/ranges, chance to burn based on level.
	Gives Cooking XP and skill progression.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local DataManager = require(ReplicatedStorage.Modules.DataManager)
local ItemDatabase = require(ReplicatedStorage.Modules.ItemDatabase)

------------------------------------------------------------
-- Remote Events
------------------------------------------------------------
local function getOrCreateRemote(name: string): RemoteEvent
	local existing = ReplicatedStorage:FindFirstChild(name)
	if existing then return existing end
	local remote = Instance.new("RemoteEvent")
	remote.Name = name
	remote.Parent = ReplicatedStorage
	return remote
end

local StartCookingEvent = getOrCreateRemote("StartCooking")
local CookingProgressEvent = getOrCreateRemote("CookingProgress")
local CookingCompleteEvent = getOrCreateRemote("CookingComplete")

------------------------------------------------------------
-- Cooking Recipes
------------------------------------------------------------
local CookingRecipes = {
	["Raw Shrimp"] = {
		result = "Cooked Shrimp",
		burnResult = "Burnt Shrimp",
		baseTime = 3, -- seconds
		baseXP = 30,
		levelRequired = 1,
		burnChanceAt1 = 0.4, -- 40% burn chance at level 1
		burnChanceAt99 = 0.05, -- 5% burn chance at level 99
	},
	["Raw Sardine"] = {
		result = "Cooked Sardine",
		burnResult = "Burnt Sardine",
		baseTime = 3.5,
		baseXP = 40,
		levelRequired = 5,
		burnChanceAt1 = 0.45,
		burnChanceAt99 = 0.06,
	},
	["Raw Trout"] = {
		result = "Cooked Trout",
		burnResult = "Burnt Trout",
		baseTime = 4,
		baseXP = 70,
		levelRequired = 15,
		burnChanceAt1 = 0.5,
		burnChanceAt99 = 0.08,
	},
	["Raw Salmon"] = {
		result = "Cooked Salmon",
		burnResult = "Burnt Salmon",
		baseTime = 5,
		baseXP = 90,
		levelRequired = 25,
		burnChanceAt1 = 0.55,
		burnChanceAt99 = 0.1,
	},
	["Raw Tuna"] = {
		result = "Cooked Tuna",
		burnResult = "Burnt Tuna",
		baseTime = 6,
		baseXP = 100,
		levelRequired = 30,
		burnChanceAt1 = 0.6,
		burnChanceAt99 = 0.12,
	},
	["Raw Lobster"] = {
		result = "Cooked Lobster",
		burnResult = "Burnt Lobster",
		baseTime = 8,
		baseXP = 120,
		levelRequired = 40,
		burnChanceAt1 = 0.65,
		burnChanceAt99 = 0.15,
	},
	["Raw Swordfish"] = {
		result = "Cooked Swordfish",
		burnResult = "Burnt Swordfish",
		baseTime = 10,
		baseXP = 140,
		levelRequired = 45,
		burnChanceAt1 = 0.7,
		burnChanceAt99 = 0.18,
	},
}

------------------------------------------------------------
-- Active Cooking Sessions
------------------------------------------------------------
local activeCookingSessions = {} -- [player] = { recipe, startTime, cookingSpot, totalTime }

------------------------------------------------------------
-- Helpers
------------------------------------------------------------
local function getSkillLevel(player: Player, skillName: string): number
	local playerData = DataManager:GetPlayerData(player)
	if not playerData or not playerData.Skills or not playerData.Skills[skillName] then
		return 1
	end
	-- Calculate level from XP (same as other skills)
	local xp = playerData.Skills[skillName]
	local level = 1
	local totalXP = 0
	while totalXP &lt; xp and level &lt; 99 do
		level = level + 1
		totalXP = totalXP + math.floor(level * 10.5) -- XP formula
	end
	return level - 1
end

local function addCookingXP(player: Player, xp: number)
	local playerData = DataManager:GetPlayerData(player)
	if not playerData then return end

	playerData.Skills = playerData.Skills or {}
	playerData.Skills.Cooking = (playerData.Skills.Cooking or 0) + xp

	-- Fire XP update event (if exists)
	local xpUpdateEvent = ReplicatedStorage:FindFirstChild("XPUpdate")
	if xpUpdateEvent and xpUpdateEvent:IsA("RemoteEvent") then
		xpUpdateEvent:FireClient(player, "Cooking", xp)
	end

	DataManager:SavePlayerData(player)
end

local function hasItem(player: Player, itemName: string): boolean
	local playerData = DataManager:GetPlayerData(player)
	if not playerData or not playerData.Inventory then return false end

	for _, invItem in ipairs(playerData.Inventory) do
		if invItem.name == itemName and invItem.quantity > 0 then
			return true
		end
	end
	return false
end

local function removeItem(player: Player, itemName: string, quantity: number): boolean
	local playerData = DataManager:GetPlayerData(player)
	if not playerData or not playerData.Inventory then return false end

	local removed = 0
	for i = #playerData.Inventory, 1, -1 do
		local invItem = playerData.Inventory[i]
		if invItem.name == itemName then
			local removeFromThis = math.min(invItem.quantity, quantity - removed)
			invItem.quantity = invItem.quantity - removeFromThis
			removed = removed + removeFromThis

			if invItem.quantity &lt;= 0 then
				table.remove(playerData.Inventory, i)
			end

			if removed >= quantity then
				break
			end
		end
	end

	if removed >= quantity then
		DataManager:SavePlayerData(player)
		return true
	end
	return false
end

local function addItem(player: Player, itemName: string, quantity: number)
	local playerData = DataManager:GetPlayerData(player)
	if not playerData then return end

	playerData.Inventory = playerData.Inventory or {}
	
	-- Check if item is stackable
	local itemData = ItemDatabase.Items[itemName]
	if itemData and itemData.stackable then
		-- Find existing stack
		local found = false
		for _, invItem in ipairs(playerData.Inventory) do
			if invItem.name == itemName then
				invItem.quantity = invItem.quantity + quantity
				found = true
				break
			end
		end
		if not found then
			table.insert(playerData.Inventory, {name = itemName, quantity = quantity})
		end
	else
		-- Add individual items
		for i = 1, quantity do
			table.insert(playerData.Inventory, {name = itemName, quantity = 1})
		end
	end

	DataManager:SavePlayerData(player)
end

local function calculateBurnChance(recipe, cookingLevel: number): number
	local minChance = recipe.burnChanceAt99
	local maxChance = recipe.burnChanceAt1
	local levelFactor = math.max(0, math.min(1, (99 - cookingLevel) / 98))
	return minChance + (maxChance - minChance) * levelFactor
end

local function findNearbyFire(player: Player): Part?
	local character = player.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") then return nil end

	local position = character.HumanoidRootPart.Position
	local fires = workspace:FindFirstChild("CookingFires")
	if not fires then return nil end

	for _, fire in ipairs(fires:GetChildren()) do
		if fire:IsA("Part") and fire.Name:find("Fire") then
			local distance = (fire.Position - position).Magnitude
			if distance &lt;= 5 then -- 5 stud range
				return fire
			end
		end
	end
	return nil
end

------------------------------------------------------------
-- Cooking Logic
------------------------------------------------------------
local function startCooking(player: Player, rawItemName: string)
	-- Check if already cooking
	if activeCookingSessions[player] then
		return -- Already cooking
	end

	-- Get recipe
	local recipe = CookingRecipes[rawItemName]
	if not recipe then
		warn("[CookingManager] No recipe for:", rawItemName)
		return
	end

	-- Check cooking level
	local cookingLevel = getSkillLevel(player, "Cooking")
	if cookingLevel &lt; recipe.levelRequired then
		-- Could send message to player about level requirement
		return
	end

	-- Check player has the item
	if not hasItem(player, rawItemName) then
		return
	end

	-- Find nearby cooking spot
	local cookingSpot = findNearbyFire(player)
	if not cookingSpot then
		-- Could send message about needing to be near a fire
		return
	end

	-- Remove raw item
	if not removeItem(player, rawItemName, 1) then
		return
	end

	-- Start cooking session
	local totalTime = recipe.baseTime
	activeCookingSessions[player] = {
		recipe = recipe,
		startTime = tick(),
		cookingSpot = cookingSpot,
		totalTime = totalTime,
		rawItem = rawItemName
	}

	-- Notify client to show progress bar
	CookingProgressEvent:FireClient(player, {
		action = "start",
		totalTime = totalTime,
		itemName = rawItemName
	})

	print("[CookingManager]", player.Name, "started cooking", rawItemName)
end

local function completeCooking(player: Player, session)
	local recipe = session.recipe
	local cookingLevel = getSkillLevel(player, "Cooking")

	-- Calculate if burnt
	local burnChance = calculateBurnChance(recipe, cookingLevel)
	local isBurnt = math.random() &lt; burnChance

	local resultItem = isBurnt and recipe.burnResult or recipe.result
	local xpGained = isBurnt and 0 or recipe.baseXP

	-- Add result item
	addItem(player, resultItem, 1)

	-- Add XP (only if not burnt)
	if xpGained > 0 then
		addCookingXP(player, xpGained)
	end

	-- Notify client
	CookingCompleteEvent:FireClient(player, {
		result = resultItem,
		xpGained = xpGained,
		burnt = isBurnt
	})

	-- Fire quest event for cooking
	local questCraftEvent = ReplicatedStorage:FindFirstChild("QuestCraftEvent")
	if questCraftEvent and questCraftEvent:IsA("BindableEvent") then
		questCraftEvent:Fire(player, resultItem, 1)
	end

	print("[CookingManager]", player.Name, "finished cooking:", resultItem, "XP:", xpGained)
end

------------------------------------------------------------
-- Update Loop
------------------------------------------------------------
local function updateCookingSessions()
	local currentTime = tick()

	for player, session in pairs(activeCookingSessions) do
		local elapsed = currentTime - session.startTime
		local progress = elapsed / session.totalTime

		-- Check if player is still near the cooking spot
		local character = player.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			local distance = (character.HumanoidRootPart.Position - session.cookingSpot.Position).Magnitude
			if distance > 10 then -- Allow a bit more range than required to start
				-- Player moved too far, cancel cooking
				activeCookingSessions[player] = nil
				CookingProgressEvent:FireClient(player, {action = "cancel"})
				-- Return raw item
				addItem(player, session.rawItem, 1)
				continue
			end
		end

		if progress >= 1 then
			-- Cooking complete
			completeCooking(player, session)
			activeCookingSessions[player] = nil
		else
			-- Send progress update
			CookingProgressEvent:FireClient(player, {
				action = "progress",
				progress = progress
			})
		end
	end
end

-- Run update loop
RunService.Heartbeat:Connect(updateCookingSessions)

------------------------------------------------------------
-- Event Handlers
------------------------------------------------------------
StartCookingEvent.OnServerEvent:Connect(function(player: Player, rawItemName: string)
	startCooking(player, rawItemName)
end)

-- Clean up when player leaves
Players.PlayerRemoving:Connect(function(player: Player)
	activeCookingSessions[player] = nil
end)

print("[CookingManager] Cooking system initialized")</string>
      </Properties>
    </Item>
    <Item class="Script" referent="36">
      <Properties>
        <string name="Name">CraftingManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	CraftingManager.server.lua
	Handles Smithing & Cooking crafting stations for Haven town.
	Validates recipes, consumes ingredients, awards products & XP.
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Modules
local Modules = ReplicatedStorage:WaitForChild("Modules")
local DataManager = require(Modules:WaitForChild("DataManager"))
local ItemDatabase = require(Modules:WaitForChild("ItemDatabase"))

----------------------------------------------------------------------
-- Remote Events
----------------------------------------------------------------------
local function getOrCreateRemote(name: string): RemoteEvent
	local existing = ReplicatedStorage:FindFirstChild(name)
	if existing then return existing end
	local re = Instance.new("RemoteEvent")
	re.Name = name
	re.Parent = ReplicatedStorage
	return re
end

local CraftRequest  = getOrCreateRemote("CraftRequest")   -- client ‚Üí server
local CraftComplete = getOrCreateRemote("CraftComplete")   -- server ‚Üí client
local CraftUpdate   = getOrCreateRemote("CraftUpdate")     -- server ‚Üí client (progress)

----------------------------------------------------------------------
-- Recipe Definitions
----------------------------------------------------------------------
export type Recipe = {
	id: string,
	skill: string,
	level: number,
	xp: number,
	ingredients: { [string]: number },
	product: string,
	productQty: number,
	station: string, -- "Anvil" | "Forge" | "CookingRange"
}

local Recipes: { Recipe } = {
	-- Smithing: smelting (Forge)
	{ id = "smelt_copper",  skill = "Smithing", level = 1,  xp = 25,  ingredients = { ["Copper Ore"] = 1 }, product = "Copper Bar", productQty = 1, station = "Forge" },
	{ id = "smelt_iron",    skill = "Smithing", level = 15, xp = 45,  ingredients = { ["Iron Ore"]   = 1 }, product = "Iron Bar",   productQty = 1, station = "Forge" },
	{ id = "smelt_gold",    skill = "Smithing", level = 40, xp = 75,  ingredients = { ["Gold Ore"]   = 1 }, product = "Gold Bar",   productQty = 1, station = "Forge" },

	-- Smithing: smithing (Anvil)
	{ id = "smith_copper_sword", skill = "Smithing", level = 1,  xp = 50,  ingredients = { ["Copper Bar"] = 2 }, product = "Copper Sword", productQty = 1, station = "Anvil" },
	{ id = "smith_iron_sword",   skill = "Smithing", level = 20, xp = 80,  ingredients = { ["Iron Bar"]   = 2 }, product = "Iron Sword",   productQty = 1, station = "Anvil" },
	{ id = "smith_gold_sword",   skill = "Smithing", level = 45, xp = 120, ingredients = { ["Gold Bar"]   = 3 }, product = "Gold Sword",   productQty = 1, station = "Anvil" },

	-- Cooking (CookingRange)
	{ id = "cook_shrimp",    skill = "Cooking", level = 1,  xp = 20,  ingredients = { ["Shrimp"]    = 1 }, product = "Cooked Shrimp",    productQty = 1, station = "CookingRange" },
	{ id = "cook_trout",     skill = "Cooking", level = 20, xp = 40,  ingredients = { ["Trout"]     = 1 }, product = "Cooked Trout",     productQty = 1, station = "CookingRange" },
	{ id = "cook_lobster",   skill = "Cooking", level = 40, xp = 65,  ingredients = { ["Lobster"]   = 1 }, product = "Cooked Lobster",   productQty = 1, station = "CookingRange" },
	{ id = "cook_dark_crab", skill = "Cooking", level = 70, xp = 140, ingredients = { ["Dark Crab"] = 1 }, product = "Cooked Dark Crab", productQty = 1, station = "CookingRange" },
}

-- Index by id for fast lookup
local RecipeById: { [string]: Recipe } = {}
for _, r in Recipes do
	RecipeById[r.id] = r
end

----------------------------------------------------------------------
-- Helpers
----------------------------------------------------------------------

--- Check if player has enough of each ingredient
local function hasIngredients(player: Player, ingredients: { [string]: number }): boolean
	for itemName, qty in ingredients do
		if DataManager:GetItemCount(player, itemName) < qty then
			return false
		end
	end
	return true
end

--- Get player skill level
local function getSkillLevel(player: Player, skill: string): number
	return DataManager:GetSkillLevel(player, skill) or 1
end

--- How many times can the player craft this recipe?
local function maxCraftCount(player: Player, recipe: Recipe): number
	local count = math.huge
	for itemName, qty in recipe.ingredients do
		local have = DataManager:GetItemCount(player, itemName)
		count = math.min(count, math.floor(have / qty))
	end
	if count == math.huge then count = 0 end
	return count
end

----------------------------------------------------------------------
-- Craft Handler
----------------------------------------------------------------------
local function handleCraftRequest(player: Player, recipeId: string, quantity: number)
	-- Validate recipe exists
	local recipe = RecipeById[recipeId]
	if not recipe then
		warn("[CraftingManager] Unknown recipe:", recipeId)
		CraftComplete:FireClient(player, { success = false, message = "Unknown recipe." })
		return
	end

	-- Clamp quantity
	quantity = math.clamp(math.floor(quantity or 1), 1, 100)

	-- Check skill level
	local level = getSkillLevel(player, recipe.skill)
	if level < recipe.level then
		CraftComplete:FireClient(player, {
			success = false,
			message = string.format("You need %s level %d to craft this.", recipe.skill, recipe.level),
		})
		return
	end

	-- Determine how many we can actually craft
	local canCraft = math.min(quantity, maxCraftCount(player, recipe))
	if canCraft <= 0 then
		CraftComplete:FireClient(player, { success = false, message = "Not enough ingredients." })
		return
	end

	-- Process each craft one at a time (allows progress updates)
	local crafted = 0
	for i = 1, canCraft do
		-- Re-check ingredients each iteration (safety)
		if not hasIngredients(player, recipe.ingredients) then break end

		-- Consume ingredients
		for itemName, qty in recipe.ingredients do
			DataManager:RemoveItem(player, itemName, qty)
		end

		-- Grant product
		DataManager:AddItem(player, recipe.product, recipe.productQty)

		-- Award XP
		DataManager:AddSkillXP(player, recipe.skill, recipe.xp)

		crafted += 1

		-- Send progress update to client
		CraftUpdate:FireClient(player, {
			recipeId = recipeId,
			current = i,
			total = canCraft,
		})

		-- Wait between crafts (server pacing ‚Äî client shows progress bar)
		if i < canCraft then
			task.wait(1.5)
		end
	end

	-- Done
	CraftComplete:FireClient(player, {
		success = true,
		recipeId = recipeId,
		crafted = crafted,
		product = recipe.product,
		message = string.format("Crafted %dx %s!", crafted, recipe.product),
	})
end

CraftRequest.OnServerEvent:Connect(handleCraftRequest)

----------------------------------------------------------------------
-- Station Setup (ClickDetectors)
----------------------------------------------------------------------
local STATION_NAMES = { "Anvil", "Forge", "CookingRange" }

local function setupStations()
	-- Wait for MapSetup to finish placing parts
	task.wait(2)

	for _, stationName in STATION_NAMES do
		local part = workspace:FindFirstChild(stationName, true)
		if not part then
			-- Station not placed on map yet, skip silently
			continue
		end

		-- Add ClickDetector if missing
		local cd = part:FindFirstChildOfClass("ClickDetector")
		if not cd then
			cd = Instance.new("ClickDetector")
			cd.MaxActivationDistance = 10
			cd.Parent = part
		end

		cd.MouseClick:Connect(function(player: Player)
			-- Tell client to open the crafting UI for this station
			CraftUpdate:FireClient(player, {
				action = "open",
				station = stationName,
				recipes = getRecipesForStation(stationName, player),
			})
		end)

		print(string.format("[CraftingManager] ClickDetector ready on %s", stationName))
	end
end

--- Build recipe list payload for a station, annotated with player info
function getRecipesForStation(stationName: string, player: Player): { any }
	local list = {}
	local playerSkills = {} -- cache

	for _, recipe in Recipes do
		if recipe.station ~= stationName then continue end

		-- Cache skill level
		if not playerSkills[recipe.skill] then
			playerSkills[recipe.skill] = getSkillLevel(player, recipe.skill)
		end
		local lvl = playerSkills[recipe.skill]

		-- Build ingredient info
		local ingredientInfo = {}
		for itemName, qty in recipe.ingredients do
			table.insert(ingredientInfo, {
				name = itemName,
				required = qty,
				have = DataManager:GetItemCount(player, itemName),
			})
		end

		table.insert(list, {
			id = recipe.id,
			product = recipe.product,
			productQty = recipe.productQty,
			skill = recipe.skill,
			level = recipe.level,
			xp = recipe.xp,
			ingredients = ingredientInfo,
			canCraft = lvl >= recipe.level,
			maxCraft = maxCraftCount(player, recipe),
		})
	end

	return list
end

----------------------------------------------------------------------
-- Init
----------------------------------------------------------------------
task.spawn(setupStations)
print("[CraftingManager] Crafting system active!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="37">
      <Properties>
        <string name="Name">DeathManager</string>
        <token name="RunContext">0</token>
        <string name="Source">--[[
	DeathManager.server.lua
	Server-side death and respawn system for the Wilderness MMO.
	- Wilderness deaths: drop ALL inventory (full loot PvP), create grave
	- Safe zone deaths: keep items, respawn at Haven
	- Death screen overlay with timer and respawn button
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")

local DataManager = require(ReplicatedStorage.Modules.DataManager)

------------------------------------------------------------
-- Remote Events
------------------------------------------------------------
local function getOrCreateRemote(name: string): RemoteEvent
	local existing = ReplicatedStorage:FindFirstChild(name)
	if existing then return existing end
	local remote = Instance.new("RemoteEvent")
	remote.Name = name
	remote.Parent = ReplicatedStorage
	return remote
end

local PlayerDiedEvent = getOrCreateRemote("PlayerDied")
local RespawnPlayerEvent = getOrCreateRemote("RespawnPlayer")
local ShowDeathScreenEvent = getOrCreateRemote("ShowDeathScreen")
local GraveInteractEvent = getOrCreateRemote("GraveInteract")

------------------------------------------------------------
-- Constants
------------------------------------------------------------
local RESPAWN_POSITIONS = {
	Safe = Vector3.new(50, 15, 50), -- Haven City center
	Wilderness = Vector3.new(50, 15, 50), -- Still respawn at Haven
}

local GRAVE_LIFETIME = 120 -- 2 minutes in seconds
local DEATH_TIMER = 5 -- 5 seconds before can respawn

------------------------------------------------------------
-- Active Graves
------------------------------------------------------------
local activeGraves = {} -- [graveModel] = { owner, items, timestamp, position }

------------------------------------------------------------
-- Zone Detection
------------------------------------------------------------
local function getPlayerZone(player: Player): string
	local character = player.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") then
		return "Safe" -- Default to safe
	end

	local position = character.HumanoidRootPart.Position
	-- Simple zone detection - beyond 200 studs from Haven (50,15,50) is Wilderness
	local havenCenter = Vector3.new(50, 15, 50)
	local distance = (position - havenCenter).Magnitude

	if distance > 200 then
		return "Wilderness"
	else
		return "Safe"
	end
end

------------------------------------------------------------
-- Grave System
------------------------------------------------------------
local function createGrave(player: Player, position: Vector3, droppedItems: table)
	-- Create grave model
	local grave = Instance.new("Model")
	grave.Name = player.Name .. "'s Grave"
	grave.Parent = workspace

	-- Main gravestone
	local stone = Instance.new("Part")
	stone.Name = "Gravestone"
	stone.Size = Vector3.new(2, 3, 0.5)
	stone.Position = position + Vector3.new(0, 1.5, 0)
	stone.BrickColor = BrickColor.new("Dark stone grey")
	stone.Material = Enum.Material.Rock
	stone.Anchored = true
	stone.CanCollide = false
	stone.Parent = grave

	-- Make it slightly rounded
	local cornerRound = Instance.new("UICorner")
	cornerRound.CornerRadius = UDim.new(0, 8)

	-- Cross on top
	local cross = Instance.new("Part")
	cross.Name = "Cross"
	cross.Size = Vector3.new(0.8, 0.2, 0.2)
	cross.Position = stone.Position + Vector3.new(0, 1.7, 0)
	cross.BrickColor = BrickColor.new("Institutional white")
	cross.Material = Enum.Material.Marble
	cross.Anchored = true
	cross.CanCollide = false
	cross.Parent = grave

	local crossV = cross:Clone()
	crossV.Size = Vector3.new(0.2, 0.8, 0.2)
	crossV.Position = cross.Position
	crossV.Parent = grave

	-- Nameplate
	local nameGui = Instance.new("BillboardGui")
	nameGui.Size = UDim2.new(4, 0, 2, 0)
	nameGui.StudsOffset = Vector3.new(0, 1, 0)
	nameGui.Parent = stone

	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(1, 0, 0.6, 0)
	nameLabel.Position = UDim2.new(0, 0, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = "RIP " .. player.Name
	nameLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	nameLabel.TextScaled = true
	nameLabel.Font = Enum.Font.Antique
	nameLabel.Parent = nameGui

	local itemCountLabel = Instance.new("TextLabel")
	itemCountLabel.Size = UDim2.new(1, 0, 0.4, 0)
	itemCountLabel.Position = UDim2.new(0, 0, 0.6, 0)
	itemCountLabel.BackgroundTransparency = 1
	itemCountLabel.Text = #droppedItems .. " items"
	itemCountLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
	itemCountLabel.TextScaled = true
	itemCountLabel.Font = Enum.Font.Gotham
	itemCountLabel.Parent = nameGui

	-- Click detection
	local detector = Instance.new("ClickDetector")
	detector.MaxActivationDistance = 10
	detector.Parent = stone

	-- Store grave info
	activeGraves[grave] = {
		owner = player.UserId,
		ownerName = player.Name,
		items = droppedItems,
		timestamp = tick(),
		position = position
	}

	-- Handle clicks
	detector.MouseClick:Connect(function(clickingPlayer)
		if activeGraves[grave] then
			local items = activeGraves[grave].items
			local owner = activeGraves[grave].owner

			-- Anyone can loot graves in Wilderness (full PvP loot)
			GraveInteractEvent:FireClient(clickingPlayer, {
				graveName = grave.Name,
				items = items,
				isOwner = clickingPlayer.UserId == owner,
				ownerName = activeGraves[grave].ownerName
			})
		end
	end)

	-- Auto-cleanup after lifetime
	Debris:AddItem(grave, GRAVE_LIFETIME)
	task.spawn(function()
		task.wait(GRAVE_LIFETIME)
		activeGraves[grave] = nil
	end)

	print("[DeathManager] Created grave for", player.Name, "with", #droppedItems, "items")
	return grave
end

local function lootGrave(player: Player, graveName: string)
	-- Find the grave
	local grave = workspace:FindFirstChild(graveName)
	if not grave or not activeGraves[grave] then
		return
	end

	local graveData = activeGraves[grave]
	local items = graveData.items

	-- Add items to player inventory
	local playerData = DataManager:GetPlayerData(player)
	if playerData then
		playerData.Inventory = playerData.Inventory or {}
		
		for _, item in ipairs(items) do
			table.insert(playerData.Inventory, item)
		end

		DataManager:SavePlayerData(player)
		print("[DeathManager]", player.Name, "looted grave with", #items, "items")
		
		-- Update inventory UI
		local invUpdateEvent = ReplicatedStorage:FindFirstChild("InventoryUpdate")
		if invUpdateEvent and invUpdateEvent:IsA("RemoteEvent") then
			invUpdateEvent:FireClient(player)
		end
	end

	-- Remove grave
	activeGraves[grave] = nil
	if grave.Parent then
		grave:Destroy()
	end
end

------------------------------------------------------------
-- Death Handling
------------------------------------------------------------
local function handlePlayerDeath(player: Player, killer: Player?)
	local character = player.Character
	if not character then return end

	local zone = getPlayerZone(player)
	local deathPosition = character:FindFirstChild("HumanoidRootPart") and 
		character.HumanoidRootPart.Position or Vector3.new(50, 15, 50)

	local playerData = DataManager:GetPlayerData(player)
	if not playerData then return end

	-- Update death stats
	playerData.TotalDeaths = (playerData.TotalDeaths or 0) + 1
	if killer then
		local killerData = DataManager:GetPlayerData(killer)
		if killerData then
			killerData.TotalKills = (killerData.TotalKills or 0) + 1
			DataManager:SavePlayerData(killer)
		end
	end

	local droppedItems = {}

	if zone == "Wilderness" then
		-- WILDERNESS DEATH: Drop everything
		print("[DeathManager]", player.Name, "died in Wilderness - dropping all items")
		
		-- Copy inventory to dropped items
		if playerData.Inventory then
			for _, item in ipairs(playerData.Inventory) do
				table.insert(droppedItems, {
					name = item.name,
					quantity = item.quantity
				})
			end
		end

		-- Clear inventory
		playerData.Inventory = {}

		-- Create grave with dropped items
		if #droppedItems > 0 then
			createGrave(player, deathPosition, droppedItems)
		end
	else
		-- SAFE ZONE DEATH: Keep items
		print("[DeathManager]", player.Name, "died in Safe zone - keeping items")
		-- Items stay in inventory, no grave created
	end

	-- Save player data
	DataManager:SavePlayerData(player)

	-- Show death screen
	ShowDeathScreenEvent:FireClient(player, {
		zone = zone,
		droppedItemCount = #droppedItems,
		killer = killer and killer.Name or nil,
		deathTimer = DEATH_TIMER
	})

	-- Force respawn after timer
	task.spawn(function()
		task.wait(DEATH_TIMER)
		respawnPlayer(player)
	end)

	print("[DeathManager]", player.Name, "died in", zone, "- dropped", #droppedItems, "items")
end

local function respawnPlayer(player: Player)
	-- Respawn player at Haven City
	local respawnPosition = RESPAWN_POSITIONS.Safe
	
	-- Load character
	player:LoadCharacter()
	
	-- Wait for character to load and teleport
	local character = player.CharacterAdded:Wait()
	local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
	
	-- Teleport to respawn position
	task.wait(0.1) -- Small delay to ensure character is fully loaded
	humanoidRootPart.CFrame = CFrame.new(respawnPosition)
	
	print("[DeathManager]", player.Name, "respawned at Haven City")
end

------------------------------------------------------------
-- Event Handlers
------------------------------------------------------------

-- Listen for player deaths
Players.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function(character)
		local humanoid = character:WaitForChild("Humanoid")
		
		humanoid.Died:Connect(function()
			-- Try to find who killed the player (basic implementation)
			local killer = nil
			local lastDamager = character:FindFirstChild("LastDamager")
			if lastDamager and lastDamager.Value and lastDamager.Value.Parent then
				killer = Players:GetPlayerFromCharacter(lastDamager.Value.Parent)
			end
			
			handlePlayerDeath(player, killer)
		end)
	end)
end)

-- Handle respawn requests
RespawnPlayerEvent.OnServerEvent:Connect(function(player: Player)
	respawnPlayer(player)
end)

-- Handle grave looting
GraveInteractEvent.OnServerEvent:Connect(function(player: Player, graveName: string)
	lootGrave(player, graveName)
end)

------------------------------------------------------------
-- Cleanup
------------------------------------------------------------

-- Clean up graves periodically
task.spawn(function()
	while true do
		task.wait(30) -- Check every 30 seconds
		
		local currentTime = tick()
		for grave, data in pairs(activeGraves) do
			if currentTime - data.timestamp > GRAVE_LIFETIME then
				activeGraves[grave] = nil
				if grave.Parent then
					grave:Destroy()
				end
			end
		end
	end
end)

Players.PlayerRemoving:Connect(function(player)
	-- Clean up any data related to the leaving player
	-- Graves will persist for other players to loot
end)

print("[DeathManager] Death and respawn system initialized")</string>
      </Properties>
    </Item>
    <Item class="Script" referent="38">
      <Properties>
        <string name="Name">DropHandler</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	DropHandler.server.lua
	Handles dropping items from inventory onto the ground.
	Shift+click in inventory fires DropItem remote.
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

task.wait(3)

local DataManager = require(ReplicatedStorage.Modules.DataManager)
local ItemDatabase = require(ReplicatedStorage.Modules.ItemDatabase)

local RARITY_COLORS = {
	common = Color3.fromRGB(157, 157, 157),
	uncommon = Color3.fromRGB(30, 255, 0),
	rare = Color3.fromRGB(0, 112, 221),
	epic = Color3.fromRGB(163, 53, 238),
	legendary = Color3.fromRGB(255, 128, 0),
}

local DESPAWN_TIME = 120 -- seconds before dropped items vanish

local function getRemote(name)
	local r = ReplicatedStorage:FindFirstChild("Remotes")
	if r then
		local e = r:FindFirstChild(name)
		if e then return e end
	end
	return ReplicatedStorage:FindFirstChild(name)
end

local DropItemRemote = getRemote("DropItem")
if not DropItemRemote then
	warn("[DropHandler] No DropItem remote found!")
	return
end

DropItemRemote.OnServerEvent:Connect(function(player, itemName, qty)
	if type(itemName) ~= "string" or type(qty) ~= "number" then return end
	qty = math.max(1, math.floor(qty))

	-- Validate player has the item
	local data = DataManager.GetData(player)
	if not data or not data.Inventory then return end

	-- Find item in inventory
	local found = false
	for i, slot in ipairs(data.Inventory) do
		if slot.name == itemName then
			if slot.quantity and slot.quantity > 1 then
				slot.quantity = slot.quantity - qty
				if slot.quantity <= 0 then
					table.remove(data.Inventory, i)
				end
			else
				table.remove(data.Inventory, i)
			end
			found = true
			break
		end
	end

	if not found then return end

	-- Save
	DataManager.SaveData(player)

	-- Spawn the item on the ground near the player
	local char = player.Character
	if not char then return end
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	-- Drop position: in front of player, on the ground
	local dropPos = hrp.Position + hrp.CFrame.LookVector * 3
	dropPos = Vector3.new(dropPos.X, 0.6, dropPos.Z)

	local itemDef = ItemDatabase.Items and ItemDatabase.Items[itemName]
	local rarity = (itemDef and itemDef.rarity) or "common"

	local itemPart = Instance.new("Part")
	itemPart.Name = "DroppedItem_" .. itemName
	itemPart.Size = Vector3.new(1.2, 1.2, 1.2)
	itemPart.Shape = Enum.PartType.Block
	itemPart.Anchored = true
	itemPart.CanCollide = false
	itemPart.Position = dropPos
	itemPart.Material = Enum.Material.Neon
	itemPart.Color = RARITY_COLORS[rarity] or RARITY_COLORS.common
	itemPart.Parent = workspace

	-- Label
	local bbg = Instance.new("BillboardGui")
	bbg.Size = UDim2.new(5, 0, 1, 0)
	bbg.StudsOffset = Vector3.new(0, 1.5, 0)
	bbg.AlwaysOnTop = true
	bbg.Adornee = itemPart
	bbg.Parent = itemPart

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	local displayText = itemName
	if qty > 1 then displayText = displayText .. " x" .. qty end
	label.Text = displayText
	label.TextColor3 = RARITY_COLORS[rarity] or RARITY_COLORS.common
	label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	label.TextStrokeTransparency = 0
	label.TextScaled = true
	label.Font = Enum.Font.GothamBold
	label.Parent = bbg

	-- Click to pick up (anyone can pick up dropped items)
	local click = Instance.new("ClickDetector")
	click.MaxActivationDistance = 14
	click.Parent = itemPart

	local picked = false
	click.MouseClick:Connect(function(picker)
		if picked then return end
		picked = true
		pcall(function()
			DataManager.AddItem(picker, itemName, qty)
		end)
		TweenService:Create(itemPart, TweenInfo.new(0.3), {
			Size = Vector3.new(0.1, 0.1, 0.1),
			Transparency = 1,
		}):Play()
		task.delay(0.35, function()
			if itemPart and itemPart.Parent then itemPart:Destroy() end
		end)
	end)

	-- Bobbing
	task.spawn(function()
		local startY = itemPart.Position.Y
		local t = math.random() * math.pi * 2
		while itemPart and itemPart.Parent do
			t = t + 0.05
			itemPart.Position = Vector3.new(itemPart.Position.X, startY + math.sin(t) * 0.3, itemPart.Position.Z)
			task.wait(0.03)
		end
	end)

	-- Auto-despawn
	task.delay(DESPAWN_TIME, function()
		if itemPart and itemPart.Parent then itemPart:Destroy() end
	end)

	print("[DropHandler] " .. player.Name .. " dropped " .. itemName .. " x" .. qty)
end)

print("[DropHandler] Ready!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="39">
      <Properties>
        <string name="Name">EquipmentManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- EquipmentManager.server.lua
-- Handles equipping/unequipping items for players

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local DataManager = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("DataManager"))
local ItemDatabase = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("ItemDatabase"))

-- Valid equipment slots
local VALID_SLOTS = {Head = true, Body = true, Legs = true, Weapon = true, Shield = true, Tool = true}

-- getOrCreate RemoteEvents
local function getOrCreateRemote(name)
	local remote = ReplicatedStorage:FindFirstChild(name)
	if not remote then
		remote = Instance.new("RemoteEvent")
		remote.Name = name
		remote.Parent = ReplicatedStorage
	end
	return remote
end

local EquipItemRemote = getOrCreateRemote("EquipItem")
local UnequipItemRemote = getOrCreateRemote("UnequipItem")
local EquipmentUpdateRemote = getOrCreateRemote("EquipmentUpdate")
local EquipmentInfoRemote = getOrCreateRemote("EquipmentInfo")

local function getWeaponTypeFromName(weaponName)
	if not weaponName or weaponName == "" then return "fist" end
	local lower = weaponName:lower()
	if lower:find("crossbow") then return "crossbow"
	elseif lower:find("bow") then return "bow"
	elseif lower:find("sword") or lower:find("scimitar") or lower:find("axe") or lower:find("dagger") then return "sword"
	else return "sword" end
end

local function sendEquipmentUpdate(player)
	local data = DataManager.GetData(player)
	if data then
		EquipmentUpdateRemote:FireClient(player, data.Equipment)

		-- Send weapon type info to client for animation system
		local weaponName = (data.Equipment and data.Equipment.Weapon) or ""
		local weaponType = getWeaponTypeFromName(weaponName)
		EquipmentInfoRemote:FireClient(player, {
			weaponType = weaponType,
			weaponName = weaponName,
			hasShield = (data.Equipment.Shield ~= nil and data.Equipment.Shield ~= ""),
		})
	end
	-- Fire BindableEvent so VisualEquipment updates character appearance
	local equipChanged = ReplicatedStorage:FindFirstChild("EquipmentChanged")
	if equipChanged then
		equipChanged:Fire(player)
	end
end

EquipItemRemote.OnServerEvent:Connect(function(player, slotName, itemName)
	if type(slotName) ~= "string" or type(itemName) ~= "string" then return end
	if not VALID_SLOTS[slotName] then return end

	local data = DataManager.GetData(player)
	if not data then return end

	-- Validate item exists in database and fits the slot
	local itemInfo = ItemDatabase.GetItem(itemName)
	if not itemInfo then return end
	if itemInfo.equipSlot ~= slotName then return end

	-- Validate player has the item
	if not DataManager.HasItem(player, itemName, 1) then return end

	-- Unequip current item in that slot (put back in inventory)
	local currentEquip = data.Equipment[slotName]
	if currentEquip and currentEquip ~= "" then
		DataManager.AddToInventory(player, currentEquip, 1)
	end

	-- Remove new item from inventory and equip it
	DataManager.RemoveFromInventory(player, itemName, 1)
	data.Equipment[slotName] = itemName

	sendEquipmentUpdate(player)
	print("[Equipment] " .. player.Name .. " equipped " .. itemName .. " in " .. slotName)
end)

UnequipItemRemote.OnServerEvent:Connect(function(player, slotName)
	if type(slotName) ~= "string" then return end
	if not VALID_SLOTS[slotName] then return end

	local data = DataManager.GetData(player)
	if not data then return end

	local currentEquip = data.Equipment[slotName]
	if not currentEquip or currentEquip == "" then return end

	-- Move back to inventory
	local added = DataManager.AddToInventory(player, currentEquip, 1)
	if not added then return end -- inventory full

	data.Equipment[slotName] = ""
	sendEquipmentUpdate(player)
	print("[Equipment] " .. player.Name .. " unequipped " .. currentEquip .. " from " .. slotName)
end)

-- Send equipment state when player joins
Players.PlayerAdded:Connect(function(player)
	-- Wait for data to load
	task.defer(function()
		task.wait(2)
		sendEquipmentUpdate(player)
	end)
end)

print("[EquipmentManager] Loaded!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="40">
      <Properties>
        <string name="Name">GameInit</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- GameInit.server.lua
-- Bootstrap script: handles player join/leave, data loading, auto-save

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local DataManager = require(ReplicatedStorage.Modules.DataManager)

Players.PlayerAdded:Connect(function(player)
	DataManager.LoadData(player)

	local data = DataManager.GetData(player)

	-- === TEST MODE: Level 30 mid-tier testing ===
	-- Set to false for production
	local TEST_MODE = true
	if TEST_MODE and data then
		-- Set all skills to level 30 XP (30^2 * 100 = 90000)
		local testXP = 90000
		for skillName, _ in pairs(data.Skills) do
			data.Skills[skillName] = testXP
		end
		-- Iron/Gold equipment (level 30 appropriate)
		data.Equipment.Weapon = "Gold Sword"
		data.Equipment.Head = "Bronze Helmet"
		data.Equipment.Body = "Iron Platebody"
		data.Equipment.Legs = "Iron Platelegs"
		data.Equipment.Shield = "Iron Shield"
		data.Equipment.Tool = "Iron Pickaxe"
		-- Mid-tier inventory for testing
		data.Inventory = {}
		local testItems = {
			-- Equipped tier + upgrades to find
			"Gold Sword", "Iron Sword", "Copper Sword",
			"Iron Platebody", "Iron Platelegs", "Iron Chainmail",
			"Bronze Helmet", "Iron Shield", "Gold Shield",
			-- Ranged gear
			"Willow Shortbow", "Oak Longbow", "Iron Crossbow",
			"Iron Arrows", "Iron Arrows", "Iron Arrows",
			"Iron Bolts", "Iron Bolts",
			-- Ranger armor
			"Leather Body", "Leather Chaps", "Studded Body",
			-- Tools
			"Iron Pickaxe", "Iron Axe", "Iron Rod",
			-- Food (enough to test but not invincible)
			"Cooked Trout", "Cooked Trout", "Cooked Trout",
			"Cooked Trout", "Cooked Trout", "Cooked Lobster",
			-- Some materials
			"Iron Bar", "Iron Bar", "Gold Ore", "Willow Log",
		}
		for _, itemName in ipairs(testItems) do
			table.insert(data.Inventory, {name = itemName, quantity = 1})
		end
		data.Gold = 10000
		print("[GameInit] TEST MODE: Gave " .. player.Name .. " level 30 stats + iron/gold gear")
	end

	-- Give starter tools to new players (only if not test mode)
	if not TEST_MODE and data and #data.Inventory == 0 then
		DataManager.AddToInventory(player, "Bronze Pickaxe", 1)
		DataManager.AddToInventory(player, "Bronze Axe", 1)
		DataManager.AddToInventory(player, "Wooden Rod", 1)
	end
	
	-- Send initial inventory to client
	player.CharacterAdded:Connect(function()
		task.wait(1)
		local data = DataManager.GetData(player)
		if data then
			local invRemote = ReplicatedStorage.Remotes:FindFirstChild("InventoryUpdate")
			if invRemote then
				invRemote:FireClient(player, data.Inventory)
			end
			-- Send initial skill levels
			local xpRemote = ReplicatedStorage.Remotes:FindFirstChild("XPUpdate")
			if xpRemote then
				local Config = require(ReplicatedStorage.Modules.Config)
				for skillName, xp in pairs(data.Skills) do
					local level = Config.GetLevelFromXP(xp)
					xpRemote:FireClient(player, skillName, xp, level)
				end
			end
		end
	end)
end)

Players.PlayerRemoving:Connect(function(player)
	DataManager.SaveData(player)
	DataManager.PlayerData[player.UserId] = nil
end)

-- Auto-save every 5 minutes
task.spawn(function()
	while true do
		task.wait(300)
		for _, player in ipairs(Players:GetPlayers()) do
			DataManager.SaveData(player)
		end
		print("[GameInit] Auto-save complete")
	end
end)

game:BindToClose(function()
	for _, player in ipairs(Players:GetPlayers()) do
		DataManager.SaveData(player)
	end
end)

-- === REMOTE FUNCTIONS FOR SKILL/DATA QUERIES ===
local Remotes = ReplicatedStorage:WaitForChild("Remotes")

-- GetSkillData ‚Äî returns all skill XP and levels
local getSkillData = Instance.new("RemoteFunction")
getSkillData.Name = "GetSkillData"
getSkillData.Parent = Remotes

getSkillData.OnServerInvoke = function(player)
	local data = DataManager.GetData(player)
	if not data then return {} end
	local Config = require(ReplicatedStorage.Modules.Config)
	local result = {}
	for skillName, xp in pairs(data.Skills) do
		local level = Config.GetLevelFromXP(xp)
		local nextLevelXP = Config.GetXPForLevel(level + 1)
		result[skillName] = {
			xp = xp,
			level = level,
			nextLevelXP = nextLevelXP,
		}
	end
	return result
end

-- GetCombatLevel ‚Äî returns player's combat level
local getCombatLevel = Instance.new("RemoteFunction")
getCombatLevel.Name = "GetCombatLevel"
getCombatLevel.Parent = Remotes

getCombatLevel.OnServerInvoke = function(player)
	return DataManager.GetCombatLevel(player)
end

-- GetPlayerData ‚Äî returns full player data (gold, kills, deaths, etc.)
local getPlayerData = Instance.new("RemoteFunction")
getPlayerData.Name = "GetPlayerData"
getPlayerData.Parent = Remotes

getPlayerData.OnServerInvoke = function(player)
	local data = DataManager.GetData(player)
	if not data then return {} end
	return {
		Gold = data.Gold or 0,
		TotalKills = data.TotalKills or 0,
		TotalDeaths = data.TotalDeaths or 0,
	}
end

print("[GameInit] Server initialized!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="41">
      <Properties>
        <string name="Name">HotbarHandler</string>
        <token name="RunContext">0</token>
        <string name="Source">--[[
	HotbarHandler.server.lua
	Server-side handler for hotbar item usage
	Handles food consumption, healing, and other consumable items
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

print("[HotbarHandler] Starting...")

-- Modules
local Modules = ReplicatedStorage:WaitForChild("Modules")
local DataManager = require(Modules:WaitForChild("DataManager"))
local ItemDatabase = require(Modules:WaitForChild("ItemDatabase"))

-- Create UseItem RemoteEvent if it doesn't exist
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local UseItemRemote = Remotes:FindFirstChild("UseItem")
if not UseItemRemote then
	UseItemRemote = Instance.new("RemoteEvent")
	UseItemRemote.Name = "UseItem"
	UseItemRemote.Parent = Remotes
	print("[HotbarHandler] Created UseItem RemoteEvent")
end

-- Also get other remotes for notifications
local XPPopupEvent = Remotes:FindFirstChild("XPPopup")
local InventoryUpdateEvent = Remotes:FindFirstChild("InventoryUpdate")

-----------------------------------------------------------------------
-- ITEM USAGE HANDLERS
-----------------------------------------------------------------------

local function handleFoodConsumption(player, itemName)
	local itemDef = ItemDatabase.GetItem(itemName)
	if not itemDef then
		warn("[HotbarHandler] Unknown item:", itemName)
		return false
	end
	
	-- Verify it's actually food
	if itemDef.type ~= "food" then
		warn("[HotbarHandler] Item is not food:", itemName)
		return false
	end
	
	-- Check if player has the item
	local playerData = DataManager.GetData(player)
	if not playerData then
		warn("[HotbarHandler] No player data for:", player.Name)
		return false
	end
	
	-- Find item in inventory
	local foundSlot = nil
	for i, slot in ipairs(playerData.inventory) do
		if slot and slot.name == itemName and slot.count > 0 then
			foundSlot = i
			break
		end
	end
	
	if not foundSlot then
		warn("[HotbarHandler] Player doesn't have item:", itemName)
		return false
	end
	
	-- Get heal amount (with fallback based on tier)
	local healAmount = itemDef.healAmount
	if not healAmount then
		-- Default heal amounts based on item tier/value
		local value = itemDef.value or 0
		if value >= 200 then
			healAmount = 50 -- High tier food
		elseif value >= 50 then
			healAmount = 25 -- Mid tier food
		elseif value >= 10 then
			healAmount = 15 -- Low tier food
		else
			healAmount = 8 -- Basic food
		end
	end
	
	-- Get player's current health
	local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
	if not humanoid then
		warn("[HotbarHandler] Player has no humanoid")
		return false
	end
	
	local currentHealth = humanoid.Health
	local maxHealth = humanoid.MaxHealth
	
	-- Don't eat if already at full health
	if currentHealth >= maxHealth then
		print("[HotbarHandler] Player already at full health")
		return false
	end
	
	-- Consume the item
	local consumed = DataManager.RemoveItem(player, itemName, 1)
	if not consumed then
		warn("[HotbarHandler] Failed to remove item:", itemName)
		return false
	end
	
	-- Heal the player
	local newHealth = math.min(currentHealth + healAmount, maxHealth)
	humanoid.Health = newHealth
	
	print("[HotbarHandler] " .. player.Name .. " ate " .. itemName .. " and healed " .. healAmount .. " HP")
	
	-- Notify client of inventory update
	if InventoryUpdateEvent then
		InventoryUpdateEvent:FireClient(player)
	end
	
	-- Show heal effect (you could add a visual effect here)
	-- For now, just print to the player
	if XPPopupEvent then
		XPPopupEvent:FireClient(player, "+" .. healAmount .. " HP", Color3.fromRGB(0, 255, 0), player.Character.HumanoidRootPart.Position + Vector3.new(0, 5, 0))
	end
	
	return true
end

local function handlePotionConsumption(player, itemName)
	-- Future: Handle potions (stat boosts, temporary effects, etc.)
	print("[HotbarHandler] Potion consumption not yet implemented:", itemName)
	return false
end

local function handleOtherConsumables(player, itemName)
	-- Future: Handle other consumable items
	print("[HotbarHandler] Other consumable usage not yet implemented:", itemName)
	return false
end

-----------------------------------------------------------------------
-- MAIN HANDLER
-----------------------------------------------------------------------

UseItemRemote.OnServerEvent:Connect(function(player, itemName)
	if not player or not itemName then
		warn("[HotbarHandler] Invalid parameters")
		return
	end
	
	print("[HotbarHandler] " .. player.Name .. " attempting to use:", itemName)
	
	local itemDef = ItemDatabase.GetItem(itemName)
	if not itemDef then
		warn("[HotbarHandler] Unknown item:", itemName)
		return
	end
	
	-- Route to appropriate handler based on item type
	local success = false
	
	if itemDef.type == "food" then
		success = handleFoodConsumption(player, itemName)
	elseif itemDef.type == "potion" then
		success = handlePotionConsumption(player, itemName)
	else
		-- Try as other consumable
		success = handleOtherConsumables(player, itemName)
	end
	
	if not success then
		warn("[HotbarHandler] Failed to use item:", itemName)
	end
end)

print("[HotbarHandler] Ready!")</string>
      </Properties>
    </Item>
    <Item class="Script" referent="42">
      <Properties>
        <string name="Name">LootManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	LootManager.server.lua
	Handles full-loot PvP death drops in the wilderness.
	When a player dies at Z < -100, all inventory items drop as a loot bag
	that any player can loot within 60 seconds.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")

-- Modules
local DataManager = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("DataManager"))

-- Config
local Config = {
	WildernessZ = -100,          -- Z threshold for wilderness
	LootDropDuration = 60,       -- seconds before bag despawns
	BagSize = Vector3.new(2, 2, 2),
	BagColor = Color3.fromRGB(139, 90, 43), -- brown sack
	GlowColor = Color3.fromRGB(240, 192, 64),
	MaxLootDistance = 10,
	CleanupInterval = 5,         -- seconds between cleanup sweeps
}

-- RemoteEvents
local function getOrCreateRemote(name: string): RemoteEvent
	local remote = ReplicatedStorage:FindFirstChild(name)
	if not remote then
		remote = Instance.new("RemoteEvent")
		remote.Name = name
		remote.Parent = ReplicatedStorage
	end
	return remote
end

local LootBagOpen = getOrCreateRemote("LootBagOpen")
local LootBagTake = getOrCreateRemote("LootBagTake")
local LootBagUpdate = getOrCreateRemote("LootBagUpdate")

-- Active loot bags: bagId -> { model, contents, position, timestamp, owner }
local activeBags: { [string]: {
	model: Model,
	contents: { { itemId: string, name: string, quantity: number, [string]: any } },
	position: Vector3,
	timestamp: number,
	ownerName: string,
} } = {}

local nextBagId = 1

--------------------------------------------------------------------------------
-- Loot Bag Creation
--------------------------------------------------------------------------------

--- Build the 3D loot bag model at the given position
local function createBagModel(position: Vector3, ownerName: string, bagId: string): Model
	local model = Instance.new("Model")
	model.Name = "LootBag_" .. bagId

	-- Primary part: the brown sack
	local part = Instance.new("Part")
	part.Name = "Sack"
	part.Size = Config.BagSize
	part.Position = position + Vector3.new(0, 1, 0) -- slightly above ground
	part.Anchored = true
	part.CanCollide = false
	part.Shape = Enum.PartType.Ball
	part.Color = Config.BagColor
	part.Material = Enum.Material.Fabric
	part.Parent = model

	model.PrimaryPart = part

	-- Glow effect
	local light = Instance.new("PointLight")
	light.Color = Config.GlowColor
	light.Brightness = 0.8
	light.Range = 6
	light.Parent = part

	-- BillboardGui label
	local billboard = Instance.new("BillboardGui")
	billboard.Name = "Label"
	billboard.Size = UDim2.new(0, 200, 0, 60)
	billboard.StudsOffset = Vector3.new(0, 2.5, 0)
	billboard.AlwaysOnTop = true
	billboard.Parent = part

	local title = Instance.new("TextLabel")
	title.Size = UDim2.new(1, 0, 0.5, 0)
	title.BackgroundTransparency = 1
	title.Text = "üíÄ Loot Bag"
	title.TextColor3 = Config.GlowColor
	title.TextScaled = true
	title.Font = Enum.Font.GothamBold
	title.Parent = billboard

	local subtitle = Instance.new("TextLabel")
	subtitle.Size = UDim2.new(1, 0, 0.5, 0)
	subtitle.Position = UDim2.new(0, 0, 0.5, 0)
	subtitle.BackgroundTransparency = 1
	subtitle.Text = ownerName
	subtitle.TextColor3 = Color3.new(1, 1, 1)
	subtitle.TextScaled = true
	subtitle.Font = Enum.Font.Gotham
	subtitle.Parent = billboard

	-- ClickDetector for interaction
	local click = Instance.new("ClickDetector")
	click.MaxActivationDistance = Config.MaxLootDistance
	click.Parent = part

	-- Store bagId as attribute for identification
	model:SetAttribute("BagId", bagId)

	-- Parent to workspace
	model.Parent = workspace

	return model
end

--- Drop all of a player's inventory as a loot bag at their death position
local function dropLootBag(player: Player, deathPosition: Vector3)
	-- Get player inventory from DataManager
	local inventory = DataManager:GetInventory(player)
	if not inventory or #inventory == 0 then
		return -- nothing to drop
	end

	local bagId = tostring(nextBagId)
	nextBagId += 1

	-- Deep copy inventory contents
	local contents = {}
	for _, item in inventory do
		table.insert(contents, table.clone(item))
	end

	-- Clear player's inventory
	DataManager:ClearInventory(player)

	-- Create bag
	local model = createBagModel(deathPosition, player.Name, bagId)

	activeBags[bagId] = {
		model = model,
		contents = contents,
		position = deathPosition,
		timestamp = os.clock(),
		ownerName = player.Name,
	}

	-- Wire up click detector
	local sack = model.PrimaryPart
	local clickDetector = sack:FindFirstChildOfClass("ClickDetector")
	clickDetector.MouseClick:Connect(function(looter: Player)
		local bag = activeBags[bagId]
		if not bag then return end

		-- Send bag contents to the clicking player
		LootBagOpen:FireClient(looter, bagId, bag.contents, bag.ownerName)
	end)

	-- Auto-despawn via Debris as a safety net
	Debris:AddItem(model, Config.LootDropDuration + 1)

	print(string.format("[LootManager] %s dropped loot bag #%s (%d items) at %s",
		player.Name, bagId, #contents, tostring(deathPosition)))
end

--------------------------------------------------------------------------------
-- Loot Taking
--------------------------------------------------------------------------------

--- Handle a player requesting to take a single item from a bag
LootBagTake.OnServerEvent:Connect(function(player: Player, bagId: string, itemIndex: number)
	local bag = activeBags[bagId]
	if not bag then return end

	-- Validate index
	if itemIndex < 1 or itemIndex > #bag.contents then return end

	-- Distance check
	local character = player.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") then return end
	local dist = (character.HumanoidRootPart.Position - bag.position).Magnitude
	if dist > Config.MaxLootDistance + 2 then return end -- small grace

	-- Remove item from bag and give to player
	local item = table.remove(bag.contents, itemIndex)
	if not item then return end

	DataManager:AddItem(player, item)

	print(string.format("[LootManager] %s looted %s from bag #%s", player.Name, item.name or item.itemId, bagId))

	-- Notify all clients who might have this bag open
	if #bag.contents == 0 then
		-- Bag is empty, destroy it
		LootBagUpdate:FireAllClients(bagId, nil) -- nil = bag gone
		if bag.model then bag.model:Destroy() end
		activeBags[bagId] = nil
	else
		-- Update remaining contents
		LootBagUpdate:FireAllClients(bagId, bag.contents)
	end
end)

--------------------------------------------------------------------------------
-- Death Handling
--------------------------------------------------------------------------------

local function onCharacterAdded(player: Player, character: Model)
	local humanoid = character:WaitForChild("Humanoid")

	humanoid.Died:Connect(function()
		local rootPart = character:FindFirstChild("HumanoidRootPart")
		if not rootPart then return end

		local pos = rootPart.Position

		-- Only drop loot in wilderness (Z < -100)
		if pos.Z < Config.WildernessZ then
			dropLootBag(player, pos)
		end
	end)
end

local function onPlayerAdded(player: Player)
	player.CharacterAdded:Connect(function(character)
		onCharacterAdded(player, character)
	end)

	-- Handle already-spawned character
	if player.Character then
		onCharacterAdded(player, player.Character)
	end
end

Players.PlayerAdded:Connect(onPlayerAdded)
for _, player in Players:GetPlayers() do
	onPlayerAdded(player)
end

--------------------------------------------------------------------------------
-- Cleanup Loop: remove expired bags
--------------------------------------------------------------------------------

task.spawn(function()
	while true do
		task.wait(Config.CleanupInterval)
		local now = os.clock()

		for bagId, bag in activeBags do
			if now - bag.timestamp >= Config.LootDropDuration then
				print(string.format("[LootManager] Bag #%s expired, destroying", bagId))
				LootBagUpdate:FireAllClients(bagId, nil)
				if bag.model then bag.model:Destroy() end
				activeBags[bagId] = nil
			end
		end
	end
end)

print("[LootManager] Loot system active!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="43">
      <Properties>
        <string name="Name">MapSetup</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- MapSetup.server.lua
-- Creates the entire game world: terrain, city, wilderness, ponds, mine, forests

print("[MapSetup] Starting world generation...")
local WS = game:GetService("Workspace")

-- === HELPER FUNCTIONS ===
local function makePart(name, size, position, color, material, parent, props)
	local p = Instance.new("Part")
	p.Name = name
	p.Size = size
	p.Position = position
	p.Anchored = true
	if typeof(color) == "Color3" then
		p.Color = color
	else
		p.BrickColor = BrickColor.new(color)
	end
	p.Material = material or Enum.Material.SmoothPlastic
	p.Parent = parent
	if props then
		for k, v in pairs(props) do
			p[k] = v
		end
	end
	return p
end

local function makeWedge(name, size, position, color, material, parent, props)
	local w = Instance.new("WedgePart")
	w.Name = name
	w.Size = size
	w.Position = position
	w.Anchored = true
	w.BrickColor = BrickColor.new(color)
	w.Material = material or Enum.Material.SmoothPlastic
	w.Parent = parent
	if props then
		for k, v in pairs(props) do
			w[k] = v
		end
	end
	return w
end

local function makeSign(parent, text, offset, size)
	local bg = Instance.new("BillboardGui")
	bg.Size = size or UDim2.new(8, 0, 2, 0)
	bg.StudsOffset = offset or Vector3.new(0, 5, 0)
	bg.Parent = parent
	local tl = Instance.new("TextLabel")
	tl.Size = UDim2.new(1, 0, 1, 0)
	tl.BackgroundTransparency = 1
	tl.Text = text
	tl.TextColor3 = Color3.fromRGB(255, 255, 255)
	tl.TextScaled = true
	tl.Font = Enum.Font.GothamBold
	tl.TextStrokeTransparency = 0.3
	tl.Parent = bg
	return bg
end

local function makeTorch(position, parent)
	local pole = makePart("TorchPole", Vector3.new(0.5, 6, 0.5), position, "Reddish brown", Enum.Material.Wood, parent)
	local flame = makePart("TorchFlame", Vector3.new(1, 1.5, 1), position + Vector3.new(0, 3.5, 0), "Bright orange", Enum.Material.Neon, parent, {Transparency = 0.2})
	local light = Instance.new("PointLight")
	light.Color = Color3.fromRGB(255, 150, 50)
	light.Brightness = 2
	light.Range = 20
	light.Parent = flame
	return pole
end

local function makeLantern(position, parent)
	local post = makePart("LanternPost", Vector3.new(0.4, 5, 0.4), position, "Dark stone grey", Enum.Material.Metal, parent)
	local lamp = makePart("Lantern", Vector3.new(1.2, 1.5, 1.2), position + Vector3.new(0, 3.2, 0), "Bright yellow", Enum.Material.Neon, parent, {Transparency = 0.3})
	local light = Instance.new("PointLight")
	light.Color = Color3.fromRGB(255, 220, 120)
	light.Brightness = 1.5
	light.Range = 25
	light.Parent = lamp
	return post
end

-- === FOLDERS ===
local function getOrMake(parent, name)
	local f = parent:FindFirstChild(name)
	if not f then f = Instance.new("Folder") f.Name = name f.Parent = parent end
	return f
end

local safeZone = getOrMake(WS, "SafeZone")
local wilderness = getOrMake(WS, "Wilderness")
local resourceNodes = getOrMake(WS, "ResourceNodes")

-- ============================================================
-- === GROUND / TERRAIN ===
-- ============================================================

-- Main baseplate (safe zone - green grass) ‚Äî HUGE
if not WS:FindFirstChild("Baseplate") then
	local bp = Instance.new("Part")
	bp.Name = "Baseplate"
	bp.Size = Vector3.new(800, 1, 800)
	bp.Position = Vector3.new(0, -0.5, 0)
	bp.Anchored = true
	bp.BrickColor = BrickColor.new("Bright green")
	bp.Material = Enum.Material.Grass
	bp.Parent = WS
end

-- Wilderness ground (darker, dead ‚Äî extends north)
if not WS:FindFirstChild("WildernessGround") then
	local wg = Instance.new("Part")
	wg.Name = "WildernessGround"
	wg.Size = Vector3.new(800, 1.01, 600)
	wg.Position = Vector3.new(0, -0.5, -400)
	wg.Anchored = true
	wg.BrickColor = BrickColor.new("Dark stone grey")
	wg.Material = Enum.Material.Ground
	wg.Parent = WS
end

-- === SPAWN POINT ===
if not WS:FindFirstChild("SpawnLocation") then
	local sp = Instance.new("SpawnLocation")
	sp.Size = Vector3.new(12, 1, 12)
	sp.Position = Vector3.new(0, 0.5, 60)
	sp.Anchored = true
	sp.BrickColor = BrickColor.new("White")
	sp.Material = Enum.Material.Marble
	sp.Parent = WS
end

-- === WILDERNESS BORDER ===
if not WS:FindFirstChild("WildernessBorder") then
	local b = makePart("WildernessBorder", Vector3.new(800, 30, 2), Vector3.new(0, 15, -100), Color3.fromRGB(100, 15, 15), Enum.Material.ForceField, WS, {Transparency = 0.4, CanCollide = false})
	local borderGlow = Instance.new("PointLight")
	borderGlow.Color = Color3.fromRGB(180, 20, 20)
	borderGlow.Brightness = 0.8
	borderGlow.Range = 20
	borderGlow.Parent = b
	makeSign(b, "‚ö†Ô∏è WILDERNESS ‚Äî FULL LOOT PVP ‚ö†Ô∏è\nCross at your own risk!", Vector3.new(0, 8, 0))
end

-- ============================================================
-- === THE CITY OF HAVEN ===
-- ============================================================

local cityFolder = getOrMake(safeZone, "City")

-- ---- CITY WALLS (big stone perimeter) ----
-- Back wall (north side) ‚Äî split for North Gate
makePart("WallBackL", Vector3.new(50, 14, 4), Vector3.new(-37, 7, -10), "Medium stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("WallBackR", Vector3.new(50, 14, 4), Vector3.new(37, 7, -10), "Medium stone grey", Enum.Material.Cobblestone, cityFolder)
-- North Gate (leads to wilderness)
makePart("NorthGateLeft", Vector3.new(6, 18, 6), Vector3.new(-10, 9, -10), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("NorthGateRight", Vector3.new(6, 18, 6), Vector3.new(10, 9, -10), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("NorthGateArch", Vector3.new(26, 4, 6), Vector3.new(0, 18, -10), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("NorthPortcullis", Vector3.new(14, 14, 0.5), Vector3.new(0, 10, -10), "Black", Enum.Material.DiamondPlate, cityFolder, {Transparency = 0.5, CanCollide = false})
local northGateSign = makePart("NorthGateSign", Vector3.new(1, 1, 1), Vector3.new(0, 22, -10), "Dark stone grey", Enum.Material.Cobblestone, cityFolder, {Transparency = 1})
makeSign(northGateSign, "‚ö†Ô∏è WILDERNESS", Vector3.new(0, 0, 0), UDim2.new(10, 0, 3, 0))
-- North gate red torches
do
	local poleN1 = makePart("NorthTorchPole1", Vector3.new(0.5, 6, 0.5), Vector3.new(-7, 3, -14), "Reddish brown", Enum.Material.Wood, cityFolder)
	local flameN1 = makePart("NorthTorchFlame1", Vector3.new(1, 1.5, 1), Vector3.new(-7, 6.5, -14), "Really red", Enum.Material.Neon, cityFolder, {Transparency = 0.2})
	local lN1 = Instance.new("PointLight") lN1.Color = Color3.fromRGB(255, 50, 50) lN1.Brightness = 2 lN1.Range = 20 lN1.Parent = flameN1
	local poleN2 = makePart("NorthTorchPole2", Vector3.new(0.5, 6, 0.5), Vector3.new(7, 3, -14), "Reddish brown", Enum.Material.Wood, cityFolder)
	local flameN2 = makePart("NorthTorchFlame2", Vector3.new(1, 1.5, 1), Vector3.new(7, 6.5, -14), "Really red", Enum.Material.Neon, cityFolder, {Transparency = 0.2})
	local lN2 = Instance.new("PointLight") lN2.Color = Color3.fromRGB(255, 50, 50) lN2.Brightness = 2 lN2.Range = 20 lN2.Parent = flameN2
end

-- Left wall (west) ‚Äî split for West Gate (center at Z=50)
makePart("WallLeftN", Vector3.new(4, 14, 50), Vector3.new(-62, 7, 15), "Medium stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("WallLeftS", Vector3.new(4, 14, 50), Vector3.new(-62, 7, 85), "Medium stone grey", Enum.Material.Cobblestone, cityFolder)
-- West Gate (leads to mine/forest)
makePart("WestGateTop", Vector3.new(6, 18, 6), Vector3.new(-62, 9, 40), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("WestGateBot", Vector3.new(6, 18, 6), Vector3.new(-62, 9, 60), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("WestGateArch", Vector3.new(6, 4, 26), Vector3.new(-62, 18, 50), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("WestPortcullis", Vector3.new(0.5, 14, 14), Vector3.new(-62, 10, 50), "Black", Enum.Material.DiamondPlate, cityFolder, {Transparency = 0.5, CanCollide = false})
local westGateSign = makePart("WestGateSign", Vector3.new(1, 1, 1), Vector3.new(-62, 22, 50), "Dark stone grey", Enum.Material.Cobblestone, cityFolder, {Transparency = 1})
makeSign(westGateSign, "‚õèÔ∏è HAVEN MINE", Vector3.new(0, 0, 0), UDim2.new(10, 0, 3, 0))
makeTorch(Vector3.new(-66, 3, 43), cityFolder)
makeTorch(Vector3.new(-66, 3, 57), cityFolder)

-- Right wall (east) ‚Äî split for East Gate (center at Z=50)
makePart("WallRightN", Vector3.new(4, 14, 50), Vector3.new(62, 7, 15), "Medium stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("WallRightS", Vector3.new(4, 14, 50), Vector3.new(62, 7, 85), "Medium stone grey", Enum.Material.Cobblestone, cityFolder)
-- East Gate (leads to forest/farmlands)
makePart("EastGateTop", Vector3.new(6, 18, 6), Vector3.new(62, 9, 40), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("EastGateBot", Vector3.new(6, 18, 6), Vector3.new(62, 9, 60), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("EastGateArch", Vector3.new(6, 4, 26), Vector3.new(62, 18, 50), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("EastPortcullis", Vector3.new(0.5, 14, 14), Vector3.new(62, 10, 50), "Black", Enum.Material.DiamondPlate, cityFolder, {Transparency = 0.5, CanCollide = false})
local eastGateSign = makePart("EastGateSign", Vector3.new(1, 1, 1), Vector3.new(62, 22, 50), "Dark stone grey", Enum.Material.Cobblestone, cityFolder, {Transparency = 1})
makeSign(eastGateSign, "üå≤ HAVEN FOREST", Vector3.new(0, 0, 0), UDim2.new(10, 0, 3, 0))
makeTorch(Vector3.new(66, 3, 43), cityFolder)
makeTorch(Vector3.new(66, 3, 57), cityFolder)
-- Front wall LEFT of gate
makePart("WallFrontL", Vector3.new(48, 14, 4), Vector3.new(-36, 7, 108), "Medium stone grey", Enum.Material.Cobblestone, cityFolder)
-- Front wall RIGHT of gate
makePart("WallFrontR", Vector3.new(48, 14, 4), Vector3.new(36, 7, 108), "Medium stone grey", Enum.Material.Cobblestone, cityFolder)

-- Wall towers (corners)
makePart("TowerNW", Vector3.new(8, 18, 8), Vector3.new(-62, 9, -10), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("TowerNE", Vector3.new(8, 18, 8), Vector3.new(62, 9, -10), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("TowerSW", Vector3.new(8, 18, 8), Vector3.new(-62, 9, 108), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("TowerSE", Vector3.new(8, 18, 8), Vector3.new(62, 9, 108), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
-- Tower tops (crenellation feel)
makePart("TowerTopNW", Vector3.new(10, 2, 10), Vector3.new(-62, 19, -10), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("TowerTopNE", Vector3.new(10, 2, 10), Vector3.new(62, 19, -10), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("TowerTopSW", Vector3.new(10, 2, 10), Vector3.new(-62, 19, 108), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("TowerTopSE", Vector3.new(10, 2, 10), Vector3.new(62, 19, 108), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)

-- ---- MAIN GATE ----
makePart("GateLeft", Vector3.new(6, 18, 6), Vector3.new(-10, 9, 108), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("GateRight", Vector3.new(6, 18, 6), Vector3.new(10, 9, 108), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
makePart("GateArch", Vector3.new(26, 4, 6), Vector3.new(0, 18, 108), "Dark stone grey", Enum.Material.Cobblestone, cityFolder)
-- Gate portcullis (decorative iron bars)
makePart("Portcullis", Vector3.new(14, 14, 0.5), Vector3.new(0, 10, 108), "Black", Enum.Material.DiamondPlate, cityFolder, {Transparency = 0.5, CanCollide = false})
-- Gate sign
local gateSign = makePart("GateSignPost", Vector3.new(1, 1, 1), Vector3.new(0, 22, 108), "Dark stone grey", Enum.Material.Cobblestone, cityFolder, {Transparency = 1})
makeSign(gateSign, "üè∞ HAVEN", Vector3.new(0, 0, 0), UDim2.new(10, 0, 3, 0))
-- Gate torches
makeTorch(Vector3.new(-7, 3, 112), cityFolder)
makeTorch(Vector3.new(7, 3, 112), cityFolder)

-- ---- CITY GROUND ----
makePart("CityFloor", Vector3.new(120, 0.2, 116), Vector3.new(0, 0.1, 49), "Medium stone grey", Enum.Material.Cobblestone, cityFolder)

-- ---- MAIN ROAD (gate to town square and beyond) ----
makePart("MainRoad", Vector3.new(8, 0.15, 60), Vector3.new(0, 0.12, 78), "Institutional white", Enum.Material.Cobblestone, cityFolder)
-- East-west crossroad
makePart("CrossRoad", Vector3.new(100, 0.15, 6), Vector3.new(0, 0.12, 50), "Institutional white", Enum.Material.Cobblestone, cityFolder)

-- ============================================================
-- === TOWN SQUARE (center) ===
-- ============================================================

-- Big fountain
makePart("FountainBase", Vector3.new(14, 3, 14), Vector3.new(0, 1.5, 50), "Medium stone grey", Enum.Material.Marble, cityFolder)
makePart("FountainInner", Vector3.new(10, 0.5, 10), Vector3.new(0, 3.25, 50), "Medium stone grey", Enum.Material.Marble, cityFolder)
makePart("FountainWater", Vector3.new(9, 0.4, 9), Vector3.new(0, 3, 50), Color3.fromRGB(65, 130, 175), Enum.Material.Water, cityFolder, {Transparency = 0.3})
makePart("FountainPillar", Vector3.new(2, 8, 2), Vector3.new(0, 7, 50), "Medium stone grey", Enum.Material.Marble, cityFolder)
makePart("FountainTop", Vector3.new(6, 1, 6), Vector3.new(0, 11.5, 50), "Medium stone grey", Enum.Material.Marble, cityFolder)
makePart("FountainTopWater", Vector3.new(4, 0.3, 4), Vector3.new(0, 11.8, 50), Color3.fromRGB(65, 130, 175), Enum.Material.Water, cityFolder, {Transparency = 0.3})

local squareSign = makePart("SquareSign", Vector3.new(1, 1, 1), Vector3.new(0, 13, 50), "White", nil, cityFolder, {Transparency = 1})
makeSign(squareSign, "‚õ≤ Town Square", Vector3.new(0, 0, 0))

-- Benches around fountain
makePart("Bench1", Vector3.new(5, 1.5, 1.5), Vector3.new(-10, 0.75, 50), "Reddish brown", Enum.Material.Wood, cityFolder)
makePart("Bench2", Vector3.new(5, 1.5, 1.5), Vector3.new(10, 0.75, 50), "Reddish brown", Enum.Material.Wood, cityFolder)
makePart("Bench3", Vector3.new(1.5, 1.5, 5), Vector3.new(0, 0.75, 40), "Reddish brown", Enum.Material.Wood, cityFolder)
makePart("Bench4", Vector3.new(1.5, 1.5, 5), Vector3.new(0, 0.75, 60), "Reddish brown", Enum.Material.Wood, cityFolder)

-- Town square lanterns
makeLantern(Vector3.new(-10, 0, 44), cityFolder)
makeLantern(Vector3.new(10, 0, 44), cityFolder)
makeLantern(Vector3.new(-10, 0, 56), cityFolder)
makeLantern(Vector3.new(10, 0, 56), cityFolder)

-- ============================================================
-- === BANK OF HAVEN (east side) ===
-- ============================================================
local bankBuilding = getOrMake(cityFolder, "BankBuilding")
-- Foundation
makePart("BankFoundation", Vector3.new(22, 1, 18), Vector3.new(35, 0.5, 50), "Dark stone grey", Enum.Material.Cobblestone, bankBuilding)
-- Floor
makePart("BankFloor", Vector3.new(20, 0.3, 16), Vector3.new(35, 1.15, 50), "Reddish brown", Enum.Material.WoodPlanks, bankBuilding)
-- Walls
makePart("BankWallBack", Vector3.new(20, 12, 1), Vector3.new(35, 7, 42), "Brick yellow", Enum.Material.Brick, bankBuilding)
makePart("BankWallLeft", Vector3.new(1, 12, 16), Vector3.new(25, 7, 50), "Brick yellow", Enum.Material.Brick, bankBuilding)
makePart("BankWallRight", Vector3.new(1, 12, 16), Vector3.new(45, 7, 50), "Brick yellow", Enum.Material.Brick, bankBuilding)
-- Front wall with gap for door
makePart("BankFrontL", Vector3.new(7, 12, 1), Vector3.new(28.5, 7, 58), "Brick yellow", Enum.Material.Brick, bankBuilding)
makePart("BankFrontR", Vector3.new(7, 12, 1), Vector3.new(41.5, 7, 58), "Brick yellow", Enum.Material.Brick, bankBuilding)
makePart("BankFrontTop", Vector3.new(6, 4, 1), Vector3.new(35, 11, 58), "Brick yellow", Enum.Material.Brick, bankBuilding)
-- Roof
makePart("BankRoof", Vector3.new(24, 1.5, 20), Vector3.new(35, 13.75, 50), "Dark stone grey", Enum.Material.Slate, bankBuilding)
-- Peaked roof
makeWedge("BankRoofPeakL", Vector3.new(20, 6, 12), Vector3.new(35, 17.5, 44), "Dark stone grey", Enum.Material.Slate, bankBuilding, {Orientation = Vector3.new(0, 0, 0)})
-- Gold trim along roofline
makePart("BankGoldTrim", Vector3.new(24, 0.5, 0.5), Vector3.new(35, 14.75, 60), "Bright yellow", Enum.Material.Metal, bankBuilding)
-- Bank counter inside
makePart("BankCounter", Vector3.new(12, 3, 2), Vector3.new(35, 2.5, 48), "Reddish brown", Enum.Material.WoodPlanks, bankBuilding)
-- Gold bars on counter
makePart("GoldBar1", Vector3.new(1, 0.5, 0.5), Vector3.new(33, 4.25, 48), "Bright yellow", Enum.Material.Metal, bankBuilding)
makePart("GoldBar2", Vector3.new(1, 0.5, 0.5), Vector3.new(35, 4.25, 48), "Bright yellow", Enum.Material.Metal, bankBuilding)
makePart("GoldBar3", Vector3.new(1, 0.5, 0.5), Vector3.new(37, 4.25, 48), "Bright yellow", Enum.Material.Metal, bankBuilding)
-- Bank sign
local bankSign = makePart("BankSign", Vector3.new(1, 1, 1), Vector3.new(35, 16, 58), "White", nil, bankBuilding, {Transparency = 1})
makeSign(bankSign, "üè¶ BANK OF HAVEN", Vector3.new(0, 0, 0), UDim2.new(10, 0, 2, 0))
-- Bank torches
makeTorch(Vector3.new(26, 3, 58), bankBuilding)
makeTorch(Vector3.new(44, 3, 58), bankBuilding)

-- ============================================================
-- === GENERAL STORE (west side) ===
-- ============================================================
local shopBuilding = getOrMake(cityFolder, "ShopBuilding")
makePart("ShopFoundation", Vector3.new(18, 1, 14), Vector3.new(-35, 0.5, 50), "Dark stone grey", Enum.Material.Cobblestone, shopBuilding)
makePart("ShopFloor", Vector3.new(16, 0.3, 12), Vector3.new(-35, 1.15, 50), "Reddish brown", Enum.Material.WoodPlanks, shopBuilding)
makePart("ShopWallBack", Vector3.new(16, 10, 1), Vector3.new(-35, 6, 44), "Brick yellow", Enum.Material.Brick, shopBuilding)
makePart("ShopWallLeft", Vector3.new(1, 10, 12), Vector3.new(-43, 6, 50), "Brick yellow", Enum.Material.Brick, shopBuilding)
makePart("ShopWallRight", Vector3.new(1, 10, 12), Vector3.new(-27, 6, 50), "Brick yellow", Enum.Material.Brick, shopBuilding)
makePart("ShopRoof", Vector3.new(20, 1, 16), Vector3.new(-35, 11.5, 50), "Reddish brown", Enum.Material.Wood, shopBuilding)
-- Awning over door
makePart("ShopAwning", Vector3.new(10, 0.3, 4), Vector3.new(-35, 8, 58), "Bright red", Enum.Material.Fabric, shopBuilding)
-- Display shelves outside
makePart("ShopShelf1", Vector3.new(3, 3, 1), Vector3.new(-30, 1.5, 57), "Reddish brown", Enum.Material.Wood, shopBuilding)
makePart("ShopShelf2", Vector3.new(3, 3, 1), Vector3.new(-40, 1.5, 57), "Reddish brown", Enum.Material.Wood, shopBuilding)
-- Barrels
makePart("Barrel1", Vector3.new(2, 3, 2), Vector3.new(-44, 1.5, 55), "Reddish brown", Enum.Material.Wood, shopBuilding)
makePart("Barrel2", Vector3.new(2, 3, 2), Vector3.new(-44, 1.5, 52), "Reddish brown", Enum.Material.Wood, shopBuilding)
makePart("Barrel3", Vector3.new(2, 3, 2), Vector3.new(-44, 4.3, 53.5), "Reddish brown", Enum.Material.Wood, shopBuilding)
local shopSign = makePart("ShopSign", Vector3.new(1, 1, 1), Vector3.new(-35, 13, 56), "White", nil, shopBuilding, {Transparency = 1})
makeSign(shopSign, "üè™ General Store", Vector3.new(0, 0, 0))
makeTorch(Vector3.new(-27, 3, 56), shopBuilding)
makeTorch(Vector3.new(-43, 3, 56), shopBuilding)

-- ============================================================
-- === SMITHY & KITCHEN (northwest area) ===
-- ============================================================
local smithy = getOrMake(cityFolder, "Smithy")
makePart("SmithyFoundation", Vector3.new(20, 1, 16), Vector3.new(-35, 0.5, 20), "Dark stone grey", Enum.Material.Cobblestone, smithy)
makePart("SmithyFloor", Vector3.new(18, 0.3, 14), Vector3.new(-35, 1.15, 20), "Dark stone grey", Enum.Material.Slate, smithy)
-- Walls (open front for smoke/heat)
makePart("SmithyWallBack", Vector3.new(18, 10, 1), Vector3.new(-35, 6, 13), "Dark stone grey", Enum.Material.Cobblestone, smithy)
makePart("SmithyWallLeft", Vector3.new(1, 10, 14), Vector3.new(-44, 6, 20), "Dark stone grey", Enum.Material.Cobblestone, smithy)
makePart("SmithyWallRight", Vector3.new(1, 10, 8), Vector3.new(-26, 6, 17), "Dark stone grey", Enum.Material.Cobblestone, smithy)
makePart("SmithyRoof", Vector3.new(22, 1, 18), Vector3.new(-35, 11.5, 20), "Dark stone grey", Enum.Material.Slate, smithy)
-- Chimney
makePart("Chimney", Vector3.new(4, 8, 4), Vector3.new(-40, 16, 15), "Dark stone grey", Enum.Material.Cobblestone, smithy)
makePart("ChimneySmoke", Vector3.new(2, 2, 2), Vector3.new(-40, 21, 15), "Medium stone grey", Enum.Material.SmoothPlastic, smithy, {Transparency = 0.6})
-- Forge (big glowing furnace)
makePart("ForgeBase", Vector3.new(5, 3, 4), Vector3.new(-40, 2.5, 15), "Dark stone grey", Enum.Material.Cobblestone, smithy)
makePart("ForgeFire", Vector3.new(3, 2, 2), Vector3.new(-40, 2, 15), "Bright red", Enum.Material.Neon, smithy, {Transparency = 0.2})
local forgeLight = Instance.new("PointLight")
forgeLight.Color = Color3.fromRGB(255, 100, 30)
forgeLight.Brightness = 3
forgeLight.Range = 20
forgeLight.Parent = smithy:FindFirstChild("ForgeFire")
-- Anvil
makePart("Anvil", Vector3.new(2, 1.5, 3), Vector3.new(-35, 1.75, 18), "Black", Enum.Material.Metal, smithy)
makePart("AnvilHorn", Vector3.new(1, 0.5, 1), Vector3.new(-35, 2.75, 16.5), "Black", Enum.Material.Metal, smithy)
-- Weapon rack
makePart("WeaponRack", Vector3.new(0.5, 6, 4), Vector3.new(-43.5, 4, 18), "Reddish brown", Enum.Material.Wood, smithy)
makePart("RackSword1", Vector3.new(0.3, 4, 0.3), Vector3.new(-43.5, 4.5, 19.5), "Medium stone grey", Enum.Material.Metal, smithy)
makePart("RackSword2", Vector3.new(0.3, 3.5, 0.3), Vector3.new(-43.5, 4.5, 17.5), "Medium stone grey", Enum.Material.Metal, smithy)
-- Cooking range (next to smithy)
makePart("CookingRange", Vector3.new(4, 2, 4), Vector3.new(-30, 2, 18), "Bright orange", Enum.Material.Neon, smithy, {Transparency = 0.3})
makePart("CookingPot", Vector3.new(2, 1.5, 2), Vector3.new(-30, 3.5, 18), "Dark stone grey", Enum.Material.Metal, smithy)
local smithySign = makePart("SmithySign", Vector3.new(1, 1, 1), Vector3.new(-35, 13, 27), "White", nil, smithy, {Transparency = 1})
makeSign(smithySign, "üî® Smithy & Kitchen", Vector3.new(0, 0, 0))

-- === INTERACTIVE STATIONS FOR COOKING & SMITHING ===
-- Create stations folders for the cooking and smithing systems
local stationsFolder = Instance.new("Folder")
stationsFolder.Name = "SmithingStations"
stationsFolder.Parent = workspace

local cookingFolder = Instance.new("Folder")
cookingFolder.Name = "CookingFires"
cookingFolder.Parent = workspace

-- Smithing Furnace (interactive - reuse existing forge position)
local furnace = makePart("SmithingFurnace", Vector3.new(5, 3, 4), Vector3.new(-40, 2.5, 15), "Dark stone grey", Enum.Material.Cobblestone, stationsFolder)
furnace.Name = "SmithingFurnace"

-- Smithing Anvil (interactive - reuse existing anvil position) 
local anvil = makePart("SmithingAnvil", Vector3.new(2, 1.5, 3), Vector3.new(-35, 1.75, 18), "Black", Enum.Material.Metal, stationsFolder)
anvil.Name = "SmithingAnvil"

-- Cooking Fire (interactive - reuse existing cooking range position)
local cookingFire = makePart("CookingFire", Vector3.new(4, 2, 4), Vector3.new(-30, 2, 18), "Bright orange", Enum.Material.Neon, cookingFolder, {Transparency = 0.3})
cookingFire.Name = "CookingFire"

-- Additional cooking fire near Old Bess (tavern area)
local tavernFire = makePart("TavernCookingFire", Vector3.new(3, 1.5, 3), Vector3.new(10, 1.75, 35), "Bright orange", Enum.Material.Neon, cookingFolder, {Transparency = 0.3})
tavernFire.Name = "TavernCookingFire"

-- Cooking fire near the marketplace for easy access
local marketFire = makePart("MarketCookingFire", Vector3.new(2.5, 1.5, 2.5), Vector3.new(25, 1.75, 10), "Bright orange", Enum.Material.Neon, cookingFolder, {Transparency = 0.3})
marketFire.Name = "MarketCookingFire"

-- ============================================================
-- === CHAPEL OF LIGHT (northeast area) ===
-- ============================================================
local church = getOrMake(cityFolder, "Church")
makePart("ChurchFoundation", Vector3.new(16, 1, 22), Vector3.new(35, 0.5, 25), "White", Enum.Material.Marble, church)
makePart("ChurchFloor", Vector3.new(14, 0.3, 20), Vector3.new(35, 1.15, 25), "White", Enum.Material.Marble, church)
-- Walls
makePart("ChurchWallBack", Vector3.new(14, 14, 1), Vector3.new(35, 8, 15), "White", Enum.Material.Brick, church)
makePart("ChurchWallLeft", Vector3.new(1, 14, 20), Vector3.new(28, 8, 25), "White", Enum.Material.Brick, church)
makePart("ChurchWallRight", Vector3.new(1, 14, 20), Vector3.new(42, 8, 25), "White", Enum.Material.Brick, church)
-- Stained glass windows (colored panels)
makePart("StainedGlass1", Vector3.new(0.3, 4, 2), Vector3.new(28, 9, 22), "Bright blue", Enum.Material.Neon, church, {Transparency = 0.4})
makePart("StainedGlass2", Vector3.new(0.3, 4, 2), Vector3.new(42, 9, 22), "Bright violet", Enum.Material.Neon, church, {Transparency = 0.4})
makePart("StainedGlass3", Vector3.new(0.3, 4, 2), Vector3.new(28, 9, 28), "Bright green", Enum.Material.Neon, church, {Transparency = 0.4})
makePart("StainedGlass4", Vector3.new(0.3, 4, 2), Vector3.new(42, 9, 28), "Bright red", Enum.Material.Neon, church, {Transparency = 0.4})
-- Roof
makePart("ChurchRoof", Vector3.new(18, 1.5, 24), Vector3.new(35, 15.75, 25), "Dark stone grey", Enum.Material.Slate, church)
-- Steeple
makePart("Steeple", Vector3.new(6, 12, 6), Vector3.new(35, 22, 18), "Dark stone grey", Enum.Material.Slate, church)
makePart("SteepleTop", Vector3.new(3, 6, 3), Vector3.new(35, 31, 18), "Dark stone grey", Enum.Material.Slate, church)
-- Cross on top
makePart("CrossV", Vector3.new(0.5, 4, 0.5), Vector3.new(35, 36, 18), "Bright yellow", Enum.Material.Metal, church)
makePart("CrossH", Vector3.new(2.5, 0.5, 0.5), Vector3.new(35, 37, 18), "Bright yellow", Enum.Material.Metal, church)
-- Interior altar
makePart("Altar", Vector3.new(4, 3, 2), Vector3.new(35, 2.5, 16), "White", Enum.Material.Marble, church)
makePart("AltarCloth", Vector3.new(4.2, 0.1, 2.2), Vector3.new(35, 4.05, 16), "Bright violet", Enum.Material.Fabric, church)
-- Pews
for i = 1, 4 do
	makePart("Pew" .. i, Vector3.new(8, 2, 1.5), Vector3.new(35, 1, 20 + i * 3), "Reddish brown", Enum.Material.Wood, church)
end
local churchSign = makePart("ChurchSign", Vector3.new(1, 1, 1), Vector3.new(35, 17, 35), "White", nil, church, {Transparency = 1})
makeSign(churchSign, "‚õ™ Chapel of Light", Vector3.new(0, 0, 0))

-- ============================================================
-- === TAVERN (south-central, near gate) ===
-- ============================================================
local tavern = getOrMake(cityFolder, "Tavern")
makePart("TavernFoundation", Vector3.new(18, 1, 14), Vector3.new(-15, 0.5, 85), "Dark stone grey", Enum.Material.Cobblestone, tavern)
makePart("TavernFloor", Vector3.new(16, 0.3, 12), Vector3.new(-15, 1.15, 85), "Reddish brown", Enum.Material.WoodPlanks, tavern)
makePart("TavernWallBack", Vector3.new(16, 10, 1), Vector3.new(-15, 6, 79), "Brown", Enum.Material.Wood, tavern)
makePart("TavernWallLeft", Vector3.new(1, 10, 12), Vector3.new(-23, 6, 85), "Brown", Enum.Material.Wood, tavern)
makePart("TavernWallRight", Vector3.new(1, 10, 12), Vector3.new(-7, 6, 85), "Brown", Enum.Material.Wood, tavern)
makePart("TavernRoof", Vector3.new(20, 1, 16), Vector3.new(-15, 11.5, 85), "Reddish brown", Enum.Material.Wood, tavern)
-- Second floor
makePart("TavernFloor2", Vector3.new(16, 0.5, 12), Vector3.new(-15, 6, 85), "Reddish brown", Enum.Material.WoodPlanks, tavern, {Transparency = 0.1})
-- Bar counter
makePart("BarCounter", Vector3.new(10, 3, 2), Vector3.new(-15, 2.5, 81), "Reddish brown", Enum.Material.WoodPlanks, tavern)
-- Tables
makePart("Table1", Vector3.new(3, 2, 3), Vector3.new(-19, 2, 86), "Reddish brown", Enum.Material.Wood, tavern)
makePart("Table2", Vector3.new(3, 2, 3), Vector3.new(-11, 2, 86), "Reddish brown", Enum.Material.Wood, tavern)
-- Kegs behind bar
makePart("Keg1", Vector3.new(2, 3, 2), Vector3.new(-19, 1.5, 80), "Reddish brown", Enum.Material.Wood, tavern)
makePart("Keg2", Vector3.new(2, 3, 2), Vector3.new(-17, 1.5, 80), "Reddish brown", Enum.Material.Wood, tavern)
local tavernSign = makePart("TavernSign", Vector3.new(1, 1, 1), Vector3.new(-15, 13, 91), "White", nil, tavern, {Transparency = 1})
makeSign(tavernSign, "üç∫ The Rusty Blade Tavern", Vector3.new(0, 0, 0))
makeTorch(Vector3.new(-7, 3, 91), tavern)
makeTorch(Vector3.new(-23, 3, 91), tavern)

-- ============================================================
-- === GUARD TOWER (near gate, east side) ===
-- ============================================================
local guardTower = getOrMake(cityFolder, "GuardTower")
makePart("GTBase", Vector3.new(8, 20, 8), Vector3.new(15, 10, 85), "Medium stone grey", Enum.Material.Cobblestone, guardTower)
makePart("GTTop", Vector3.new(10, 1, 10), Vector3.new(15, 20.5, 85), "Dark stone grey", Enum.Material.Cobblestone, guardTower)
makePart("GTRail1", Vector3.new(10, 3, 0.5), Vector3.new(15, 22.5, 80), "Dark stone grey", Enum.Material.Cobblestone, guardTower)
makePart("GTRail2", Vector3.new(10, 3, 0.5), Vector3.new(15, 22.5, 90), "Dark stone grey", Enum.Material.Cobblestone, guardTower)
makePart("GTRail3", Vector3.new(0.5, 3, 10), Vector3.new(10, 22.5, 85), "Dark stone grey", Enum.Material.Cobblestone, guardTower)
makePart("GTRail4", Vector3.new(0.5, 3, 10), Vector3.new(20, 22.5, 85), "Dark stone grey", Enum.Material.Cobblestone, guardTower)
-- Ladder
makePart("Ladder", Vector3.new(0.5, 20, 2), Vector3.new(19, 10, 85), "Reddish brown", Enum.Material.Wood, guardTower)
local gtSign = makePart("GTSign", Vector3.new(1, 1, 1), Vector3.new(15, 25, 85), "White", nil, guardTower, {Transparency = 1})
makeSign(gtSign, "üõ°Ô∏è Guard Tower", Vector3.new(0, 0, 0))

-- ============================================================
-- === MARKETPLACE (south-west area) ===
-- ============================================================
local market = getOrMake(cityFolder, "Market")
-- Market stalls
for i = 0, 3 do
	local xOff = -50 + i * 10
	local stallColor = ({"Bright red", "Bright blue", "Bright green", "Bright yellow"})[i + 1]
	-- Posts
	makePart("Stall" .. i .. "PostL", Vector3.new(0.5, 6, 0.5), Vector3.new(xOff - 3, 3, 75), "Reddish brown", Enum.Material.Wood, market)
	makePart("Stall" .. i .. "PostR", Vector3.new(0.5, 6, 0.5), Vector3.new(xOff + 3, 3, 75), "Reddish brown", Enum.Material.Wood, market)
	-- Awning
	makePart("Stall" .. i .. "Awning", Vector3.new(7, 0.2, 5), Vector3.new(xOff, 6.5, 75), stallColor, Enum.Material.Fabric, market)
	-- Counter
	makePart("Stall" .. i .. "Counter", Vector3.new(6, 3, 2), Vector3.new(xOff, 1.5, 76), "Reddish brown", Enum.Material.WoodPlanks, market)
end
local marketSign = makePart("MarketSign", Vector3.new(1, 1, 1), Vector3.new(-35, 8, 75), "White", nil, market, {Transparency = 1})
makeSign(marketSign, "üè™ Marketplace", Vector3.new(0, 0, 0))

-- ============================================================
-- === FISHING POND (south-east, inside walls) ===
-- ============================================================
local pond = getOrMake(safeZone, "FishingPond")
-- Pond water
makePart("PondWater", Vector3.new(30, 0.5, 20), Vector3.new(80, -0.25, 80), Color3.fromRGB(65, 130, 175), Enum.Material.Water, pond, {Transparency = 0.3})
-- Pond banks (dirt edges)
makePart("PondBankN", Vector3.new(34, 1, 3), Vector3.new(80, 0, 69), "Brown", Enum.Material.Ground, pond)
makePart("PondBankS", Vector3.new(34, 1, 3), Vector3.new(80, 0, 91), "Brown", Enum.Material.Ground, pond)
makePart("PondBankW", Vector3.new(3, 1, 20), Vector3.new(64, 0, 80), "Brown", Enum.Material.Ground, pond)
makePart("PondBankE", Vector3.new(3, 1, 20), Vector3.new(96, 0, 80), "Brown", Enum.Material.Ground, pond)
-- Reeds / cattails
for i = 1, 6 do
	local rx = 64 + math.random(0, 30)
	local rz = 70 + math.random(0, 18)
	makePart("Reed" .. i, Vector3.new(0.3, 3 + math.random(), 0.3), Vector3.new(rx, 1.5, rz), "Earth green", Enum.Material.Grass, pond)
end
-- Dock / pier
makePart("Dock", Vector3.new(4, 0.5, 12), Vector3.new(80, 0.5, 86), "Reddish brown", Enum.Material.WoodPlanks, pond)
makePart("DockPost1", Vector3.new(0.5, 3, 0.5), Vector3.new(78, 0.5, 92), "Reddish brown", Enum.Material.Wood, pond)
makePart("DockPost2", Vector3.new(0.5, 3, 0.5), Vector3.new(82, 0.5, 92), "Reddish brown", Enum.Material.Wood, pond)
local pondSign = makePart("PondSign", Vector3.new(1, 1, 1), Vector3.new(80, 3, 68), "White", nil, pond, {Transparency = 1})
makeSign(pondSign, "üé£ Haven Pond", Vector3.new(0, 0, 0))

-- Second smaller pond (lily pond)
makePart("LilyPond", Vector3.new(14, 0.5, 10), Vector3.new(110, -0.25, 60), Color3.fromRGB(65, 130, 175), Enum.Material.Water, pond, {Transparency = 0.3})
makePart("LilyPondBank", Vector3.new(18, 0.8, 14), Vector3.new(110, -0.1, 60), "Brown", Enum.Material.Ground, pond)
-- Lily pads
for i = 1, 4 do
	makePart("LilyPad" .. i, Vector3.new(2, 0.1, 2), Vector3.new(106 + i * 2, 0.1, 58 + math.random(-3, 3)), "Earth green", Enum.Material.Grass, pond)
end

-- ============================================================
-- === MINING CAVE (west side, outside walls) ===
-- ============================================================
local mine = getOrMake(safeZone, "MiningCave")
-- Cave entrance (big rocky arch)
makePart("CaveWallL", Vector3.new(6, 16, 8), Vector3.new(-100, 8, 30), "Dark stone grey", Enum.Material.Slate, mine)
makePart("CaveWallR", Vector3.new(6, 16, 8), Vector3.new(-86, 8, 30), "Dark stone grey", Enum.Material.Slate, mine)
makePart("CaveArch", Vector3.new(20, 5, 8), Vector3.new(-93, 18.5, 30), "Dark stone grey", Enum.Material.Slate, mine)
-- Cave interior (hollowed out area)
makePart("CaveFloor", Vector3.new(30, 0.3, 30), Vector3.new(-93, 0.15, 15), "Dark stone grey", Enum.Material.Slate, mine)
makePart("CaveRoof", Vector3.new(34, 2, 34), Vector3.new(-93, 14, 15), "Dark stone grey", Enum.Material.Slate, mine)
makePart("CaveWallBack", Vector3.new(34, 14, 2), Vector3.new(-93, 7, -1), "Dark stone grey", Enum.Material.Slate, mine)
makePart("CaveWallSideL", Vector3.new(2, 14, 34), Vector3.new(-110, 7, 15), "Dark stone grey", Enum.Material.Slate, mine)
makePart("CaveWallSideR", Vector3.new(2, 14, 34), Vector3.new(-76, 7, 15), "Dark stone grey", Enum.Material.Slate, mine)
-- Cave supports (wooden beams)
makePart("Support1", Vector3.new(1, 12, 1), Vector3.new(-100, 6, 20), "Reddish brown", Enum.Material.Wood, mine)
makePart("Support2", Vector3.new(1, 12, 1), Vector3.new(-86, 6, 20), "Reddish brown", Enum.Material.Wood, mine)
makePart("SupportBeam", Vector3.new(16, 1, 1), Vector3.new(-93, 12, 20), "Reddish brown", Enum.Material.Wood, mine)
makePart("Support3", Vector3.new(1, 12, 1), Vector3.new(-100, 6, 8), "Reddish brown", Enum.Material.Wood, mine)
makePart("Support4", Vector3.new(1, 12, 1), Vector3.new(-86, 6, 8), "Reddish brown", Enum.Material.Wood, mine)
makePart("SupportBeam2", Vector3.new(16, 1, 1), Vector3.new(-93, 12, 8), "Reddish brown", Enum.Material.Wood, mine)
-- Mine cart tracks
makePart("Track1", Vector3.new(0.3, 0.2, 30), Vector3.new(-91.5, 0.3, 15), "Dark stone grey", Enum.Material.Metal, mine)
makePart("Track2", Vector3.new(0.3, 0.2, 30), Vector3.new(-94.5, 0.3, 15), "Dark stone grey", Enum.Material.Metal, mine)
-- Mine cart
makePart("CartBody", Vector3.new(3, 2, 4), Vector3.new(-93, 1.5, 22), "Dark stone grey", Enum.Material.Metal, mine)
makePart("CartWheel1", Vector3.new(1.5, 1.5, 0.3), Vector3.new(-91.5, 0.8, 24), "Black", Enum.Material.Metal, mine)
makePart("CartWheel2", Vector3.new(1.5, 1.5, 0.3), Vector3.new(-94.5, 0.8, 24), "Black", Enum.Material.Metal, mine)
-- Torch lighting inside cave
makeTorch(Vector3.new(-100, 3, 15), mine)
makeTorch(Vector3.new(-86, 3, 15), mine)
makeTorch(Vector3.new(-100, 3, 5), mine)
makeTorch(Vector3.new(-86, 3, 5), mine)
-- Ore veins (visual, the actual clickable nodes are from SkillManager)
makePart("OreVeinCopper", Vector3.new(3, 3, 1), Vector3.new(-109, 3, 10), "Nougat", Enum.Material.Slate, mine)
makePart("OreVeinIron", Vector3.new(2, 4, 1), Vector3.new(-109, 4, 18), "Dark stone grey", Enum.Material.Slate, mine)
local mineSign = makePart("MineSign", Vector3.new(1, 1, 1), Vector3.new(-93, 22, 34), "White", nil, mine, {Transparency = 1})
makeSign(mineSign, "‚õèÔ∏è Haven Mine", Vector3.new(0, 0, 0), UDim2.new(10, 0, 2, 0))

-- ============================================================
-- === FOREST (east side, outside walls) ===
-- ============================================================
local forest = getOrMake(safeZone, "Forest")
-- Grass clearing floor
makePart("ForestFloor", Vector3.new(80, 0.15, 80), Vector3.new(130, 0.08, 30), "Earth green", Enum.Material.Grass, forest)
-- Scattered decorative trees (non-clickable, just scenery)
local function makeSceneryTree(pos, scale, leafColor)
	scale = scale or 1
	leafColor = leafColor or "Forest green"
	makePart("STree", Vector3.new(2*scale, 10*scale, 2*scale), pos + Vector3.new(0, 5*scale, 0), "Reddish brown", Enum.Material.Wood, forest)
	makePart("SLeaf", Vector3.new(10*scale, 10*scale, 10*scale), pos + Vector3.new(0, 11*scale, 0), leafColor, Enum.Material.Grass, forest)
end
-- Dense forest ‚Äî many trees
local treePositions = {
	{100, 0, 10}, {110, 0, 15}, {120, 0, 5}, {105, 0, 25}, {115, 0, 30},
	{130, 0, 10}, {140, 0, 20}, {150, 0, 15}, {135, 0, 35}, {145, 0, 40},
	{100, 0, 45}, {110, 0, 50}, {125, 0, 55}, {155, 0, 30}, {160, 0, 45},
	{115, 0, 60}, {130, 0, 65}, {145, 0, 55}, {150, 0, 65}, {105, 0, 70},
}
for _, tp in ipairs(treePositions) do
	local scale = 0.7 + math.random() * 0.6
	local colors = {"Forest green", "Earth green", "Dark green", "Bright green"}
	makeSceneryTree(Vector3.new(tp[1], tp[2], tp[3]), scale, colors[math.random(#colors)])
end
-- Path into forest
makePart("ForestPath", Vector3.new(4, 0.12, 40), Vector3.new(90, 0.06, 30), "Brown", Enum.Material.Ground, forest)
local forestSign = makePart("ForestSign", Vector3.new(1, 1, 1), Vector3.new(90, 4, 50), "White", nil, forest, {Transparency = 1})
makeSign(forestSign, "üå≤ Haven Forest", Vector3.new(0, 0, 0))

-- ============================================================
-- === WILDERNESS DECORATIONS ===
-- ============================================================

-- Dead trees scattered
local function makeDeadTree(position)
	makePart("DeadTrunk", Vector3.new(1.5, 7, 1.5), position + Vector3.new(0, 3.5, 0), "Dark stone grey", Enum.Material.Wood, wilderness)
	makePart("DeadBranch1", Vector3.new(0.5, 3, 0.5), position + Vector3.new(1.5, 6, 0), "Dark stone grey", Enum.Material.Wood, wilderness, {Orientation = Vector3.new(0, 0, 30)})
	makePart("DeadBranch2", Vector3.new(0.5, 2.5, 0.5), position + Vector3.new(-1, 5, 0.5), "Dark stone grey", Enum.Material.Wood, wilderness, {Orientation = Vector3.new(0, 0, -25)})
end

local deadTreePos = {
	{20, 0, -120}, {-30, 0, -140}, {50, 0, -160}, {-15, 0, -180},
	{35, 0, -200}, {-45, 0, -220}, {70, 0, -130}, {-60, 0, -170},
	{10, 0, -250}, {-40, 0, -280}, {80, 0, -210}, {-70, 0, -240},
}
for _, dt in ipairs(deadTreePos) do
	makeDeadTree(Vector3.new(dt[1], dt[2], dt[3]))
end

-- Skull warning signs
local function makeWarningSign(position)
	local post = makePart("SignPost", Vector3.new(0.5, 4, 0.5), position + Vector3.new(0, 2, 0), "Reddish brown", Enum.Material.Wood, wilderness)
	local board = makePart("SignBoard", Vector3.new(3, 2, 0.3), position + Vector3.new(0, 4.5, 0), "Brown", Enum.Material.Wood, wilderness)
	makeSign(board, "‚ò†Ô∏è DANGER", Vector3.new(0, 1, 0))
end
makeWarningSign(Vector3.new(25, 0, -105))
makeWarningSign(Vector3.new(-25, 0, -105))
makeWarningSign(Vector3.new(0, 0, -105))
makeWarningSign(Vector3.new(60, 0, -105))
makeWarningSign(Vector3.new(-60, 0, -105))

-- Ancient ruins (bigger)
local ruins = getOrMake(wilderness, "AncientRuins")
makePart("RuinWall1", Vector3.new(6, 10, 1.5), Vector3.new(60, 5, -170), "Medium stone grey", Enum.Material.Cobblestone, ruins)
makePart("RuinWall2", Vector3.new(1.5, 8, 10), Vector3.new(66, 4, -175), "Medium stone grey", Enum.Material.Cobblestone, ruins)
makePart("RuinWall3", Vector3.new(6, 5, 1.5), Vector3.new(60, 2.5, -180), "Medium stone grey", Enum.Material.Cobblestone, ruins)
makePart("RuinFloor", Vector3.new(14, 0.3, 14), Vector3.new(61, 0.15, -175), "Medium stone grey", Enum.Material.Cobblestone, ruins)
-- Broken pillars
makePart("Pillar1", Vector3.new(2, 8, 2), Vector3.new(55, 4, -172), "Medium stone grey", Enum.Material.Marble, ruins)
makePart("Pillar2", Vector3.new(2, 5, 2), Vector3.new(67, 2.5, -178), "Medium stone grey", Enum.Material.Marble, ruins)
makePart("PillarBroken", Vector3.new(2, 3, 2), Vector3.new(55, 1.5, -178), "Medium stone grey", Enum.Material.Marble, ruins)
local ruinSign = makePart("RuinSign", Vector3.new(1, 1, 1), Vector3.new(61, 12, -175), "White", nil, ruins, {Transparency = 1})
makeSign(ruinSign, "üèõÔ∏è Ancient Ruins", Vector3.new(0, 0, 0))

-- Wilderness graveyard
local graveyard = getOrMake(wilderness, "Graveyard")
for i = 1, 8 do
	local gx = -50 + (i % 4) * 8
	local gz = -145 - math.floor(i / 4) * 8
	makePart("Grave" .. i, Vector3.new(2, 3, 0.5), Vector3.new(gx, 1.5, gz), "Medium stone grey", Enum.Material.Cobblestone, graveyard)
	makePart("GraveMound" .. i, Vector3.new(3, 0.5, 4), Vector3.new(gx, 0.25, gz + 2.5), "Brown", Enum.Material.Ground, graveyard)
end
-- Spooky fence
makePart("GraveFence1", Vector3.new(40, 3, 0.3), Vector3.new(-34, 1.5, -140), "Black", Enum.Material.Metal, graveyard)
makePart("GraveFence2", Vector3.new(0.3, 3, 20), Vector3.new(-54, 1.5, -150), "Black", Enum.Material.Metal, graveyard)
makePart("GraveFence3", Vector3.new(0.3, 3, 20), Vector3.new(-14, 1.5, -150), "Black", Enum.Material.Metal, graveyard)
local graveSign = makePart("GraveSign", Vector3.new(1, 1, 1), Vector3.new(-34, 5, -140), "White", nil, graveyard, {Transparency = 1})
makeSign(graveSign, "üíÄ Forgotten Graveyard", Vector3.new(0, 0, 0))

-- Lava pit (deep wilderness)
makePart("LavaRim", Vector3.new(20, 1, 20), Vector3.new(0, 0.5, -260), "Dark stone grey", Enum.Material.Slate, wilderness)
makePart("LavaPit", Vector3.new(16, 0.5, 16), Vector3.new(0, 0.1, -260), "Bright red", Enum.Material.Neon, wilderness, {Transparency = 0.2})
local lavaLight = Instance.new("PointLight")
lavaLight.Color = Color3.fromRGB(255, 60, 20)
lavaLight.Brightness = 4
lavaLight.Range = 40
lavaLight.Parent = wilderness:FindFirstChild("LavaPit") or wilderness
-- Lava rocks around pit
makePart("LavaRock1", Vector3.new(4, 3, 3), Vector3.new(12, 1.5, -255), "Black", Enum.Material.Slate, wilderness)
makePart("LavaRock2", Vector3.new(3, 4, 4), Vector3.new(-10, 2, -265), "Black", Enum.Material.Slate, wilderness)
makePart("LavaRock3", Vector3.new(5, 2, 3), Vector3.new(5, 1, -270), "Black", Enum.Material.Slate, wilderness)

-- Wilderness dark pond (for dark crabs)
local darkPond = getOrMake(wilderness, "DarkPond")
makePart("DarkPondWater", Vector3.new(20, 0.5, 14), Vector3.new(-60, -0.25, -210), Color3.fromRGB(30, 80, 120), Enum.Material.Water, darkPond, {Transparency = 0.3})
makePart("DarkPondBank", Vector3.new(24, 0.8, 18), Vector3.new(-60, -0.1, -210), "Dark stone grey", Enum.Material.Ground, darkPond)
-- Glowing mushrooms around dark pond
for i = 1, 5 do
	local mx = -68 + math.random(0, 16)
	local mz = -218 + math.random(0, 16)
	local shroom = makePart("Mushroom" .. i, Vector3.new(1, 1.5, 1), Vector3.new(mx, 0.75, mz), "Bright violet", Enum.Material.Neon, darkPond, {Transparency = 0.3})
	local shroomLight = Instance.new("PointLight")
	shroomLight.Color = Color3.fromRGB(180, 50, 255)
	shroomLight.Brightness = 1
	shroomLight.Range = 8
	shroomLight.Parent = shroom
end
local darkPondSign = makePart("DPSign", Vector3.new(1, 1, 1), Vector3.new(-60, 3, -200), "White", nil, darkPond, {Transparency = 1})
makeSign(darkPondSign, "üåë Dark Waters", Vector3.new(0, 0, 0))

-- Scattered boulders in wilderness
for i = 1, 10 do
	local bx = math.random(-150, 150)
	local bz = math.random(-300, -110)
	local bs = 3 + math.random() * 4
	makePart("Boulder" .. i, Vector3.new(bs, bs * 0.7, bs), Vector3.new(bx, bs * 0.35, bz), "Dark stone grey", Enum.Material.Slate, wilderness)
end

-- ============================================================
-- === TERRAIN FEATURES ===
-- ============================================================

-- ---- ROLLING HILLS (farmlands area) ----
local hillData = {
	{170, 3, 130, 30, 6, 25}, {220, 4, 180, 25, 8, 20}, {280, 2.5, 160, 35, 5, 30},
	{310, 3.5, 200, 20, 7, 22}, {190, 2, 220, 28, 4, 24}, {250, 3, 240, 22, 6, 18},
	{150, 2, 200, 18, 4, 16},
}
for i, h in ipairs(hillData) do
	makePart("FarmHill"..i, Vector3.new(h[4], h[2], h[6]), Vector3.new(h[1], h[2]/2, h[3]), "Bright green", Enum.Material.Grass, safeZone)
end

-- ---- GENTLE HILLS AROUND HAVEN ----
local havenHillData = {
	{-30, 2, 140, 20, 15}, {30, 1.5, 150, 18, 14}, {-50, 2.5, 160, 25, 20},
	{50, 2, 170, 22, 16}, {0, 1.8, 180, 30, 20}, {-80, 2, 130, 15, 12},
	{80, 1.5, 145, 16, 14},
}
for i, h in ipairs(havenHillData) do
	makePart("HavenHill"..i, Vector3.new(h[4], h[2], h[5]), Vector3.new(h[1], h[2]/2, h[3]), "Bright green", Enum.Material.Grass, safeZone)
end

-- ---- MOUNTAIN FOOTHILLS (approaching Dragon's Spine) ----
local foothillData = {
	{-180, 8, -270, 20, 18}, {-140, 6, -260, 15, 14}, {-100, 10, -290, 25, 22},
	{-60, 7, -300, 18, 16}, {-120, 5, -250, 12, 12}, {-160, 9, -310, 22, 20},
}
for i, h in ipairs(foothillData) do
	makePart("Foothill"..i, Vector3.new(h[4], h[2], h[5]), Vector3.new(h[1], h[2]/2, h[3]), "Dark stone grey", Enum.Material.Slate, wilderness)
end
-- Large boulders near foothills
for i = 1, 8 do
	local bx = -200 + math.random(0, 150)
	local bz = -350 + math.random(0, 100)
	local bs = 4 + math.random() * 5
	makePart("FoothillBoulder"..i, Vector3.new(bs, bs * 0.8, bs * 0.9), Vector3.new(bx, bs * 0.4, bz), "Dark stone grey", Enum.Material.Slate, wilderness)
end

-- ---- SUNKEN VALLEY IN DARK FOREST ----
makePart("DarkValleyFloor", Vector3.new(100, 0.3, 80), Vector3.new(130, -0.5, -180), "Really black", Enum.Material.Ground, wilderness)
-- Fog in dark valley
for i = 1, 8 do
	local fx = 80 + math.random(0, 100)
	local fz = -220 + math.random(0, 80)
	makePart("DarkValleyFog"..i, Vector3.new(20 + math.random(0, 15), 4, 20 + math.random(0, 15)), Vector3.new(fx, 2, fz), "Really black", Enum.Material.SmoothPlastic, wilderness, {Transparency = 0.85, CanCollide = false})
end

-- ---- RIVER VALLEY (east-west, Z around 0) ----
makePart("RiverWater", Vector3.new(200, 0.5, 8), Vector3.new(0, -0.3, 0), Color3.fromRGB(65, 130, 175), Enum.Material.Water, safeZone, {Transparency = 0.3, CanCollide = false})
makePart("RiverBankN", Vector3.new(200, 0.6, 3), Vector3.new(0, 0, -5), "Brown", Enum.Material.Ground, safeZone)
makePart("RiverBankS", Vector3.new(200, 0.6, 3), Vector3.new(0, 0, 5), "Brown", Enum.Material.Ground, safeZone)
-- Stone bridge over river
makePart("BridgeDeck", Vector3.new(10, 1, 12), Vector3.new(0, 1, 0), "Medium stone grey", Enum.Material.Cobblestone, safeZone)
makePart("BridgeRailL", Vector3.new(1, 3, 12), Vector3.new(-5, 2.5, 0), "Medium stone grey", Enum.Material.Cobblestone, safeZone)
makePart("BridgeRailR", Vector3.new(1, 3, 12), Vector3.new(5, 2.5, 0), "Medium stone grey", Enum.Material.Cobblestone, safeZone)

-- ---- CRATER NEAR THE ABYSS ----
makePart("CraterRim", Vector3.new(100, 2, 70), Vector3.new(0, 1, -465), "Really black", Enum.Material.Slate, wilderness)
makePart("CraterFloor", Vector3.new(80, 0.3, 50), Vector3.new(0, -1, -465), "Really black", Enum.Material.Ground, wilderness)
-- Neon cracks in crater
for i = 1, 6 do
	local cx = -30 + math.random(0, 60)
	local cz = -490 + math.random(0, 50)
	makePart("CraterCrack"..i, Vector3.new(math.random(5, 15), 0.3, 0.5), Vector3.new(cx, -0.5, cz), "Bright orange", Enum.Material.Neon, wilderness, {Transparency = 0.2})
end

-- ---- ROCKY OUTCROPS (scattered boulders in wilderness) ----
for i = 1, 15 do
	local bx = math.random(-200, 200)
	local bz = math.random(-380, -110)
	local bs = 3 + math.random() * 6
	makePart("WildBoulder"..i, Vector3.new(bs, bs * 0.7, bs * 0.8), Vector3.new(bx, bs * 0.35, bz), "Dark stone grey", Enum.Material.Slate, wilderness)
end

-- Rock formations near mine entrance
for i = 1, 5 do
	local rx = -110 + math.random(0, 30)
	local rz = 20 + math.random(0, 20)
	local rs = 3 + math.random() * 4
	makePart("MineRock"..i, Vector3.new(rs, rs * 1.2, rs * 0.8), Vector3.new(rx, rs * 0.6, rz), "Dark stone grey", Enum.Material.Slate, safeZone)
end

-- ---- VEGETATION: BUSHES (safe zone) ----
for i = 1, 25 do
	local bx = math.random(-80, 160)
	local bz = math.random(110, 250)
	local bs = 1.5 + math.random() * 2
	makePart("Bush"..i, Vector3.new(bs, bs * 0.7, bs), Vector3.new(bx, bs * 0.35, bz), "Forest green", Enum.Material.Grass, safeZone, {CanCollide = false})
end

-- ---- DEAD BUSHES (wilderness) ----
for i = 1, 15 do
	local bx = math.random(-150, 150)
	local bz = math.random(-300, -110)
	makePart("DeadBush"..i, Vector3.new(1 + math.random(), 1 + math.random() * 0.5, 1 + math.random()), Vector3.new(bx, 0.5, bz), "Brown", Enum.Material.Grass, wilderness, {CanCollide = false})
end

-- ---- MUSHROOM CLUSTERS IN DARK FOREST ----
for i = 1, 10 do
	local mx = 80 + math.random(0, 100)
	local mz = -210 + math.random(0, 80)
	makePart("RedMushroom"..i, Vector3.new(0.8, 1.2, 0.8), Vector3.new(mx, 0.6, mz), "Bright red", Enum.Material.SmoothPlastic, wilderness, {CanCollide = false})
	makePart("MushroomSpot"..i, Vector3.new(0.3, 0.3, 0.1), Vector3.new(mx + 0.2, 1, mz), "White", Enum.Material.SmoothPlastic, wilderness, {CanCollide = false})
end

-- ---- FLOWER PATCHES NEAR HAVEN ----
local flowerColors = {"Bright red", "Bright yellow", "Bright violet", "Bright blue", "Hot pink"}
for i = 1, 20 do
	local fx = math.random(-50, 50)
	local fz = math.random(115, 160)
	makePart("Flower"..i, Vector3.new(0.5, 0.8, 0.5), Vector3.new(fx, 0.4, fz), flowerColors[math.random(#flowerColors)], Enum.Material.SmoothPlastic, safeZone, {CanCollide = false})
end

-- ---- DIRT PATHS FROM GATES ----
-- North gate path
makePart("NorthPath", Vector3.new(8, 0.12, 80), Vector3.new(0, 0.06, -50), "Brown", Enum.Material.Ground, safeZone)
-- West gate path
makePart("WestPath", Vector3.new(30, 0.12, 6), Vector3.new(-78, 0.06, 50), "Brown", Enum.Material.Ground, safeZone)
-- East gate path
makePart("EastPath", Vector3.new(30, 0.12, 6), Vector3.new(78, 0.06, 50), "Brown", Enum.Material.Ground, safeZone)
-- South gate path (already has MainRoad, extend outward)
makePart("SouthPath", Vector3.new(8, 0.12, 40), Vector3.new(0, 0.06, 128), "Brown", Enum.Material.Ground, safeZone)

-- ---- WILDERNESS PATHS ----
makePart("WildPath1", Vector3.new(5, 0.12, 150), Vector3.new(0, 0.06, -175), "Dark stone grey", Enum.Material.Ground, wilderness)
makePart("WildPath2", Vector3.new(100, 0.12, 5), Vector3.new(0, 0.06, -150), "Dark stone grey", Enum.Material.Ground, wilderness)

-- ---- WILDERNESS FOG PATCHES ----
for i = 1, 10 do
	local fx = math.random(-180, 180)
	local fz = math.random(-350, -120)
	makePart("WildFog"..i, Vector3.new(30 + math.random(0, 20), 5, 30 + math.random(0, 20)), Vector3.new(fx, 2.5, fz), "Dark stone grey", Enum.Material.SmoothPlastic, wilderness, {Transparency = 0.88, CanCollide = false})
end

-- ---- LAVA GLOW NEAR ABYSS ----
for i = 1, 6 do
	local lx = -40 + math.random(0, 80)
	local lz = -510 + math.random(0, 70)
	local lg = makePart("LavaGlow"..i, Vector3.new(8 + math.random(0, 10), 0.3, 8 + math.random(0, 10)), Vector3.new(lx, 0.2, lz), "Bright orange", Enum.Material.Neon, wilderness, {Transparency = 0.3, CanCollide = false})
end

-- ---- SWAMP BUBBLES ----
for i = 1, 12 do
	local sx = 50 + math.random(0, 140)
	local sz = -370 + math.random(0, 90)
	makePart("SwampBubble"..i, Vector3.new(0.5, 0.5, 0.5), Vector3.new(sx, 0.3, sz), "Bright green", Enum.Material.SmoothPlastic, wilderness, {Transparency = 0.5, CanCollide = false})
end

-- ============================================================
-- === LIGHTING ===
-- ============================================================
local Lighting = game:GetService("Lighting")
Lighting.Ambient = Color3.fromRGB(80, 80, 100)
Lighting.OutdoorAmbient = Color3.fromRGB(100, 100, 120)
Lighting.Brightness = 2
Lighting.ClockTime = 10
Lighting.FogEnd = 1200
Lighting.FogColor = Color3.fromRGB(180, 200, 220)

-- ============================================================
print("[MapSetup] World generation complete!")
print("[MapSetup] City: Haven ‚Äî walls, gate, bank, shop, smithy, chapel, tavern, guard tower, marketplace")
print("[MapSetup] Outside: Haven Pond, Haven Mine, Haven Forest")
print("[MapSetup] Wilderness: dead trees, graveyard, ruins, dark pond, lava pit, boulders")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="44">
      <Properties>
        <string name="Name">MapSetup2</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- MapSetup2.server.lua
-- WORLD EXPANSION: Areas outside Haven, safe zone content, and deep wilderness
-- Runs AFTER MapSetup.server.lua

task.wait(1) -- let MapSetup finish first
print("[MapSetup2] Starting world expansion...")

local WS = game:GetService("Workspace")

local function makePart(name, size, position, color, material, parent, props)
	local p = Instance.new("Part")
	p.Name = name
	p.Size = size
	p.Position = position
	p.Anchored = true
	if typeof(color) == "Color3" then
		p.Color = color
	else
		p.BrickColor = BrickColor.new(color)
	end
	p.Material = material or Enum.Material.SmoothPlastic
	p.Parent = parent
	if props then for k, v in pairs(props) do p[k] = v end end
	return p
end

local function makeSign(parent, text, offset, size)
	local bg = Instance.new("BillboardGui")
	bg.Size = size or UDim2.new(10, 0, 2.5, 0)
	bg.StudsOffset = offset or Vector3.new(0, 5, 0)
	bg.Parent = parent
	local tl = Instance.new("TextLabel")
	tl.Size = UDim2.new(1, 0, 1, 0)
	tl.BackgroundTransparency = 1
	tl.Text = text
	tl.TextColor3 = Color3.fromRGB(255, 255, 255)
	tl.TextScaled = true
	tl.Font = Enum.Font.GothamBold
	tl.TextStrokeTransparency = 0.3
	tl.Parent = bg
	return bg
end

local function makeTorch(position, parent)
	local pole = makePart("TorchPole", Vector3.new(0.5, 6, 0.5), position, "Reddish brown", Enum.Material.Wood, parent)
	local flame = makePart("TorchFlame", Vector3.new(1, 1.5, 1), position + Vector3.new(0, 3.5, 0), "Bright orange", Enum.Material.Neon, parent, {Transparency = 0.2})
	local light = Instance.new("PointLight")
	light.Color = Color3.fromRGB(255, 150, 50)
	light.Brightness = 2
	light.Range = 20
	light.Parent = flame
end

local function makeLantern(position, parent)
	makePart("LPost", Vector3.new(0.4, 5, 0.4), position, "Dark stone grey", Enum.Material.Metal, parent)
	local lamp = makePart("Lamp", Vector3.new(1.2, 1.5, 1.2), position + Vector3.new(0, 3.2, 0), "Bright yellow", Enum.Material.Neon, parent, {Transparency = 0.3})
	local light = Instance.new("PointLight")
	light.Color = Color3.fromRGB(255, 220, 120)
	light.Brightness = 1.5
	light.Range = 25
	light.Parent = lamp
end

local function makeTree(position, parent, scale, leafColor)
	scale = scale or 1
	leafColor = leafColor or "Forest green"
	makePart("Trunk", Vector3.new(2*scale, 10*scale, 2*scale), position + Vector3.new(0, 5*scale, 0), "Reddish brown", Enum.Material.Wood, parent)
	makePart("Leaves", Vector3.new(10*scale, 10*scale, 10*scale), position + Vector3.new(0, 11*scale, 0), leafColor, Enum.Material.Grass, parent)
end

local function makeHouse(position, parent, width, depth, height, wallColor, roofColor, name)
	local f = Instance.new("Folder") f.Name = name or "House" f.Parent = parent
	makePart("Floor", Vector3.new(width, 0.3, depth), position + Vector3.new(0, 0.15, 0), "Reddish brown", Enum.Material.WoodPlanks, f)
	makePart("WallBack", Vector3.new(width, height, 1), position + Vector3.new(0, height/2, -depth/2), wallColor, Enum.Material.Brick, f)
	makePart("WallLeft", Vector3.new(1, height, depth), position + Vector3.new(-width/2, height/2, 0), wallColor, Enum.Material.Brick, f)
	makePart("WallRight", Vector3.new(1, height, depth), position + Vector3.new(width/2, height/2, 0), wallColor, Enum.Material.Brick, f)
	makePart("Roof", Vector3.new(width+2, 1, depth+2), position + Vector3.new(0, height+0.5, 0), roofColor, Enum.Material.Slate, f)
	return f
end

local function getOrMake(parent, name)
	local f = parent:FindFirstChild(name)
	if not f then f = Instance.new("Folder") f.Name = name f.Parent = parent end
	return f
end

local safeZone = getOrMake(WS, "SafeZone")
local wilderness = getOrMake(WS, "Wilderness")

-- ============================================================
-- 1. FARMLANDS (east, x=100-250, z=120-220)
-- ============================================================
print("[MapSetup2] Building Farmlands...")
local farm = getOrMake(safeZone, "Farmlands")

-- Dirt ground
makePart("FarmGround", Vector3.new(160, 0.15, 110), Vector3.new(175, 0.08, 170), "Brown", Enum.Material.Ground, farm)

-- Wheat fields (rows of yellow)
for row = 0, 5 do
	for col = 0, 8 do
		makePart("Wheat", Vector3.new(3, 2, 12), Vector3.new(110 + col * 7, 1, 130 + row * 14), "Bright yellow", Enum.Material.Grass, farm, {CanCollide = false})
	end
end

-- Farmhouse 1
local fh1 = makeHouse(Vector3.new(200, 0, 140), farm, 14, 10, 8, "Brick yellow", "Reddish brown", "Farmhouse1")
local fh1Sign = makePart("Sign", Vector3.new(1,1,1), Vector3.new(200, 10, 145), "White", nil, farm, {Transparency = 1})
makeSign(fh1Sign, "üè° Old MacDonald's Farm", Vector3.new(0,0,0))

-- Farmhouse 2
makeHouse(Vector3.new(230, 0, 180), farm, 12, 8, 7, "Brown", "Dark stone grey", "Farmhouse2")

-- Fences around pasture
for i = 0, 15 do
	makePart("FencePost", Vector3.new(0.5, 3, 0.5), Vector3.new(155 + i * 6, 1.5, 155), "Reddish brown", Enum.Material.Wood, farm)
	makePart("FenceRail", Vector3.new(6, 0.3, 0.3), Vector3.new(158 + i * 6, 2.2, 155), "Reddish brown", Enum.Material.Wood, farm)
	makePart("FenceRail2", Vector3.new(6, 0.3, 0.3), Vector3.new(158 + i * 6, 1.2, 155), "Reddish brown", Enum.Material.Wood, farm)
end
for i = 0, 8 do
	makePart("FencePost", Vector3.new(0.5, 3, 0.5), Vector3.new(155, 1.5, 155 + i * 6), "Reddish brown", Enum.Material.Wood, farm)
	makePart("FencePost", Vector3.new(0.5, 3, 0.5), Vector3.new(245, 1.5, 155 + i * 6), "Reddish brown", Enum.Material.Wood, farm)
end

-- Scarecrow
makePart("ScarecrowPole", Vector3.new(0.5, 6, 0.5), Vector3.new(140, 3, 145), "Reddish brown", Enum.Material.Wood, farm)
makePart("ScarecrowArms", Vector3.new(4, 0.5, 0.5), Vector3.new(140, 5, 145), "Reddish brown", Enum.Material.Wood, farm)
makePart("ScarecrowHead", Vector3.new(1.5, 1.5, 1.5), Vector3.new(140, 6.5, 145), "Bright orange", Enum.Material.SmoothPlastic, farm)

-- Hay bales
for i = 1, 6 do
	makePart("HayBale"..i, Vector3.new(3, 2, 3), Vector3.new(210 + math.random(-5,5), 1, 165 + math.random(-5,5)), "Bright yellow", Enum.Material.Grass, farm)
end

-- Windmill
makePart("WindmillBase", Vector3.new(8, 20, 8), Vector3.new(240, 10, 145), "Brick yellow", Enum.Material.Brick, farm)
makePart("WindmillRoof", Vector3.new(10, 2, 10), Vector3.new(240, 21, 145), "Reddish brown", Enum.Material.Wood, farm)
-- Sails (simplified as crossed planks)
makePart("Sail1", Vector3.new(1, 18, 1), Vector3.new(240, 18, 141), "White", Enum.Material.Fabric, farm, {CanCollide = false})
makePart("Sail2", Vector3.new(18, 1, 1), Vector3.new(240, 18, 141), "White", Enum.Material.Fabric, farm, {CanCollide = false})

-- Chicken coop
makePart("CoopBase", Vector3.new(6, 3, 5), Vector3.new(170, 1.5, 170), "Reddish brown", Enum.Material.Wood, farm)
makePart("CoopRoof", Vector3.new(7, 0.5, 6), Vector3.new(170, 3.5, 170), "Reddish brown", Enum.Material.Wood, farm)
makePart("CoopFence", Vector3.new(12, 2, 0.3), Vector3.new(170, 1, 175), "Reddish brown", Enum.Material.Wood, farm)

task.wait()

-- ============================================================
-- 2. HAVEN LAKE (west, x=-200 to -100, z=100-200)
-- ============================================================
print("[MapSetup2] Building Haven Lake...")
local lake = getOrMake(safeZone, "HavenLake")

-- Lake water
makePart("LakeWater", Vector3.new(80, 1, 60), Vector3.new(-150, -0.5, 150), Color3.fromRGB(65, 130, 175), Enum.Material.Water, lake, {Transparency = 0.3, CanCollide = false})
-- Sandy beach (south side)
makePart("Beach", Vector3.new(90, 0.3, 15), Vector3.new(-150, 0.15, 185), "Brick yellow", Enum.Material.Sand, lake)
-- Dirt banks
makePart("BankNorth", Vector3.new(90, 0.8, 5), Vector3.new(-150, 0.1, 118), "Brown", Enum.Material.Ground, lake)
makePart("BankWest", Vector3.new(5, 0.8, 70), Vector3.new(-195, 0.1, 150), "Brown", Enum.Material.Ground, lake)
makePart("BankEast", Vector3.new(5, 0.8, 70), Vector3.new(-105, 0.1, 150), "Brown", Enum.Material.Ground, lake)

-- Fishing dock
makePart("Dock", Vector3.new(5, 0.6, 20), Vector3.new(-130, 0.5, 170), "Reddish brown", Enum.Material.WoodPlanks, lake)
makePart("DockPost1", Vector3.new(0.5, 3, 0.5), Vector3.new(-128, 0.5, 180), "Reddish brown", Enum.Material.Wood, lake)
makePart("DockPost2", Vector3.new(0.5, 3, 0.5), Vector3.new(-132, 0.5, 180), "Reddish brown", Enum.Material.Wood, lake)

-- Rowboat
makePart("BoatHull", Vector3.new(3, 1, 6), Vector3.new(-140, 0.2, 165), "Reddish brown", Enum.Material.Wood, lake)
makePart("BoatSeat", Vector3.new(2, 0.3, 1), Vector3.new(-140, 1, 165), "Reddish brown", Enum.Material.Wood, lake)

-- Small island in lake
makePart("Island", Vector3.new(12, 1, 10), Vector3.new(-155, 0.2, 148), "Bright green", Enum.Material.Grass, lake)
makeTree(Vector3.new(-155, 0.7, 148), lake, 0.8, "Forest green")

-- Lighthouse
makePart("LighthouseBase", Vector3.new(6, 25, 6), Vector3.new(-192, 12.5, 135), "White", Enum.Material.Brick, lake)
makePart("LighthouseTop", Vector3.new(8, 3, 8), Vector3.new(-192, 26.5, 135), "Bright red", Enum.Material.Brick, lake)
local lhLight = makePart("LighthouseLight", Vector3.new(2, 2, 2), Vector3.new(-192, 29, 135), "Bright yellow", Enum.Material.Neon, lake, {Transparency = 0.2})
local pl = Instance.new("PointLight") pl.Color = Color3.fromRGB(255, 255, 200) pl.Brightness = 5 pl.Range = 60 pl.Parent = lhLight

-- Cattails/reeds
for i = 1, 12 do
	local rx = -190 + math.random(0, 80)
	local rz = 120 + math.random(0, 60)
	makePart("Reed"..i, Vector3.new(0.3, 2 + math.random(), 0.3), Vector3.new(rx, 1, rz), "Earth green", Enum.Material.Grass, lake)
end

local lakeSign = makePart("LakeSign", Vector3.new(1,1,1), Vector3.new(-150, 4, 190), "White", nil, lake, {Transparency = 1})
makeSign(lakeSign, "üèûÔ∏è Haven Lake", Vector3.new(0,0,0))

task.wait()

-- ============================================================
-- 3. COMBAT TRAINING GROUNDS (east, x=150-250, z=-30 to 70)
-- ============================================================
print("[MapSetup2] Building Training Grounds...")
local training = getOrMake(safeZone, "TrainingGrounds")

-- Arena floor
makePart("ArenaFloor", Vector3.new(80, 0.2, 80), Vector3.new(195, 0.1, 20), "Brown", Enum.Material.Ground, training)
-- Arena walls (stone)
makePart("ArenaWallN", Vector3.new(84, 8, 3), Vector3.new(195, 4, -22), "Medium stone grey", Enum.Material.Cobblestone, training)
makePart("ArenaWallS", Vector3.new(84, 8, 3), Vector3.new(195, 4, 62), "Medium stone grey", Enum.Material.Cobblestone, training)
makePart("ArenaWallW", Vector3.new(3, 8, 80), Vector3.new(152, 4, 20), "Medium stone grey", Enum.Material.Cobblestone, training)
makePart("ArenaWallE", Vector3.new(3, 8, 80), Vector3.new(238, 4, 20), "Medium stone grey", Enum.Material.Cobblestone, training)

-- Training dummies (T-shapes)
for i = 0, 2 do
	local dx = 170 + i * 20
	makePart("DummyPole"..i, Vector3.new(1, 6, 1), Vector3.new(dx, 3, 10), "Reddish brown", Enum.Material.Wood, training)
	makePart("DummyArms"..i, Vector3.new(4, 1, 1), Vector3.new(dx, 5, 10), "Reddish brown", Enum.Material.Wood, training)
	makePart("DummyHead"..i, Vector3.new(1.5, 1.5, 1.5), Vector3.new(dx, 7, 10), "Bright yellow", Enum.Material.SmoothPlastic, training)
end

-- Archery targets
for i = 0, 3 do
	makePart("Target"..i, Vector3.new(0.5, 4, 4), Vector3.new(230, 2.5, 0 + i * 12), "White", Enum.Material.SmoothPlastic, training)
	makePart("TargetRing"..i, Vector3.new(0.6, 2, 2), Vector3.new(230, 2.5, 0 + i * 12), "Bright red", Enum.Material.SmoothPlastic, training)
	makePart("TargetBull"..i, Vector3.new(0.7, 0.8, 0.8), Vector3.new(230, 2.5, 0 + i * 12), "Bright yellow", Enum.Material.SmoothPlastic, training)
end

-- Weapon racks
makePart("WeaponRack1", Vector3.new(0.5, 5, 4), Vector3.new(158, 2.5, 30), "Reddish brown", Enum.Material.Wood, training)
makePart("WeaponRack2", Vector3.new(0.5, 5, 4), Vector3.new(158, 2.5, 40), "Reddish brown", Enum.Material.Wood, training)

-- Spectator benches
for i = 0, 3 do
	makePart("Bench"..i, Vector3.new(8, 1.5, 1.5), Vector3.new(195, 0.75 + i * 1.5, 58 - i * 2), "Reddish brown", Enum.Material.Wood, training)
end

-- Armory building
makeHouse(Vector3.new(170, 0, 50), training, 12, 10, 8, "Dark stone grey", "Dark stone grey", "Armory")
local armSign = makePart("ArmSign", Vector3.new(1,1,1), Vector3.new(170, 10, 55), "White", nil, training, {Transparency = 1})
makeSign(armSign, "‚öîÔ∏è Combat Training Grounds", Vector3.new(0,0,0))

task.wait()

-- ============================================================
-- 4. ANCIENT GROVE (west, x=-250 to -100, z=-60 to 60)
-- ============================================================
print("[MapSetup2] Building Ancient Grove...")
local grove = getOrMake(safeZone, "AncientGrove")

-- Mystic ground
makePart("GroveGround", Vector3.new(140, 0.15, 120), Vector3.new(-175, 0.08, 0), "Earth green", Enum.Material.Grass, grove)

-- HUGE ancient trees (5 studs wide trunks, 25 tall)
local ancientPos = {
	{-200, 0, -30}, {-160, 0, -40}, {-130, 0, -20}, {-220, 0, 10},
	{-180, 0, 30}, {-140, 0, 40}, {-210, 0, 50}, {-160, 0, 20},
}
for i, tp in ipairs(ancientPos) do
	makePart("AncientTrunk"..i, Vector3.new(5, 25, 5), Vector3.new(tp[1], 12.5, tp[3]), "Reddish brown", Enum.Material.Wood, grove)
	makePart("AncientCanopy"..i, Vector3.new(20, 15, 20), Vector3.new(tp[1], 27, tp[3]), "Dark green", Enum.Material.Grass, grove, {CanCollide = false})
	-- Roots
	makePart("Root"..i.."a", Vector3.new(1, 1, 6), Vector3.new(tp[1]+3, 0.5, tp[3]+2), "Reddish brown", Enum.Material.Wood, grove)
	makePart("Root"..i.."b", Vector3.new(6, 1, 1), Vector3.new(tp[1]-2, 0.5, tp[3]-3), "Reddish brown", Enum.Material.Wood, grove)
end

-- Glowing blue mushrooms
for i = 1, 15 do
	local mx = -240 + math.random(0, 130)
	local mz = -55 + math.random(0, 110)
	local shroom = makePart("BlueMushroom"..i, Vector3.new(0.8, 1.2, 0.8), Vector3.new(mx, 0.6, mz), "Bright blue", Enum.Material.Neon, grove, {Transparency = 0.3, CanCollide = false})
	local sl = Instance.new("PointLight") sl.Color = Color3.fromRGB(50, 120, 255) sl.Brightness = 1 sl.Range = 6 sl.Parent = shroom
end

-- Stone circle (8 standing stones in a ring)
local circleCenter = Vector3.new(-180, 0, 0)
for i = 0, 7 do
	local angle = (i / 8) * math.pi * 2
	local sx = circleCenter.X + math.cos(angle) * 15
	local sz = circleCenter.Z + math.sin(angle) * 15
	local height = 6 + math.random(0, 4)
	makePart("DruidStone"..i, Vector3.new(2, height, 1.5), Vector3.new(sx, height/2, sz), "Medium stone grey", Enum.Material.Slate, grove)
end
-- Center altar
makePart("DruidAltar", Vector3.new(4, 1.5, 4), Vector3.new(-180, 0.75, 0), "Medium stone grey", Enum.Material.Marble, grove)
local altarGlow = makePart("AltarGlow", Vector3.new(2, 0.5, 2), Vector3.new(-180, 1.75, 0), "Bright green", Enum.Material.Neon, grove, {Transparency = 0.4})
local agl = Instance.new("PointLight") agl.Color = Color3.fromRGB(50, 255, 100) agl.Brightness = 2 agl.Range = 15 agl.Parent = altarGlow

-- Moss-covered ruins
makePart("MossRuin1", Vector3.new(5, 4, 1.5), Vector3.new(-220, 2, -40), "Earth green", Enum.Material.Cobblestone, grove)
makePart("MossRuin2", Vector3.new(1.5, 3, 5), Vector3.new(-217, 1.5, -37), "Earth green", Enum.Material.Cobblestone, grove)

-- Waterfall cave entrance
makePart("CaveRockL", Vector3.new(5, 12, 5), Vector3.new(-245, 6, 20), "Dark stone grey", Enum.Material.Slate, grove)
makePart("CaveRockR", Vector3.new(5, 12, 5), Vector3.new(-235, 6, 20), "Dark stone grey", Enum.Material.Slate, grove)
makePart("CaveArch", Vector3.new(15, 4, 5), Vector3.new(-240, 14, 20), "Dark stone grey", Enum.Material.Slate, grove)
makePart("Waterfall", Vector3.new(6, 12, 0.5), Vector3.new(-240, 6, 20), Color3.fromRGB(65, 130, 175), Enum.Material.Water, grove, {Transparency = 0.3, CanCollide = false})

local groveSign = makePart("GroveSign", Vector3.new(1,1,1), Vector3.new(-175, 5, 60), "White", nil, grove, {Transparency = 1})
makeSign(groveSign, "üåø Ancient Grove", Vector3.new(0,0,0))

task.wait()

-- ============================================================
-- 5. OUTSKIRTS VILLAGE (south, x=-60 to 60, z=150-230)
-- ============================================================
print("[MapSetup2] Building Outskirts Village...")
local village = getOrMake(safeZone, "OutskirtsVillage")

-- Village ground
makePart("VillageGround", Vector3.new(120, 0.15, 80), Vector3.new(0, 0.08, 190), "Brown", Enum.Material.Ground, village)

-- Houses
makeHouse(Vector3.new(-30, 0, 175), village, 10, 8, 7, "Brick yellow", "Reddish brown", "VHouse1")
makeHouse(Vector3.new(-10, 0, 200), village, 10, 8, 7, "Brown", "Dark stone grey", "VHouse2")
makeHouse(Vector3.new(15, 0, 175), village, 12, 8, 7, "Brick yellow", "Reddish brown", "VHouse3")
makeHouse(Vector3.new(35, 0, 200), village, 10, 8, 7, "Brown", "Dark stone grey", "VHouse4")
makeHouse(Vector3.new(-35, 0, 210), village, 10, 8, 7, "Brick yellow", "Reddish brown", "VHouse5")

-- Well in center
makePart("WellBase", Vector3.new(4, 3, 4), Vector3.new(0, 1.5, 190), "Medium stone grey", Enum.Material.Cobblestone, village)
makePart("WellWater", Vector3.new(2, 0.3, 2), Vector3.new(0, 0.5, 190), Color3.fromRGB(65, 130, 175), Enum.Material.Water, village, {Transparency = 0.3})
makePart("WellRoof", Vector3.new(5, 0.5, 5), Vector3.new(0, 5, 190), "Reddish brown", Enum.Material.Wood, village)
makePart("WellPost1", Vector3.new(0.3, 5, 0.3), Vector3.new(-2, 2.5, 188), "Reddish brown", Enum.Material.Wood, village)
makePart("WellPost2", Vector3.new(0.3, 5, 0.3), Vector3.new(2, 2.5, 192), "Reddish brown", Enum.Material.Wood, village)

-- Market cart
makePart("CartBody", Vector3.new(4, 2, 6), Vector3.new(25, 1.5, 190), "Reddish brown", Enum.Material.Wood, village)
makePart("CartGoods", Vector3.new(3, 1, 5), Vector3.new(25, 3, 190), "Bright green", Enum.Material.Fabric, village)

-- Small chapel
local chapel = makeHouse(Vector3.new(45, 0, 185), village, 8, 10, 8, "White", "Dark stone grey", "VChapel")
makePart("ChapelSteeple", Vector3.new(3, 6, 3), Vector3.new(45, 14, 182), "Dark stone grey", Enum.Material.Slate, village)

-- Clotheslines
makePart("ClothPost1", Vector3.new(0.3, 4, 0.3), Vector3.new(-20, 2, 188), "Reddish brown", Enum.Material.Wood, village)
makePart("ClothPost2", Vector3.new(0.3, 4, 0.3), Vector3.new(-5, 2, 188), "Reddish brown", Enum.Material.Wood, village)
makePart("ClothLine", Vector3.new(15, 0.1, 0.1), Vector3.new(-12.5, 3.8, 188), "White", Enum.Material.Fabric, village)
makePart("Cloth1", Vector3.new(2, 2, 0.1), Vector3.new(-15, 2.8, 188), "Bright blue", Enum.Material.Fabric, village, {CanCollide = false})
makePart("Cloth2", Vector3.new(2, 2, 0.1), Vector3.new(-10, 2.8, 188), "Bright red", Enum.Material.Fabric, village, {CanCollide = false})

local villSign = makePart("VillSign", Vector3.new(1,1,1), Vector3.new(0, 7, 230), "White", nil, village, {Transparency = 1})
makeSign(villSign, "üèòÔ∏è Outskirts Village", Vector3.new(0,0,0))

task.wait()

-- ============================================================
-- 6. WATCHTOWER HILL (northeast, x=200-240, z=-80 to -50)
-- ============================================================
print("[MapSetup2] Building Watchtower Hill...")
local hill = getOrMake(safeZone, "WatchtowerHill")

-- Raised hill platform
makePart("HillBase", Vector3.new(50, 8, 40), Vector3.new(220, 4, -65), "Earth green", Enum.Material.Grass, hill)
makePart("HillRamp", Vector3.new(12, 1, 20), Vector3.new(200, 4, -55), "Earth green", Enum.Material.Grass, hill, {Orientation = Vector3.new(20, 0, 0)})

-- Watchtower (tall!)
makePart("TowerBase", Vector3.new(8, 30, 8), Vector3.new(220, 23, -65), "Medium stone grey", Enum.Material.Cobblestone, hill)
makePart("TowerTop", Vector3.new(12, 2, 12), Vector3.new(220, 39, -65), "Dark stone grey", Enum.Material.Cobblestone, hill)
-- Railings
makePart("Rail1", Vector3.new(12, 3, 0.5), Vector3.new(220, 41.5, -71), "Dark stone grey", Enum.Material.Cobblestone, hill)
makePart("Rail2", Vector3.new(12, 3, 0.5), Vector3.new(220, 41.5, -59), "Dark stone grey", Enum.Material.Cobblestone, hill)
makePart("Rail3", Vector3.new(0.5, 3, 12), Vector3.new(214, 41.5, -65), "Dark stone grey", Enum.Material.Cobblestone, hill)
makePart("Rail4", Vector3.new(0.5, 3, 12), Vector3.new(226, 41.5, -65), "Dark stone grey", Enum.Material.Cobblestone, hill)

-- Warning flags
makePart("FlagPole1", Vector3.new(0.3, 8, 0.3), Vector3.new(214, 47, -71), "Dark stone grey", Enum.Material.Metal, hill)
makePart("Flag1", Vector3.new(3, 2, 0.1), Vector3.new(216, 49, -71), "Really red", Enum.Material.Fabric, hill, {CanCollide = false})

-- Guard campfire
makePart("FireLogs1", Vector3.new(2, 0.5, 0.5), Vector3.new(210, 8.5, -60), "Reddish brown", Enum.Material.Wood, hill)
makePart("FireLogs2", Vector3.new(0.5, 0.5, 2), Vector3.new(210, 8.5, -60), "Reddish brown", Enum.Material.Wood, hill)
local campfire = makePart("Campfire", Vector3.new(1.5, 2, 1.5), Vector3.new(210, 9.5, -60), "Bright orange", Enum.Material.Neon, hill, {Transparency = 0.3})
local cfl = Instance.new("PointLight") cfl.Color = Color3.fromRGB(255, 140, 40) cfl.Brightness = 3 cfl.Range = 20 cfl.Parent = campfire

local hillSign = makePart("HillSign", Vector3.new(1,1,1), Vector3.new(220, 44, -65), "White", nil, hill, {Transparency = 1})
makeSign(hillSign, "üè∞ Watchtower Hill", Vector3.new(0,0,0))

task.wait()

-- ============================================================
-- 7. MERCHANT ROADS (connecting all areas)
-- ============================================================
print("[MapSetup2] Building roads...")
local roads = getOrMake(safeZone, "Roads")

-- Haven gate to south (Outskirts Village)
makePart("RoadSouth", Vector3.new(6, 0.12, 120), Vector3.new(0, 0.06, 168), "Medium stone grey", Enum.Material.Cobblestone, roads)
-- Haven to east (Farmlands/Training)
makePart("RoadEast", Vector3.new(120, 0.12, 6), Vector3.new(120, 0.06, 108), "Medium stone grey", Enum.Material.Cobblestone, roads)
-- Haven to west (Lake/Grove)
makePart("RoadWest", Vector3.new(130, 0.12, 6), Vector3.new(-120, 0.06, 108), "Medium stone grey", Enum.Material.Cobblestone, roads)
-- Road to lake
makePart("RoadToLake", Vector3.new(6, 0.12, 80), Vector3.new(-150, 0.06, 148), "Medium stone grey", Enum.Material.Cobblestone, roads)
-- Road to grove
makePart("RoadToGrove", Vector3.new(6, 0.12, 60), Vector3.new(-120, 0.06, 70), "Medium stone grey", Enum.Material.Cobblestone, roads)
-- Road to training
makePart("RoadToTraining", Vector3.new(6, 0.12, 40), Vector3.new(195, 0.06, 80), "Medium stone grey", Enum.Material.Cobblestone, roads)
-- Road to wilderness (north from Haven)
makePart("RoadNorth", Vector3.new(6, 0.12, 100), Vector3.new(0, 0.06, -55), "Medium stone grey", Enum.Material.Cobblestone, roads)

-- Signposts at intersections
local function makeSignpost(position, texts)
	makePart("Signpost", Vector3.new(0.5, 5, 0.5), position, "Reddish brown", Enum.Material.Wood, roads)
	for i, t in ipairs(texts) do
		local board = makePart("SignBoard"..i, Vector3.new(4, 1, 0.3), position + Vector3.new(2, 4.5 - i * 1.2, 0), "Brown", Enum.Material.Wood, roads)
		makeSign(board, t, Vector3.new(0, 0.5, 0), UDim2.new(6, 0, 1.5, 0))
	end
end

makeSignpost(Vector3.new(5, 0, 115), {"‚Üí Farmlands", "‚Üê Haven Lake", "‚Üë Haven"})
makeSignpost(Vector3.new(0, 0, 155), {"‚Üë Haven", "‚Üì Outskirts Village"})
makeSignpost(Vector3.new(0, 0, -50), {"‚Üë ‚ö†Ô∏è WILDERNESS", "‚Üì Haven"})

-- Lanterns along roads
for i = 0, 8 do
	makeLantern(Vector3.new(5, 0, 120 + i * 12), roads)
	makeLantern(Vector3.new(-5, 0, -10 - i * 10), roads)
end

task.wait()

-- ============================================================
-- 8. BANDIT CAMP (wilderness, x=-80 to -30, z=-180 to -130)
-- ============================================================
print("[MapSetup2] Building Bandit Camp...")
local bandits = getOrMake(wilderness, "BanditCamp")

-- Palisade walls (crude wooden fence)
makePart("PalisadeN", Vector3.new(55, 6, 1), Vector3.new(-55, 3, -130), "Reddish brown", Enum.Material.Wood, bandits)
makePart("PalisadeS", Vector3.new(55, 6, 1), Vector3.new(-55, 3, -180), "Reddish brown", Enum.Material.Wood, bandits)
makePart("PalisadeW", Vector3.new(1, 6, 50), Vector3.new(-82, 3, -155), "Reddish brown", Enum.Material.Wood, bandits)
makePart("PalisadeE", Vector3.new(1, 6, 50), Vector3.new(-28, 3, -155), "Reddish brown", Enum.Material.Wood, bandits)

-- Tents
for i, pos in ipairs({{-65, 0, -145}, {-50, 0, -160}, {-40, 0, -145}, {-70, 0, -170}}) do
	makePart("TentBase"..i, Vector3.new(6, 0.1, 6), Vector3.new(pos[1], 0.05, pos[3]), "Brown", Enum.Material.Fabric, bandits)
	makePart("TentPole"..i, Vector3.new(0.3, 5, 0.3), Vector3.new(pos[1], 2.5, pos[3]), "Reddish brown", Enum.Material.Wood, bandits)
	makePart("TentCover"..i, Vector3.new(7, 0.2, 7), Vector3.new(pos[1], 4.5, pos[3]), "Brown", Enum.Material.Fabric, bandits, {Orientation = Vector3.new(10, math.random(-20,20), 0)})
end

-- Campfire
makePart("BanditFireLogs", Vector3.new(2, 0.5, 2), Vector3.new(-55, 0.25, -155), "Reddish brown", Enum.Material.Wood, bandits)
local bf = makePart("BanditFire", Vector3.new(1.5, 2, 1.5), Vector3.new(-55, 1.5, -155), "Bright orange", Enum.Material.Neon, bandits, {Transparency = 0.3})
local bfl = Instance.new("PointLight") bfl.Color = Color3.fromRGB(255, 120, 30) bfl.Brightness = 3 bfl.Range = 20 bfl.Parent = bf

-- Weapon crates
makePart("WeaponCrate1", Vector3.new(3, 2, 2), Vector3.new(-45, 1, -150), "Brown", Enum.Material.Wood, bandits)
makePart("WeaponCrate2", Vector3.new(3, 2, 2), Vector3.new(-45, 3, -150), "Brown", Enum.Material.Wood, bandits)

-- Skull flag
makePart("SkullPole", Vector3.new(0.4, 8, 0.4), Vector3.new(-55, 4, -132), "Reddish brown", Enum.Material.Wood, bandits)
makePart("SkullFlag", Vector3.new(4, 3, 0.1), Vector3.new(-53, 7, -132), "Black", Enum.Material.Fabric, bandits)

local banditSign = makePart("BSign", Vector3.new(1,1,1), Vector3.new(-55, 8, -130), "White", nil, bandits, {Transparency = 1})
makeSign(banditSign, "‚öîÔ∏è Bandit Camp", Vector3.new(0,0,0))

task.wait()

-- ============================================================
-- 9. DARK FOREST (wilderness, x=60 to 200, z=-220 to -120)
-- ============================================================
print("[MapSetup2] Building Dark Forest...")
local darkForest = getOrMake(wilderness, "DarkForest")

-- Dark ground
makePart("DarkForestGround", Vector3.new(140, 0.15, 100), Vector3.new(130, 0.08, -170), "Really black", Enum.Material.Ground, darkForest)

-- Dense dead/twisted trees
for i = 1, 25 do
	local tx = 70 + math.random(0, 120)
	local tz = -210 + math.random(0, 80)
	local th = 6 + math.random(0, 8)
	makePart("DarkTrunk"..i, Vector3.new(1.5, th, 1.5), Vector3.new(tx, th/2, tz), "Really black", Enum.Material.Wood, darkForest)
	if math.random() > 0.4 then
		makePart("DarkBranch"..i, Vector3.new(0.5, 3, 0.5), Vector3.new(tx+1.5, th-1, tz), "Really black", Enum.Material.Wood, darkForest, {Orientation = Vector3.new(0,0,30)})
	end
end

-- Spider webs between trees
for i = 1, 8 do
	local wx = 80 + math.random(0, 100)
	local wz = -200 + math.random(0, 70)
	makePart("Web"..i, Vector3.new(5, 5, 0.1), Vector3.new(wx, 4, wz), "White", Enum.Material.Neon, darkForest, {Transparency = 0.7, CanCollide = false})
end

-- Fog (low transparent grey)
for i = 1, 6 do
	local fx = 80 + math.random(0, 110)
	local fz = -205 + math.random(0, 75)
	makePart("Fog"..i, Vector3.new(25, 3, 25), Vector3.new(fx, 1.5, fz), "Medium stone grey", Enum.Material.SmoothPlastic, darkForest, {Transparency = 0.85, CanCollide = false})
end

-- Abandoned cabin
local cabin = getOrMake(darkForest, "AbandonedCabin")
makePart("CabinFloor", Vector3.new(10, 0.3, 8), Vector3.new(140, 0.15, -180), "Reddish brown", Enum.Material.WoodPlanks, cabin)
makePart("CabinWall1", Vector3.new(10, 6, 1), Vector3.new(140, 3, -184), "Reddish brown", Enum.Material.Wood, cabin)
makePart("CabinWall2", Vector3.new(1, 6, 8), Vector3.new(135, 3, -180), "Reddish brown", Enum.Material.Wood, cabin)
-- Missing wall (broken)
makePart("CabinWall3Broken", Vector3.new(1, 3, 5), Vector3.new(145, 1.5, -178), "Reddish brown", Enum.Material.Wood, cabin)
-- Partial roof
makePart("CabinRoof", Vector3.new(8, 0.5, 6), Vector3.new(138, 6.5, -181), "Reddish brown", Enum.Material.Wood, cabin)

-- Creepy totem poles
for i = 0, 2 do
	makePart("Totem"..i, Vector3.new(1.5, 8, 1.5), Vector3.new(100 + i * 25, 4, -140), "Reddish brown", Enum.Material.Wood, darkForest)
	makePart("TotemFace"..i, Vector3.new(2, 2, 0.5), Vector3.new(100 + i * 25, 6, -139.5), "Bright red", Enum.Material.Neon, darkForest, {Transparency = 0.4})
end

local dfSign = makePart("DFSign", Vector3.new(1,1,1), Vector3.new(130, 5, -120), "White", nil, darkForest, {Transparency = 1})
makeSign(dfSign, "üåë Dark Forest", Vector3.new(0,0,0))

task.wait()

-- ============================================================
-- 10. DRAGON'S SPINE MOUNTAINS (deep wilderness, x=-180 to -60, z=-380 to -260)
-- ============================================================
print("[MapSetup2] Building Dragon's Spine Mountains...")
local mountains = getOrMake(wilderness, "DragonSpine")

-- Mountain base
makePart("MtnBase", Vector3.new(130, 2, 130), Vector3.new(-120, 1, -320), "Dark stone grey", Enum.Material.Slate, mountains)

-- Rock spires/peaks
local peakData = {
	{-160, 0, -290, 50}, {-130, 0, -310, 40}, {-100, 0, -280, 45},
	{-80, 0, -330, 55}, {-140, 0, -350, 35}, {-110, 0, -360, 42},
	{-170, 0, -340, 38}, {-90, 0, -300, 48},
}
for i, pd in ipairs(peakData) do
	local h = pd[4]
	makePart("Peak"..i, Vector3.new(12, h, 12), Vector3.new(pd[1], h/2 + 2, pd[3]), "Dark stone grey", Enum.Material.Slate, mountains)
	-- Snow cap
	makePart("Snow"..i, Vector3.new(10, 3, 10), Vector3.new(pd[1], h + 1, pd[3]), "White", Enum.Material.SmoothPlastic, mountains)
end

-- Cave entrance in mountain
makePart("MtnCaveL", Vector3.new(6, 14, 6), Vector3.new(-130, 9, -270), "Dark stone grey", Enum.Material.Slate, mountains)
makePart("MtnCaveR", Vector3.new(6, 14, 6), Vector3.new(-118, 9, -270), "Dark stone grey", Enum.Material.Slate, mountains)
makePart("MtnCaveTop", Vector3.new(18, 4, 6), Vector3.new(-124, 18, -270), "Dark stone grey", Enum.Material.Slate, mountains)

-- Rope bridge between peaks
makePart("RopeBridge", Vector3.new(3, 0.3, 30), Vector3.new(-115, 25, -305), "Reddish brown", Enum.Material.Wood, mountains)
makePart("BridgeRope1", Vector3.new(0.2, 2, 30), Vector3.new(-113.5, 26, -305), "Brown", Enum.Material.Fabric, mountains)
makePart("BridgeRope2", Vector3.new(0.2, 2, 30), Vector3.new(-116.5, 26, -305), "Brown", Enum.Material.Fabric, mountains)

-- Dragon bones
makePart("DragonSkull", Vector3.new(6, 4, 8), Vector3.new(-140, 4, -370), "White", Enum.Material.SmoothPlastic, mountains)
makePart("DragonSpine1", Vector3.new(2, 3, 2), Vector3.new(-140, 3, -362), "White", Enum.Material.SmoothPlastic, mountains)
makePart("DragonSpine2", Vector3.new(2, 2.5, 2), Vector3.new(-140, 2.5, -356), "White", Enum.Material.SmoothPlastic, mountains)
makePart("DragonRib1", Vector3.new(0.5, 5, 3), Vector3.new(-138, 3, -365), "White", Enum.Material.SmoothPlastic, mountains)
makePart("DragonRib2", Vector3.new(0.5, 5, 3), Vector3.new(-142, 3, -365), "White", Enum.Material.SmoothPlastic, mountains)

local mtnSign = makePart("MtnSign", Vector3.new(1,1,1), Vector3.new(-120, 30, -275), "White", nil, mountains, {Transparency = 1})
makeSign(mtnSign, "üèîÔ∏è Dragon's Spine", Vector3.new(0,0,0))

task.wait()

-- ============================================================
-- 11. CURSED SWAMP (deep wilderness, x=40 to 200, z=-380 to -270)
-- ============================================================
print("[MapSetup2] Building Cursed Swamp...")
local swamp = getOrMake(wilderness, "CursedSwamp")

-- Murky water
makePart("SwampWater", Vector3.new(160, 0.5, 110), Vector3.new(120, -0.25, -325), Color3.fromRGB(30, 80, 120), Enum.Material.Water, swamp, {Transparency = 0.3, CanCollide = false})
-- Muddy ground
makePart("SwampMud", Vector3.new(170, 0.3, 120), Vector3.new(120, -0.1, -325), "Brown", Enum.Material.Ground, swamp)

-- Dead trees emerging from water
for i = 1, 12 do
	local sx = 50 + math.random(0, 140)
	local sz = -370 + math.random(0, 90)
	makePart("SwampTree"..i, Vector3.new(1, 6 + math.random(0,4), 1), Vector3.new(sx, 3, sz), "Dark stone grey", Enum.Material.Wood, swamp)
end

-- Bubbling pits
for i = 1, 5 do
	local bx = 60 + math.random(0, 120)
	local bz = -360 + math.random(0, 70)
	local pit = makePart("BubblePit"..i, Vector3.new(4, 0.5, 4), Vector3.new(bx, 0.1, bz), "Bright green", Enum.Material.Neon, swamp, {Transparency = 0.4})
	local pgl = Instance.new("PointLight") pgl.Color = Color3.fromRGB(50, 200, 50) pgl.Brightness = 1.5 pgl.Range = 10 pgl.Parent = pit
end

-- Rickety walkways
makePart("Walkway1", Vector3.new(3, 0.3, 40), Vector3.new(100, 0.4, -315), "Reddish brown", Enum.Material.WoodPlanks, swamp)
makePart("Walkway2", Vector3.new(30, 0.3, 3), Vector3.new(120, 0.4, -335), "Reddish brown", Enum.Material.WoodPlanks, swamp)
makePart("Walkway3", Vector3.new(3, 0.3, 30), Vector3.new(140, 0.4, -345), "Reddish brown", Enum.Material.WoodPlanks, swamp)

-- Witch's hut on stilts
makePart("HutStilt1", Vector3.new(0.5, 6, 0.5), Vector3.new(155, 3, -350), "Reddish brown", Enum.Material.Wood, swamp)
makePart("HutStilt2", Vector3.new(0.5, 6, 0.5), Vector3.new(165, 3, -350), "Reddish brown", Enum.Material.Wood, swamp)
makePart("HutStilt3", Vector3.new(0.5, 6, 0.5), Vector3.new(155, 3, -356), "Reddish brown", Enum.Material.Wood, swamp)
makePart("HutStilt4", Vector3.new(0.5, 6, 0.5), Vector3.new(165, 3, -356), "Reddish brown", Enum.Material.Wood, swamp)
makePart("HutFloor", Vector3.new(12, 0.3, 8), Vector3.new(160, 6, -353), "Reddish brown", Enum.Material.WoodPlanks, swamp)
makePart("HutWall1", Vector3.new(12, 6, 0.5), Vector3.new(160, 9, -357), "Reddish brown", Enum.Material.Wood, swamp)
makePart("HutWall2", Vector3.new(0.5, 6, 8), Vector3.new(154, 9, -353), "Reddish brown", Enum.Material.Wood, swamp)
makePart("HutRoof", Vector3.new(14, 0.5, 10), Vector3.new(160, 12, -353), "Really black", Enum.Material.Slate, swamp)

-- Poisonous mushrooms (red with white)
for i = 1, 8 do
	local mx = 60 + math.random(0, 130)
	local mz = -370 + math.random(0, 80)
	makePart("PoisonShroom"..i, Vector3.new(1.2, 1.5, 1.2), Vector3.new(mx, 0.75, mz), "Bright red", Enum.Material.SmoothPlastic, swamp, {CanCollide = false})
	makePart("ShroomSpot"..i, Vector3.new(0.4, 0.4, 0.1), Vector3.new(mx + 0.3, 1.2, mz), "White", Enum.Material.SmoothPlastic, swamp, {CanCollide = false})
end

local swampSign = makePart("SwampSign", Vector3.new(1,1,1), Vector3.new(120, 4, -272), "White", nil, swamp, {Transparency = 1})
makeSign(swampSign, "üß™ Cursed Swamp", Vector3.new(0,0,0))

task.wait()

-- ============================================================
-- 12. THE ABYSS (deepest wilderness, x=-80 to 80, z=-520 to -420)
-- ============================================================
print("[MapSetup2] Building The Abyss...")
local abyss = getOrMake(wilderness, "TheAbyss")

-- Obsidian ground
makePart("AbyssGround", Vector3.new(180, 0.3, 120), Vector3.new(0, 0.15, -470), "Really black", Enum.Material.Slate, abyss)

-- Lava rivers (red neon strips)
makePart("LavaRiver1", Vector3.new(4, 0.5, 100), Vector3.new(-30, 0.25, -470), "Bright red", Enum.Material.Neon, abyss, {Transparency = 0.2, CanCollide = false})
makePart("LavaRiver2", Vector3.new(80, 0.5, 4), Vector3.new(10, 0.25, -450), "Bright red", Enum.Material.Neon, abyss, {Transparency = 0.2, CanCollide = false})
makePart("LavaRiver3", Vector3.new(4, 0.5, 60), Vector3.new(40, 0.25, -490), "Bright red", Enum.Material.Neon, abyss, {Transparency = 0.2, CanCollide = false})

-- Floating crystal formations
for i = 1, 10 do
	local cx = -60 + math.random(0, 120)
	local cy = 5 + math.random(0, 15)
	local cz = -510 + math.random(0, 80)
	local crystal = makePart("Crystal"..i, Vector3.new(2, 5 + math.random(0, 4), 2), Vector3.new(cx, cy, cz), "Bright violet", Enum.Material.Neon, abyss, {Transparency = 0.3, CanCollide = false, Orientation = Vector3.new(math.random(-15,15), math.random(0,360), math.random(-15,15))})
	local crl = Instance.new("PointLight") crl.Color = Color3.fromRGB(150, 50, 255) crl.Brightness = 2 crl.Range = 15 crl.Parent = crystal
end

-- Ruined altar/temple
local temple = getOrMake(abyss, "DarkTemple")
makePart("TempleFloor", Vector3.new(30, 1, 24), Vector3.new(0, 0.5, -480), "Really black", Enum.Material.Marble, temple)
-- Pillars
for i = 0, 3 do
	makePart("TPillarL"..i, Vector3.new(3, 16, 3), Vector3.new(-12, 8, -472 - i * 5), "Dark stone grey", Enum.Material.Marble, temple)
	makePart("TPillarR"..i, Vector3.new(3, 16, 3), Vector3.new(12, 8, -472 - i * 5), "Dark stone grey", Enum.Material.Marble, temple)
end
-- Temple roof fragments
makePart("TempleRoof1", Vector3.new(15, 2, 10), Vector3.new(-3, 17, -475), "Dark stone grey", Enum.Material.Marble, temple)
makePart("TempleRoof2", Vector3.new(10, 2, 8), Vector3.new(5, 17, -488), "Dark stone grey", Enum.Material.Marble, temple)
-- Dark altar
makePart("DarkAltar", Vector3.new(6, 3, 4), Vector3.new(0, 2, -490), "Really black", Enum.Material.Marble, temple)
local altarOrb = makePart("AltarOrb", Vector3.new(2, 2, 2), Vector3.new(0, 4.5, -490), "Bright violet", Enum.Material.Neon, temple, {Transparency = 0.2})
local aol = Instance.new("PointLight") aol.Color = Color3.fromRGB(200, 50, 255) aol.Brightness = 5 aol.Range = 30 aol.Parent = altarOrb

-- Demonic statues
for i, pos in ipairs({{-20, 0, -465}, {20, 0, -465}, {-15, 0, -495}, {15, 0, -495}}) do
	makePart("DemonBase"..i, Vector3.new(3, 1, 3), Vector3.new(pos[1], 0.5, pos[3]), "Really black", Enum.Material.Marble, abyss)
	makePart("DemonBody"..i, Vector3.new(2, 6, 2), Vector3.new(pos[1], 4, pos[3]), "Really black", Enum.Material.Slate, abyss)
	makePart("DemonHead"..i, Vector3.new(1.5, 1.5, 1.5), Vector3.new(pos[1], 7.75, pos[3]), "Really black", Enum.Material.Slate, abyss)
	makePart("DemonEyes"..i, Vector3.new(0.8, 0.3, 0.1), Vector3.new(pos[1], 8, pos[3] + 0.8), "Bright red", Enum.Material.Neon, abyss)
end

local abyssSign = makePart("AbyssSign", Vector3.new(1,1,1), Vector3.new(0, 20, -425), "White", nil, abyss, {Transparency = 1})
makeSign(abyssSign, "üëÅÔ∏è THE ABYSS ‚Äî Turn Back", Vector3.new(0,0,0), UDim2.new(14, 0, 3, 0))

-- ============================================================
-- 13. ADDITIONAL TERRAIN FEATURES
-- ============================================================
print("[MapSetup2] Adding terrain details...")

-- Cliff edges near Dragon's Spine
local cliffs = getOrMake(wilderness, "DragonSpine")
for i = 1, 6 do
	local cx = -180 + i * 20
	makePart("Cliff"..i, Vector3.new(15, 12 + math.random(0, 8), 4), Vector3.new(cx, 6, -265), "Dark stone grey", Enum.Material.Slate, cliffs)
end

-- Extra boulders around training grounds
for i = 1, 6 do
	local bx = 155 + math.random(0, 80)
	local bz = -25 + math.random(0, 90)
	local bs = 2 + math.random() * 3
	makePart("TrainBoulder"..i, Vector3.new(bs, bs * 0.7, bs), Vector3.new(bx, bs * 0.35, bz), "Medium stone grey", Enum.Material.Slate, safeZone)
end

-- Flower meadow near lake
for i = 1, 15 do
	local fx = -190 + math.random(0, 80)
	local fz = 190 + math.random(0, 20)
	local colors = {"Bright red", "Bright yellow", "Hot pink", "Bright violet", "Bright blue"}
	makePart("LakeFlower"..i, Vector3.new(0.5, 0.7, 0.5), Vector3.new(fx, 0.35, fz), colors[math.random(#colors)], Enum.Material.SmoothPlastic, safeZone, {CanCollide = false})
end

-- Bushes around village
for i = 1, 12 do
	local bx = -50 + math.random(0, 100)
	local bz = 160 + math.random(0, 60)
	local bs = 1.5 + math.random() * 1.5
	makePart("VillageBush"..i, Vector3.new(bs, bs * 0.6, bs), Vector3.new(bx, bs * 0.3, bz), "Forest green", Enum.Material.Grass, safeZone, {CanCollide = false})
end

-- Swamp fog patches
for i = 1, 5 do
	local fx = 60 + math.random(0, 120)
	local fz = -370 + math.random(0, 80)
	makePart("SwampFog"..i, Vector3.new(25 + math.random(0, 15), 4, 25 + math.random(0, 15)), Vector3.new(fx, 2, fz), "Dark green", Enum.Material.SmoothPlastic, wilderness, {Transparency = 0.88, CanCollide = false})
end

-- Grove moss patches
for i = 1, 10 do
	local mx = -240 + math.random(0, 120)
	local mz = -50 + math.random(0, 100)
	makePart("MossPatch"..i, Vector3.new(3 + math.random() * 4, 0.15, 3 + math.random() * 4), Vector3.new(mx, 0.1, mz), "Earth green", Enum.Material.Grass, safeZone, {CanCollide = false})
end

-- ============================================================
-- EXPAND BASEPLATE for all new areas
-- ============================================================
local bp = WS:FindFirstChild("Baseplate")
if bp then
	bp.Size = Vector3.new(800, 1, 800)
	bp.Position = Vector3.new(0, -0.5, 50)
end
local wg = WS:FindFirstChild("WildernessGround")
if wg then
	wg.Size = Vector3.new(800, 1.01, 800)
	wg.Position = Vector3.new(0, -0.5, -400)
end

print("[MapSetup2] World expansion complete!")
print("[MapSetup2] Areas: Farmlands, Haven Lake, Training Grounds, Ancient Grove, Outskirts Village, Watchtower Hill")
print("[MapSetup2] Wilderness: Bandit Camp, Dark Forest, Dragon's Spine, Cursed Swamp, The Abyss")
print("[MapSetup2] Roads connecting all areas with signposts and lanterns")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="45">
      <Properties>
        <string name="Name">MapSetup3</string>
        <token name="RunContext">0</token>
        <string name="Source">--[[
	MapSetup3.server.lua
	ServerScriptService

	Fills the ENTIRE 800x800 map with terrain features, removing all empty space.
	Adds procedurally generated hills, boulders, trees, decorations, and border walls.
]]

-- Wait for MapSetup2 to finish
task.wait(3)

print("[MapSetup3] Starting comprehensive map filling...")

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------
local function getOrMake(parent, name)
	local existing = parent:FindFirstChild(name)
	if existing then return existing end
	local folder = Instance.new("Folder")
	folder.Name = name
	folder.Parent = parent
	return folder
end

local function makePart(name, size, position, color, material, parent, props)
	local part = Instance.new("Part")
	part.Name = name
	part.Size = size
	part.Position = position
	part.Anchored = true
	part.CanCollide = true
	part.Color = typeof(color) == "string" and BrickColor.new(color).Color or color
	part.Material = material or Enum.Material.SmoothPlastic
	
	if props then
		for key, value in pairs(props) do
			if key == "Orientation" then
				part.Orientation = value
			else
				part[key] = value
			end
		end
	end
	
	part.Parent = parent
	return part
end

local function makeTree(position, parent, scale)
	scale = scale or 1
	-- Trunk
	local trunk = makePart(
		"TreeTrunk",
		Vector3.new(1.5 * scale, 6 * scale, 1.5 * scale),
		position + Vector3.new(0, 3 * scale, 0),
		Color3.fromRGB(101, 67, 33),
		Enum.Material.Wood,
		parent
	)
	
	-- Canopy
	local canopy = makePart(
		"TreeCanopy",
		Vector3.new(6 * scale, 4 * scale, 6 * scale),
		position + Vector3.new(0, 7 * scale, 0),
		Color3.fromRGB(34, 139, 34),
		Enum.Material.Grass,
		parent,
		{ Shape = Enum.PartType.Ball }
	)
	
	return trunk, canopy
end

local function makeBush(position, parent, color, scale)
	scale = scale or 1
	color = color or Color3.fromRGB(34, 100, 34)
	return makePart(
		"Bush",
		Vector3.new(2 * scale, 1.5 * scale, 2 * scale),
		position + Vector3.new(0, 0.75 * scale, 0),
		color,
		Enum.Material.Grass,
		parent,
		{ Shape = Enum.PartType.Ball }
	)
end

local function makeBoulder(position, parent, scale, color)
	scale = scale or 1
	color = color or Color3.fromRGB(105, 105, 105)
	local size = Vector3.new(
		2 + math.random() * 3,
		1.5 + math.random() * 2,
		2 + math.random() * 3
	) * scale
	
	return makePart(
		"Boulder",
		size,
		position + Vector3.new(0, size.Y / 2, 0),
		color,
		Enum.Material.Rock,
		parent,
		{ Shape = Enum.PartType.Ball }
	)
end

local function makeHill(position, parent, scale, height)
	scale = scale or 1
	height = height or (2 + math.random() * 6)
	local size = Vector3.new(
		8 + math.random() * 12,
		height,
		8 + math.random() * 12
	) * scale
	
	return makePart(
		"Hill",
		size,
		position + Vector3.new(0, height / 2, 0),
		Color3.fromRGB(34, 139, 34),
		Enum.Material.Grass,
		parent,
		{ Shape = Enum.PartType.Ball }
	)
end

local function makeFlowerPatch(position, parent)
	local colors = {
		Color3.fromRGB(255, 192, 203), -- Pink
		Color3.fromRGB(255, 255, 0),   -- Yellow
		Color3.fromRGB(138, 43, 226),  -- Purple
		Color3.fromRGB(255, 165, 0),   -- Orange
		Color3.fromRGB(255, 20, 147),  -- Deep Pink
	}
	
	for i = 1, 3 + math.random(4) do
		local offset = Vector3.new(
			(math.random() - 0.5) * 4,
			0,
			(math.random() - 0.5) * 4
		)
		makePart(
			"Flower",
			Vector3.new(0.3, 1.2, 0.3),
			position + offset + Vector3.new(0, 0.6, 0),
			colors[math.random(#colors)],
			Enum.Material.Neon,
			parent,
			{ CanCollide = false }
		)
	end
end

local function makePond(position, parent, scale)
	scale = scale or 1
	-- Pond base
	local pond = makePart(
		"Pond",
		Vector3.new(8 * scale, 0.3, 8 * scale),
		position + Vector3.new(0, 0.15, 0),
		Color3.fromRGB(65, 130, 175),
		Enum.Material.Water,
		parent,
		{ Shape = Enum.PartType.Ball, Transparency = 0.3, CanCollide = false }
	)
	
	-- Lily pads
	for i = 1, 2 + math.random(3) do
		local padPos = position + Vector3.new(
			(math.random() - 0.5) * 6 * scale,
			0.4,
			(math.random() - 0.5) * 6 * scale
		)
		makePart(
			"LilyPad",
			Vector3.new(1.2, 0.1, 1.2),
			padPos,
			Color3.fromRGB(34, 139, 34),
			Enum.Material.Grass,
			parent,
			{ Shape = Enum.PartType.Cylinder, CanCollide = false }
		)
	end
	
	return pond
end

local function makeFence(startPos, endPos, parent)
	local direction = (endPos - startPos).Unit
	local distance = (endPos - startPos).Magnitude
	local posts = math.floor(distance / 4) + 1
	
	for i = 0, posts - 1 do
		local postPos = startPos + direction * (i * distance / (posts - 1))
		makePart(
			"FencePost",
			Vector3.new(0.3, 2, 0.3),
			postPos + Vector3.new(0, 1, 0),
			Color3.fromRGB(101, 67, 33),
			Enum.Material.Wood,
			parent
		)
		
		if i &lt; posts - 1 then
			local railPos = postPos + direction * (distance / (posts - 1) / 2)
			makePart(
				"FenceRail",
				Vector3.new(0.2, 0.3, distance / (posts - 1)),
				railPos + Vector3.new(0, 1, 0),
				Color3.fromRGB(101, 67, 33),
				Enum.Material.Wood,
				parent
			)
		end
	end
end

--------------------------------------------------------------------------------
-- MAIN GENERATION
--------------------------------------------------------------------------------
local terrain = getOrMake(workspace, "TerrainFeatures")
local RNG = Random.new(12345) -- Seeded for consistent generation

-- BORDER WALLS - Define the edge of the map
print("[MapSetup3] Creating border walls...")
local borderWalls = getOrMake(terrain, "BorderWalls")

-- North wall (Z = 395)
for x = -395, 395, 20 do
	makePart(
		"NorthWall",
		Vector3.new(20, 15, 5),
		Vector3.new(x, 7.5, 395),
		Color3.fromRGB(40, 40, 40),
		Enum.Material.Concrete,
		borderWalls
	)
end

-- South wall (Z = -795) ‚Äî pushed far south so Dragon's Nest, Underground Ruins etc are accessible
for x = -395, 395, 20 do
	makePart(
		"SouthWall",
		Vector3.new(20, 15, 5),
		Vector3.new(x, 7.5, -795),
		Color3.fromRGB(40, 40, 40),
		Enum.Material.Concrete,
		borderWalls
	)
end

-- East wall (X = 395)
for z = -395, 395, 20 do
	makePart(
		"EastWall",
		Vector3.new(5, 15, 20),
		Vector3.new(395, 7.5, z),
		Color3.fromRGB(40, 40, 40),
		Enum.Material.Concrete,
		borderWalls
	)
end

-- West wall (X = -395)
for z = -395, 395, 20 do
	makePart(
		"WestWall",
		Vector3.new(5, 15, 20),
		Vector3.new(-395, 7.5, z),
		Color3.fromRGB(40, 40, 40),
		Enum.Material.Concrete,
		borderWalls
	)
end

-- NE QUADRANT (X: 100-400, Z: 100-400) ‚Äî Rolling farmland
print("[MapSetup3] Filling NE quadrant - Rolling farmland...")
local neFarmland = getOrMake(terrain, "NEFarmland")

for i = 1, 20 do
	local pos = Vector3.new(
		100 + RNG:NextNumber() * 300,
		0,
		100 + RNG:NextNumber() * 300
	)
	makeHill(pos, neFarmland, 1, 2 + RNG:NextNumber() * 4)
end

-- Farmland fences
for i = 1, 8 do
	local startX = 120 + RNG:NextNumber() * 260
	local startZ = 120 + RNG:NextNumber() * 260
	local endX = startX + 20 + RNG:NextNumber() * 40
	local endZ = startZ + (-10 + RNG:NextNumber() * 20)
	makeFence(
		Vector3.new(startX, 0, startZ),
		Vector3.new(endX, 0, endZ),
		neFarmland
	)
end

-- Haystacks
for i = 1, 12 do
	local pos = Vector3.new(
		120 + RNG:NextNumber() * 260,
		0,
		120 + RNG:NextNumber() * 260
	)
	makePart(
		"Haystack",
		Vector3.new(3, 2.5, 3),
		pos + Vector3.new(0, 1.25, 0),
		Color3.fromRGB(218, 165, 32),
		Enum.Material.Fabric,
		neFarmland,
		{ Shape = Enum.PartType.Ball }
	)
end

-- Scarecrows
for i = 1, 6 do
	local pos = Vector3.new(
		130 + RNG:NextNumber() * 240,
		0,
		130 + RNG:NextNumber() * 240
	)
	-- Scarecrow post
	makePart(
		"ScarecrowPost",
		Vector3.new(0.3, 4, 0.3),
		pos + Vector3.new(0, 2, 0),
		Color3.fromRGB(101, 67, 33),
		Enum.Material.Wood,
		neFarmland
	)
	-- Scarecrow head
	makePart(
		"ScarecrowHead",
		Vector3.new(0.8, 0.8, 0.8),
		pos + Vector3.new(0, 3.8, 0),
		Color3.fromRGB(255, 165, 0),
		Enum.Material.SmoothPlastic,
		neFarmland,
		{ Shape = Enum.PartType.Ball }
	)
	-- Arms
	makePart(
		"ScarecrowArms",
		Vector3.new(3, 0.2, 0.2),
		pos + Vector3.new(0, 3, 0),
		Color3.fromRGB(101, 67, 33),
		Enum.Material.Wood,
		neFarmland
	)
end

-- NW QUADRANT (X: -400 to -100, Z: 100-400) ‚Äî Rocky highlands
print("[MapSetup3] Filling NW quadrant - Rocky highlands...")
local nwHighlands = getOrMake(terrain, "NWHighlands")

for i = 1, 25 do
	local pos = Vector3.new(
		-400 + RNG:NextNumber() * 300,
		0,
		100 + RNG:NextNumber() * 300
	)
	makeBoulder(pos, nwHighlands, 1 + RNG:NextNumber(), Color3.fromRGB(70, 70, 80))
end

-- Highland cliffs (raised terrain)
for i = 1, 15 do
	local pos = Vector3.new(
		-380 + RNG:NextNumber() * 260,
		0,
		120 + RNG:NextNumber() * 260
	)
	makeHill(pos, nwHighlands, 1.5, 6 + RNG:NextNumber() * 8)
end

-- Mountain flowers
for i = 1, 8 do
	local pos = Vector3.new(
		-380 + RNG:NextNumber() * 260,
		0,
		120 + RNG:NextNumber() * 260
	)
	makeFlowerPatch(pos, nwHighlands)
end

-- SE QUADRANT (X: 100-400, Z: -100 to -400) ‚Äî Marshland
print("[MapSetup3] Filling SE quadrant - Marshland...")
local seMarshland = getOrMake(terrain, "SEMarshland")

-- Marshland puddles
for i = 1, 15 do
	local pos = Vector3.new(
		120 + RNG:NextNumber() * 260,
		0,
		-380 + RNG:NextNumber() * 260
	)
	makePond(pos, seMarshland, 0.7)
end

-- Dead trees
for i = 1, 20 do
	local pos = Vector3.new(
		120 + RNG:NextNumber() * 260,
		0,
		-380 + RNG:NextNumber() * 260
	)
	-- Dead tree trunk (taller, thinner)
	makePart(
		"DeadTreeTrunk",
		Vector3.new(1, 8, 1),
		pos + Vector3.new(0, 4, 0),
		Color3.fromRGB(50, 40, 30),
		Enum.Material.Wood,
		seMarshland
	)
	-- A few dead branches
	for j = 1, 2 + math.random(2) do
		local branchHeight = 4 + RNG:NextNumber() * 3
		local branchAngle = RNG:NextNumber() * 360
		local branchOffset = Vector3.new(
			math.sin(math.rad(branchAngle)) * 1.5,
			0,
			math.cos(math.rad(branchAngle)) * 1.5
		)
		makePart(
			"DeadBranch",
			Vector3.new(0.2, 1.5, 0.2),
			pos + Vector3.new(0, branchHeight, 0) + branchOffset,
			Color3.fromRGB(40, 30, 20),
			Enum.Material.Wood,
			seMarshland
		)
	end
end

-- Fog-colored ground patches
for i = 1, 12 do
	local pos = Vector3.new(
		130 + RNG:NextNumber() * 240,
		0,
		-370 + RNG:NextNumber() * 240
	)
	makePart(
		"FogPatch",
		Vector3.new(8, 0.5, 8),
		pos + Vector3.new(0, 0.25, 0),
		Color3.fromRGB(200, 200, 200),
		Enum.Material.Neon,
		seMarshland,
		{ Transparency = 0.7, CanCollide = false, Shape = Enum.PartType.Ball }
	)
end

-- SW QUADRANT (X: -400 to -100, Z: -100 to -400) ‚Äî Dark forest
print("[MapSetup3] Filling SW quadrant - Dark forest...")
local swDarkForest = getOrMake(terrain, "SWDarkForest")

-- Dense tree clusters
for i = 1, 25 do
	local pos = Vector3.new(
		-380 + RNG:NextNumber() * 260,
		0,
		-380 + RNG:NextNumber() * 260
	)
	makeTree(pos, swDarkForest, 1 + RNG:NextNumber() * 0.5)
end

-- Mushroom circles
for i = 1, 8 do
	local centerPos = Vector3.new(
		-360 + RNG:NextNumber() * 220,
		0,
		-360 + RNG:NextNumber() * 220
	)
	for j = 1, 6 + math.random(6) do
		local angle = (j / (6 + math.random(6))) * math.pi * 2
		local radius = 3 + RNG:NextNumber() * 4
		local mushroomPos = centerPos + Vector3.new(
			math.sin(angle) * radius,
			0,
			math.cos(angle) * radius
		)
		makePart(
			"Mushroom",
			Vector3.new(0.8, 1.2, 0.8),
			mushroomPos + Vector3.new(0, 0.6, 0),
			Color3.fromRGB(128, 0, 128),
			Enum.Material.Neon,
			swDarkForest,
			{ Shape = Enum.PartType.Ball }
		)
	end
end

-- Spider webs (thin transparent parts)
for i = 1, 15 do
	local pos = Vector3.new(
		-370 + RNG:NextNumber() * 240,
		2 + RNG:NextNumber() * 4,
		-370 + RNG:NextNumber() * 240
	)
	makePart(
		"SpiderWeb",
		Vector3.new(3, 0.05, 3),
		pos,
		Color3.fromRGB(220, 220, 220),
		Enum.Material.ForceField,
		swDarkForest,
		{ Transparency = 0.8, CanCollide = false }
	)
end

-- CENTRAL WILDERNESS (X: -100 to 100, Z: -200 to -400) ‚Äî More ruins and atmosphere
print("[MapSetup3] Filling central wilderness...")
local centralWilderness = getOrMake(terrain, "CentralWilderness")

-- More ruins
for i = 1, 20 do
	local pos = Vector3.new(
		-80 + RNG:NextNumber() * 160,
		0,
		-380 + RNG:NextNumber() * 180
	)
	local ruinHeight = 1 + RNG:NextNumber() * 4
	makePart(
		"RuinWall",
		Vector3.new(2 + RNG:NextNumber() * 3, ruinHeight, 0.5),
		pos + Vector3.new(0, ruinHeight / 2, 0),
		Color3.fromRGB(100, 100, 100),
		Enum.Material.Concrete,
		centralWilderness
	)
end

-- Gravestones
for i = 1, 15 do
	local pos = Vector3.new(
		-90 + RNG:NextNumber() * 180,
		0,
		-370 + RNG:NextNumber() * 160
	)
	makePart(
		"Gravestone",
		Vector3.new(0.8, 2, 0.3),
		pos + Vector3.new(0, 1, 0),
		Color3.fromRGB(80, 80, 80),
		Enum.Material.Concrete,
		centralWilderness
	)
end

-- Cracked earth
for i = 1, 10 do
	local pos = Vector3.new(
		-70 + RNG:NextNumber() * 140,
		0,
		-360 + RNG:NextNumber() * 140
	)
	makePart(
		"CrackedEarth",
		Vector3.new(6, 0.2, 6),
		pos + Vector3.new(0, 0.1, 0),
		Color3.fromRGB(60, 40, 30),
		Enum.Material.Concrete,
		centralWilderness,
		{ Shape = Enum.PartType.Ball }
	)
end

-- ROLLING HILLS across all areas
print("[MapSetup3] Adding rolling hills across all empty areas...")
local globalHills = getOrMake(terrain, "GlobalHills")

for i = 1, 60 do -- 80 total hills
	local pos = Vector3.new(
		-390 + RNG:NextNumber() * 780,
		0,
		-390 + RNG:NextNumber() * 780
	)
	
	-- Skip areas that are already built up
	local skipArea = false
	-- Skip Haven City area
	if pos.X > -62 and pos.X &lt; 62 and pos.Z > -10 and pos.Z &lt; 108 then
		skipArea = true
	end
	-- Skip core wilderness spawn
	if pos.X > -50 and pos.X &lt; 50 and pos.Z > -450 and pos.Z &lt; -200 then
		skipArea = true
	end
	
	if not skipArea then
		makeHill(pos, globalHills, 0.8 + RNG:NextNumber() * 0.7, 2 + RNG:NextNumber() * 6)
	end
end

-- ADDITIONAL BOULDERS everywhere
print("[MapSetup3] Scattering boulders...")
local globalBoulders = getOrMake(terrain, "GlobalBoulders")

for i = 1, 75 do -- 100 total boulders
	local pos = Vector3.new(
		-380 + RNG:NextNumber() * 760,
		0,
		-380 + RNG:NextNumber() * 760
	)
	
	-- Skip main areas
	local skipArea = false
	if pos.X > -70 and pos.X &lt; 70 and pos.Z > -20 and pos.Z &lt; 120 then
		skipArea = true
	end
	
	if not skipArea then
		makeBoulder(pos, globalBoulders, 0.5 + RNG:NextNumber() * 1.5)
	end
end

-- ADDITIONAL TREES everywhere
print("[MapSetup3] Planting additional trees...")
local globalTrees = getOrMake(terrain, "GlobalTrees")

for i = 1, 35 do -- 60 total trees
	local pos = Vector3.new(
		-370 + RNG:NextNumber() * 740,
		0,
		-370 + RNG:NextNumber() * 740
	)
	
	-- Skip built areas
	local skipArea = false
	if pos.X > -80 and pos.X &lt; 80 and pos.Z > -30 and pos.Z &lt; 130 then
		skipArea = true
	end
	
	if not skipArea then
		makeTree(pos, globalTrees, 0.7 + RNG:NextNumber() * 0.6)
	end
end

-- BUSHES everywhere
print("[MapSetup3] Adding bushes...")
local globalBushes = getOrMake(terrain, "GlobalBushes")

for i = 1, 40 do
	local pos = Vector3.new(
		-350 + RNG:NextNumber() * 700,
		0,
		-350 + RNG:NextNumber() * 700
	)
	makeBush(pos, globalBushes, nil, 0.5 + RNG:NextNumber() * 1.0)
end

-- PONDS scattered around
print("[MapSetup3] Creating scattered ponds...")
local globalPonds = getOrMake(terrain, "GlobalPonds")

for i = 1, 20 do
	local pos = Vector3.new(
		-320 + RNG:NextNumber() * 640,
		0,
		-320 + RNG:NextNumber() * 640
	)
	
	-- Skip central areas
	local skipArea = false
	if pos.X > -100 and pos.X &lt; 100 and pos.Z > -50 and pos.Z &lt; 150 then
		skipArea = true
	end
	
	if not skipArea then
		makePond(pos, globalPonds, 0.8 + RNG:NextNumber() * 0.4)
	end
end

-- FLOWER PATCHES
print("[MapSetup3] Planting flower patches...")
local globalFlowers = getOrMake(terrain, "GlobalFlowers")

for i = 1, 30 do
	local pos = Vector3.new(
		-300 + RNG:NextNumber() * 600,
		0,
		-300 + RNG:NextNumber() * 600
	)
	makeFlowerPatch(pos, globalFlowers)
end

-- MISC DECORATIONS
print("[MapSetup3] Adding miscellaneous decorations...")
local miscDecorations = getOrMake(terrain, "MiscDecorations")

-- Fallen logs
for i = 1, 20 do
	local pos = Vector3.new(
		-350 + RNG:NextNumber() * 700,
		0,
		-350 + RNG:NextNumber() * 700
	)
	local angle = RNG:NextNumber() * 360
	makePart(
		"FallenLog",
		Vector3.new(6, 0.8, 0.8),
		pos + Vector3.new(0, 0.4, 0),
		Color3.fromRGB(101, 67, 33),
		Enum.Material.Wood,
		miscDecorations,
		{ Orientation = Vector3.new(0, angle, 0) }
	)
end

-- Stone wall fragments
for i = 1, 15 do
	local pos = Vector3.new(
		-330 + RNG:NextNumber() * 660,
		0,
		-330 + RNG:NextNumber() * 660
	)
	local wallLength = 5 + RNG:NextNumber() * 10
	makePart(
		"StoneWallFragment",
		Vector3.new(wallLength, 1.5 + RNG:NextNumber(), 0.5),
		pos + Vector3.new(0, 0.75 + RNG:NextNumber() * 0.5, 0),
		Color3.fromRGB(120, 120, 120),
		Enum.Material.Cobblestone,
		miscDecorations
	)
end

-- Random mushrooms
for i = 1, 15 do
	local pos = Vector3.new(
		-340 + RNG:NextNumber() * 680,
		0,
		-340 + RNG:NextNumber() * 680
	)
	makePart(
		"Mushroom",
		Vector3.new(1, 1.5, 1),
		pos + Vector3.new(0, 0.75, 0),
		Color3.fromRGB(200, 50, 50),
		Enum.Material.Neon,
		miscDecorations,
		{ Shape = Enum.PartType.Ball }
	)
end

-- CONNECTING STREAMS between ponds
print("[MapSetup3] Creating connecting streams...")
local streams = getOrMake(terrain, "Streams")

-- Create a few streams connecting some ponds
for i = 1, 8 do
	local startPos = Vector3.new(
		-200 + RNG:NextNumber() * 400,
		0,
		-200 + RNG:NextNumber() * 400
	)
	local endPos = startPos + Vector3.new(
		-50 + RNG:NextNumber() * 100,
		0,
		-50 + RNG:NextNumber() * 100
	)
	
	local direction = (endPos - startPos).Unit
	local distance = (endPos - startPos).Magnitude
	local segments = math.floor(distance / 3)
	
	for j = 0, segments do
		local segmentPos = startPos + direction * (j * 3)
		makePart(
			"StreamSegment",
			Vector3.new(2, 0.2, 3),
			segmentPos + Vector3.new(0, 0.1, 0),
			Color3.fromRGB(65, 130, 175),
			Enum.Material.Water,
			streams,
			{ Transparency = 0.4, CanCollide = false }
		)
	end
end

print("[MapSetup3] Map filling complete!")
print("[MapSetup3] Generated terrain features:")
print("- 80+ hills of various sizes")
print("- 100+ boulders and rocks")
print("- 60+ trees (regular + dead)")
print("- 40+ bushes")
print("- 20+ ponds with lily pads")
print("- 30+ flower patches")
print("- Border walls on all 4 edges")
print("- 50+ misc decorations (fences, logs, mushrooms, ruins)")
print("- Themed quadrants: NE farmland, NW highlands, SE marshland, SW dark forest")
print("- Connecting streams and atmospheric details")
print("[MapSetup3] No empty space remains!")</string>
      </Properties>
    </Item>
    <Item class="Script" referent="46">
      <Properties>
        <string name="Name">MapSetup4</string>
        <token name="RunContext">0</token>
        <string name="Source">--[[
	MapSetup4.server.lua
	ServerScriptService

	Adds 7 new dense themed areas across the map:
	1. Whispering Woods (X: 200-350, Z: 50-200)
	2. Deep Mine (X: -300 to -200, Z: -50 to 50)
	3. Crystal Cavern (X: -350 to -250, Z: -150 to -80)
	4. Moonlit Pond (X: 250-320, Z: -50 to 20)
	5. Thornwood Thicket (X: -200 to -100, Z: 200-350)
	6. Sunflower Fields (X: 100-250, Z: 250-380)
	7. Abandoned Quarry (X: -150 to -50, Z: -250 to -150)
]]

-- Wait for other MapSetup files to finish
task.wait(5)

print("[MapSetup4] Starting themed area creation...")

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------
local function getOrMake(parent, name)
	local existing = parent:FindFirstChild(name)
	if existing then return existing end
	local folder = Instance.new("Folder")
	folder.Name = name
	folder.Parent = parent
	return folder
end

local function makePart(name, size, position, color, material, parent, props)
	local part = Instance.new("Part")
	part.Name = name
	part.Size = size
	part.Position = position
	part.Anchored = true
	part.CanCollide = true
	part.Color = typeof(color) == "string" and BrickColor.new(color).Color or color
	part.Material = material or Enum.Material.SmoothPlastic
	
	if props then
		for key, value in pairs(props) do
			if key == "Orientation" then
				part.Orientation = value
			else
				part[key] = value
			end
		end
	end
	
	part.Parent = parent
	return part
end

local function randomInRange(min, max)
	return min + math.random() * (max - min)
end

local function randomPointInRect(xMin, xMax, zMin, zMax)
	return Vector3.new(randomInRange(xMin, xMax), 0, randomInRange(zMin, zMax))
end

local Workspace = game:GetService("Workspace")
local MapDecorations = getOrMake(Workspace, "MapDecorations")

--------------------------------------------------------------------------------
-- 1. WHISPERING WOODS (X: 200-350, Z: 50-200)
--------------------------------------------------------------------------------
print("[MapSetup4] Building Whispering Woods...")
local WhisperingWoods = getOrMake(MapDecorations, "WhisperingWoods")

-- Create 40+ trees of varying sizes
for i = 1, 45 do
	local pos = randomPointInRect(200, 350, 50, 200)
	local treeHeight = randomInRange(8, 18)
	local trunkSize = randomInRange(1.5, 3.0)
	local crownSize = randomInRange(6, 12)
	
	-- Tree trunk
	makePart("TreeTrunk" .. i, Vector3.new(trunkSize, treeHeight, trunkSize), pos + Vector3.new(0, treeHeight/2, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, WhisperingWoods)
	
	-- Tree crown
	makePart("TreeCrown" .. i, Vector3.new(crownSize, crownSize * 0.8, crownSize), pos + Vector3.new(0, treeHeight + crownSize/3, 0), 
		Color3.fromRGB(34, 139, 34), Enum.Material.Grass, WhisperingWoods, {Shape = Enum.PartType.Ball})
end

-- Undergrowth bushes
for i = 1, 25 do
	local pos = randomPointInRect(200, 350, 50, 200)
	makePart("Bush" .. i, Vector3.new(randomInRange(2, 4), randomInRange(1.5, 2.5), randomInRange(2, 4)), 
		pos + Vector3.new(0, 1, 0), Color3.fromRGB(85, 107, 47), Enum.Material.Grass, WhisperingWoods)
end

-- Fallen logs
for i = 1, 8 do
	local pos = randomPointInRect(200, 350, 50, 200)
	makePart("FallenLog" .. i, Vector3.new(0.8, 0.8, randomInRange(6, 12)), pos + Vector3.new(0, 0.4, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, WhisperingWoods, 
		{Orientation = Vector3.new(0, randomInRange(0, 360), randomInRange(-15, 15))})
end

-- Mushroom rings
for ring = 1, 3 do
	local centerPos = randomPointInRect(210, 340, 60, 190)
	local radius = randomInRange(3, 6)
	for j = 1, 8 do
		local angle = (j / 8) * 2 * math.pi
		local mushroomPos = centerPos + Vector3.new(math.cos(angle) * radius, 0, math.sin(angle) * radius)
		makePart("Mushroom" .. ring .. "_" .. j, Vector3.new(0.6, 1.2, 0.6), mushroomPos + Vector3.new(0, 0.6, 0), 
			Color3.fromRGB(160, 82, 45), Enum.Material.SmoothPlastic, WhisperingWoods)
		-- Mushroom cap
		makePart("MushroomCap" .. ring .. "_" .. j, Vector3.new(1.5, 0.3, 1.5), mushroomPos + Vector3.new(0, 1.35, 0), 
			Color3.fromRGB(220, 20, 60), Enum.Material.SmoothPlastic, WhisperingWoods, {Shape = Enum.PartType.Cylinder})
	end
end

-- Hidden clearing with ancient stones
local clearingCenter = Vector3.new(275, 0, 125)
for i = 1, 6 do
	local angle = (i / 6) * 2 * math.pi
	local stonePos = clearingCenter + Vector3.new(math.cos(angle) * 8, 0, math.sin(angle) * 8)
	makePart("AncientStone" .. i, Vector3.new(randomInRange(2, 3), randomInRange(4, 7), randomInRange(1.5, 2.5)), 
		stonePos + Vector3.new(0, 2.5, 0), Color3.fromRGB(105, 105, 105), Enum.Material.Rock, WhisperingWoods)
end

-- Fog-colored ground patches
for i = 1, 15 do
	local pos = randomPointInRect(200, 350, 50, 200)
	makePart("FogPatch" .. i, Vector3.new(randomInRange(4, 8), 0.1, randomInRange(4, 8)), 
		pos + Vector3.new(0, 0.05, 0), Color3.fromRGB(248, 248, 255), Enum.Material.ForceField, WhisperingWoods, 
		{Transparency = 0.7, CanCollide = false})
end

-- Owl perches on tall trees
for i = 1, 5 do
	local pos = randomPointInRect(220, 330, 70, 180)
	makePart("OwlPerch" .. i, Vector3.new(0.5, 0.5, 1.2), pos + Vector3.new(0, 15, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, WhisperingWoods)
	-- Owl
	makePart("Owl" .. i, Vector3.new(0.8, 1, 0.6), pos + Vector3.new(0, 15.7, 0), 
		Color3.fromRGB(139, 69, 19), Enum.Material.SmoothPlastic, WhisperingWoods)
end

-- Firefly particles (neon dots)
for i = 1, 20 do
	local pos = randomPointInRect(200, 350, 50, 200)
	makePart("Firefly" .. i, Vector3.new(0.1, 0.1, 0.1), pos + Vector3.new(0, randomInRange(2, 6), 0), 
		Color3.fromRGB(255, 255, 0), Enum.Material.Neon, WhisperingWoods, 
		{Transparency = 0.3, CanCollide = false, Shape = Enum.PartType.Ball})
	-- Add light
	local light = Instance.new("PointLight")
	light.Color = Color3.fromRGB(255, 255, 0)
	light.Brightness = 1
	light.Range = 3
	light.Parent = WhisperingWoods:FindFirstChild("Firefly" .. i)
end

--------------------------------------------------------------------------------
-- 2. DEEP MINE (X: -300 to -200, Z: -50 to 50)
--------------------------------------------------------------------------------
print("[MapSetup4] Building Deep Mine...")
local DeepMine = getOrMake(MapDecorations, "DeepMine")

-- Mine entrance (stone arch)
makePart("MineEntrance", Vector3.new(12, 8, 3), Vector3.new(-250, 4, 0), 
	Color3.fromRGB(105, 105, 105), Enum.Material.Rock, DeepMine)
makePart("MineEntranceHole", Vector3.new(6, 6, 4), Vector3.new(-250, 3, 0), 
	Color3.fromRGB(0, 0, 0), Enum.Material.SmoothPlastic, DeepMine, {Transparency = 0.9})

-- Minecart tracks (parallel thin dark parts)
for i = 1, 20 do
	local zPos = -40 + (i * 4)
	-- Left rail
	makePart("RailLeft" .. i, Vector3.new(0.2, 0.3, 2), Vector3.new(-275, 0.15, zPos), 
		Color3.fromRGB(64, 64, 64), Enum.Material.Metal, DeepMine)
	-- Right rail
	makePart("RailRight" .. i, Vector3.new(0.2, 0.3, 2), Vector3.new(-272, 0.15, zPos), 
		Color3.fromRGB(64, 64, 64), Enum.Material.Metal, DeepMine)
	-- Cross ties
	if i % 2 == 0 then
		makePart("CrossTie" .. i, Vector3.new(4, 0.5, 0.3), Vector3.new(-273.5, 0.1, zPos), 
			Color3.fromRGB(101, 67, 33), Enum.Material.Wood, DeepMine)
	end
end

-- Support beams (brown blocks)
for i = 1, 12 do
	local pos = randomPointInRect(-295, -205, -45, 45)
	makePart("SupportBeam" .. i, Vector3.new(0.8, randomInRange(6, 10), 0.8), pos + Vector3.new(0, 4, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, DeepMine)
	-- Cross beam
	makePart("CrossBeam" .. i, Vector3.new(randomInRange(4, 8), 0.6, 0.6), pos + Vector3.new(0, 8, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, DeepMine)
end

-- Ore veins glowing on walls
for i = 1, 15 do
	local pos = randomPointInRect(-295, -205, -45, 45)
	local oreColor = ({Color3.fromRGB(255, 215, 0), Color3.fromRGB(169, 169, 169), Color3.fromRGB(184, 115, 51)})[math.random(1,3)]
	makePart("OreVein" .. i, Vector3.new(randomInRange(2, 4), randomInRange(1.5, 3), 0.5), pos + Vector3.new(0, 2, 0), 
		oreColor, Enum.Material.Neon, DeepMine, {Transparency = 0.2})
end

-- Mine shaft going down (dark hole with ladder)
makePart("MineShaft", Vector3.new(6, 20, 6), Vector3.new(-260, -10, 10), 
	Color3.fromRGB(0, 0, 0), Enum.Material.SmoothPlastic, DeepMine, {Transparency = 0.8})
-- Ladder
for i = 1, 10 do
	makePart("LadderRung" .. i, Vector3.new(0.3, 0.2, 2), Vector3.new(-257, i * -2, 10), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, DeepMine)
end

-- Lanterns
for i = 1, 8 do
	local pos = randomPointInRect(-290, -210, -40, 40)
	makePart("LanternPost" .. i, Vector3.new(0.3, 4, 0.3), pos + Vector3.new(0, 2, 0), 
		Color3.fromRGB(64, 64, 64), Enum.Material.Metal, DeepMine)
	makePart("Lantern" .. i, Vector3.new(1, 1.5, 1), pos + Vector3.new(0, 4.5, 0), 
		Color3.fromRGB(255, 140, 0), Enum.Material.Neon, DeepMine, {Transparency = 0.3})
	-- Light
	local light = Instance.new("PointLight")
	light.Color = Color3.fromRGB(255, 140, 0)
	light.Brightness = 2
	light.Range = 12
	light.Parent = DeepMine:FindFirstChild("Lantern" .. i)
end

-- Rubble piles
for i = 1, 10 do
	local pos = randomPointInRect(-295, -205, -45, 45)
	makePart("RubblePile" .. i, Vector3.new(randomInRange(2, 5), randomInRange(1, 2.5), randomInRange(2, 5)), 
		pos + Vector3.new(0, 1, 0), Color3.fromRGB(105, 105, 105), Enum.Material.Rock, DeepMine)
end

--------------------------------------------------------------------------------
-- 3. CRYSTAL CAVERN (X: -350 to -250, Z: -150 to -80)
--------------------------------------------------------------------------------
print("[MapSetup4] Building Crystal Cavern...")
local CrystalCavern = getOrMake(MapDecorations, "CrystalCavern")

-- Large crystal spires (neon purple/blue/pink transparent parts pointing up at angles)
for i = 1, 20 do
	local pos = randomPointInRect(-345, -255, -145, -85)
	local crystalColors = {Color3.fromRGB(138, 43, 226), Color3.fromRGB(75, 0, 130), Color3.fromRGB(255, 20, 147)}
	local color = crystalColors[math.random(1, #crystalColors)]
	local height = randomInRange(6, 15)
	
	makePart("CrystalSpire" .. i, Vector3.new(randomInRange(1.5, 3), height, randomInRange(1.5, 3)), 
		pos + Vector3.new(0, height/2, 0), color, Enum.Material.ForceField, CrystalCavern,
		{Transparency = 0.4, Orientation = Vector3.new(randomInRange(-10, 10), randomInRange(0, 360), randomInRange(-10, 10))})
	
	-- Crystal glow
	local light = Instance.new("PointLight")
	light.Color = color
	light.Brightness = 1.5
	light.Range = 8
	light.Parent = CrystalCavern:FindFirstChild("CrystalSpire" .. i)
end

-- Crystal pools (blue transparent floors)
for i = 1, 6 do
	local pos = randomPointInRect(-340, -260, -140, -90)
	makePart("CrystalPool" .. i, Vector3.new(randomInRange(6, 12), 0.5, randomInRange(6, 12)), 
		pos + Vector3.new(0, 0.25, 0), Color3.fromRGB(65, 130, 175), Enum.Material.Water, CrystalCavern,
		{Transparency = 0.3})
end

-- Glowing mushrooms
for i = 1, 15 do
	local pos = randomPointInRect(-345, -255, -145, -85)
	makePart("GlowMushroom" .. i, Vector3.new(randomInRange(0.8, 2), randomInRange(1, 3), randomInRange(0.8, 2)), 
		pos + Vector3.new(0, 1, 0), Color3.fromRGB(0, 255, 127), Enum.Material.Neon, CrystalCavern, 
		{Transparency = 0.3})
end

-- Ambient sparkle parts
for i = 1, 30 do
	local pos = randomPointInRect(-345, -255, -145, -85)
	makePart("Sparkle" .. i, Vector3.new(0.2, 0.2, 0.2), pos + Vector3.new(0, randomInRange(1, 8), 0), 
		Color3.fromRGB(255, 255, 255), Enum.Material.Neon, CrystalCavern,
		{Transparency = 0.2, CanCollide = false, Shape = Enum.PartType.Ball})
end

--------------------------------------------------------------------------------
-- 4. MOONLIT POND (X: 250-320, Z: -50 to 20)
--------------------------------------------------------------------------------
print("[MapSetup4] Building Moonlit Pond...")
local MoonlitPond = getOrMake(MapDecorations, "MoonlitPond")

-- Large scenic pond (blue transparent part)
makePart("MainPond", Vector3.new(60, 2, 60), Vector3.new(285, 1, -15), 
	Color3.fromRGB(65, 130, 175), Enum.Material.Water, MoonlitPond, {Transparency = 0.3})

-- Water lilies (green+pink flat parts)
for i = 1, 12 do
	local pos = randomPointInRect(260, 310, -40, 10)
	makePart("LilyPad" .. i, Vector3.new(randomInRange(2, 3), 0.1, randomInRange(2, 3)), 
		pos + Vector3.new(0, 2.1, 0), Color3.fromRGB(34, 139, 34), Enum.Material.SmoothPlastic, MoonlitPond,
		{CanCollide = false, Shape = Enum.PartType.Cylinder})
	-- Lily flower
	makePart("LilyFlower" .. i, Vector3.new(0.8, 0.3, 0.8), pos + Vector3.new(0, 2.3, 0), 
		Color3.fromRGB(255, 182, 193), Enum.Material.SmoothPlastic, MoonlitPond, {CanCollide = false})
end

-- Cattails (thin brown+green parts)
for i = 1, 20 do
	local pos = randomPointInRect(255, 315, -45, 15)
	makePart("CattailStem" .. i, Vector3.new(0.3, randomInRange(4, 6), 0.3), pos + Vector3.new(0, 2.5, 0), 
		Color3.fromRGB(85, 107, 47), Enum.Material.SmoothPlastic, MoonlitPond)
	makePart("CattailHead" .. i, Vector3.new(0.5, 1.5, 0.5), pos + Vector3.new(0, 5.5, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.SmoothPlastic, MoonlitPond, {Shape = Enum.PartType.Cylinder})
end

-- Wooden dock (brown planks)
local dockStart = Vector3.new(270, 2, -5)
for i = 1, 8 do
	makePart("DockPlank" .. i, Vector3.new(3, 0.5, 12), dockStart + Vector3.new(i * 3, 0, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, MoonlitPond)
end
-- Dock posts
for i = 1, 3 do
	makePart("DockPost" .. i, Vector3.new(0.8, 4, 0.8), dockStart + Vector3.new(i * 8, -1, -5), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, MoonlitPond)
	makePart("DockPost" .. i .. "B", Vector3.new(0.8, 4, 0.8), dockStart + Vector3.new(i * 8, -1, 5), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, MoonlitPond)
end

-- Frogs (small green parts)
for i = 1, 8 do
	local pos = randomPointInRect(260, 310, -40, 10)
	makePart("Frog" .. i, Vector3.new(0.8, 0.6, 1.2), pos + Vector3.new(0, 2.3, 0), 
		Color3.fromRGB(0, 128, 0), Enum.Material.SmoothPlastic, MoonlitPond, {CanCollide = false})
end

-- Willow trees (drooping branch parts)
for i = 1, 5 do
	local pos = randomPointInRect(252, 318, -48, 18)
	-- Main trunk
	makePart("WillowTrunk" .. i, Vector3.new(2, 12, 2), pos + Vector3.new(0, 6, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, MoonlitPond)
	-- Drooping branches
	for j = 1, 8 do
		local angle = (j / 8) * 2 * math.pi
		local branchPos = pos + Vector3.new(math.cos(angle) * 4, 10, math.sin(angle) * 4)
		makePart("WillowBranch" .. i .. "_" .. j, Vector3.new(0.5, randomInRange(6, 10), 0.5), 
			branchPos + Vector3.new(0, -3, 0), Color3.fromRGB(85, 107, 47), Enum.Material.Grass, MoonlitPond,
			{Orientation = Vector3.new(randomInRange(15, 35), randomInRange(0, 360), randomInRange(-10, 10))})
	end
end

--------------------------------------------------------------------------------
-- 5. THORNWOOD THICKET (X: -200 to -100, Z: 200-350)
--------------------------------------------------------------------------------
print("[MapSetup4] Building Thornwood Thicket...")
local ThornwoodThicket = getOrMake(MapDecorations, "ThornwoodThicket")

-- Twisted dark trees
for i = 1, 25 do
	local pos = randomPointInRect(-195, -105, 205, 345)
	local height = randomInRange(8, 16)
	makePart("TwistedTrunk" .. i, Vector3.new(randomInRange(1.5, 2.5), height, randomInRange(1.5, 2.5)), 
		pos + Vector3.new(0, height/2, 0), Color3.fromRGB(64, 64, 64), Enum.Material.Wood, ThornwoodThicket,
		{Orientation = Vector3.new(0, randomInRange(0, 360), randomInRange(-15, 15))})
	-- Dark crown
	makePart("TwistedCrown" .. i, Vector3.new(randomInRange(5, 8), randomInRange(3, 5), randomInRange(5, 8)), 
		pos + Vector3.new(0, height + 2, 0), Color3.fromRGB(25, 25, 25), Enum.Material.Grass, ThornwoodThicket,
		{Shape = Enum.PartType.Ball})
end

-- Thorny bushes (dark green with red dots)
for i = 1, 20 do
	local pos = randomPointInRect(-195, -105, 205, 345)
	makePart("ThornBush" .. i, Vector3.new(randomInRange(3, 5), randomInRange(2, 3), randomInRange(3, 5)), 
		pos + Vector3.new(0, 1.5, 0), Color3.fromRGB(25, 25, 25), Enum.Material.Grass, ThornwoodThicket)
	-- Red thorns
	for j = 1, 5 do
		local thornPos = pos + Vector3.new(randomInRange(-2, 2), randomInRange(1, 3), randomInRange(-2, 2))
		makePart("Thorn" .. i .. "_" .. j, Vector3.new(0.2, 0.8, 0.2), thornPos, 
			Color3.fromRGB(139, 0, 0), Enum.Material.SmoothPlastic, ThornwoodThicket, {CanCollide = false})
	end
end

-- Spider webs between trees (white thin parts)
for i = 1, 12 do
	local pos = randomPointInRect(-190, -110, 210, 340)
	makePart("SpiderWeb" .. i, Vector3.new(randomInRange(3, 6), 0.1, randomInRange(3, 6)), 
		pos + Vector3.new(0, randomInRange(3, 8), 0), Color3.fromRGB(248, 248, 255), Enum.Material.ForceField, 
		ThornwoodThicket, {Transparency = 0.7, CanCollide = false})
end

-- Dark purple ground patches
for i = 1, 15 do
	local pos = randomPointInRect(-195, -105, 205, 345)
	makePart("DarkPatch" .. i, Vector3.new(randomInRange(4, 8), 0.1, randomInRange(4, 8)), 
		pos + Vector3.new(0, 0.05, 0), Color3.fromRGB(75, 0, 130), Enum.Material.SmoothPlastic, ThornwoodThicket,
		{Transparency = 0.5, CanCollide = false})
end

-- Ravens (small black parts on trees)
for i = 1, 8 do
	local pos = randomPointInRect(-190, -110, 210, 340)
	makePart("Raven" .. i, Vector3.new(0.6, 0.5, 0.8), pos + Vector3.new(0, randomInRange(10, 15), 0), 
		Color3.fromRGB(0, 0, 0), Enum.Material.SmoothPlastic, ThornwoodThicket, {CanCollide = false})
end

--------------------------------------------------------------------------------
-- 6. SUNFLOWER FIELDS (X: 100-250, Z: 250-380)
--------------------------------------------------------------------------------
print("[MapSetup4] Building Sunflower Fields...")
local SunflowerFields = getOrMake(MapDecorations, "SunflowerFields")

-- Rows of sunflowers (yellow circles on green stems)
for row = 1, 8 do
	for col = 1, 15 do
		local pos = Vector3.new(110 + col * 9, 0, 260 + row * 15)
		-- Stem
		makePart("SunflowerStem" .. row .. "_" .. col, Vector3.new(0.4, randomInRange(4, 7), 0.4), 
			pos + Vector3.new(0, 2.5, 0), Color3.fromRGB(85, 107, 47), Enum.Material.Grass, SunflowerFields)
		-- Flower head
		makePart("SunflowerHead" .. row .. "_" .. col, Vector3.new(2, 0.5, 2), 
			pos + Vector3.new(0, randomInRange(5, 8), 0), Color3.fromRGB(255, 215, 0), Enum.Material.SmoothPlastic, 
			SunflowerFields, {Shape = Enum.PartType.Cylinder})
	end
end

-- Bee hives (yellow cubes)
for i = 1, 6 do
	local pos = randomPointInRect(120, 240, 270, 370)
	makePart("BeeHive" .. i, Vector3.new(2, 3, 2), pos + Vector3.new(0, 1.5, 0), 
		Color3.fromRGB(255, 215, 0), Enum.Material.SmoothPlastic, SunflowerFields)
	makePart("BeeHiveEntry" .. i, Vector3.new(0.8, 0.8, 0.3), pos + Vector3.new(0, 1.5, 1.2), 
		Color3.fromRGB(0, 0, 0), Enum.Material.SmoothPlastic, SunflowerFields)
end

-- Honey puddles
for i = 1, 8 do
	local pos = randomPointInRect(110, 240, 260, 370)
	makePart("HoneyPuddle" .. i, Vector3.new(randomInRange(2, 4), 0.2, randomInRange(2, 4)), 
		pos + Vector3.new(0, 0.1, 0), Color3.fromRGB(255, 140, 0), Enum.Material.SmoothPlastic, SunflowerFields,
		{Transparency = 0.3})
end

-- Picket fences
for i = 1, 20 do
	local pos = Vector3.new(105 + i * 7, 0, 255)
	makePart("FencePost" .. i, Vector3.new(0.3, 2, 0.3), pos + Vector3.new(0, 1, 0), 
		Color3.fromRGB(245, 245, 220), Enum.Material.SmoothPlastic, SunflowerFields)
	if i &lt; 20 then
		makePart("FenceRail" .. i, Vector3.new(7, 0.2, 0.3), pos + Vector3.new(3.5, 1.5, 0), 
			Color3.fromRGB(245, 245, 220), Enum.Material.SmoothPlastic, SunflowerFields)
	end
end

-- Windmill (large structure)
local windmillPos = Vector3.new(175, 0, 315)
makePart("WindmillBase", Vector3.new(6, 20, 6), windmillPos + Vector3.new(0, 10, 0), 
	Color3.fromRGB(245, 245, 220), Enum.Material.SmoothPlastic, SunflowerFields, {Shape = Enum.PartType.Cylinder})
-- Windmill blades
for i = 1, 4 do
	local angle = (i / 4) * 2 * math.pi
	makePart("WindmillBlade" .. i, Vector3.new(0.5, 12, 1), 
		windmillPos + Vector3.new(math.cos(angle) * 8, 20, math.sin(angle) * 8), 
		Color3.fromRGB(245, 245, 220), Enum.Material.SmoothPlastic, SunflowerFields,
		{Orientation = Vector3.new(0, math.deg(angle), 0)})
end

-- Wheat patches (tan thin parts)
for i = 1, 15 do
	local pos = randomPointInRect(120, 230, 270, 370)
	for j = 1, 10 do
		makePart("WheatStalk" .. i .. "_" .. j, Vector3.new(0.1, randomInRange(2, 3), 0.1), 
			pos + Vector3.new(randomInRange(-2, 2), 1.5, randomInRange(-2, 2)), 
			Color3.fromRGB(210, 180, 140), Enum.Material.SmoothPlastic, SunflowerFields)
	end
end

--------------------------------------------------------------------------------
-- 7. ABANDONED QUARRY (X: -150 to -50, Z: -250 to -150)
--------------------------------------------------------------------------------
print("[MapSetup4] Building Abandoned Quarry...")
local AbandonedQuarry = getOrMake(MapDecorations, "AbandonedQuarry")

-- Stepped terrain going down
for level = 1, 5 do
	local yPos = -(level * 3)
	local size = 80 - (level * 10)
	makePart("QuarryLevel" .. level, Vector3.new(size, 1, size), 
		Vector3.new(-100, yPos, -200), Color3.fromRGB(105, 105, 105), Enum.Material.Rock, AbandonedQuarry)
end

-- Broken machinery
for i = 1, 6 do
	local pos = randomPointInRect(-145, -55, -245, -155)
	makePart("BrokenMachine" .. i, Vector3.new(randomInRange(3, 6), randomInRange(2, 4), randomInRange(2, 5)), 
		pos + Vector3.new(0, 1.5, 0), Color3.fromRGB(64, 64, 64), Enum.Material.Metal, AbandonedQuarry)
	-- Rust patches
	makePart("RustPatch" .. i, Vector3.new(randomInRange(1, 3), randomInRange(1, 2), 0.1), 
		pos + Vector3.new(0, 2, 2.6), Color3.fromRGB(139, 69, 19), Enum.Material.SmoothPlastic, AbandonedQuarry)
end

-- Ore carts
for i = 1, 4 do
	local pos = randomPointInRect(-140, -60, -240, -160)
	makePart("OreCart" .. i, Vector3.new(3, 2, 4), pos + Vector3.new(0, 1, 0), 
		Color3.fromRGB(64, 64, 64), Enum.Material.Metal, AbandonedQuarry)
	-- Cart contents (ore)
	makePart("CartOre" .. i, Vector3.new(2.5, 1, 3.5), pos + Vector3.new(0, 2.25, 0), 
		Color3.fromRGB(105, 105, 105), Enum.Material.Rock, AbandonedQuarry)
end

-- Stagnant water at bottom
makePart("StagnantWater", Vector3.new(60, 1, 60), Vector3.new(-100, -14.5, -200), 
	Color3.fromRGB(30, 80, 120), Enum.Material.Water, AbandonedQuarry, {Transparency = 0.3})

-- Rusted metal parts
for i = 1, 12 do
	local pos = randomPointInRect(-145, -55, -245, -155)
	makePart("RustedMetal" .. i, Vector3.new(randomInRange(1, 3), randomInRange(0.5, 2), randomInRange(1, 3)), 
		pos + Vector3.new(0, 0.75, 0), Color3.fromRGB(139, 69, 19), Enum.Material.Metal, AbandonedQuarry)
end

-- Danger signs
for i = 1, 5 do
	local pos = randomPointInRect(-140, -60, -240, -160)
	makePart("DangerSignPost" .. i, Vector3.new(0.3, 4, 0.3), pos + Vector3.new(0, 2, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, AbandonedQuarry)
	makePart("DangerSign" .. i, Vector3.new(0.2, 2, 3), pos + Vector3.new(0, 3, 0), 
		Color3.fromRGB(255, 0, 0), Enum.Material.SmoothPlastic, AbandonedQuarry)
end

print("[MapSetup4] All themed areas completed!")</string>
      </Properties>
    </Item>
    <Item class="Script" referent="47">
      <Properties>
        <string name="Name">MapSetup5</string>
        <token name="RunContext">0</token>
        <string name="Source">--[[
	MapSetup5.server.lua
	ServerScriptService

	Creates 6 MASSIVE new themed areas with incredible detail (50-80 parts each):
	1. Pirate Cove (X: 300-400, Z: -200 to -100)
	2. Frozen Peaks (X: -400 to -300, Z: -300 to -200)
	3. Volcanic Crater (X: 300-400, Z: -400 to -300)
	4. Enchanted Garden (X: -300 to -200, Z: 200-350)
	5. Underground Ruins (X: -100 to 50, Z: -450 to -350)
	6. Dragon's Nest (X: 0-100, Z: -500 to -450)
]]

-- Wait for previous map setups to finish
task.wait(7)

print("[MapSetup5] Starting major new area creation...")

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------
local function getOrMake(parent, name)
	local existing = parent:FindFirstChild(name)
	if existing then return existing end
	local folder = Instance.new("Folder")
	folder.Name = name
	folder.Parent = parent
	return folder
end

local function makePart(name, size, position, color, material, parent, props)
	local part = Instance.new("Part")
	part.Name = name
	part.Size = size
	part.Position = position
	part.Anchored = true
	part.CanCollide = true
	part.Color = typeof(color) == "string" and BrickColor.new(color).Color or color
	part.Material = material or Enum.Material.SmoothPlastic
	
	if props then
		for key, value in pairs(props) do
			if key == "Orientation" then
				part.Orientation = value
			elseif key == "Transparency" then
				part.Transparency = value
			elseif key == "CanCollide" then
				part.CanCollide = value
			elseif key == "Shape" then
				part.Shape = value
			else
				part[key] = value
			end
		end
	end
	
	part.Parent = parent
	return part
end

local function makeSign(parent, text, offset, size)
	local bg = Instance.new("BillboardGui")
	bg.Size = size or UDim2.new(12, 0, 3, 0)
	bg.StudsOffset = offset or Vector3.new(0, 5, 0)
	bg.Parent = parent
	local tl = Instance.new("TextLabel")
	tl.Size = UDim2.new(1, 0, 1, 0)
	tl.BackgroundTransparency = 1
	tl.Text = text
	tl.TextColor3 = Color3.fromRGB(255, 255, 255)
	tl.TextScaled = true
	tl.Font = Enum.Font.GothamBold
	tl.TextStrokeTransparency = 0.3
	tl.Parent = bg
	return bg
end

local function randomInRange(min, max)
	return min + math.random() * (max - min)
end

local function randomPointInRect(xMin, xMax, zMin, zMax)
	return Vector3.new(randomInRange(xMin, xMax), 0, randomInRange(zMin, zMax))
end

local Workspace = game:GetService("Workspace")
local NewAreas = getOrMake(Workspace, "NewAreas")
local ResourceNodes = getOrMake(Workspace, "ResourceNodes")

--------------------------------------------------------------------------------
-- 1. PIRATE COVE (X: 300-400, Z: -200 to -100)
--------------------------------------------------------------------------------
print("[MapSetup5] Building Pirate Cove...")
local PirateCove = getOrMake(NewAreas, "PirateCove")

-- Sandy beach ground
for i = 1, 8 do
	local pos = randomPointInRect(300, 400, -200, -100)
	makePart("SandPatch" .. i, Vector3.new(randomInRange(15, 25), 0.5, randomInRange(15, 25)), 
		pos + Vector3.new(0, 0.25, 0), Color3.fromRGB(194, 178, 128), Enum.Material.Sand, PirateCove)
end

-- WRECKED PIRATE SHIP (massive centerpiece)
local shipCenter = Vector3.new(350, 0, -150)
-- Hull pieces (broken ship)
makePart("ShipHullMain", Vector3.new(25, 8, 5), shipCenter + Vector3.new(0, 4, 0), 
	Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove)
makePart("ShipHullBow", Vector3.new(15, 6, 4), shipCenter + Vector3.new(15, 3, -2), 
	Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove, {Orientation = Vector3.new(0, 15, -10)})
makePart("ShipHullStern", Vector3.new(12, 5, 4), shipCenter + Vector3.new(-18, 2.5, 3), 
	Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove, {Orientation = Vector3.new(0, -20, 5)})

-- Broken mast
makePart("MainMast", Vector3.new(1.5, 20, 1.5), shipCenter + Vector3.new(0, 10, 0), 
	Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove, {Orientation = Vector3.new(0, 0, -15)})
makePart("BrokenMastTop", Vector3.new(1, 8, 1), shipCenter + Vector3.new(-8, 4, -5), 
	Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove, {Orientation = Vector3.new(0, 45, -30)})

-- Tattered sails
for i = 1, 4 do
	local sailPos = shipCenter + Vector3.new(randomInRange(-10, 10), randomInRange(8, 15), randomInRange(-8, 8))
	makePart("TatteredSail" .. i, Vector3.new(randomInRange(6, 12), randomInRange(4, 8), 0.2), 
		sailPos, Color3.fromRGB(240, 230, 200), Enum.Material.Fabric, PirateCove, 
		{Transparency = 0.2, Orientation = Vector3.new(randomInRange(-20, 20), randomInRange(0, 360), randomInRange(-15, 15))})
end

-- Ship rigging (ropes)
for i = 1, 12 do
	local startPos = shipCenter + Vector3.new(randomInRange(-12, 12), randomInRange(5, 18), randomInRange(-6, 6))
	local endPos = startPos + Vector3.new(randomInRange(-8, 8), randomInRange(-5, 5), randomInRange(-8, 8))
	local midPoint = (startPos + endPos) * 0.5
	local length = (endPos - startPos).Magnitude
	makePart("Rigging" .. i, Vector3.new(0.15, 0.15, length), midPoint, 
		Color3.fromRGB(139, 90, 43), Enum.Material.Fabric, PirateCove)
end

-- Treasure chests scattered around
local treasurePositions = {
	{325, 0, -140}, {370, 0, -165}, {340, 0, -185}, {385, 0, -120}, {315, 0, -170}
}
for i, pos in ipairs(treasurePositions) do
	makePart("TreasureChest" .. i, Vector3.new(3, 2, 2), Vector3.new(pos[1], 1, pos[3]), 
		Color3.fromRGB(139, 90, 43), Enum.Material.Wood, PirateCove)
	makePart("ChestBanding" .. i, Vector3.new(3.2, 0.3, 2.2), Vector3.new(pos[1], 1, pos[3]), 
		Color3.fromRGB(64, 64, 64), Enum.Material.Metal, PirateCove)
	makePart("ChestLock" .. i, Vector3.new(0.6, 0.6, 0.4), Vector3.new(pos[1], 1, pos[3] + 1.2), 
		Color3.fromRGB(255, 215, 0), Enum.Material.Metal, PirateCove)
	-- Spilled treasure
	for j = 1, 5 do
		local coinPos = Vector3.new(pos[1], 0.2, pos[3]) + Vector3.new(randomInRange(-3, 3), 0, randomInRange(-3, 3))
		makePart("Coin" .. i .. "_" .. j, Vector3.new(0.3, 0.1, 0.3), coinPos, 
			Color3.fromRGB(255, 215, 0), Enum.Material.Metal, PirateCove, {Shape = Enum.PartType.Cylinder})
	end
end

-- Wooden dock with rope posts
local dockStart = Vector3.new(320, 0, -120)
for i = 1, 15 do
	makePart("DockPlank" .. i, Vector3.new(4, 0.5, 20), dockStart + Vector3.new(i * 4, 0.25, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove)
end
-- Dock posts with ropes
for i = 1, 4 do
	local postPos = dockStart + Vector3.new(i * 15, 0, -12)
	makePart("DockPost" .. i, Vector3.new(0.8, 6, 0.8), postPos + Vector3.new(0, 3, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove)
	-- Rope coiled around post
	makePart("CoiledRope" .. i, Vector3.new(2, 1.5, 2), postPos + Vector3.new(0, 1.5, 0), 
		Color3.fromRGB(139, 90, 43), Enum.Material.Fabric, PirateCove, {Shape = Enum.PartType.Ball})
end

-- Barrels and crates scattered around
for i = 1, 15 do
	local pos = randomPointInRect(305, 395, -195, -105)
	if math.random() > 0.5 then
		-- Barrel
		makePart("Barrel" .. i, Vector3.new(2.5, 3, 2.5), pos + Vector3.new(0, 1.5, 0), 
			Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove, {Shape = Enum.PartType.Cylinder})
		makePart("BarrelBand" .. i, Vector3.new(2.7, 0.2, 2.7), pos + Vector3.new(0, 1.5, 0), 
			Color3.fromRGB(64, 64, 64), Enum.Material.Metal, PirateCove)
	else
		-- Crate
		makePart("Crate" .. i, Vector3.new(2.5, 2.5, 2.5), pos + Vector3.new(0, 1.25, 0), 
			Color3.fromRGB(139, 90, 43), Enum.Material.Wood, PirateCove)
	end
end

-- Cannons (old ship artillery)
for i = 1, 6 do
	local cannonPos = randomPointInRect(320, 380, -180, -120)
	makePart("CannonBase" .. i, Vector3.new(3, 1, 4), cannonPos + Vector3.new(0, 0.5, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove)
	makePart("CannonBarrel" .. i, Vector3.new(1.5, 1.5, 6), cannonPos + Vector3.new(0, 1.5, 0), 
		Color3.fromRGB(64, 64, 64), Enum.Material.Metal, PirateCove, 
		{Shape = Enum.PartType.Cylinder, Orientation = Vector3.new(0, 0, 90)})
	makePart("CannonMuzzle" .. i, Vector3.new(1.8, 1.8, 0.5), cannonPos + Vector3.new(0, 1.5, 3.5), 
		Color3.fromRGB(40, 40, 40), Enum.Material.Metal, PirateCove, {Shape = Enum.PartType.Cylinder})
end

-- Palm trees (curved trunks)
for i = 1, 12 do
	local palmPos = randomPointInRect(310, 390, -190, -110)
	-- Curved trunk
	makePart("PalmTrunk" .. i, Vector3.new(1.5, 12, 1.5), palmPos + Vector3.new(0, 6, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove, 
		{Orientation = Vector3.new(randomInRange(-15, 15), randomInRange(0, 360), randomInRange(-20, 20))})
	-- Palm fronds (large leaves)
	for j = 1, 8 do
		local angle = (j / 8) * 360
		local frondPos = palmPos + Vector3.new(
			math.cos(math.rad(angle)) * 4, 
			12, 
			math.sin(math.rad(angle)) * 4
		)
		makePart("PalmFrond" .. i .. "_" .. j, Vector3.new(0.5, 0.2, 6), frondPos, 
			Color3.fromRGB(34, 139, 34), Enum.Material.Grass, PirateCove, 
			{Orientation = Vector3.new(randomInRange(-20, 20), angle, randomInRange(-30, 30))})
	end
	-- Coconuts
	for k = 1, 3 do
		local coconutPos = palmPos + Vector3.new(randomInRange(-2, 2), 10, randomInRange(-2, 2))
		makePart("Coconut" .. i .. "_" .. k, Vector3.new(0.8, 1, 0.8), coconutPos, 
			Color3.fromRGB(139, 69, 19), Enum.Material.Wood, PirateCove, {Shape = Enum.PartType.Ball})
	end
end

-- Tide pools (small water features)
for i = 1, 8 do
	local poolPos = randomPointInRect(305, 395, -195, -105)
	makePart("TidePool" .. i, Vector3.new(randomInRange(3, 6), 0.3, randomInRange(3, 6)), 
		poolPos + Vector3.new(0, 0.15, 0), Color3.fromRGB(65, 130, 175), Enum.Material.Water, 
		PirateCove, {Transparency = 0.3, Shape = Enum.PartType.Ball})
	-- Pool creatures
	for j = 1, 3 do
		local creaturePos = poolPos + Vector3.new(randomInRange(-2, 2), 0.5, randomInRange(-2, 2))
		makePart("Starfish" .. i .. "_" .. j, Vector3.new(0.5, 0.1, 0.5), creaturePos, 
			Color3.fromRGB(255, 69, 0), Enum.Material.SmoothPlastic, PirateCove)
	end
end

-- Cave entrance in cliff
makePart("CliffWallL", Vector3.new(8, 15, 12), Vector3.new(390, 7.5, -180), 
	Color3.fromRGB(105, 105, 105), Enum.Material.Rock, PirateCove)
makePart("CliffWallR", Vector3.new(8, 15, 12), Vector3.new(405, 7.5, -180), 
	Color3.fromRGB(105, 105, 105), Enum.Material.Rock, PirateCove)
makePart("CaveArch", Vector3.new(9, 6, 8), Vector3.new(397.5, 13, -180), 
	Color3.fromRGB(105, 105, 105), Enum.Material.Rock, PirateCove)
makePart("CaveEntrance", Vector3.new(6, 8, 10), Vector3.new(397.5, 4, -175), 
	Color3.fromRGB(20, 20, 20), Enum.Material.SmoothPlastic, PirateCove, {Transparency = 0.8})

-- Seagull perches (tall posts)
for i = 1, 6 do
	local perchPos = randomPointInRect(315, 385, -185, -115)
	makePart("SeagullPerch" .. i, Vector3.new(0.5, 8, 0.5), perchPos + Vector3.new(0, 4, 0), 
		Color3.fromRGB(101, 67, 33), Enum.Material.Wood, PirateCove)
	makePart("Seagull" .. i, Vector3.new(1, 0.8, 1.5), perchPos + Vector3.new(0, 8.5, 0), 
		Color3.fromRGB(240, 240, 240), Enum.Material.SmoothPlastic, PirateCove)
end

-- Ship anchor
makePart("Anchor", Vector3.new(2, 4, 1), Vector3.new(345, 1, -130), 
	Color3.fromRGB(64, 64, 64), Enum.Material.Metal, PirateCove)
makePart("AnchorChain", Vector3.new(0.3, 15, 0.3), Vector3.new(345, 8, -130), 
	Color3.fromRGB(64, 64, 64), Enum.Material.Metal, PirateCove)

-- Pirate Cove sign
local pirateSign = makePart("PirateSign", Vector3.new(1, 1, 1), Vector3.new(350, 12, -100), 
	"White", nil, PirateCove, {Transparency = 1})
makeSign(pirateSign, "üè¥‚Äç‚ò†Ô∏è PIRATE COVE", Vector3.new(0, 0, 0))

--------------------------------------------------------------------------------
-- 2. FROZEN PEAKS (X: -400 to -300, Z: -300 to -200)
--------------------------------------------------------------------------------
print("[MapSetup5] Building Frozen Peaks...")
local FrozenPeaks = getOrMake(NewAreas, "FrozenPeaks")

-- Snow-covered ground patches
for i = 1, 12 do
	local pos = randomPointInRect(-400, -300, -300, -200)
	makePart("SnowPatch" .. i, Vector3.new(randomInRange(12, 20), 0.8, randomInRange(12, 20)), 
		pos + Vector3.new(0, 0.4, 0), Color3.fromRGB(248, 248, 255), Enum.Material.Snow, FrozenPeaks)
end

-- Massive ice crystals (angled spires)
for i = 1, 15 do
	local pos = randomPointInRect(-395, -305, -295, -205)
	local height = randomInRange(8, 18)
	makePart("IceCrystal" .. i, Vector3.new(randomInRange(2, 4), height, randomInRange(2, 4)), 
		pos + Vector3.new(0, height/2, 0), Color3.fromRGB(173, 216, 230), Enum.Material.ForceField, 
		FrozenPeaks, {Transparency = 0.3, Orientation = Vector3.new(randomInRange(-15, 15), randomInRange(0, 360), randomInRange(-15, 15))})
	-- Crystal glow
	local light = Instance.new("PointLight")
	light.Color = Color3.fromRGB(173, 216, 230)
	light.Brightness = 1.5
	light.Range = 12
	light.Parent = FrozenPeaks:FindFirstChild("IceCrystal" .. i)
end

-- Frozen waterfall (vertical ice strip)
makePart("WaterfallIce", Vector3.new(6, 25, 1), Vector3.new(-370, 12.5, -220), 
	Color3.fromRGB(173, 216, 230), Enum.Material.ForceField, FrozenPeaks, {Transparency = 0.4})
makePart("WaterfallBase", Vector3.new(8, 2, 8), Vector3.new(-370, 1, -220), 
	Color3.fromRGB(173, 216, 230), Enum.Material.Ice, FrozenPeaks, {Transparency = 0.2})
-- Icicles around waterfall
for i = 1, 12 do
	local iciclePos = Vector3.new(-370, 0, -220) + Vector3.new(randomInRange(-8, 8), randomInRange(15, 22), randomInRange(-3, 3))
	makePart("Icicle" .. i, Vector3.new(0.5, randomInRange(3, 8), 0.5), iciclePos, 
		Color3.fromRGB(240, 248, 255), Enum.Material.Ice, FrozenPeaks, {Transparency = 0.2})
end

-- Snow-covered pine trees
for i = 1, 20 do
	local treePos = randomPointInRect(-390, -310, -290, -210)
	-- Trunk
	makePart("PineTrunk" .. i, Vector3.new(1.5, randomInRange(10, 16), 1.5), 
		treePos + Vector3.new(0, 6, 0), Color3.fromRGB(101, 67, 33), Enum.Material.Wood, FrozenPeaks)
	-- Layered pine branches with snow
	local treeHeight = 12
	for layer = 1, 4 do
		local layerY = treeHeight - (layer * 2.5)
		local layerSize = 5 + (4 - layer) * 1.5
		-- Green base
		makePart("PineBranch" .. i .. "_" .. layer, 
			Vector3.new(layerSize, 1.5, layerSize), 
			treePos + Vector3.new(0, layerY, 0), 
			Color3.fromRGB(34, 139, 34), Enum.Material.Grass, FrozenPeaks, {Shape = Enum.PartType.Ball})
		-- Snow topping
		makePart("PineSnow" .. i .. "_" .. layer, 
			Vector3.new(layerSize * 0.8, 0.8, layerSize * 0.8), 
			treePos + Vector3.new(0, layerY + 0.8, 0), 
			Color3.fromRGB(248, 248, 255), Enum.Material.Snow, FrozenPeaks, {Shape = Enum.PartType.Ball})
	end
end

-- Ice cave entrance
makePart("IceCaveL", Vector3.new(8, 12, 8), Vector3.new(-380, 6, -260), 
	Color3.fromRGB(173, 216, 230), Enum.Material.Ice, FrozenPeaks, {Transparency = 0.2})
makePart("IceCaveR", Vector3.new(8, 12, 8), Vector3.new(-365, 6, -260), 
	Color3.fromRGB(173, 216, 230), Enum.Material.Ice, FrozenPeaks, {Transparency = 0.2})
makePart("IceCaveTop", Vector3.new(23, 5, 8), Vector3.new(-372.5, 14, -260), 
	Color3.fromRGB(173, 216, 230), Enum.Material.Ice, FrozenPeaks, {Transparency = 0.2})
makePart("CaveInterior", Vector3.new(12, 8, 15), Vector3.new(-372.5, 4, -255), 
	Color3.fromRGB(30, 30, 60), Enum.Material.SmoothPlastic, FrozenPeaks, {Transparency = 0.7})

-- Frozen lake (large ice sheet)
makePart("FrozenLake", Vector3.new(40, 0.8, 30), Vector3.new(-350, 0.4, -240), 
	Color3.fromRGB(173, 216, 230), Enum.Material.Ice, FrozenPeaks, {Transparency = 0.3})
-- Cracks in ice
for i = 1, 8 do
	local crackPos = Vector3.new(-350, 0.9, -240) + Vector3.new(randomInRange(-18, 18), 0, randomInRange(-13, 13))
	makePart("IceCrack" .. i, Vector3.new(0.2, 0.1, randomInRange(5, 12)), crackPos, 
		Color3.fromRGB(100, 150, 200), Enum.Material.Ice, FrozenPeaks, {Transparency = 0.5})
end

-- Snow drifts (white bumps)
for i = 1, 15 do
	local driftPos = randomPointInRect(-395, -305, -295, -205)
	makePart("SnowDrift" .. i, Vector3.new(randomInRange(4, 8), randomInRange(2, 4), randomInRange(4, 8)), 
		driftPos + Vector3.new(0, 1, 0), Color3.fromRGB(248, 248, 255), Enum.Material.Snow, FrozenPeaks, 
		{Shape = Enum.PartType.Ball})
end

-- Rock overhangs with icicles
for i = 1, 6 do
	local overhangPos = randomPointInRect(-390, -310, -290, -210)
	makePart("RockOverhang" .. i, Vector3.new(randomInRange(8, 12), 3, randomInRange(6, 10)), 
		overhangPos + Vector3.new(0, 8, 0), Color3.fromRGB(105, 105, 105), Enum.Material.Rock, FrozenPeaks)
	-- Hanging icicles
	for j = 1, 6 do
		local iciclePos = overhangPos + Vector3.new(randomInRange(-5, 5), 6.5, randomInRange(-4, 4))
		makePart("HangingIcicle" .. i .. "_" .. j, 
			Vector3.new(0.4, randomInRange(2, 5), 0.4), iciclePos, 
			Color3.fromRGB(240, 248, 255), Enum.Material.Ice, FrozenPeaks, {Transparency = 0.2})
	end
end

-- Frozen Peaks sign
local frozenSign = makePart("FrozenSign", Vector3.new(1, 1, 1), Vector3.new(-350, 15, -200), 
	"White", nil, FrozenPeaks, {Transparency = 1})
makeSign(frozenSign, "üóª FROZEN PEAKS", Vector3.new(0, 0, 0))

--------------------------------------------------------------------------------
-- 3. VOLCANIC CRATER (X: 300-400, Z: -400 to -300)
--------------------------------------------------------------------------------
print("[MapSetup5] Building Volcanic Crater...")
local VolcanicCrater = getOrMake(NewAreas, "VolcanicCrater")

-- Dark volcanic rock terrain
for i = 1, 10 do
	local pos = randomPointInRect(300, 400, -400, -300)
	makePart("VolcanicGround" .. i, Vector3.new(randomInRange(15, 25), 1, randomInRange(15, 25)), 
		pos + Vector3.new(0, 0.5, 0), Color3.fromRGB(64, 32, 32), Enum.Material.Rock, VolcanicCrater)
end

-- Lava pools (orange-red neon with lights)
for i = 1, 12 do
	local poolPos = randomPointInRect(310, 390, -390, -310)
	local pool = makePart("LavaPool" .. i, Vector3.new(randomInRange(5, 10), 0.8, randomInRange(5, 10)), 
		poolPos + Vector3.new(0, 0.4, 0), Color3.fromRGB(255, 69, 0), Enum.Material.Neon, 
		VolcanicCrater, {Transparency = 0.2})
	-- Lava light
	local lavaLight = Instance.new("PointLight")
	lavaLight.Color = Color3.fromRGB(255, 100, 20)
	lavaLight.Brightness = 3
	lavaLight.Range = 15
	lavaLight.Parent = pool
	-- Bubbling effect
	for j = 1, 3 do
		local bubblePos = poolPos + Vector3.new(randomInRange(-3, 3), 1.5, randomInRange(-3, 3))
		makePart("LavaBubble" .. i .. "_" .. j, Vector3.new(0.8, 0.8, 0.8), bubblePos, 
			Color3.fromRGB(255, 140, 0), Enum.Material.Neon, VolcanicCrater, 
			{Transparency = 0.4, Shape = Enum.PartType.Ball, CanCollide = false})
	end
end

-- Obsidian spikes (black shiny pointed parts)
for i = 1, 18 do
	local spikePos = randomPointInRect(305, 395, -395, -305)
	local height = randomInRange(4, 12)
	makePart("ObsidianSpike" .. i, Vector3.new(randomInRange(1.5, 3), height, randomInRange(1.5, 3)), 
		spikePos + Vector3.new(0, height/2, 0), Color3.fromRGB(20, 20, 20), Enum.Material.Glass, 
		VolcanicCrater, {Orientation = Vector3.new(randomInRange(-10, 10), randomInRange(0, 360), randomInRange(-10, 10))})
end

-- Sulfur vents (yellow parts with smoke effect)
for i = 1, 8 do
	local ventPos = randomPointInRect(315, 385, -385, -315)
	makePart("SulfurVent" .. i, Vector3.new(2, 1, 2), ventPos + Vector3.new(0, 0.5, 0), 
		Color3.fromRGB(255, 255, 0), Enum.Material.Neon, VolcanicCrater, {Transparency = 0.3})
	-- Sulfur crystals around vent
	for j = 1, 4 do
		local crystalPos = ventPos + Vector3.new(randomInRange(-3, 3), 0.5, randomInRange(-3, 3))
		makePart("SulfurCrystal" .. i .. "_" .. j, Vector3.new(0.5, randomInRange(1, 2), 0.5), crystalPos, 
			Color3.fromRGB(255, 215, 0), Enum.Material.Neon, VolcanicCrater, {Transparency = 0.4})
	end
	-- Smoke effect (gray transparent parts)
	for k = 1, 3 do
		local smokeHeight = k * 3
		makePart("Smoke" .. i .. "_" .. k, Vector3.new(3 + k, 2, 3 + k), 
			ventPos + Vector3.new(0, smokeHeight, 0), Color3.fromRGB(100, 100, 100), 
			Enum.Material.ForceField, VolcanicCrater, 
			{Transparency = 0.7 + (k * 0.1), CanCollide = false, Shape = Enum.PartType.Ball})
	end
end

-- Charred trees (black trunks, no leaves)
for i = 1, 15 do
	local treePos = randomPointInRect(310, 390, -390, -310)
	local height = randomInRange(6, 12)
	makePart("CharredTrunk" .. i, Vector3.new(1.2, height, 1.2), 
		treePos + Vector3.new(0, height/2, 0), Color3.fromRGB(20, 20, 20), 
		Enum.Material.Wood, VolcanicCrater)
	-- Charred branches
	for j = 1, 3 do
		local branchAngle = (j / 3) * 360
		local branchPos = treePos + Vector3.new(
			math.cos(math.rad(branchAngle)) * 2, 
			height * 0.7, 
			math.sin(math.rad(branchAngle)) * 2
		)
		makePart("CharredBranch" .. i .. "_" .. j, Vector3.new(0.5, 0.5, 3), branchPos, 
			Color3.fromRGB(30, 30, 30), Enum.Material.Wood, VolcanicCrater, 
			{Orientation = Vector3.new(0, branchAngle, randomInRange(-30, 30))})
	end
end

-- Volcanic boulders
for i = 1, 20 do
	local boulderPos = randomPointInRect(305, 395, -395, -305)
	makePart("VolcanicBoulder" .. i, 
		Vector3.new(randomInRange(3, 8), randomInRange(2, 5), randomInRange(3, 8)), 
		boulderPos + Vector3.new(0, 2, 0), Color3.fromRGB(80, 40, 40), 
		Enum.Material.Rock, VolcanicCrater, {Shape = Enum.PartType.Ball})
end

-- Cracked earth (dark lines on ground)
for i = 1, 15 do
	local crackPos = randomPointInRect(310, 390, -390, -310)
	makePart("EarthCrack" .. i, Vector3.new(0.5, 0.2, randomInRange(8, 15)), crackPos, 
		Color3.fromRGB(40, 20, 20), Enum.Material.Concrete, VolcanicCrater, 
		{Orientation = Vector3.new(0, randomInRange(0, 360), 0)})
end

-- Fire geysers
for i = 1, 6 do
	local geyserPos = randomPointInRect(320, 380, -380, -320)
	makePart("GeyserBase" .. i, Vector3.new(3, 0.8, 3), geyserPos + Vector3.new(0, 0.4, 0), 
		Color3.fromRGB(60, 30, 30), Enum.Material.Rock, VolcanicCrater)
	-- Fire column
	for j = 1, 5 do
		local fireHeight = j * 2
		makePart("GeyserFire" .. i .. "_" .. j, Vector3.new(2 - (j * 0.2), 1.5, 2 - (j * 0.2)), 
			geyserPos + Vector3.new(0, fireHeight, 0), Color3.fromRGB(255, 100 - (j * 15), 0), 
			Enum.Material.Neon, VolcanicCrater, 
			{Transparency = 0.2 + (j * 0.1), CanCollide = false})
	end
end

-- Ash piles
for i = 1, 12 do
	local ashPos = randomPointInRect(315, 385, -385, -315)
	makePart("AshPile" .. i, Vector3.new(randomInRange(3, 6), randomInRange(1, 2), randomInRange(3, 6)), 
		ashPos + Vector3.new(0, 0.75, 0), Color3.fromRGB(64, 64, 64), 
		Enum.Material.Sand, VolcanicCrater, {Shape = Enum.PartType.Ball})
end

-- Volcanic Crater sign
local volcanicSign = makePart("VolcanicSign", Vector3.new(1, 1, 1), Vector3.new(350, 12, -300), 
	"White", nil, VolcanicCrater, {Transparency = 1})
makeSign(volcanicSign, "üåã VOLCANIC CRATER", Vector3.new(0, 0, 0))

--------------------------------------------------------------------------------
-- 4. ENCHANTED GARDEN (X: -300 to -200, Z: 200-350)
--------------------------------------------------------------------------------
print("[MapSetup5] Building Enchanted Garden...")
local EnchantedGarden = getOrMake(NewAreas, "EnchantedGarden")

-- Magical flower paradise - giant flowers
for i = 1, 20 do
	local flowerPos = randomPointInRect(-295, -205, 205, 345)
	local colors = {Color3.fromRGB(255, 20, 147), Color3.fromRGB(138, 43, 226), Color3.fromRGB(255, 69, 0), 
					Color3.fromRGB(50, 205, 50), Color3.fromRGB(30, 144, 255), Color3.fromRGB(255, 215, 0)}
	local color = colors[math.random(1, #colors)]
	
	-- Stem
	makePart("FlowerStem" .. i, Vector3.new(0.8, randomInRange(6, 10), 0.8), 
		flowerPos + Vector3.new(0, 4, 0), Color3.fromRGB(34, 139, 34), 
		Enum.Material.Grass, EnchantedGarden)
	
	-- Oversized petals
	local petalCount = 6
	local stemHeight = 8
	for j = 1, petalCount do
		local angle = (j / petalCount) * 360
		local petalPos = flowerPos + Vector3.new(
			math.cos(math.rad(angle)) * 3, 
			stemHeight, 
			math.sin(math.rad(angle)) * 3
		)
		makePart("FlowerPetal" .. i .. "_" .. j, Vector3.new(2, 0.3, 4), petalPos, 
			color, Enum.Material.Neon, EnchantedGarden, 
			{Transparency = 0.2, Orientation = Vector3.new(randomInRange(-15, 15), angle, randomInRange(-20, 20))})
	end
	
	-- Flower center
	makePart("FlowerCenter" .. i, Vector3.new(2, 1, 2), flowerPos + Vector3.new(0, stemHeight, 0), 
		Color3.fromRGB(255, 215, 0), Enum.Material.Neon, EnchantedGarden, 
		{Transparency = 0.1, Shape = Enum.PartType.Ball})
end

-- Fairy rings (circles of glowing mushrooms)
for ring = 1, 5 do
	local centerPos = randomPointInRect(-280, -220, 220, 330)
	local radius = randomInRange(5, 8)
	for i = 1, 12 do
		local angle = (i / 12) * 360
		local mushroomPos = centerPos + Vector3.new(
			math.cos(math.rad(angle)) * radius, 
			0, 
			math.sin(math.rad(angle)) * radius
		)
		local mushroom = makePart("FairyMushroom" .. ring .. "_" .. i, 
			Vector3.new(0.8, 1.5, 0.8), mushroomPos + Vector3.new(0, 0.75, 0), 
			Color3.fromRGB(147, 0, 211), Enum.Material.Neon, EnchantedGarden, 
			{Transparency = 0.3})
		-- Mushroom glow
		local mushroomLight = Instance.new("PointLight")
		mushroomLight.Color = Color3.fromRGB(147, 0, 211)
		mushroomLight.Brightness = 1.5
		mushroomLight.Range = 5
		mushroomLight.Parent = mushroom
		
		-- Mushroom cap
		makePart("FairyMushroomCap" .. ring .. "_" .. i, Vector3.new(1.5, 0.4, 1.5), 
			mushroomPos + Vector3.new(0, 1.7, 0), Color3.fromRGB(255, 20, 147), 
			Enum.Material.Neon, EnchantedGarden, {Transparency = 0.2, Shape = Enum.PartType.Ball})
	end
	-- Fairy ring center glow
	makePart("FairyRingCenter" .. ring, Vector3.new(radius * 2, 0.1, radius * 2), centerPos, 
		Color3.fromRGB(186, 85, 211), Enum.Material.Neon, EnchantedGarden, 
		{Transparency = 0.8, CanCollide = false})
end

-- Enchanted fountain
local fountainCenter = Vector3.new(-250, 0, 275)
makePart("FountainBase", Vector3.new(12, 3, 12), fountainCenter + Vector3.new(0, 1.5, 0), 
	Color3.fromRGB(176, 196, 222), Enum.Material.Marble, EnchantedGarden)
makePart("FountainPool", Vector3.new(10, 0.5, 10), fountainCenter + Vector3.new(0, 3.25, 0), 
	Color3.fromRGB(176, 196, 222), Enum.Material.Marble, EnchantedGarden)
makePart("FountainWater", Vector3.new(9, 0.4, 9), fountainCenter + Vector3.new(0, 3.5, 0), 
	Color3.fromRGB(65, 130, 175), Enum.Material.Water, EnchantedGarden, 
	{Transparency = 0.3, CanCollide = false})
makePart("FountainPillar", Vector3.new(2, 8, 2), fountainCenter + Vector3.new(0, 8, 0), 
	Color3.fromRGB(176, 196, 222), Enum.Material.Marble, EnchantedGarden)
makePart("FountainSpray", Vector3.new(1, 6, 1), fountainCenter + Vector3.new(0, 15, 0), 
	Color3.fromRGB(0, 191, 255), Enum.Material.Neon, EnchantedGarden, 
	{Transparency = 0.4, CanCollide = false})

-- Rainbow bridge (multi-colored arc)
local bridgeCenter = Vector3.new(-250, 0, 320)
local colors = {Color3.fromRGB(255, 0, 0), Color3.fromRGB(255, 165, 0), Color3.fromRGB(255, 255, 0), 
				Color3.fromRGB(0, 255, 0), Color3.fromRGB(0, 0, 255), Color3.fromRGB(75, 0, 130), 
				Color3.fromRGB(238, 130, 238)}
for i, color in ipairs(colors) do
	local angle = (i - 1) * 15 - 45
	local radius = 15
	local bridgePos = bridgeCenter + Vector3.new(
		math.cos(math.rad(angle)) * radius, 
		8 + math.sin(math.rad(angle)) * 5, 
		0
	)
	makePart("RainbowSegment" .. i, Vector3.new(3, 1, 2), bridgePos, 
		color, Enum.Material.Neon, EnchantedGarden, 
		{Transparency = 0.2, Orientation = Vector3.new(0, 0, angle)})
end

-- Crystal butterflies (small neon parts)
for i = 1, 25 do
	local butterflyPos = randomPointInRect(-295, -205, 205, 345)
	butterflyPos = butterflyPos + Vector3.new(0, randomInRange(3, 8), 0)
	local colors = {Color3.fromRGB(255, 20, 147), Color3.fromRGB(0, 255, 255), Color3.fromRGB(255, 255, 0), 
					Color3.fromRGB(255, 0, 255), Color3.fromRGB(0, 255, 0)}
	local color = colors[math.random(1, #colors)]
	
	-- Butterfly body
	makePart("ButterflyBody" .. i, Vector3.new(0.1, 0.8, 0.1), butterflyPos, 
		Color3.fromRGB(0, 0, 0), Enum.Material.SmoothPlastic, EnchantedGarden, {CanCollide = false})
	-- Butterfly wings
	makePart("ButterflyWingL" .. i, Vector3.new(0.8, 0.1, 1), 
		butterflyPos + Vector3.new(-0.5, 0, 0), color, Enum.Material.Neon, 
		EnchantedGarden, {Transparency = 0.3, CanCollide = false})
	makePart("ButterflyWingR" .. i, Vector3.new(0.8, 0.1, 1), 
		butterflyPos + Vector3.new(0.5, 0, 0), color, Enum.Material.Neon, 
		EnchantedGarden, {Transparency = 0.3, CanCollide = false})
end

-- Magic trees with glowing fruit
for i = 1, 12 do
	local treePos = randomPointInRect(-290, -210, 210, 340)
	-- Trunk
	makePart("MagicTrunk" .. i, Vector3.new(2, randomInRange(10, 15), 2), 
		treePos + Vector3.new(0, 6, 0), Color3.fromRGB(139, 69, 19), 
		Enum.Material.Wood, EnchantedGarden)
	-- Magical canopy
	makePart("MagicCanopy" .. i, Vector3.new(8, 6, 8), treePos + Vector3.new(0, 14, 0), 
		Color3.fromRGB(50, 205, 50), Enum.Material.Grass, EnchantedGarden, {Shape = Enum.PartType.Ball})
	-- Glowing fruit
	for j = 1, 6 do
		local fruitPos = treePos + Vector3.new(randomInRange(-3, 3), randomInRange(11, 16), randomInRange(-3, 3))
		local fruit = makePart("MagicFruit" .. i .. "_" .. j, Vector3.new(0.6, 0.8, 0.6), fruitPos, 
			Color3.fromRGB(255, 215, 0), Enum.Material.Neon, EnchantedGarden, 
			{Transparency = 0.2, Shape = Enum.PartType.Ball, CanCollide = false})
		-- Fruit glow
		local fruitLight = Instance.new("PointLight")
		fruitLight.Color = Color3.fromRGB(255, 215, 0)
		fruitLight.Brightness = 1
		fruitLight.Range = 4
		fruitLight.Parent = fruit
	end
end

-- Hedge maze walls (green blocks in maze pattern)
local mazeCenter = Vector3.new(-270, 0, 300)
local mazeSize = 20
-- Outer walls
for i = 0, mazeSize do
	makePart("MazeWallN" .. i, Vector3.new(2, 4, 2), 
		mazeCenter + Vector3.new(-mazeSize + i * 2, 2, -mazeSize), 
		Color3.fromRGB(34, 139, 34), Enum.Material.Grass, EnchantedGarden)
	makePart("MazeWallS" .. i, Vector3.new(2, 4, 2), 
		mazeCenter + Vector3.new(-mazeSize + i * 2, 2, mazeSize), 
		Color3.fromRGB(34, 139, 34), Enum.Material.Grass, EnchantedGarden)
end
for i = 0, mazeSize do
	makePart("MazeWallW" .. i, Vector3.new(2, 4, 2), 
		mazeCenter + Vector3.new(-mazeSize, 2, -mazeSize + i * 2), 
		Color3.fromRGB(34, 139, 34), Enum.Material.Grass, EnchantedGarden)
	makePart("MazeWallE" .. i, Vector3.new(2, 4, 2), 
		mazeCenter + Vector3.new(mazeSize, 2, -mazeSize + i * 2), 
		Color3.fromRGB(34, 139, 34), Enum.Material.Grass, EnchantedGarden)
end
-- Internal maze walls (simple pattern)
local mazePattern = {
	{-10, -10, 8, 2}, {-5, -15, 2, 12}, {5, -10, 2, 8}, {10, -5, 8, 2},
	{-15, 5, 12, 2}, {0, 0, 2, 10}, {-8, 8, 16, 2}, {8, 12, 2, 8}
}
for i, wall in ipairs(mazePattern) do
	makePart("MazeInternal" .. i, Vector3.new(wall[3], 4, wall[4]), 
		mazeCenter + Vector3.new(wall[1], 2, wall[2]), 
		Color3.fromRGB(34, 139, 34), Enum.Material.Grass, EnchantedGarden)
end

-- Wishing well
local wellPos = Vector3.new(-230, 0, 250)
makePart("WishingWellBase", Vector3.new(5, 4, 5), wellPos + Vector3.new(0, 2, 0), 
	Color3.fromRGB(105, 105, 105), Enum.Material.Cobblestone, EnchantedGarden)
makePart("WellWater", Vector3.new(3, 0.5, 3), wellPos + Vector3.new(0, 4.5, 0), 
	Color3.fromRGB(65, 130, 175), Enum.Material.Water, EnchantedGarden, 
	{Transparency = 0.3, CanCollide = false})
makePart("WellRoof", Vector3.new(7, 0.5, 7), wellPos + Vector3.new(0, 8, 0), 
	Color3.fromRGB(139, 69, 19), Enum.Material.Wood, EnchantedGarden)
-- Well posts
makePart("WellPostL", Vector3.new(0.5, 6, 0.5), wellPos + Vector3.new(-3, 6, 0), 
	Color3.fromRGB(139, 69, 19), Enum.Material.Wood, EnchantedGarden)
makePart("WellPostR", Vector3.new(0.5, 6, 0.5), wellPos + Vector3.new(3, 6, 0), 
	Color3.fromRGB(139, 69, 19), Enum.Material.Wood, EnchantedGarden)

-- Enchanted Garden sign
local gardenSign = makePart("GardenSign", Vector3.new(1, 1, 1), Vector3.new(-250, 12, 350), 
	"White", nil, EnchantedGarden, {Transparency = 1})
makeSign(gardenSign, "üå∫ ENCHANTED GARDEN", Vector3.new(0, 0, 0))

--------------------------------------------------------------------------------
-- 5. UNDERGROUND RUINS (X: -100 to 50, Z: -450 to -350)
--------------------------------------------------------------------------------
print("[MapSetup5] Building Underground Ruins...")
local UndergroundRuins = getOrMake(NewAreas, "UndergroundRuins")

-- Ancient civilization remains - broken pillars
for i = 1, 15 do
	local pillarPos = randomPointInRect(-95, 45, -445, -355)
	local height = randomInRange(8, 16)
	local isToppled = math.random() > 0.6
	
	if isToppled then
		-- Toppled pillar (horizontal)
		makePart("TopplePillar" .. i, Vector3.new(height, 2, 2), pillarPos + Vector3.new(height/2, 1, 0), 
			Color3.fromRGB(105, 105, 105), Enum.Material.Cobblestone, UndergroundRuins, 
			{Orientation = Vector3.new(0, 0, -90)})
	else
		-- Standing pillar (may be broken)
		local actualHeight = isToppled and height * 0.6 or height
		makePart("StandingPillar" .. i, Vector3.new(2, actualHeight, 2), 
			pillarPos + Vector3.new(0, actualHeight/2, 0), Color3.fromRGB(105, 105, 105), 
			Enum.Material.Cobblestone, UndergroundRuins)
		-- Pillar capital
		makePart("PillarCapital" .. i, Vector3.new(3, 1, 3), 
			pillarPos + Vector3.new(0, actualHeight + 0.5, 0), Color3.fromRGB(145, 145, 145), 
			Enum.Material.Marble, UndergroundRuins)
	end
end

-- Crumbled walls (stone blocks in ruined patterns)
local wallSections = {
	{-80, 0, -420, 20, 6}, {-50, 0, -440, 15, 4}, {-10, 0, -410, 25, 8},
	{20, 0, -380, 18, 5}, {-20, 0, -370, 22, 7}, {40, 0, -400, 16, 6}
}
for i, wall in ipairs(wallSections) do
	local basePos = Vector3.new(wall[1], wall[2], wall[3])
	local length = wall[4]
	local height = wall[5]
	-- Main wall section
	makePart("RuinedWall" .. i, Vector3.new(length, height, 3), 
		basePos + Vector3.new(0, height/2, 0), Color3.fromRGB(105, 105, 105), 
		Enum.Material.Cobblestone, UndergroundRuins)
	-- Wall breach (gap)
	local breachPos = basePos + Vector3.new(randomInRange(-length/3, length/3), height/2, 0)
	makePart("WallBreach" .. i, Vector3.new(randomInRange(4, 8), height * 0.7, 3.5), 
		breachPos, Color3.fromRGB(20, 20, 20), Enum.Material.SmoothPlastic, 
		UndergroundRuins, {Transparency = 0.9, CanCollide = false})
	-- Rubble at base
	for j = 1, 5 do
		local rubblePos = basePos + Vector3.new(randomInRange(-length/2, length/2), 1, randomInRange(-2, 5))
		makePart("WallRubble" .. i .. "_" .. j, 
			Vector3.new(randomInRange(1, 3), randomInRange(1, 2), randomInRange(1, 3)), 
			rubblePos, Color3.fromRGB(85, 85, 85), Enum.Material.Concrete, UndergroundRuins)
	end
end

-- Hieroglyph panels (decorated stone slabs)
for i = 1, 10 do
	local panelPos = randomPointInRect(-90, 40, -440, -360)
	makePart("HieroglyphPanel" .. i, Vector3.new(4, 6, 0.5), panelPos + Vector3.new(0, 3, 0), 
		Color3.fromRGB(139, 134, 130), Enum.Material.Slate, UndergroundRuins)
	-- Hieroglyph symbols (simple geometric shapes)
	for j = 1, 6 do
		local symbolPos = panelPos + Vector3.new(randomInRange(-1.5, 1.5), randomInRange(1, 5), 0.3)
		local shapes = {Enum.PartType.Block, Enum.PartType.Ball, Enum.PartType.Cylinder}
		makePart("Hieroglyph" .. i .. "_" .. j, Vector3.new(0.3, 0.3, 0.1), symbolPos, 
			Color3.fromRGB(205, 133, 63), Enum.Material.Neon, UndergroundRuins, 
			{Transparency = 0.3, Shape = shapes[math.random(1, #shapes)], CanCollide = false})
	end
end

-- Sacrificial altar (dark stone platform)
local altarPos = Vector3.new(-25, 0, -400)
makePart("AltarBase", Vector3.new(8, 2, 12), altarPos + Vector3.new(0, 1, 0), 
	Color3.fromRGB(64, 64, 64), Enum.Material.Slate, UndergroundRuins)
makePart("AltarTop", Vector3.new(6, 0.5, 10), altarPos + Vector3.new(0, 2.5, 0), 
	Color3.fromRGB(40, 40, 40), Enum.Material.Marble, UndergroundRuins)
makePart("AltarBowl", Vector3.new(3, 0.8, 3), altarPos + Vector3.new(0, 3.2, 0), 
	Color3.fromRGB(80, 0, 0), Enum.Material.Neon, UndergroundRuins, 
	{Transparency = 0.4, Shape = Enum.PartType.Ball})
-- Altar steps
for i = 1, 3 do
	makePart("AltarStep" .. i, Vector3.new(10 + i * 2, 1, 14 + i * 2), 
		altarPos + Vector3.new(0, -i * 0.5, 0), Color3.fromRGB(85, 85, 85), 
		Enum.Material.Cobblestone, UndergroundRuins)
end

-- Underground river (blue transparent strip)
local riverPath = {{-80, 0, -380}, {-50, 0, -390}, {-20, 0, -420}, {10, 0, -430}, {40, 0, -420}}
for i = 1, #riverPath - 1 do
	local startPos = Vector3.new(riverPath[i][1], riverPath[i][2], riverPath[i][3])
	local endPos = Vector3.new(riverPath[i+1][1], riverPath[i+1][2], riverPath[i+1][3])
	local midPos = (startPos + endPos) * 0.5
	local length = (endPos - startPos).Magnitude
	makePart("RiverSegment" .. i, Vector3.new(6, 0.8, length), midPos + Vector3.new(0, 0.4, 0), 
		Color3.fromRGB(30, 80, 120), Enum.Material.Water, UndergroundRuins, 
		{Transparency = 0.3, CanCollide = false})
	-- River rocks
	for j = 1, 3 do
		local rockPos = midPos + Vector3.new(randomInRange(-4, 4), 0.5, randomInRange(-length/2, length/2))
		makePart("RiverRock" .. i .. "_" .. j, 
			Vector3.new(randomInRange(0.8, 1.5), randomInRange(0.5, 1), randomInRange(0.8, 1.5)), 
			rockPos, Color3.fromRGB(105, 105, 105), Enum.Material.Rock, UndergroundRuins, 
			{Shape = Enum.PartType.Ball})
	end
end

-- Ancient statues (gray humanoid shapes)
for i = 1, 8 do
	local statuePos = randomPointInRect(-85, 35, -435, -365)
	-- Statue base/pedestal
	makePart("StatuePedestal" .. i, Vector3.new(3, 2, 3), statuePos + Vector3.new(0, 1, 0), 
		Color3.fromRGB(105, 105, 105), Enum.Material.Marble, UndergroundRuins)
	-- Statue body
	makePart("StatueBody" .. i, Vector3.new(2, 4, 1.5), statuePos + Vector3.new(0, 4, 0), 
		Color3.fromRGB(145, 145, 145), Enum.Material.Marble, UndergroundRuins)
	-- Statue head (some may be missing)
	if math.random() > 0.3 then
		makePart("StatueHead" .. i, Vector3.new(1.2, 1.2, 1.2), statuePos + Vector3.new(0, 6.5, 0), 
			Color3.fromRGB(145, 145, 145), Enum.Material.Marble, UndergroundRuins, {Shape = Enum.PartType.Ball})
	end
	-- Statue arms (may be broken)
	if math.random() > 0.4 then
		makePart("StatueArmL" .. i, Vector3.new(0.8, 3, 0.8), statuePos + Vector3.new(-1.5, 4, 0), 
			Color3.fromRGB(145, 145, 145), Enum.Material.Marble, UndergroundRuins)
	end
	if math.random() > 0.4 then
		makePart("StatueArmR" .. i, Vector3.new(0.8, 3, 0.8), statuePos + Vector3.new(1.5, 4, 0), 
			Color3.fromRGB(145, 145, 145), Enum.Material.Marble, UndergroundRuins)
	end
end

-- Treasure vault door (large ornate golden door)
local vaultPos = Vector3.new(30, 0, -380)
makePart("VaultDoorFrame", Vector3.new(12, 15, 4), vaultPos + Vector3.new(0, 7.5, 0), 
	Color3.fromRGB(105, 105, 105), Enum.Material.Slate, UndergroundRuins)
makePart("VaultDoor", Vector3.new(8, 12, 1), vaultPos + Vector3.new(0, 6, 2), 
	Color3.fromRGB(255, 215, 0), Enum.Material.Metal, UndergroundRuins)
-- Door decorations
for i = 1, 4 do
	local decorPos = vaultPos + Vector3.new(-2 + i, 6, 2.5)
	makePart("VaultDecor" .. i, Vector3.new(0.8, 0.8, 0.3), decorPos, 
		Color3.fromRGB(184, 134, 11), Enum.Material.Metal, UndergroundRuins, {Shape = Enum.PartType.Ball})
end
-- Door handles
makePart("VaultHandleL", Vector3.new(0.5, 1.5, 0.8), vaultPos + Vector3.new(-2, 6, 2.8), 
	Color3.fromRGB(139, 69, 19), Enum.Material.Wood, UndergroundRuins)
makePart("VaultHandleR", Vector3.new(0.5, 1.5, 0.8), vaultPos + Vector3.new(2, 6, 2.8), 
	Color3.fromRGB(139, 69, 19), Enum.Material.Wood, UndergroundRuins)

-- Trap floor tiles (slightly different colored)
for i = 1, 12 do
	local trapPos = randomPointInRect(-75, 25, -425, -375)
	makePart("TrapTile" .. i, Vector3.new(4, 0.2, 4), trapPos + Vector3.new(0, 0.1, 0), 
		Color3.fromRGB(120, 120, 120), Enum.Material.Slate, UndergroundRuins, {Transparency = 0.1})
	-- Trap mechanism (spikes that could emerge)
	for j = 1, 4 do
		local spikePos = trapPos + Vector3.new(randomInRange(-1.5, 1.5), -0.5, randomInRange(-1.5, 1.5))
		makePart("TrapSpike" .. i .. "_" .. j, Vector3.new(0.2, 1, 0.2), spikePos, 
			Color3.fromRGB(64, 64, 64), Enum.Material.Metal, UndergroundRuins, {Transparency = 0.7})
	end
end

-- Torch sconces (wall-mounted torches)
for i = 1, 15 do
	local sconcePillar = randomPointInRect(-90, 40, -440, -360)
	makePart("TorchSconce" .. i, Vector3.new(0.8, 6, 0.8), sconcePillar + Vector3.new(0, 3, 0), 
		Color3.fromRGB(139, 69, 19), Enum.Material.Wood, UndergroundRuins)
	makePart("TorchFlame" .. i, Vector3.new(0.8, 1.5, 0.8), sconcePillar + Vector3.new(0, 6.5, 0), 
		Color3.fromRGB(255, 140, 0), Enum.Material.Neon, UndergroundRuins, {Transparency = 0.3})
	-- Torch light
	local torchLight = Instance.new("PointLight")
	torchLight.Color = Color3.fromRGB(255, 140, 0)
	torchLight.Brightness = 2
	torchLight.Range = 12
	torchLight.Parent = UndergroundRuins:FindFirstChild("TorchFlame" .. i)
end

-- Underground Ruins sign
local ruinsSign = makePart("RuinsSign", Vector3.new(1, 1, 1), Vector3.new(-25, 15, -350), 
	"White", nil, UndergroundRuins, {Transparency = 1})
makeSign(ruinsSign, "üèõÔ∏è UNDERGROUND RUINS", Vector3.new(0, 0, 0))

--------------------------------------------------------------------------------
-- 6. DRAGON'S NEST (X: 0-100, Z: -500 to -450)
--------------------------------------------------------------------------------
print("[MapSetup5] Building Dragon's Nest...")
local DragonNest = getOrMake(NewAreas, "DragonNest")

-- Scorched earth (black/dark brown ground)
for i = 1, 8 do
	local pos = randomPointInRect(5, 95, -495, -455)
	makePart("ScorchedGround" .. i, Vector3.new(randomInRange(12, 20), 0.5, randomInRange(12, 20)), 
		pos + Vector3.new(0, 0.25, 0), Color3.fromRGB(25, 25, 25), Enum.Material.Asphalt, DragonNest)
end

-- MASSIVE dragon skeleton (centerpiece)
local skeletonCenter = Vector3.new(50, 0, -475)
-- Dragon skull (huge)
makePart("DragonSkull", Vector3.new(12, 8, 15), skeletonCenter + Vector3.new(0, 4, 20), 
	Color3.fromRGB(230, 225, 210), Enum.Material.SmoothPlastic, DragonNest)
-- Skull eye sockets
makePart("SkullEyeL", Vector3.new(2.5, 2.5, 2), skeletonCenter + Vector3.new(-3, 5, 26), 
	Color3.fromRGB(20, 20, 20), Enum.Material.SmoothPlastic, DragonNest, {Shape = Enum.PartType.Ball})
makePart("SkullEyeR", Vector3.new(2.5, 2.5, 2), skeletonCenter + Vector3.new(3, 5, 26), 
	Color3.fromRGB(20, 20, 20), Enum.Material.SmoothPlastic, DragonNest, {Shape = Enum.PartType.Ball})
-- Dragon fangs
makePart("SkullFangL", Vector3.new(0.8, 3, 0.8), skeletonCenter + Vector3.new(-2, 2, 27), 
	Color3.fromRGB(240, 235, 220), Enum.Material.SmoothPlastic, DragonNest)
makePart("SkullFangR", Vector3.new(0.8, 3, 0.8), skeletonCenter + Vector3.new(2, 2, 27), 
	Color3.fromRGB(240, 235, 220), Enum.Material.SmoothPlastic, DragonNest)

-- Dragon spine (vertebrae)
for i = 1, 20 do
	local vertebraPos = skeletonCenter + Vector3.new(0, 2, 15 - i * 3)
	makePart("Vertebra" .. i, Vector3.new(3, 2, 2), vertebraPos, 
		Color3.fromRGB(230, 225, 210), Enum.Material.SmoothPlastic, DragonNest)
	-- Spine spikes
	makePart("SpineSpike" .. i, Vector3.new(0.5, randomInRange(2, 4), 0.5), vertebraPos + Vector3.new(0, 2, 0), 
		Color3.fromRGB(210, 205, 190), Enum.Material.SmoothPlastic, DragonNest)
end

-- Dragon ribcage (curved ribs)
for i = 1, 12 do
	local ribSpacing = i * 3
	local ribHeight = 8 - (i * 0.3)
	local ribPos = skeletonCenter + Vector3.new(0, 0, 10 - ribSpacing)
	-- Left rib
	makePart("RibL" .. i, Vector3.new(0.8, 0.8, ribHeight), ribPos + Vector3.new(-ribHeight/2, ribHeight/2, 0), 
		Color3.fromRGB(230, 225, 210), Enum.Material.SmoothPlastic, DragonNest, 
		{Orientation = Vector3.new(0, 0, -45)})
	-- Right rib
	makePart("RibR" .. i, Vector3.new(0.8, 0.8, ribHeight), ribPos + Vector3.new(ribHeight/2, ribHeight/2, 0), 
		Color3.fromRGB(230, 225, 210), Enum.Material.SmoothPlastic, DragonNest, 
		{Orientation = Vector3.new(0, 0, 45)})
end

-- Dragon wing bones
for side = 1, 2 do
	local sideMultiplier = side == 1 and -1 or 1
	local wingBase = skeletonCenter + Vector3.new(sideMultiplier * 8, 2, 0)
	-- Wing arm bone
	makePart("WingArm" .. side, Vector3.new(1.5, 1.5, 12), wingBase + Vector3.new(sideMultiplier * 6, 3, 0), 
		Color3.fromRGB(220, 215, 200), Enum.Material.SmoothPlastic, DragonNest, 
		{Orientation = Vector3.new(0, sideMultiplier * 30, sideMultiplier * 20)})
	-- Wing finger bones
	for finger = 1, 4 do
		local fingerAngle = finger * 15
		local fingerPos = wingBase + Vector3.new(sideMultiplier * 12, 2, finger * 3)
		makePart("WingFinger" .. side .. "_" .. finger, Vector3.new(0.8, 0.8, 8), fingerPos, 
			Color3.fromRGB(210, 205, 190), Enum.Material.SmoothPlastic, DragonNest, 
			{Orientation = Vector3.new(0, sideMultiplier * fingerAngle, sideMultiplier * 10)})
	end
end

-- Dragon leg bones
for leg = 1, 4 do
	local legX = (leg &lt;= 2) and -3 or 3
	local legZ = (leg == 1 or leg == 3) and 5 or -10
	local legPos = skeletonCenter + Vector3.new(legX, 0, legZ)
	-- Thigh bone
	makePart("LegThigh" .. leg, Vector3.new(1.5, 1.5, 6), legPos + Vector3.new(0, 3, 0), 
		Color3.fromRGB(225, 220, 205), Enum.Material.SmoothPlastic, DragonNest, 
		{Orientation = Vector3.new(-30, 0, 0)})
	-- Shin bone
	makePart("LegShin" .. leg, Vector3.new(1.2, 1.2, 5), legPos + Vector3.new(0, 1, 3), 
		Color3.fromRGB(215, 210, 195), Enum.Material.SmoothPlastic, DragonNest, 
		{Orientation = Vector3.new(30, 0, 0)})
	-- Foot/claw
	makePart("LegClaw" .. leg, Vector3.new(2, 1, 3), legPos + Vector3.new(0, 0, 5), 
		Color3.fromRGB(200, 195, 180), Enum.Material.SmoothPlastic, DragonNest)
end

-- Dragon tail bones (long chain)
for i = 1, 15 do
	local tailPos = skeletonCenter + Vector3.new(0, 1, -45 - i * 2)
	local tailSize = 2.5 - (i * 0.1)
	makePart("TailBone" .. i, Vector3.new(tailSize, tailSize, 1.5), tailPos, 
		Color3.fromRGB(220, 215, 200), Enum.Material.SmoothPlastic, DragonNest)
end

-- Egg nest (large oval parts in a crater)
local nestCenter = Vector3.new(75, 0, -480)
makePart("NestCrater", Vector3.new(20, 3, 15), nestCenter + Vector3.new(0, -1.5, 0), 
	Color3.fromRGB(64, 32, 32), Enum.Material.Rock, DragonNest, {Shape = Enum.PartType.Ball})
-- Dragon eggs (various sizes)
local eggSizes = {{4, 5, 3}, {3.5, 4.5, 2.5}, {5, 6, 4}, {3, 4, 2.5}, {4.5, 5.5, 3.5}}
for i, size in ipairs(eggSizes) do
	local eggPos = nestCenter + Vector3.new(randomInRange(-8, 8), 1, randomInRange(-6, 6))
	makePart("DragonEgg" .. i, Vector3.new(size[1], size[2], size[3]), eggPos, 
		Color3.fromRGB(139, 0, 0), Enum.Material.SmoothPlastic, DragonNest, {Shape = Enum.PartType.Ball})
	-- Egg patterns
	makePart("EggPattern" .. i, Vector3.new(size[1] * 0.8, size[2] * 0.8, size[3] * 0.8), eggPos, 
		Color3.fromRGB(255, 215, 0), Enum.Material.Neon, DragonNest, 
		{Shape = Enum.PartType.Ball, Transparency = 0.7, CanCollide = false})
end

-- Treasure hoard (gold-colored pile)
local treasureCenter = Vector3.new(25, 0, -465)
-- Gold pile base
makePart("TreasurePile", Vector3.new(15, 4, 12), treasureCenter + Vector3.new(0, 2, 0), 
	Color3.fromRGB(255, 215, 0), Enum.Material.Metal, DragonNest, {Shape = Enum.PartType.Ball})
-- Individual treasure items
for i = 1, 25 do
	local treasurePos = treasureCenter + Vector3.new(randomInRange(-8, 8), randomInRange(1, 5), randomInRange(-6, 6))
	local treasureTypes = {"Coin", "Gem", "Crown", "Goblet", "Sword"}
	local treasureType = treasureTypes[math.random(1, #treasureTypes)]
	
	if treasureType == "Coin" then
		makePart("TreasureCoin" .. i, Vector3.new(0.6, 0.1, 0.6), treasurePos, 
			Color3.fromRGB(255, 215, 0), Enum.Material.Metal, DragonNest, {Shape = Enum.PartType.Cylinder})
	elseif treasureType == "Gem" then
		makePart("TreasureGem" .. i, Vector3.new(0.8, 0.8, 0.8), treasurePos, 
			Color3.fromRGB(138, 43, 226), Enum.Material.Neon, DragonNest, 
			{Shape = Enum.PartType.Ball, Transparency = 0.3})
	elseif treasureType == "Crown" then
		makePart("TreasureCrown" .. i, Vector3.new(1.5, 1, 1.5), treasurePos, 
			Color3.fromRGB(255, 215, 0), Enum.Material.Metal, DragonNest)
	elseif treasureType == "Goblet" then
		makePart("TreasureGoblet" .. i, Vector3.new(0.8, 1.2, 0.8), treasurePos, 
			Color3.fromRGB(192, 192, 192), Enum.Material.Metal, DragonNest, {Shape = Enum.PartType.Cylinder})
	elseif treasureType == "Sword" then
		makePart("TreasureSword" .. i, Vector3.new(0.3, 3, 0.8), treasurePos, 
			Color3.fromRGB(192, 192, 192), Enum.Material.Metal, DragonNest)
	end
end

-- Dragon scale fragments scattered
for i = 1, 30 do
	local scalePos = randomPointInRect(10, 90, -490, -460)
	makePart("DragonScale" .. i, Vector3.new(randomInRange(0.5, 1.5), 0.2, randomInRange(0.8, 2)), scalePos, 
		Color3.fromRGB(139, 0, 0), Enum.Material.SmoothPlastic, DragonNest, 
		{Orientation = Vector3.new(randomInRange(0, 30), randomInRange(0, 360), randomInRange(0, 30))})
end

-- Burning ground patches (neon orange)
for i = 1, 10 do
	local firePos = randomPointInRect(15, 85, -485, -465)
	local fire = makePart("GroundFire" .. i, Vector3.new(randomInRange(4, 8), 1, randomInRange(4, 8)), 
		firePos + Vector3.new(0, 0.5, 0), Color3.fromRGB(255, 69, 0), Enum.Material.Neon, 
		DragonNest, {Transparency = 0.3})
	-- Fire light
	local fireLight = Instance.new("PointLight")
	fireLight.Color = Color3.fromRGB(255, 100, 20)
	fireLight.Brightness = 3
	fireLight.Range = 12
	fireLight.Parent = fire
end

-- Volcanic vents
for i = 1, 6 do
	local ventPos = randomPointInRect(20, 80, -485, -465)
	makePart("DragonVent" .. i, Vector3.new(3, 2, 3), ventPos + Vector3.new(0, 1, 0), 
		Color3.fromRGB(64, 32, 32), Enum.Material.Rock, DragonNest)
	-- Vent glow
	makePart("VentGlow" .. i, Vector3.new(2, 1, 2), ventPos + Vector3.new(0, 2.5, 0), 
		Color3.fromRGB(255, 140, 0), Enum.Material.Neon, DragonNest, {Transparency = 0.4})
end

-- Bones scattered everywhere (various creature remains)
for i = 1, 20 do
	local bonePos = randomPointInRect(10, 90, -490, -460)
	local boneTypes = {"Skull", "Femur", "Rib", "Spine"}
	local boneType = boneTypes[math.random(1, #boneTypes)]
	
	if boneType == "Skull" then
		makePart("ScatteredSkull" .. i, Vector3.new(1.5, 1, 2), bonePos + Vector3.new(0, 0.5, 0), 
			Color3.fromRGB(240, 235, 220), Enum.Material.SmoothPlastic, DragonNest)
	elseif boneType == "Femur" then
		makePart("ScatteredFemur" .. i, Vector3.new(0.8, 0.8, 3), bonePos + Vector3.new(0, 0.4, 0), 
			Color3.fromRGB(230, 225, 210), Enum.Material.SmoothPlastic, DragonNest)
	elseif boneType == "Rib" then
		makePart("ScatteredRib" .. i, Vector3.new(0.5, 2, 0.5), bonePos + Vector3.new(0, 1, 0), 
			Color3.fromRGB(225, 220, 205), Enum.Material.SmoothPlastic, DragonNest, 
			{Orientation = Vector3.new(randomInRange(0, 90), randomInRange(0, 360), randomInRange(0, 90))})
	elseif boneType == "Spine" then
		makePart("ScatteredSpine" .. i, Vector3.new(1, 1, 2), bonePos + Vector3.new(0, 0.5, 0), 
			Color3.fromRGB(220, 215, 200), Enum.Material.SmoothPlastic, DragonNest)
	end
end

-- Dragon's Nest sign
local nestSign = makePart("NestSign", Vector3.new(1, 1, 1), Vector3.new(50, 15, -450), 
	"White", nil, DragonNest, {Transparency = 1})
makeSign(nestSign, "üêâ DRAGON'S NEST", Vector3.new(0, 0, 0))

--------------------------------------------------------------------------------
-- RESOURCE NODES CREATION
--------------------------------------------------------------------------------
print("[MapSetup5] Creating resource nodes...")

-- Resource node creation helper
local function createResourceNode(name, position, nodeType, parent)
	local node = makePart(name, Vector3.new(2, 3, 2), position + Vector3.new(0, 1.5, 0), 
		Color3.fromRGB(105, 105, 105), Enum.Material.Rock, parent)
	
	-- Add ClickDetector
	local cd = Instance.new("ClickDetector")
	cd.MaxActivationDistance = 10
	cd.Parent = node
	
	-- Add BillboardGui label
	local bg = Instance.new("BillboardGui")
	bg.Size = UDim2.new(4, 0, 1, 0)
	bg.StudsOffset = Vector3.new(0, 2, 0)
	bg.Parent = node
	
	local tl = Instance.new("TextLabel")
	tl.Size = UDim2.new(1, 0, 1, 0)
	tl.BackgroundTransparency = 1
	tl.Text = nodeType
	tl.TextColor3 = Color3.fromRGB(255, 255, 255)
	tl.TextScaled = true
	tl.Font = Enum.Font.GothamBold
	tl.TextStrokeTransparency = 0.3
	tl.Parent = bg
	
	return node
end

-- Frozen Peaks nodes
for i = 1, 5 do
	local pos = randomPointInRect(-390, -310, -290, -210)
	local iceNode = createResourceNode("IceMiningNode" .. i, pos, "‚õèÔ∏è Ice Ore", ResourceNodes)
	iceNode.Color = Color3.fromRGB(173, 216, 230)
	iceNode.Material = Enum.Material.Ice
end

for i = 1, 3 do
	local pos = randomPointInRect(-385, -315, -285, -215)
	local frozenTree = createResourceNode("FrozenTreeNode" .. i, pos, "üå≤ Frozen Wood", ResourceNodes)
	frozenTree.Color = Color3.fromRGB(101, 67, 33)
	frozenTree.Material = Enum.Material.Wood
	frozenTree.Size = Vector3.new(2, 6, 2)
	frozenTree.Position = pos + Vector3.new(0, 3, 0)
end

-- Pirate Cove nodes
local coastalPositions = {{320, 0, -120}, {340, 0, -110}, {360, 0, -115}, {380, 0, -125}}
for i, pos in ipairs(coastalPositions) do
	local fishNode = createResourceNode("FishingSpot" .. i, Vector3.new(pos[1], pos[2], pos[3]), "üé£ Fishing", ResourceNodes)
	fishNode.Color = Color3.fromRGB(0, 162, 232)
	fishNode.Material = Enum.Material.Neon
	fishNode.Transparency = 0.3
	fishNode.Shape = Enum.PartType.Ball
end

for i = 1, 2 do
	local pos = randomPointInRect(315, 385, -185, -115)
	local palmNode = createResourceNode("PalmTreeNode" .. i, pos, "üå¥ Palm Wood", ResourceNodes)
	palmNode.Color = Color3.fromRGB(101, 67, 33)
	palmNode.Material = Enum.Material.Wood
	palmNode.Size = Vector3.new(1.5, 8, 1.5)
	palmNode.Position = pos + Vector3.new(0, 4, 0)
end

-- Volcanic Crater nodes
for i = 1, 5 do
	local pos = randomPointInRect(315, 385, -385, -315)
	local obsidianNode = createResourceNode("ObsidianMiningNode" .. i, pos, "‚õèÔ∏è Obsidian", ResourceNodes)
	obsidianNode.Color = Color3.fromRGB(20, 20, 20)
	obsidianNode.Material = Enum.Material.Glass
end

for i = 1, 3 do
	local pos = randomPointInRect(320, 380, -380, -320)
	local volcanicNode = createResourceNode("VolcanicOreMiningNode" .. i, pos, "‚õèÔ∏è Volcanic Ore", ResourceNodes)
	volcanicNode.Color = Color3.fromRGB(255, 69, 0)
	volcanicNode.Material = Enum.Material.Neon
	volcanicNode.Transparency = 0.2
end

-- Enchanted Garden nodes
for i = 1, 4 do
	local pos = randomPointInRect(-290, -210, 210, 340)
	local magicTree = createResourceNode("MagicTreeNode" .. i, pos, "üå≤ Magic Wood", ResourceNodes)
	magicTree.Color = Color3.fromRGB(139, 69, 19)
	magicTree.Material = Enum.Material.Wood
	magicTree.Size = Vector3.new(2, 8, 2)
	magicTree.Position = pos + Vector3.new(0, 4, 0)
	-- Add glow
	local light = Instance.new("PointLight")
	light.Color = Color3.fromRGB(255, 215, 0)
	light.Brightness = 1
	light.Range = 6
	light.Parent = magicTree
end

for i = 1, 3 do
	local pos = randomPointInRect(-285, -215, 215, 335)
	local herbNode = createResourceNode("HerbGatheringNode" .. i, pos, "üåø Magic Herbs", ResourceNodes)
	herbNode.Color = Color3.fromRGB(50, 205, 50)
	herbNode.Material = Enum.Material.Grass
	herbNode.Size = Vector3.new(3, 1, 3)
	herbNode.Position = pos + Vector3.new(0, 0.5, 0)
end

-- Underground Ruins nodes
for i = 1, 6 do
	local pos = randomPointInRect(-85, 35, -435, -365)
	local ancientNode = createResourceNode("AncientOreMiningNode" .. i, pos, "‚õèÔ∏è Ancient Ore", ResourceNodes)
	ancientNode.Color = Color3.fromRGB(139, 134, 130)
	ancientNode.Material = Enum.Material.Slate
end

-- Dragon's Nest nodes
for i = 1, 3 do
	local pos = randomPointInRect(15, 85, -485, -465)
	local dragonstoneNode = createResourceNode("DragonstoneMiningNode" .. i, pos, "‚õèÔ∏è Dragonstone", ResourceNodes)
	dragonstoneNode.Color = Color3.fromRGB(139, 0, 0)
	dragonstoneNode.Material = Enum.Material.Neon
	dragonstoneNode.Transparency = 0.1
	-- Add dramatic lighting
	local light = Instance.new("PointLight")
	light.Color = Color3.fromRGB(255, 0, 0)
	light.Brightness = 2
	light.Range = 8
	light.Parent = dragonstoneNode
end

print("[MapSetup5] All major new areas completed!")
print("[MapSetup5] Areas built:")
print("- üè¥‚Äç‚ò†Ô∏è Pirate Cove (300-400, -200 to -100): Wrecked ship, treasure, palm trees")
print("- üóª Frozen Peaks (-400 to -300, -300 to -200): Ice crystals, frozen waterfall, snow trees")
print("- üåã Volcanic Crater (300-400, -400 to -300): Lava pools, obsidian spikes, fire geysers")
print("- üå∫ Enchanted Garden (-300 to -200, 200-350): Giant flowers, fairy rings, rainbow bridge")
print("- üèõÔ∏è Underground Ruins (-100 to 50, -450 to -350): Ancient pillars, treasure vault, river")
print("- üêâ Dragon's Nest (0-100, -500 to -450): Massive skeleton, egg nest, treasure hoard")
print("- Resource nodes added for all areas with appropriate types")</string>
      </Properties>
    </Item>
    <Item class="Script" referent="48">
      <Properties>
        <string name="Name">MonsterManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	MonsterManager.server.lua
	ServerScriptService

	Spawns all monsters in the world, runs their AI (wander / aggro / attack),
	handles death, loot bags, respawning, and XP awards.
]]

--------------------------------------------------------------------------------
-- SERVICES & MODULES
--------------------------------------------------------------------------------
local Players            = game:GetService("Players")
local RunService         = game:GetService("RunService")
local ReplicatedStorage  = game:GetService("ReplicatedStorage")

-- Wait for map to finish building
task.wait(4)

local MonsterDatabase = require(ReplicatedStorage.Modules.MonsterDatabase)
local DataManager     = require(ReplicatedStorage.Modules.DataManager)
local ItemDatabase    = require(ReplicatedStorage.Modules.ItemDatabase)
local ItemVisuals     = require(ReplicatedStorage.Modules.ItemVisuals)

--------------------------------------------------------------------------------
-- REMOTE EVENTS (create if missing)
--------------------------------------------------------------------------------
local function getOrCreateRemote(name)
	local existing = ReplicatedStorage:FindFirstChild(name)
	if existing then return existing end
	local re = Instance.new("RemoteEvent")
	re.Name = name
	re.Parent = ReplicatedStorage
	return re
end

local TweenService       = game:GetService("TweenService")

local MonsterDamageEvent = getOrCreateRemote("MonsterDamage")
local MonsterDeathEvent  = getOrCreateRemote("MonsterDeath")
local MonsterLootEvent   = getOrCreateRemote("MonsterLoot")
local XPPopupEvent       = getOrCreateRemote("XPPopup")

--------------------------------------------------------------------------------
-- CONSTANTS
--------------------------------------------------------------------------------
local WANDER_RADIUS        = 15
local AGGRO_RANGE_DEFAULT  = 20
local AGGRO_RANGE_PASSIVE  = 10
local AGGRO_RANGE_BOSS     = 40
local DEAGGRO_RANGE        = 40
local LEASH_RANGE          = 80  -- max distance from spawn before forced deaggro
local ATTACK_RANGE         = 7
local ATTACK_COOLDOWN      = 2
local LOOT_DESPAWN_TIME    = 30
local WANDER_INTERVAL      = 3   -- seconds between wander moves
local MOVE_SPEED           = 12  -- studs/sec for normal monsters
local MOVE_SPEED_BOSS      = 8

--------------------------------------------------------------------------------
-- STATE
--------------------------------------------------------------------------------
local activeMonsters = {}  -- model -> state table
local totalSpawned = 0

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------
local RNG = Random.new()

local function lerp(a, b, t)
	return a + (b - a) * t
end

local function randomInRange(min, max)
	return lerp(min, max, RNG:NextNumber())
end

--- Pick a random point within a rectangle defined by min/max x/z, at ground level
local function randomPointInRect(xMin, xMax, zMin, zMax)
	return Vector3.new(
		randomInRange(xMin, xMax),
		0,
		randomInRange(zMin, zMax)
	)
end

--- Distance between two Vector3 (XZ plane only)
local function distXZ(a, b)
	local dx = a.X - b.X
	local dz = a.Z - b.Z
	return math.sqrt(dx * dx + dz * dz)
end

--------------------------------------------------------------------------------
-- MONSTER MODEL BUILDER
--------------------------------------------------------------------------------
local function buildMonsterModel(def, position)
	local model = Instance.new("Model")
	model.Name = def.name

	local m = def.model

	-- Body
	local body = Instance.new("Part")
	body.Name = "Body"
	body.Shape = Enum.PartType.Block
	body.Size = m.size
	body.Color = m.bodyColor
	body.Anchored = true
	body.CanCollide = true
	-- Position body so feet touch the ground (baseplate top = Y 0)
	body.Position = Vector3.new(position.X, m.size.Y / 2, position.Z)
	body.Parent = model

	-- Head (ball on top of body)
	local head = Instance.new("Part")
	head.Name = "Head"
	head.Shape = Enum.PartType.Ball
	head.Size = Vector3.new(m.headSize, m.headSize, m.headSize) * 2
	head.Color = m.bodyColor
	head.Anchored = true
	head.CanCollide = false
	head.Position = Vector3.new(position.X, m.size.Y + m.headSize, position.Z)
	head.Parent = model

	-- Humanoid (for health tracking)
	local humanoid = Instance.new("Humanoid")
	humanoid.MaxHealth = def.hp
	humanoid.Health = def.hp
	humanoid.Parent = model

	-- PrimaryPart
	model.PrimaryPart = body

	-- BillboardGui √É¬¢√¢'¬¨" name, level, HP bar
	local bbg = Instance.new("BillboardGui")
	bbg.Name = "OverheadGui"
	bbg.Size = UDim2.new(4, 0, 1.5, 0)
	bbg.StudsOffset = Vector3.new(0, m.size.Y / 2 + m.headSize * 2 + 1, 0)
	bbg.AlwaysOnTop = true
	bbg.Adornee = body
	bbg.Parent = model

	-- Name label
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Name = "NameLabel"
	nameLabel.Size = UDim2.new(1, 0, 0.4, 0)
	nameLabel.Position = UDim2.new(0, 0, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = def.name .. (def.level > 0 and (" [Lv." .. def.level .. "]") or "")
	nameLabel.TextColor3 = def.boss and Color3.fromRGB(255, 50, 50) or
	                        def.zone == "Wilderness" and Color3.fromRGB(255, 170, 50) or
	                        Color3.fromRGB(255, 255, 255)
	nameLabel.TextScaled = true
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.Parent = bbg

	-- HP bar background
	local hpBg = Instance.new("Frame")
	hpBg.Name = "HPBarBG"
	hpBg.Size = UDim2.new(0.8, 0, 0.15, 0)
	hpBg.Position = UDim2.new(0.1, 0, 0.45, 0)
	hpBg.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	hpBg.BorderSizePixel = 0
	hpBg.Parent = bbg

	local hpFill = Instance.new("Frame")
	hpFill.Name = "HPFill"
	hpFill.Size = UDim2.new(1, 0, 1, 0)
	hpFill.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
	hpFill.BorderSizePixel = 0
	hpFill.Parent = hpBg

	-- HP text
	local hpText = Instance.new("TextLabel")
	hpText.Name = "HPText"
	hpText.Size = UDim2.new(1, 0, 0.3, 0)
	hpText.Position = UDim2.new(0, 0, 0.65, 0)
	hpText.BackgroundTransparency = 1
	hpText.Text = def.hp .. " / " .. def.hp
	hpText.TextColor3 = Color3.fromRGB(255, 255, 255)
	hpText.TextScaled = true
	hpText.Font = Enum.Font.Gotham
	hpText.Parent = bbg

	-- ClickDetector for targeting - ADD TO ALL PARTS
	local function addClickDetectorToAllParts()
		for _, child in ipairs(model:GetChildren()) do
			if child:IsA("BasePart") then
				local click = Instance.new("ClickDetector")
				click.Name = "TargetClick"
				click.MaxActivationDistance = 30
				click.Parent = child
			end
		end
	end

	-- === EXTRA PARTS (legs, arms, horns, eyes, etc.) ===
	if m.extras then
		for _, extra in ipairs(m.extras) do
			local part = Instance.new("Part")
			part.Name = extra.name
			part.Anchored = true
			part.CanCollide = false
			part.Size = extra.size
			part.Color = extra.color
			part.Material = extra.material or Enum.Material.SmoothPlastic
			if extra.transparency then
				part.Transparency = extra.transparency
			end

			if extra.shape == "Ball" then
				part.Shape = Enum.PartType.Ball
			else
				part.Shape = Enum.PartType.Block
			end

			-- Position relative to body or head
			if extra.bodyRelative then
				part.Position = position + extra.offset
			else
				-- Relative to head
				local headPos = position + Vector3.new(0, m.size.Y / 2 + m.headSize, 0)
				part.Position = headPos + extra.offset
			end

			if extra.rotation then
				part.Orientation = extra.rotation
			end

			-- Add glow for neon parts
			if extra.material == Enum.Material.Neon then
				local light = Instance.new("PointLight")
				light.Color = extra.color
				light.Brightness = 1
				light.Range = 6
				light.Parent = part
			end

			part.Parent = model
		end
	end

	-- Add ClickDetectors to all parts
	addClickDetectorToAllParts()

	return model
end

--------------------------------------------------------------------------------
-- HP BAR UPDATE
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- MONSTER DEATH ANIMATION
--------------------------------------------------------------------------------
local function playDeathAnimation(model, deathPos)
	-- Dust/smoke puff at death location
	for i = 1, 6 do
		local puff = Instance.new("Part")
		puff.Name = "DeathPuff"
		puff.Shape = Enum.PartType.Ball
		puff.Size = Vector3.new(1, 1, 1)
		puff.Position = deathPos + Vector3.new(math.random(-2, 2), math.random(0, 2), math.random(-2, 2))
		puff.Color = Color3.fromRGB(180, 170, 150)
		puff.Material = Enum.Material.SmoothPlastic
		puff.Anchored = true
		puff.CanCollide = false
		puff.Transparency = 0.3
		puff.Parent = workspace

		TweenService:Create(puff, TweenInfo.new(1.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			Size = Vector3.new(3, 3, 3),
			Transparency = 1,
			Position = puff.Position + Vector3.new(0, 3, 0),
		}):Play()

		task.delay(1.3, function()
			if puff and puff.Parent then puff:Destroy() end
		end)
	end

	-- Body falls to the side and fades out
	local body = model.PrimaryPart
	if body then
		-- Tilt the body to fall over
		local fallCF = body.CFrame * CFrame.Angles(0, 0, math.rad(90))
		TweenService:Create(body, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
			CFrame = fallCF,
		}):Play()
	end

	-- Fade all parts
	for _, child in model:GetDescendants() do
		if child:IsA("BasePart") then
			TweenService:Create(child, TweenInfo.new(1.5, Enum.EasingStyle.Quad), {
				Transparency = 1,
			}):Play()
		elseif child:IsA("BillboardGui") then
			child.Enabled = false
		end
	end

	-- Destroy after fade completes
	task.delay(2, function()
		if model and model.Parent then
			model:Destroy()
		end
	end)
end

local function updateHPBar(model, currentHP, maxHP)
	local bbg = model:FindFirstChild("OverheadGui")
	if not bbg then return end
	local bg = bbg:FindFirstChild("HPBarBG")
	if bg then
		local fill = bg:FindFirstChild("HPFill")
		if fill then
			local pct = math.clamp(currentHP / maxHP, 0, 1)
			fill.Size = UDim2.new(pct, 0, 1, 0)
			-- Color: green √É¬¢√¢‚Ç¨ ' yellow √É¬¢√¢‚Ç¨ ' red
			if pct > 0.5 then
				fill.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
			elseif pct > 0.25 then
				fill.BackgroundColor3 = Color3.fromRGB(220, 200, 30)
			else
				fill.BackgroundColor3 = Color3.fromRGB(220, 40, 40)
			end
		end
	end
	local hpLabel = bbg:FindFirstChild("HPText")
	if hpLabel then
		hpLabel.Text = math.max(0, math.floor(currentHP)) .. " / " .. maxHP
	end
end

--------------------------------------------------------------------------------
-- LOOT BAG
--------------------------------------------------------------------------------
local function rollDrops(def)
	local results = {}
	for _, drop in def.drops do
		if RNG:NextNumber() <= drop.chance then
			local qty = RNG:NextInteger(drop.minQty, drop.maxQty)
			table.insert(results, { item = drop.item, qty = qty })
		end
	end
	return results
end

-- Rarity colors for loot items
local RARITY_COLORS = {
	common = Color3.fromRGB(157, 157, 157),
	uncommon = Color3.fromRGB(30, 255, 0),
	rare = Color3.fromRGB(0, 112, 221),
	epic = Color3.fromRGB(163, 53, 238),
	legendary = Color3.fromRGB(255, 128, 0),
}

local function createLootDrops(position, drops, killerPlayer)
	if #drops == 0 then return end

	-- Spread items in a circle around death position
	local angleStep = (2 * math.pi) / math.max(#drops, 1)
	local spreadRadius = 2.5

	for i, drop in ipairs(drops) do
		local angle = angleStep * (i - 1) + (math.random() * 0.5)
		local offsetX = math.cos(angle) * spreadRadius
		local offsetZ = math.sin(angle) * spreadRadius

		-- Get item visuals
		local visual = ItemVisuals.GetVisual(drop.item)
		local itemDef = ItemDatabase and ItemDatabase.Items and ItemDatabase.Items[drop.item]
		local rarity = (itemDef and itemDef.rarity) or "common"
		local rarityColor = RARITY_COLORS[rarity] or RARITY_COLORS.common

		-- Create different shapes based on item type
		local itemPart
		local dropSize = Vector3.new(1.2, 1.2, 1.2)
		
		if visual.shape == "sword" then
			-- Swords: elongated thin part
			dropSize = Vector3.new(0.3, 2.5, 0.3)
		elseif visual.shape == "shield" then
			-- Shields: flat wide part
			dropSize = Vector3.new(2.0, 0.3, 1.5)
		elseif visual.shape == "ore" or visual.shape == "bar" then
			-- Ores/bars: small cube
			dropSize = Vector3.new(0.8, 0.8, 0.8)
		elseif visual.shape == "log" then
			-- Logs: cylinder-shaped (elongated block)
			itemPart = Instance.new("Part")
			itemPart.Size = Vector3.new(0.6, 0.6, 2.0)
			itemPart.Shape = Enum.PartType.Cylinder
		elseif visual.shape == "fish" then
			-- Fish: flat oval
			dropSize = Vector3.new(1.0, 0.4, 1.8)
		elseif visual.shape == "food" then
			-- Food: small round
			itemPart = Instance.new("Part")
			itemPart.Size = Vector3.new(0.8, 0.8, 0.8)
			itemPart.Shape = Enum.PartType.Ball
		elseif visual.shape == "arrow" then
			-- Arrows: very thin long
			dropSize = Vector3.new(0.1, 0.1, 2.2)
		elseif visual.shape == "gem" then
			-- Gems: small wedge for crystalline look
			itemPart = Instance.new("WedgePart")
			itemPart.Size = Vector3.new(0.6, 0.8, 0.6)
		elseif visual.shape == "bone" then
			-- Bones: thin cylindrical
			itemPart = Instance.new("Part")
			itemPart.Size = Vector3.new(0.3, 0.3, 1.5)
			itemPart.Shape = Enum.PartType.Cylinder
		elseif visual.shape == "feather" then
			-- Feathers: thin flat
			dropSize = Vector3.new(0.8, 0.1, 1.2)
		elseif visual.shape == "bow" then
			-- Bows: elongated curved (approximated with block)
			dropSize = Vector3.new(0.4, 1.8, 0.2)
		else
			-- Default: small cube for misc items
			dropSize = Vector3.new(1.0, 1.0, 1.0)
		end
		
		-- Create part if not already created
		if not itemPart then
			itemPart = Instance.new("Part")
			itemPart.Size = dropSize
			itemPart.Shape = Enum.PartType.Block
		end

		itemPart.Name = "LootDrop_" .. drop.item
		itemPart.Anchored = true
		itemPart.CanCollide = false
		itemPart.Position = position + Vector3.new(offsetX, 0.6, offsetZ)
		itemPart.Material = Enum.Material.SmoothPlastic
		
		-- Use item's unique color from ItemVisuals
		itemPart.Color = visual.color
		
		-- Add glow effect for special items
		if visual.glowColor then
			local glow = Instance.new("PointLight")
			glow.Color = visual.glowColor
			glow.Brightness = 2
			glow.Range = 8
			glow.Parent = itemPart
		end

		itemPart.Parent = workspace

		-- Floating label with item emoji and name
		local bbg = Instance.new("BillboardGui")
		bbg.Size = UDim2.new(5, 0, 1, 0)
		bbg.StudsOffset = Vector3.new(0, 1.5, 0)
		bbg.AlwaysOnTop = true
		bbg.Adornee = itemPart
		bbg.Parent = itemPart

		local label = Instance.new("TextLabel")
		label.Size = UDim2.new(1, 0, 1, 0)
		label.BackgroundTransparency = 1
		
		-- Display emoji + name + quantity
		local displayText = visual.emoji .. " " .. drop.item
		if drop.qty > 1 then
			displayText = displayText .. " x" .. drop.qty
		end
		
		label.Text = displayText
		label.TextColor3 = rarityColor
		label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
		label.TextStrokeTransparency = 0
		label.TextScaled = true
		label.Font = Enum.Font.GothamBold
		label.Parent = bbg

		-- Click to pick up
		local click = Instance.new("ClickDetector")
		click.MaxActivationDistance = 14
		click.Parent = itemPart

		local picked = false
		click.MouseClick:Connect(function(player)
			if picked then return end
			picked = true

			local ok, err = pcall(function()
				DataManager.AddItem(player, drop.item, drop.qty)
			end)
			if not ok then
				warn("[MonsterManager] Failed to give item:", err)
			end

			-- Notify client
			MonsterLootEvent:FireClient(player, {{item = drop.item, qty = drop.qty}})

			-- Pick up effect: shrink and vanish
			local TweenService = game:GetService("TweenService")
			local tween = TweenService:Create(itemPart, TweenInfo.new(0.3), {
				Size = Vector3.new(0.1, 0.1, 0.1),
				Transparency = 1,
			})
			tween:Play()
			tween.Completed:Once(function()
				itemPart:Destroy()
			end)
		end)

		-- Gentle bobbing animation
		task.spawn(function()
			local startY = itemPart.Position.Y
			local t = math.random() * math.pi * 2 -- random phase so items don't bob in sync
			while itemPart and itemPart.Parent do
				t = t + 0.05
				itemPart.Position = Vector3.new(
					itemPart.Position.X,
					startY + math.sin(t) * 0.3,
					itemPart.Position.Z
				)
				task.wait(0.03)
			end
		end)

		-- Auto-despawn
		task.delay(LOOT_DESPAWN_TIME, function()
			if itemPart and itemPart.Parent then
				itemPart:Destroy()
			end
		end)
	end
end

--------------------------------------------------------------------------------
-- MOVEMENT HELPERS
--------------------------------------------------------------------------------
local function moveModelTo(model, targetPos, dt, speed)
	local body = model.PrimaryPart
	if not body then return end
	local current = body.Position
	local dir = (targetPos - current) * Vector3.new(1, 0, 1) -- XZ only
	local dist = dir.Magnitude
	if dist < 0.5 then return end

	local step = math.min(speed * dt, dist)
	local offset = dir.Unit * step
	local newPos = current + offset

	-- Keep Y stable
	newPos = Vector3.new(newPos.X, current.Y, newPos.Z)

	-- Face movement direction
	local lookCF = CFrame.new(newPos, newPos + dir.Unit)
	body.CFrame = lookCF

	-- Move ALL child parts by the same offset
	for _, child in ipairs(model:GetChildren()) do
		if child:IsA("BasePart") and child ~= body then
			child.Position = child.Position + offset
		end
	end
end

local function teleportModel(model, pos)
	local body = model.PrimaryPart
	if not body then return end
	local delta = pos - body.Position
	body.Position = pos
	-- Move all children by same delta
	for _, child in ipairs(model:GetChildren()) do
		if child:IsA("BasePart") and child ~= body then
			child.Position = child.Position + delta
		end
	end
end

--------------------------------------------------------------------------------
-- FIND NEAREST PLAYER (alive, with character)
--------------------------------------------------------------------------------
local function findNearestPlayer(position, maxRange)
	local nearest= nil
	local nearestDist = math.huge
	for _, player in Players:GetPlayers() do
		local char = player.Character
		if char then
			local hrp = char:FindFirstChild("HumanoidRootPart")
			local hum = char:FindFirstChildOfClass("Humanoid")
			if hrp and hum and hum.Health > 0 then
				local d = distXZ(position, hrp.Position)
				if d < nearestDist and d <= maxRange then
					nearestDist = d
					nearest = player
				end
			end
		end
	end
	return nearest, nearestDist
end

--------------------------------------------------------------------------------
-- SPAWN A SINGLE MONSTER
--------------------------------------------------------------------------------
local function spawnMonster(defKey, position)
	local def = MonsterDatabase.Monsters[defKey]
	if not def then
		warn("[MonsterManager] Unknown monster key:", defKey)
		return
	end

	local model = buildMonsterModel(def, position)
	model.Parent = workspace

	-- State
	local state = {
		defKey       = defKey,
		def          = def,
		model        = model,
		spawnPos     = position,
		currentHP    = def.hp,
		maxHP        = def.hp,
		alive        = true,
		aiState      = "idle",   -- idle | wander | chase | returning
		wanderTarget = nil,
		wanderTimer  = RNG:NextNumber() * WANDER_INTERVAL, -- stagger initial wander
		attackTimer  = 0,
		targetPlayer = nil,
	}

	activeMonsters[model] = state

	-- ClickDetector: player attacks monster (connect ALL ClickDetectors)
	local function onMonsterClicked(player)
			if not state.alive then return end

			local char = player.Character
			if not char then return end
			local hrp = char:FindFirstChild("HumanoidRootPart")
			if not hrp then return end

			-- Must be close enough to attack
			if distXZ(hrp.Position, model.PrimaryPart.Position) > ATTACK_RANGE * 3 then return end

			-- Player deals damage (base + weapon + level bonus)
			local playerLevel = 1
			pcall(function()
				playerLevel = DataManager.GetCombatLevel(player) or 1
			end)
			-- Check equipped weapon damage
			local weaponDmg = 0
			pcall(function()
				local data = DataManager.GetData(player)
				if data and data.Equipment and data.Equipment.Weapon and data.Equipment.Weapon ~= "" then
					local weaponInfo = ItemDatabase.GetItem(data.Equipment.Weapon)
					if weaponInfo and weaponInfo.damage then
						weaponDmg = weaponInfo.damage
					end
				end
			end)
			local baseDmg = math.max(5, weaponDmg)
			local dmg = baseDmg + math.floor(playerLevel * 1.5)
			-- Random variance 80-120%
			dmg = math.floor(dmg * (0.8 + math.random() * 0.4))

			state.currentHP = state.currentHP - dmg
			updateHPBar(model, state.currentHP, state.maxHP)

			-- Fire to all clients for hit effects (include attacker for animation trigger)
			MonsterDamageEvent:FireAllClients(model, dmg, state.currentHP, state.maxHP, player)

			-- Determine weapon type for animation
			local weaponTypeForAnim = "unarmed"
			pcall(function()
				local data = DataManager.GetData(player)
				if data and data.Equipment and data.Equipment.Weapon and data.Equipment.Weapon ~= "" then
					local wName = data.Equipment.Weapon:lower()
					if wName:find("bow") or wName:find("crossbow") then
						weaponTypeForAnim = "ranged"
					else
						weaponTypeForAnim = "melee"
					end
				end
			end)

			-- Broadcast player attack visual to nearby clients
			if shared.AttackVisualHandler then
				shared.AttackVisualHandler.BroadcastPlayerAttack(player, model, weaponTypeForAnim, dmg >= (state.maxHP * 0.2))
			end

			-- Aggro onto attacker
			if state.aiState ~= "chase" then
				state.aiState = "chase"
				state.targetPlayer = player
			end

			-- Death check
			if state.currentHP <= 0 and not def.immortal then
				state.alive = false
				state.currentHP = 0
				updateHPBar(model, 0, state.maxHP)

				-- Award XP
				pcall(function()
					DataManager.AddSkillXP(player, "Strength", def.xp)
				end)

				-- Roll & drop loot
				local drops = rollDrops(def)
				local deathPos = model.PrimaryPart.Position
				MonsterDeathEvent:FireAllClients(model, player, drops)

				-- Send XP popup to killer
				XPPopupEvent:FireClient(player, deathPos, def.xp, def.name)

				-- Remove from active tracking immediately (stop AI)
				activeMonsters[model] = nil

				-- Play death animation (delays destroy by 2s)
				playDeathAnimation(model, deathPos)

				-- Drop individual loot items
				createLootDrops(deathPos, drops, player)

				-- Respawn after delay (add 2s for death anim)
				task.delay(def.respawnTime + 2, function()
					spawnMonster(defKey, position)
				end)
			end
	end

	-- Connect all ClickDetectors in the model to the click handler
	for _, desc in ipairs(model:GetDescendants()) do
		if desc:IsA("ClickDetector") and desc.Name == "TargetClick" then
			desc.MouseClick:Connect(onMonsterClicked)
		end
	end

	totalSpawned += 1
end

--------------------------------------------------------------------------------
-- AI LOOP (runs every Heartbeat)
--------------------------------------------------------------------------------
RunService.Heartbeat:Connect(function(dt)
	for model, state in activeMonsters do
		if not state.alive then continue end
		if state.def.stationary then continue end
		if not model.PrimaryPart then continue end

		local pos = model.PrimaryPart.Position
		local aggroRange = state.def.boss and AGGRO_RANGE_BOSS
		                   or state.def.passive and AGGRO_RANGE_PASSIVE
		                   or AGGRO_RANGE_DEFAULT
		local speed = state.def.boss and MOVE_SPEED_BOSS or MOVE_SPEED

		--------------------------------------------------------------------
		-- ATTACK TIMER (deal damage while chasing & in range)
		--------------------------------------------------------------------
		if state.aiState == "chase" and state.targetPlayer then
			state.attackTimer -= dt
			local char = state.targetPlayer.Character
			if char then
				local hrp = char:FindFirstChild("HumanoidRootPart")
				local hum = char:FindFirstChildOfClass("Humanoid")
				if hrp and hum and hum.Health > 0 then
					local d = distXZ(pos, hrp.Position)
					local distFromSpawn = distXZ(pos, state.spawnPos)

					-- De-aggro if player too far OR monster too far from spawn (leash)
					if d > DEAGGRO_RANGE or distFromSpawn > LEASH_RANGE then
						state.aiState = "returning"
						state.targetPlayer = nil
					else
						-- Move toward player
						moveModelTo(model, hrp.Position, dt, speed)

						-- Attack if close enough
						if d <= ATTACK_RANGE and state.attackTimer <= 0 then
							state.attackTimer = ATTACK_COOLDOWN
							hum:TakeDamage(state.def.damage)

							-- Broadcast monster attack visual
							if shared.AttackVisualHandler then
								shared.AttackVisualHandler.BroadcastMonsterAttack(model, state.targetPlayer, state.def.name)
								-- Send hit effect to target player
								if hrp then
									shared.AttackVisualHandler.BroadcastHitEffect(
										hrp.Position,
										state.def.damage,
										"damage_taken",
										state.def.damage >= 50,
										state.targetPlayer
									)
								end
							end
						end
					end
				else
					-- Player dead or gone
					state.aiState = "returning"
					state.targetPlayer = nil
				end
			else
				state.aiState = "returning"
				state.targetPlayer = nil
			end

		--------------------------------------------------------------------
		-- RETURNING TO SPAWN
		--------------------------------------------------------------------
		elseif state.aiState == "returning" then
			local d = distXZ(pos, state.spawnPos)
			if d < 2 then
				state.aiState = "idle"
				state.wanderTimer = WANDER_INTERVAL
			else
				moveModelTo(model, state.spawnPos, dt, speed)
			end

			-- Heal while returning
			if state.currentHP < state.maxHP then
				state.currentHP = math.min(state.maxHP, state.currentHP + state.maxHP * 0.05 * dt)
				updateHPBar(model, state.currentHP, state.maxHP)
			end

		--------------------------------------------------------------------
		-- IDLE / WANDER
		--------------------------------------------------------------------
		else
			-- Check for nearby player to aggro
			local nearPlayer, nearDist = findNearestPlayer(pos, aggroRange)
			if nearPlayer then
				state.aiState = "chase"
				state.targetPlayer = nearPlayer
				state.attackTimer = 0
			else
				-- Wander logic
				state.wanderTimer -= dt
				if state.wanderTimer <= 0 then
					state.wanderTimer = WANDER_INTERVAL + RNG:NextNumber() * 2
					-- Pick random point near spawn
					local angle = RNG:NextNumber() * math.pi * 2
					local radius = RNG:NextNumber() * WANDER_RADIUS
					state.wanderTarget = state.spawnPos + Vector3.new(
						math.cos(angle) * radius,
						0,
						math.sin(angle) * radius
					)
					state.aiState = "wander"
				end

				if state.aiState == "wander" and state.wanderTarget then
					local d = distXZ(pos, state.wanderTarget)
					if d < 1 then
						state.aiState = "idle"
					else
						moveModelTo(model, state.wanderTarget, dt, speed * 0.4) -- slow wander
					end
				end
			end
		end
	end
end)

--------------------------------------------------------------------------------
-- SPAWN DEFINITIONS √É¬¢√¢'¬¨" where each monster type appears in the world
--------------------------------------------------------------------------------
local spawnTable = {
	-- SAFE ZONE
	{ key = "Chicken",       count = 5, xMin = 120,  xMax = 180,  zMin = 120,  zMax = 160  },
	{ key = "Cow",           count = 4, xMin = 160,  xMax = 220,  zMin = 140,  zMax = 180  },
	{ key = "Goblin",        count = 4, xMin = -30,  xMax = 30,   zMin = 170,  zMax = 200  },
	{ key = "GuardDog",      count = 3, xMin = 160,  xMax = 200,  zMin = 0,    zMax = 40   },
	{ key = "GiantRat",      count = 5, xMin = -110, xMax = -80,  zMin = 20,   zMax = 40   },
	{ key = "TrainingDummy", count = 3, xMin = 170,  xMax = 210,  zMin = 10,   zMax = 40   },

	-- SAFE ZONE BOSSES
	{ key = "King Rooster",       count = 1, xMin = 140,  xMax = 160,  zMin = 130,  zMax = 150  },
	{ key = "Elder Treant",       count = 1, xMin = -200, xMax = -150, zMin = -30,  zMax = 30   },
	{ key = "Iron Golem",         count = 1, xMin = 190,  xMax = 220,  zMin = 20,   zMax = 50   },
	{ key = "Lake Serpent",       count = 1, xMin = -170, xMax = -130, zMin = 140,  zMax = 180  },
	{ key = "Corrupted Guardian", count = 1, xMin = 210,  xMax = 230,  zMin = -75,  zMax = -55  },

	-- WILDERNESS
	{ key = "Skeleton",      count = 5, xMin = -50,  xMax = -20,  zMin = -160, zMax = -140 },
	{ key = "DarkWizard",    count = 3, xMin = 50,   xMax = 70,   zMin = -180, zMax = -170 },
	{ key = "Demon",         count = 3, xMin = -20,  xMax = 20,   zMin = -320, zMax = -280 },

	-- NEW AREA MONSTERS (MapSetup5)
	-- Pirate Cove (X: 300-400, Z: -200 to -100) - Safe Zone
	{ key = "Pirate Ghost",  count = 4, xMin = 310,  xMax = 390,  zMin = -190, zMax = -110 },
	
	-- Frozen Peaks (X: -400 to -300, Z: -300 to -200) - Safe Zone  
	{ key = "Ice Elemental", count = 3, xMin = -390, xMax = -310, zMin = -290, zMax = -210 },
	{ key = "Frost Wyrm",    count = 1, xMin = -380, xMax = -320, zMin = -280, zMax = -220 }, -- boss
	
	-- Volcanic Crater (X: 300-400, Z: -400 to -300) - Wilderness
	{ key = "Lava Golem",    count = 3, xMin = 310,  xMax = 390,  zMin = -390, zMax = -310 },
	
	-- Enchanted Garden (X: -300 to -200, Z: 200-350) - Safe Zone
	{ key = "Fairy Dragon",  count = 5, xMin = -290, xMax = -210, zMin = 210,  zMax = 340  },
	
	-- Underground Ruins (X: -100 to 50, Z: -450 to -350) - Wilderness
	{ key = "Ancient Guardian", count = 1, xMin = -90, xMax = 40,   zMin = -440, zMax = -360 }, -- boss
	
	-- Dragon's Nest (X: 0-100, Z: -500 to -450) - no regular spawns (just boss area)
}

-- Spawn all regular monsters
for _, entry in spawnTable do
	for i = 1, entry.count do
		local pos = randomPointInRect(entry.xMin, entry.xMax, entry.zMin, entry.zMax)
		spawnMonster(entry.key, pos)
	end
end

-- Shadow Dragon BOSS ‚Äî single fixed spawn (center of Dragon's Nest, accessible from all sides)
spawnMonster("ShadowDragon", Vector3.new(50, 0, -475))

-- Lich King Malachar BOSS ‚Äî deep wilderness undead sorcerer
spawnMonster("LichKingMalachar", Vector3.new(-50, 0, -400))

print("[MonsterManager] Spawned " .. totalSpawned .. " monsters!")

]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="49">
      <Properties>
        <string name="Name">NPCManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	NPCManager.server.lua
	ServerScriptService

	Spawns all NPCs in the game world as interactive multi-part humanoid models.
	Each NPC has a full body (torso, head, arms, legs), unique accessories,
	a BillboardGui nametag, and ClickDetectors on every part.
	Clicking fires "NPCInteract" RemoteEvent to the client.
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Wait for map to finish building (increased for heavier MapSetup scripts)
task.wait(12)

--------------------------------------------------------------------------------
-- REMOTE EVENT
--------------------------------------------------------------------------------
local function getOrCreateRemote(name)
	local existing = ReplicatedStorage:FindFirstChild(name)
	if existing then return existing end
	local re = Instance.new("RemoteEvent")
	re.Name = name
	re.Parent = ReplicatedStorage
	return re
end

local NPCInteractEvent = getOrCreateRemote("NPCInteract")

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------
local function makePart(props)
	local p = Instance.new("Part")
	p.Name = props.Name or "Part"
	p.Shape = props.Shape or Enum.PartType.Block
	p.Size = props.Size or Vector3.new(1, 1, 1)
	p.Color = props.Color or Color3.fromRGB(128, 128, 128)
	p.Anchored = true
	p.CanCollide = props.CanCollide or false
	p.CFrame = props.CFrame or CFrame.new(0, 0, 0)
	p.Transparency = props.Transparency or 0
	p.Material = props.Material or Enum.Material.SmoothPlastic
	p.Parent = props.Parent
	return p
end

local function weld(part0, part1)
	local w = Instance.new("WeldConstraint")
	w.Part0 = part0
	w.Part1 = part1
	w.Parent = part0
end

local function addClickDetector(part, npcName)
	local cd = Instance.new("ClickDetector")
	cd.MaxActivationDistance = 15
	cd.Parent = part
	cd.MouseClick:Connect(function(player)
		NPCInteractEvent:FireClient(player, npcName)
	end)
end

local function addClickToAll(model, npcName)
	for _, child in model:GetDescendants() do
		if child:IsA("BasePart") then
			addClickDetector(child, npcName)
		end
	end
end

-- Lighten a color slightly for eyeball whites
local function lighten(c, amount)
	return Color3.fromRGB(
		math.min(255, math.floor(c.R * 255 + amount)),
		math.min(255, math.floor(c.G * 255 + amount)),
		math.min(255, math.floor(c.B * 255 + amount))
	)
end

--------------------------------------------------------------------------------
-- FACE BUILDER ‚Äî gives every NPC eyes and a mouth expression
-- mood: "happy", "serious", "evil", "spooky", "mystical", "dead"
--------------------------------------------------------------------------------
local function buildFace(model, b, mood, opts)
	opts = opts or {}
	local headPos = b.headPos
	if not headPos then
		warn("[NPCManager] buildFace: headPos is nil, skipping face")
		return
	end
	local trans = b.trans or 0
	local skinColor = opts.skinColor or Color3.fromRGB(230, 200, 170)
	local eyeWhite = opts.eyeWhite or lighten(skinColor, 50)
	local pupilColor = opts.pupilColor or Color3.fromRGB(30, 25, 20)
	local mouthColor = opts.mouthColor or Color3.fromRGB(50, 30, 20)

	-- skip eyes for blindfolded Oracle
	if not opts.noEyes then
		for _, side in {1, -1} do
			-- eyeball
			local eye = makePart({
				Name = side == 1 and "RightEye" or "LeftEye",
				Shape = Enum.PartType.Ball,
				Size = Vector3.new(0.28, 0.28, 0.28),
				Color = eyeWhite,
				CFrame = CFrame.new(headPos + Vector3.new(side * 0.28, 0.08, -(HEAD_RADIUS * 0.82))),
				Transparency = trans,
				Parent = model,
			})
			weld(b.head, eye)

			-- pupil
			local pupil = makePart({
				Name = side == 1 and "RightPupil" or "LeftPupil",
				Shape = Enum.PartType.Ball,
				Size = Vector3.new(0.13, 0.13, 0.13),
				Color = pupilColor,
				CFrame = CFrame.new(headPos + Vector3.new(side * 0.28, 0.08, -(HEAD_RADIUS * 0.95))),
				Transparency = trans,
				Parent = model,
			})
			weld(b.head, pupil)
		end
	end

	-- Mouth expression
	if mood == "happy" then
		-- two small angled blocks forming a smile
		for _, side in {1, -1} do
			local m = makePart({
				Name = "Mouth" .. (side == 1 and "R" or "L"),
				Size = Vector3.new(0.2, 0.06, 0.06),
				Color = mouthColor,
				CFrame = CFrame.new(headPos + Vector3.new(side * 0.12, -0.22, -(HEAD_RADIUS * 0.88)))
					* CFrame.Angles(0, 0, math.rad(side * -15)),
				Transparency = trans,
				Parent = model,
			})
			weld(b.head, m)
		end
	elseif mood == "evil" or mood == "spooky" then
		-- frown: two angled blocks going down
		for _, side in {1, -1} do
			local m = makePart({
				Name = "Mouth" .. (side == 1 and "R" or "L"),
				Size = Vector3.new(0.2, 0.06, 0.06),
				Color = mouthColor,
				CFrame = CFrame.new(headPos + Vector3.new(side * 0.12, -0.25, -(HEAD_RADIUS * 0.88)))
					* CFrame.Angles(0, 0, math.rad(side * 15)),
				Transparency = trans,
				Parent = model,
			})
			weld(b.head, m)
		end
	elseif mood == "dead" then
		-- skeletal teeth
		for i = -2, 2 do
			local tooth = makePart({
				Name = "Tooth" .. i,
				Size = Vector3.new(0.1, 0.12, 0.06),
				Color = Color3.fromRGB(220, 220, 200),
				CFrame = CFrame.new(headPos + Vector3.new(i * 0.1, -0.25, -(HEAD_RADIUS * 0.88))),
				Transparency = trans,
				Parent = model,
			})
			weld(b.head, tooth)
		end
	else
		-- serious: straight line
		local m = makePart({
			Name = "Mouth",
			Size = Vector3.new(0.35, 0.06, 0.06),
			Color = mouthColor,
			CFrame = CFrame.new(headPos + Vector3.new(0, -0.24, -(HEAD_RADIUS * 0.88))),
			Transparency = trans,
			Parent = model,
		})
		weld(b.head, m)
	end
end

--------------------------------------------------------------------------------
-- NPC DEFINITIONS
--------------------------------------------------------------------------------
local NPC_DEFS = {
	{
		name = "Captain Aldric",
		role = "Quest Giver",
		position = Vector3.new(20, 0, 30),
		skinColor = Color3.fromRGB(210, 170, 130),
		torsoColor = Color3.fromRGB(25, 40, 100),
		legColor = Color3.fromRGB(40, 40, 60),
		armColor = Color3.fromRGB(25, 40, 100),
	},
	{
		name = "Mara the Merchant",
		role = "General Store",
		position = Vector3.new(50, 0, 60),
		skinColor = Color3.fromRGB(210, 170, 130),
		torsoColor = Color3.fromRGB(240, 210, 50),
		legColor = Color3.fromRGB(100, 70, 30),
		armColor = Color3.fromRGB(210, 170, 130),
	},
	{
		name = "Grimnir the Smith",
		role = "Weapons & Armor",
		position = Vector3.new(55, 0, 40),
		skinColor = Color3.fromRGB(190, 150, 110),
		torsoColor = Color3.fromRGB(60, 60, 60),
		legColor = Color3.fromRGB(50, 50, 50),
		armColor = Color3.fromRGB(60, 60, 60),
		noLeftArm = true,
	},
	{
		name = "Old Bess",
		role = "Food & Drink",
		position = Vector3.new(-10, 0, 20),
		skinColor = Color3.fromRGB(210, 170, 130),
		torsoColor = Color3.fromRGB(139, 90, 43),
		legColor = Color3.fromRGB(100, 70, 40),
		armColor = Color3.fromRGB(210, 170, 130),
	},
	{
		name = "Brother Elden",
		role = "Healer & Quests",
		position = Vector3.new(70, 0, 30),
		skinColor = Color3.fromRGB(200, 160, 120),
		torsoColor = Color3.fromRGB(240, 240, 240),
		legColor = Color3.fromRGB(220, 220, 220),
		armColor = Color3.fromRGB(240, 240, 240),
	},
	{
		name = "Finnick the Fletcher",
		role = "Ranged Gear",
		position = Vector3.new(25, 0, 70),
		skinColor = Color3.fromRGB(210, 170, 130),
		torsoColor = Color3.fromRGB(50, 120, 50),
		legColor = Color3.fromRGB(60, 80, 40),
		armColor = Color3.fromRGB(50, 120, 50),
	},
	{
		name = "Scout Wren",
		role = "Quest Giver",
		position = Vector3.new(45, 0, 40),
		skinColor = Color3.fromRGB(210, 170, 130),
		torsoColor = Color3.fromRGB(140, 100, 55),
		legColor = Color3.fromRGB(100, 75, 40),
		armColor = Color3.fromRGB(140, 100, 55),
	},
	{
		name = "Grave Keeper Morath",
		role = "Quest Giver",
		position = Vector3.new(-30, 0, -150),
		skinColor = Color3.fromRGB(160, 140, 120),
		torsoColor = Color3.fromRGB(50, 50, 50),
		legColor = Color3.fromRGB(40, 40, 40),
		armColor = Color3.fromRGB(50, 50, 50),
	},
	{
		name = "Witch Thessaly",
		role = "Quest Giver",
		position = Vector3.new(-200, 0, -250),
		skinColor = Color3.fromRGB(80, 160, 80),
		torsoColor = Color3.fromRGB(100, 30, 130),
		legColor = Color3.fromRGB(80, 20, 100),
		armColor = Color3.fromRGB(80, 160, 80),
	},
	{
		name = "Bandit King Rask",
		role = "Quest Giver",
		position = Vector3.new(250, 0, -200),
		skinColor = Color3.fromRGB(200, 160, 120),
		torsoColor = Color3.fromRGB(120, 70, 30),
		legColor = Color3.fromRGB(80, 50, 20),
		armColor = Color3.fromRGB(120, 70, 30),
	},
	{
		name = "The Oracle",
		role = "Seer",
		position = Vector3.new(-150, 0, -100),
		skinColor = Color3.fromRGB(255, 215, 0),
		torsoColor = Color3.fromRGB(240, 240, 240),
		legColor = Color3.fromRGB(220, 220, 240),
		armColor = Color3.fromRGB(240, 240, 240),
		floating = true,
	},
	{
		name = "Ghost of Sir Aldren",
		role = "Spirit",
		position = Vector3.new(50, 0, -160),
		skinColor = Color3.fromRGB(120, 170, 240),
		torsoColor = Color3.fromRGB(100, 150, 220),
		legColor = Color3.fromRGB(100, 150, 220),
		armColor = Color3.fromRGB(100, 150, 220),
		ghost = true,
	},
	{
		name = "Ferryman Charon",
		role = "Ferryman",
		position = Vector3.new(-20, 0, -300),
		skinColor = Color3.fromRGB(200, 200, 180),
		torsoColor = Color3.fromRGB(20, 20, 20),
		legColor = Color3.fromRGB(15, 15, 15),
		armColor = Color3.fromRGB(20, 20, 20),
		skeletal = true,
	},
	{
		name = "Dragon Priestess Lyra",
		role = "Quest Giver",
		position = Vector3.new(0, 0, -350),
		skinColor = Color3.fromRGB(210, 170, 130),
		torsoColor = Color3.fromRGB(180, 30, 30),
		legColor = Color3.fromRGB(180, 30, 30),
		armColor = Color3.fromRGB(180, 30, 30),
	},

	-- NEW AREA NPCs (MapSetup5)
	{
		name = "Captain Blackbeard",
		role = "Pirate Merchant",
		position = Vector3.new(340, 0, -150),
		skinColor = Color3.fromRGB(190, 150, 110),
		torsoColor = Color3.fromRGB(139, 0, 0),
		legColor = Color3.fromRGB(64, 64, 64),
		armColor = Color3.fromRGB(139, 0, 0),
	},
	{
		name = "Frost Sage Elara",
		role = "Ice Mage",
		position = Vector3.new(-350, 0, -250),
		skinColor = Color3.fromRGB(220, 200, 200),
		torsoColor = Color3.fromRGB(230, 230, 255),
		legColor = Color3.fromRGB(200, 200, 240),
		armColor = Color3.fromRGB(230, 230, 255),
	},
	{
		name = "Priestess Solara",
		role = "Healer",
		position = Vector3.new(-250, 0, 275),
		skinColor = Color3.fromRGB(210, 170, 130),
		torsoColor = Color3.fromRGB(255, 255, 255),
		legColor = Color3.fromRGB(255, 215, 0),
		armColor = Color3.fromRGB(255, 255, 255),
	},
	{
		name = "Archaeologist Rex",
		role = "Explorer",
		position = Vector3.new(-25, 0, -400),
		skinColor = Color3.fromRGB(210, 170, 130),
		torsoColor = Color3.fromRGB(139, 90, 43),
		legColor = Color3.fromRGB(101, 67, 33),
		armColor = Color3.fromRGB(139, 90, 43),
	},
}

--------------------------------------------------------------------------------
-- BODY DIMENSIONS
--------------------------------------------------------------------------------
local TORSO_SIZE = Vector3.new(2.4, 3, 1.2)
local HEAD_RADIUS = 0.9
local ARM_SIZE = Vector3.new(0.8, 2.8, 0.8)
local LEG_SIZE = Vector3.new(0.9, 2.8, 0.9)
local THIN_LIMB_FACTOR = 0.5 -- for skeletal NPCs

--------------------------------------------------------------------------------
-- BUILD HUMANOID BODY
--------------------------------------------------------------------------------
local function buildBody(model, def, origin)
	local trans = 0
	if def.ghost then trans = 0.5 end
	local isSkeletal = def.skeletal
	local torsoSize = TORSO_SIZE
	local armSize = ARM_SIZE
	local legSize = LEG_SIZE
	if isSkeletal then
		torsoSize = Vector3.new(TORSO_SIZE.X * 0.7, TORSO_SIZE.Y, TORSO_SIZE.Z * 0.6)
		armSize = Vector3.new(ARM_SIZE.X * THIN_LIMB_FACTOR, ARM_SIZE.Y, ARM_SIZE.Z * THIN_LIMB_FACTOR)
		legSize = Vector3.new(LEG_SIZE.X * THIN_LIMB_FACTOR, LEG_SIZE.Y, LEG_SIZE.Z * THIN_LIMB_FACTOR)
	end

	-- Floating offset for Oracle
	local yOffset = 0
	if def.floating then yOffset = 1.5 end

	local torsoCenter = origin + Vector3.new(0, legSize.Y + torsoSize.Y / 2 + yOffset, 0)
	local torsoCF = CFrame.new(torsoCenter)

	-- Morath hunched
	if def.name == "Grave Keeper Morath" then
		torsoCF = CFrame.new(torsoCenter) * CFrame.Angles(math.rad(15), 0, 0)
	end

	-- Aldric military posture ‚Äî slight lean back
	if def.name == "Captain Aldric" then
		torsoCF = CFrame.new(torsoCenter) * CFrame.Angles(math.rad(-5), 0, 0)
	end

	-- Rask muscular build ‚Äî slightly wider torso
	if def.name == "Bandit King Rask" then
		torsoSize = Vector3.new(torsoSize.X * 1.15, torsoSize.Y, torsoSize.Z * 1.1)
	end

	-- Morath gaunt torso
	if def.name == "Grave Keeper Morath" then
		torsoSize = Vector3.new(torsoSize.X * 0.9, torsoSize.Y, torsoSize.Z * 0.85)
	end

	local torso = makePart({
		Name = "Torso",
		Size = torsoSize,
		Color = def.torsoColor,
		CFrame = torsoCF,
		Transparency = trans,
		CanCollide = true,
		Parent = model,
	})
	model.PrimaryPart = torso

	-- Head
	local headDiam = HEAD_RADIUS * 2
	local headPos = torsoCenter + Vector3.new(0, torsoSize.Y / 2 + HEAD_RADIUS, 0)
	if def.name == "Grave Keeper Morath" then
		headPos = headPos + Vector3.new(0, -0.3, -0.4)
	end
	local head = makePart({
		Name = "Head",
		Shape = Enum.PartType.Ball,
		Size = Vector3.new(headDiam, headDiam, headDiam),
		Color = def.skinColor,
		CFrame = CFrame.new(headPos),
		Transparency = trans,
		Parent = model,
	})
	weld(torso, head)

	-- Right Arm
	local raPos = torsoCenter + Vector3.new(torsoSize.X / 2 + armSize.X / 2, (torsoSize.Y - armSize.Y) / 2, 0)
	local rightArm = makePart({
		Name = "RightArm",
		Size = armSize,
		Color = def.armColor,
		CFrame = CFrame.new(raPos),
		Transparency = trans,
		Parent = model,
	})
	weld(torso, rightArm)

	-- Left Arm (skip for Grimnir)
	local leftArm = nil
	if not def.noLeftArm then
		local laPos = torsoCenter + Vector3.new(-(torsoSize.X / 2 + armSize.X / 2), (torsoSize.Y - armSize.Y) / 2, 0)
		leftArm = makePart({
			Name = "LeftArm",
			Size = armSize,
			Color = def.armColor,
			CFrame = CFrame.new(laPos),
			Transparency = trans,
			Parent = model,
		})
		weld(torso, leftArm)
	end

	-- Right Leg
	local rlPos = origin + Vector3.new(torsoSize.X / 4, legSize.Y / 2 + yOffset, 0)
	local rightLeg = makePart({
		Name = "RightLeg",
		Size = legSize,
		Color = def.legColor,
		CFrame = CFrame.new(rlPos),
		Transparency = trans,
		Parent = model,
	})
	weld(torso, rightLeg)

	-- Left Leg
	local llPos = origin + Vector3.new(-torsoSize.X / 4, legSize.Y / 2 + yOffset, 0)
	local leftLeg = makePart({
		Name = "LeftLeg",
		Size = legSize,
		Color = def.legColor,
		CFrame = CFrame.new(llPos),
		Transparency = trans,
		Parent = model,
	})
	weld(torso, leftLeg)

	return {
		torso = torso,
		head = head,
		rightArm = rightArm,
		leftArm = leftArm,
		rightLeg = rightLeg,
		leftLeg = leftLeg,
		torsoCenter = torsoCenter,
		headPos = headPos,
		trans = trans,
		torsoSize = torsoSize,
		armSize = armSize,
		legSize = legSize,
		yOffset = yOffset,
	}
end

--------------------------------------------------------------------------------
-- ACCESSORY BUILDERS
--------------------------------------------------------------------------------
local function buildCaptainAldric(model, def, b)
	-- FACE: serious military expression
	buildFace(model, b, "serious", { skinColor = def.skinColor })

	-- SHORT DARK BROWN HAIR ‚Äî block on top + sides
	local hairTop = makePart({
		Name = "HairTop",
		Size = Vector3.new(HEAD_RADIUS * 1.9, 0.25, HEAD_RADIUS * 1.8),
		Color = Color3.fromRGB(60, 40, 20),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.75, 0)),
		Parent = model,
	})
	weld(b.head, hairTop)
	for _, side in {1, -1} do
		local hairSide = makePart({
			Name = side == 1 and "HairR" or "HairL",
			Size = Vector3.new(0.15, 0.5, HEAD_RADIUS * 1.4),
			Color = Color3.fromRGB(60, 40, 20),
			CFrame = CFrame.new(b.headPos + Vector3.new(side * (HEAD_RADIUS * 0.8), 0.3, 0)),
			Parent = model,
		})
		weld(b.head, hairSide)
	end

	-- CAPTAIN'S HAT ‚Äî flat-top block with brim
	local hatBrim = makePart({
		Name = "HatBrim",
		Size = Vector3.new(HEAD_RADIUS * 2.6, 0.12, HEAD_RADIUS * 2.6),
		Color = Color3.fromRGB(20, 30, 80),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.85, 0)),
		Parent = model,
	})
	weld(b.head, hatBrim)
	local hatTop = makePart({
		Name = "HatTop",
		Size = Vector3.new(HEAD_RADIUS * 1.8, 0.6, HEAD_RADIUS * 1.6),
		Color = Color3.fromRGB(20, 30, 80),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS + 0.35, 0)),
		Parent = model,
	})
	weld(b.head, hatTop)
	-- hat badge
	local hatBadge = makePart({
		Name = "HatBadge",
		Shape = Enum.PartType.Ball,
		Size = Vector3.new(0.2, 0.2, 0.2),
		Color = Color3.fromRGB(230, 200, 50),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS + 0.15, -(HEAD_RADIUS * 0.9))),
		Parent = model,
	})
	weld(b.head, hatBadge)

	-- Blue cape behind torso (existing)
	local cape = makePart({
		Name = "Cape",
		Size = Vector3.new(2, 3.2, 0.15),
		Color = Color3.fromRGB(30, 60, 160),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(0, -0.2, b.torsoSize.Z / 2 + 0.1)),
		Parent = model,
	})
	weld(b.torso, cape)

	-- Gold shoulder pads (existing)
	for _, side in {1, -1} do
		local pad = makePart({
			Name = side == 1 and "RightPad" or "LeftPad",
			Size = Vector3.new(1.2, 0.4, 1.4),
			Color = Color3.fromRGB(230, 200, 50),
			CFrame = CFrame.new(b.torsoCenter + Vector3.new(side * (b.torsoSize.X / 2 + 0.1), b.torsoSize.Y / 2 - 0.2, 0)),
			Parent = model,
		})
		weld(b.torso, pad)
	end

	-- MEDAL on chest
	local medal = makePart({
		Name = "Medal",
		Shape = Enum.PartType.Ball,
		Size = Vector3.new(0.22, 0.22, 0.22),
		Color = Color3.fromRGB(230, 200, 50),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(-0.4, 0.6, -(b.torsoSize.Z / 2 + 0.08))),
		Parent = model,
	})
	weld(b.torso, medal)
	-- medal ribbon
	local ribbon = makePart({
		Name = "MedalRibbon",
		Size = Vector3.new(0.15, 0.3, 0.05),
		Color = Color3.fromRGB(180, 30, 30),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(-0.4, 0.82, -(b.torsoSize.Z / 2 + 0.08))),
		Parent = model,
	})
	weld(b.torso, ribbon)

	-- BELT with buckle
	local belt = makePart({
		Name = "Belt",
		Size = Vector3.new(b.torsoSize.X + 0.1, 0.25, b.torsoSize.Z + 0.1),
		Color = Color3.fromRGB(60, 40, 20),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(0, -b.torsoSize.Y / 2 + 0.2, 0)),
		Parent = model,
	})
	weld(b.torso, belt)
	local buckle = makePart({
		Name = "Buckle",
		Size = Vector3.new(0.3, 0.22, 0.08),
		Color = Color3.fromRGB(230, 200, 50),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(0, -b.torsoSize.Y / 2 + 0.2, -(b.torsoSize.Z / 2 + 0.1))),
		Parent = model,
	})
	weld(b.torso, buckle)

	-- SWORD on hip
	local swordBlade = makePart({
		Name = "SwordBlade",
		Size = Vector3.new(0.08, 2.2, 0.3),
		Color = Color3.fromRGB(200, 200, 210),
		Material = Enum.Material.Metal,
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(b.torsoSize.X / 2 + 0.2, -b.torsoSize.Y / 2 - 0.5, 0.2))
			* CFrame.Angles(0, 0, math.rad(10)),
		Parent = model,
	})
	weld(b.torso, swordBlade)
	local swordHilt = makePart({
		Name = "SwordHilt",
		Size = Vector3.new(0.12, 0.35, 0.6),
		Color = Color3.fromRGB(120, 80, 30),
		CFrame = CFrame.new(swordBlade.Position + Vector3.new(0, 1.2, 0)),
		Parent = model,
	})
	weld(swordBlade, swordHilt)
end

local function buildMara(model, def, b)
	-- FACE: happy shopkeeper
	buildFace(model, b, "happy", { skinColor = def.skinColor })

	-- BROWN HAIR BUN on back of head
	local bun = makePart({
		Name = "HairBun",
		Shape = Enum.PartType.Ball,
		Size = Vector3.new(0.6, 0.6, 0.6),
		Color = Color3.fromRGB(100, 65, 30),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.4, HEAD_RADIUS * 0.7)),
		Parent = model,
	})
	weld(b.head, bun)
	-- headband
	local headband = makePart({
		Name = "Headband",
		Size = Vector3.new(HEAD_RADIUS * 2.1, 0.15, HEAD_RADIUS * 2.1),
		Color = Color3.fromRGB(180, 50, 50),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.5, 0)),
		Parent = model,
	})
	weld(b.head, headband)

	-- EARRINGS ‚Äî tiny gold balls near head sides
	for _, side in {1, -1} do
		local earring = makePart({
			Name = side == 1 and "EarringR" or "EarringL",
			Shape = Enum.PartType.Ball,
			Size = Vector3.new(0.12, 0.12, 0.12),
			Color = Color3.fromRGB(230, 200, 50),
			CFrame = CFrame.new(b.headPos + Vector3.new(side * (HEAD_RADIUS * 0.9), -0.15, 0)),
			Parent = model,
		})
		weld(b.head, earring)
	end

	-- Apron on front (existing)
	local apron = makePart({
		Name = "Apron",
		Size = Vector3.new(1.8, 2.4, 0.12),
		Color = Color3.fromRGB(220, 200, 160),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(0, -0.3, -(b.torsoSize.Z / 2 + 0.1))),
		Parent = model,
	})
	weld(b.torso, apron)

	-- Basket in right hand (existing)
	local basket = makePart({
		Name = "Basket",
		Size = Vector3.new(1.0, 0.8, 0.8),
		Color = Color3.fromRGB(139, 90, 43),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(b.torsoSize.X / 2 + b.armSize.X + 0.3, -b.torsoSize.Y / 2 + 0.5, 0)),
		Parent = model,
	})
	weld(b.rightArm, basket)

	-- COIN POUCH on belt
	local coinPouch = makePart({
		Name = "CoinPouch",
		Shape = Enum.PartType.Ball,
		Size = Vector3.new(0.3, 0.3, 0.3),
		Color = Color3.fromRGB(120, 80, 30),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(0.5, -b.torsoSize.Y / 2 + 0.1, -(b.torsoSize.Z / 2 + 0.05))),
		Parent = model,
	})
	weld(b.torso, coinPouch)

	-- MARKET STALL ‚Äî wooden table with displayed items
	local table1 = makePart({
		Name = "MarketTable",
		Size = Vector3.new(4, 0.3, 2.5),
		Color = Color3.fromRGB(120, 80, 30),
		CFrame = CFrame.new(def.position + Vector3.new(3.5, 2.0, 0)),
		Parent = model,
	})
	-- table legs
	for _, lx in {-1.5, 1.5} do
		for _, lz in {-0.9, 0.9} do
			local leg = makePart({
				Name = "TableLeg",
				Size = Vector3.new(0.2, 2.0, 0.2),
				Color = Color3.fromRGB(100, 65, 25),
				CFrame = CFrame.new(def.position + Vector3.new(3.5 + lx, 1.0, lz)),
				Parent = model,
			})
			weld(table1, leg)
		end
	end
	-- displayed items on table
	local displayColors = {
		Color3.fromRGB(200, 50, 50),
		Color3.fromRGB(50, 50, 200),
		Color3.fromRGB(50, 200, 50),
		Color3.fromRGB(200, 180, 50),
	}
	for i, col in displayColors do
		local item = makePart({
			Name = "DisplayItem" .. i,
			Size = Vector3.new(0.4, 0.4, 0.4),
			Color = col,
			CFrame = CFrame.new(def.position + Vector3.new(2.5 + i * 0.7, 2.35, (i % 2 == 0) and 0.3 or -0.3)),
			Parent = model,
		})
		weld(table1, item)
	end
end

local function buildGrimnir(model, def, b)
	-- FACE: serious working man
	buildFace(model, b, "serious", { skinColor = def.skinColor })

	-- SOOT MARKS on face
	for _, pos in { Vector3.new(0.3, 0.15, -0.8), Vector3.new(-0.2, -0.1, -0.75), Vector3.new(0.1, 0.3, -0.78) } do
		local soot = makePart({
			Name = "SootMark",
			Shape = Enum.PartType.Ball,
			Size = Vector3.new(0.15, 0.15, 0.08),
			Color = Color3.fromRGB(30, 25, 20),
			Transparency = 0.4,
			CFrame = CFrame.new(b.headPos + pos),
			Parent = model,
		})
		weld(b.head, soot)
	end

	-- LEATHER APRON on front of torso
	local apron = makePart({
		Name = "LeatherApron",
		Size = Vector3.new(b.torsoSize.X * 0.85, b.torsoSize.Y + 0.5, 0.12),
		Color = Color3.fromRGB(100, 60, 25),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(0, -0.2, -(b.torsoSize.Z / 2 + 0.08))),
		Parent = model,
	})
	weld(b.torso, apron)
	-- apron strap
	local strap = makePart({
		Name = "ApronStrap",
		Size = Vector3.new(0.15, 1.2, 0.06),
		Color = Color3.fromRGB(80, 50, 20),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(0.3, b.torsoSize.Y / 2 - 0.3, -(b.torsoSize.Z / 2 + 0.12))),
		Parent = model,
	})
	weld(b.torso, strap)

	-- TONGS where left arm would be (mechanical prosthetic)
	local tongBase = makePart({
		Name = "TongBase",
		Size = Vector3.new(0.2, 1.5, 0.15),
		Color = Color3.fromRGB(100, 100, 100),
		Material = Enum.Material.Metal,
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(-(b.torsoSize.X / 2 + 0.3), -0.2, 0)),
		Parent = model,
	})
	weld(b.torso, tongBase)
	-- tong jaws
	for _, side in {1, -1} do
		local jaw = makePart({
			Name = side == 1 and "TongJawR" or "TongJawL",
			Size = Vector3.new(0.08, 0.8, 0.1),
			Color = Color3.fromRGB(110, 110, 110),
			Material = Enum.Material.Metal,
			CFrame = CFrame.new(tongBase.Position + Vector3.new(side * 0.1, -1.0, 0))
				* CFrame.Angles(0, 0, math.rad(side * -8)),
			Parent = model,
		})
		weld(tongBase, jaw)
	end

	-- Anvil next to him (existing)
	local anvil = makePart({
		Name = "Anvil",
		Size = Vector3.new(2.0, 1.5, 1.5),
		Color = Color3.fromRGB(80, 80, 80),
		Material = Enum.Material.Metal,
		CFrame = CFrame.new(def.position + Vector3.new(-3, 0.75, 0)),
		Parent = model,
	})
	local anvilTop = makePart({
		Name = "AnvilTop",
		Size = Vector3.new(2.8, 0.5, 1.8),
		Color = Color3.fromRGB(90, 90, 90),
		Material = Enum.Material.Metal,
		CFrame = CFrame.new(def.position + Vector3.new(-3, 1.75, 0)),
		Parent = model,
	})
	weld(anvil, anvilTop)

	-- Hammer in right hand (existing)
	local hammerHandle = makePart({
		Name = "HammerHandle",
		Size = Vector3.new(0.2, 1.8, 0.2),
		Color = Color3.fromRGB(120, 80, 30),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(b.torsoSize.X / 2 + b.armSize.X / 2, -0.5, -0.3)),
		Parent = model,
	})
	weld(b.rightArm, hammerHandle)
	local hammerHead = makePart({
		Name = "HammerHead",
		Size = Vector3.new(0.6, 0.5, 0.4),
		Color = Color3.fromRGB(100, 100, 100),
		Material = Enum.Material.Metal,
		CFrame = CFrame.new(hammerHandle.Position + Vector3.new(0, -1.0, 0)),
		Parent = model,
	})
	weld(hammerHandle, hammerHead)
end

local function buildOldBess(model, def, b)
	-- FACE: happy grandma
	buildFace(model, b, "happy", { skinColor = def.skinColor })

	-- WRINKLE LINES on face sides
	for _, side in {1, -1} do
		local wrinkle = makePart({
			Name = side == 1 and "WrinkleR" or "WrinkleL",
			Size = Vector3.new(0.04, 0.3, 0.04),
			Color = Color3.fromRGB(170, 130, 100),
			CFrame = CFrame.new(b.headPos + Vector3.new(side * 0.45, -0.1, -(HEAD_RADIUS * 0.7))),
			Parent = model,
		})
		weld(b.head, wrinkle)
	end

	-- Gray hair (existing + extra strands)
	local hair = makePart({
		Name = "Hair",
		Size = Vector3.new(HEAD_RADIUS * 2.2, HEAD_RADIUS * 1.0, HEAD_RADIUS * 2.2),
		Color = Color3.fromRGB(180, 180, 180),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.3, 0)),
		Parent = model,
	})
	weld(b.head, hair)
	-- extra gray strands
	for i = 1, 4 do
		local strand = makePart({
			Name = "HairStrand" .. i,
			Size = Vector3.new(0.1, 0.4, 0.1),
			Color = Color3.fromRGB(190, 190, 190),
			CFrame = CFrame.new(b.headPos + Vector3.new(
				math.cos(i * 1.5) * HEAD_RADIUS * 0.6,
				HEAD_RADIUS * 0.6,
				math.sin(i * 1.5) * HEAD_RADIUS * 0.6
			)),
			Parent = model,
		})
		weld(b.head, strand)
	end

	-- SHAWL over shoulders
	local shawl = makePart({
		Name = "Shawl",
		Size = Vector3.new(b.torsoSize.X + 0.8, 0.6, b.torsoSize.Z + 0.4),
		Color = Color3.fromRGB(160, 120, 80),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(0, b.torsoSize.Y / 2 - 0.1, 0)),
		Parent = model,
	})
	weld(b.torso, shawl)

	-- WOODEN LADLE in right hand
	local ladleStick = makePart({
		Name = "LadleStick",
		Size = Vector3.new(0.12, 2.0, 0.12),
		Color = Color3.fromRGB(120, 80, 30),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(b.torsoSize.X / 2 + b.armSize.X / 2 + 0.2, -0.3, 0)),
		Parent = model,
	})
	weld(b.rightArm, ladleStick)
	local ladleBowl = makePart({
		Name = "LadleBowl",
		Shape = Enum.PartType.Ball,
		Size = Vector3.new(0.45, 0.25, 0.45),
		Color = Color3.fromRGB(120, 80, 30),
		CFrame = CFrame.new(ladleStick.Position + Vector3.new(0, -1.1, 0)),
		Parent = model,
	})
	weld(ladleStick, ladleBowl)

	-- Cooking pot beside her (existing)
	local pot = makePart({
		Name = "CookingPot",
		Shape = Enum.PartType.Cylinder,
		Size = Vector3.new(1.5, 1.8, 1.8),
		Color = Color3.fromRGB(60, 40, 20),
		CFrame = CFrame.new(def.position + Vector3.new(2.5, 0.75, 0)) * CFrame.Angles(0, 0, math.rad(90)),
		Parent = model,
	})

	-- FOOD CART nearby
	local cartBody = makePart({
		Name = "FoodCartBody",
		Size = Vector3.new(2.5, 1.5, 1.8),
		Color = Color3.fromRGB(100, 65, 25),
		CFrame = CFrame.new(def.position + Vector3.new(-3, 1.0, 1)),
		Parent = model,
	})
	-- cart wheels
	for _, side in {1, -1} do
		local wheel = makePart({
			Name = "CartWheel",
			Shape = Enum.PartType.Cylinder,
			Size = Vector3.new(0.2, 0.8, 0.8),
			Color = Color3.fromRGB(60, 40, 15),
			CFrame = CFrame.new(def.position + Vector3.new(-3 + side * 1.0, 0.4, 1 + 1.0))
				* CFrame.Angles(math.rad(90), 0, 0),
			Parent = model,
		})
		weld(cartBody, wheel)
	end
end

local function buildBrotherElden(model, def, b)
	-- FACE: serene/happy
	buildFace(model, b, "happy", { skinColor = def.skinColor })

	-- White hood (existing)
	local hood = makePart({
		Name = "Hood",
		Size = Vector3.new(HEAD_RADIUS * 2.4, HEAD_RADIUS * 1.6, HEAD_RADIUS * 2.4),
		Color = Color3.fromRGB(240, 240, 240),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.2, 0)),
		Parent = model,
	})
	weld(b.head, hood)

	-- HALO ‚Äî thin neon cylinder above head
	local halo = makePart({
		Name = "Halo",
		Shape = Enum.PartType.Cylinder,
		Size = Vector3.new(0.08, 1.6, 1.6),
		Color = Color3.fromRGB(255, 255, 180),
		Material = Enum.Material.Neon,
		Transparency = 0.3,
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS + 0.8, 0))
			* CFrame.Angles(0, 0, math.rad(90)),
		Parent = model,
	})
	weld(b.head, halo)
	local haloLight = Instance.new("PointLight")
	haloLight.Color = Color3.fromRGB(255, 255, 200)
	haloLight.Brightness = 0.5
	haloLight.Range = 6
	haloLight.Parent = halo

	-- Glowing staff in right hand (existing)
	local staff = makePart({
		Name = "Staff",
		Size = Vector3.new(0.25, 5.5, 0.25),
		Color = Color3.fromRGB(200, 180, 140),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(b.torsoSize.X / 2 + b.armSize.X / 2 + 0.3, 0.5, 0)),
		Parent = model,
	})
	weld(b.rightArm, staff)
	local staffOrb = makePart({
		Name = "StaffOrb",
		Shape = Enum.PartType.Ball,
		Size = Vector3.new(0.6, 0.6, 0.6),
		Color = Color3.fromRGB(255, 255, 200),
		CFrame = CFrame.new(staff.Position + Vector3.new(0, 2.8, 0)),
		Transparency = 0.2,
		Parent = model,
	})
	weld(staff, staffOrb)
	local light = Instance.new("PointLight")
	light.Color = Color3.fromRGB(255, 255, 200)
	light.Brightness = 2
	light.Range = 16
	light.Parent = staffOrb

	-- BOOK in left hand
	if b.leftArm then
		local book = makePart({
			Name = "PrayerBook",
			Size = Vector3.new(0.6, 0.8, 0.15),
			Color = Color3.fromRGB(100, 40, 30),
			CFrame = CFrame.new(b.torsoCenter + Vector3.new(-(b.torsoSize.X / 2 + b.armSize.X / 2 + 0.1), -b.armSize.Y / 2 + 0.3, -0.2)),
			Parent = model,
		})
		weld(b.leftArm, book)
		-- gold cross on book cover
		local cross1 = makePart({
			Name = "BookCrossV",
			Size = Vector3.new(0.06, 0.4, 0.05),
			Color = Color3.fromRGB(230, 200, 50),
			CFrame = CFrame.new(book.Position + Vector3.new(0, 0, -0.1)),
			Parent = model,
		})
		weld(book, cross1)
		local cross2 = makePart({
			Name = "BookCrossH",
			Size = Vector3.new(0.25, 0.06, 0.05),
			Color = Color3.fromRGB(230, 200, 50),
			CFrame = CFrame.new(book.Position + Vector3.new(0, 0.08, -0.1)),
			Parent = model,
		})
		weld(book, cross2)
	end

	-- PRAYER BEADS ‚Äî chain of tiny balls from left hand
	if b.leftArm then
		for i = 0, 5 do
			local bead = makePart({
				Name = "Bead" .. i,
				Shape = Enum.PartType.Ball,
				Size = Vector3.new(0.1, 0.1, 0.1),
				Color = Color3.fromRGB(140, 100, 50),
				CFrame = CFrame.new(b.torsoCenter + Vector3.new(-(b.torsoSize.X / 2 + b.armSize.X / 2), -b.armSize.Y / 2 - 0.1 - i * 0.15, 0)),
				Parent = model,
			})
			weld(b.leftArm, bead)
		end
	end

	-- SANDALS ‚Äî thin brown blocks on feet
	for _, legPart in {b.rightLeg, b.leftLeg} do
		local sandal = makePart({
			Name = "Sandal",
			Size = Vector3.new(b.legSize.X + 0.1, 0.1, b.legSize.Z + 0.2),
			Color = Color3.fromRGB(120, 80, 30),
			CFrame = CFrame.new(legPart.Position + Vector3.new(0, -b.legSize.Y / 2 + 0.05, 0)),
			Parent = model,
		})
		weld(legPart, sandal)
	end
end

local function buildFinnick(model, def, b)
	-- FACE: happy/friendly ranger
	buildFace(model, b, "happy", { skinColor = def.skinColor })

	-- MESSY GREEN-BROWN HAIR ‚Äî multiple small angled blocks
	local hairColors = { Color3.fromRGB(70, 90, 40), Color3.fromRGB(60, 80, 35), Color3.fromRGB(80, 70, 35) }
	local hairPositions = {
		{ Vector3.new(0, 0.8, -0.2), CFrame.Angles(math.rad(-15), 0, math.rad(10)) },
		{ Vector3.new(0.3, 0.7, 0), CFrame.Angles(math.rad(10), 0, math.rad(20)) },
		{ Vector3.new(-0.3, 0.75, 0.1), CFrame.Angles(math.rad(5), 0, math.rad(-25)) },
		{ Vector3.new(0.1, 0.85, 0.2), CFrame.Angles(math.rad(20), 0, math.rad(-5)) },
		{ Vector3.new(-0.15, 0.82, -0.15), CFrame.Angles(math.rad(-10), 0, math.rad(15)) },
	}
	for i, hp in hairPositions do
		local h = makePart({
			Name = "Hair" .. i,
			Size = Vector3.new(0.3, 0.35, 0.25),
			Color = hairColors[(i % #hairColors) + 1],
			CFrame = CFrame.new(b.headPos + hp[1]) * hp[2],
			Parent = model,
		})
		weld(b.head, h)
	end

	-- GREEN HOOD/CAP covering top/back
	local hood = makePart({
		Name = "GreenHood",
		Size = Vector3.new(HEAD_RADIUS * 2.2, HEAD_RADIUS * 0.8, HEAD_RADIUS * 2.4),
		Color = Color3.fromRGB(40, 90, 35),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.5, HEAD_RADIUS * 0.15)),
		Parent = model,
	})
	weld(b.head, hood)

	-- Quiver on back (existing + more arrows)
	local quiver = makePart({
		Name = "Quiver",
		Size = Vector3.new(0.5, 2.0, 0.4),
		Color = Color3.fromRGB(100, 70, 30),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(0.3, 0.3, b.torsoSize.Z / 2 + 0.25)),
		Parent = model,
	})
	weld(b.torso, quiver)

	-- Arrow tips sticking out (existing + more)
	for i = 1, 4 do
		local arrow = makePart({
			Name = "Arrow" .. i,
			Size = Vector3.new(0.08, 0.6, 0.08),
			Color = Color3.fromRGB(180, 180, 180),
			CFrame = CFrame.new(quiver.Position + Vector3.new((i - 2.5) * 0.12, 1.1 + i * 0.05, 0)),
			Parent = model,
		})
		weld(quiver, arrow)
		-- feather fletching
		local fletch = makePart({
			Name = "Fletch" .. i,
			Size = Vector3.new(0.06, 0.15, 0.02),
			Color = Color3.fromRGB(200, 200, 200),
			CFrame = CFrame.new(arrow.Position + Vector3.new(0, -0.2, 0.05)),
			Parent = model,
		})
		weld(arrow, fletch)
	end

	-- Bow in left hand (existing)
	local bow = makePart({
		Name = "Bow",
		Size = Vector3.new(0.15, 3.0, 0.6),
		Color = Color3.fromRGB(120, 80, 30),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(-(b.torsoSize.X / 2 + b.armSize.X / 2 + 0.4), 0, 0)),
		Parent = model,
	})
	weld(b.leftArm, bow)

	-- LEATHER BRACER on right forearm
	local bracer = makePart({
		Name = "Bracer",
		Size = Vector3.new(b.armSize.X + 0.12, 0.8, b.armSize.Z + 0.12),
		Color = Color3.fromRGB(80, 50, 20),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(b.torsoSize.X / 2 + b.armSize.X / 2, -0.5, 0)),
		Parent = model,
	})
	weld(b.rightArm, bracer)

	-- BELT WITH POUCHES
	local belt = makePart({
		Name = "Belt",
		Size = Vector3.new(b.torsoSize.X + 0.1, 0.2, b.torsoSize.Z + 0.1),
		Color = Color3.fromRGB(80, 50, 20),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(0, -b.torsoSize.Y / 2 + 0.15, 0)),
		Parent = model,
	})
	weld(b.torso, belt)
	for _, side in {1, -1} do
		local pouch = makePart({
			Name = side == 1 and "PouchR" or "PouchL",
			Size = Vector3.new(0.35, 0.3, 0.25),
			Color = Color3.fromRGB(90, 60, 25),
			CFrame = CFrame.new(b.torsoCenter + Vector3.new(side * (b.torsoSize.X / 2), -b.torsoSize.Y / 2 + 0.15, 0)),
			Parent = model,
		})
		weld(b.torso, pouch)
	end
end

local function buildScoutWren(model, def, b)
	-- FACE: curious/happy explorer
	buildFace(model, b, "happy", { skinColor = def.skinColor })

	-- SHORT AUBURN HAIR
	local hairTop = makePart({
		Name = "HairTop",
		Size = Vector3.new(HEAD_RADIUS * 2.0, 0.3, HEAD_RADIUS * 1.9),
		Color = Color3.fromRGB(150, 70, 30),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.7, 0)),
		Parent = model,
	})
	weld(b.head, hairTop)
	-- hair sides
	for _, side in {1, -1} do
		local hs = makePart({
			Name = "HairSide",
			Size = Vector3.new(0.12, 0.5, HEAD_RADIUS * 1.2),
			Color = Color3.fromRGB(150, 70, 30),
			CFrame = CFrame.new(b.headPos + Vector3.new(side * (HEAD_RADIUS * 0.78), 0.2, 0.1)),
			Parent = model,
		})
		weld(b.head, hs)
	end

	-- FEATHER in hair ‚Äî bright colored angled block
	local feather = makePart({
		Name = "Feather",
		Size = Vector3.new(0.08, 0.7, 0.2),
		Color = Color3.fromRGB(30, 180, 220),
		CFrame = CFrame.new(b.headPos + Vector3.new(0.4, HEAD_RADIUS + 0.2, 0.1))
			* CFrame.Angles(0, 0, math.rad(15)),
		Parent = model,
	})
	weld(b.head, feather)

	-- Spyglass in right hand (existing)
	local spyglass = makePart({
		Name = "Spyglass",
		Shape = Enum.PartType.Cylinder,
		Size = Vector3.new(2.0, 0.3, 0.3),
		Color = Color3.fromRGB(170, 130, 60),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(b.torsoSize.X / 2 + b.armSize.X / 2 + 0.3, 0, 0))
			* CFrame.Angles(0, 0, math.rad(90)),
		Parent = model,
	})
	weld(b.rightArm, spyglass)
	local lens = makePart({
		Name = "Lens",
		Shape = Enum.PartType.Cylinder,
		Size = Vector3.new(0.1, 0.45, 0.45),
		Color = Color3.fromRGB(150, 200, 255),
		Transparency = 0.3,
		CFrame = CFrame.new(spyglass.Position + Vector3.new(0, 1.0, 0))
			* CFrame.Angles(0, 0, math.rad(90)),
		Parent = model,
	})
	weld(spyglass, lens)

	-- MAP SCROLL in left hand
	if b.leftArm then
		local scroll = makePart({
			Name = "MapScroll",
			Shape = Enum.PartType.Cylinder,
			Size = Vector3.new(1.0, 0.25, 0.25),
			Color = Color3.fromRGB(220, 200, 150),
			CFrame = CFrame.new(b.torsoCenter + Vector3.new(-(b.torsoSize.X / 2 + b.armSize.X / 2 + 0.2), -b.armSize.Y / 2 + 0.3, 0))
				* CFrame.Angles(0, 0, math.rad(90)),
			Parent = model,
		})
		weld(b.leftArm, scroll)
	end

	-- COMPASS on belt
	local compass = makePart({
		Name = "Compass",
		Shape = Enum.PartType.Cylinder,
		Size = Vector3.new(0.08, 0.3, 0.3),
		Color = Color3.fromRGB(200, 180, 50),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(0.4, -b.torsoSize.Y / 2 + 0.15, -(b.torsoSize.Z / 2 + 0.06)))
			* CFrame.Angles(math.rad(90), 0, 0),
		Parent = model,
	})
	weld(b.torso, compass)

	-- BINOCULARS around neck
	for _, side in {1, -1} do
		local bino = makePart({
			Name = side == 1 and "BinoR" or "BinoL",
			Shape = Enum.PartType.Cylinder,
			Size = Vector3.new(0.5, 0.22, 0.22),
			Color = Color3.fromRGB(50, 50, 50),
			CFrame = CFrame.new(b.torsoCenter + Vector3.new(side * 0.18, b.torsoSize.Y / 2 - 0.4, -(b.torsoSize.Z / 2 + 0.12)))
				* CFrame.Angles(math.rad(90), 0, 0),
			Parent = model,
		})
		weld(b.torso, bino)
	end
	-- binocular strap
	local strap = makePart({
		Name = "BinoStrap",
		Size = Vector3.new(0.08, 1.0, 0.04),
		Color = Color3.fromRGB(60, 40, 20),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(0, b.torsoSize.Y / 2 + 0.1, -(b.torsoSize.Z / 2 + 0.05))),
		Parent = model,
	})
	weld(b.torso, strap)
end

local function buildMorath(model, def, b)
	-- FACE: spooky/creepy
	buildFace(model, b, "spooky", {
		skinColor = def.skinColor,
		eyeWhite = Color3.fromRGB(200, 190, 160),
		pupilColor = Color3.fromRGB(60, 50, 30),
	})

	-- HOLLOW CHEEKS ‚Äî darker transparent blocks on face sides
	for _, side in {1, -1} do
		local cheek = makePart({
			Name = side == 1 and "CheekR" or "CheekL",
			Size = Vector3.new(0.2, 0.35, 0.15),
			Color = Color3.fromRGB(100, 80, 60),
			Transparency = 0.4,
			CFrame = CFrame.new(b.headPos + Vector3.new(side * 0.5, -0.15, -(HEAD_RADIUS * 0.55))),
			Parent = model,
		})
		weld(b.head, cheek)
	end

	-- Lantern in right hand (existing + slight rotation for sway feel)
	local lantern = makePart({
		Name = "Lantern",
		Size = Vector3.new(0.5, 0.7, 0.5),
		Color = Color3.fromRGB(120, 100, 40),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(b.torsoSize.X / 2 + b.armSize.X / 2 + 0.3, -b.armSize.Y / 2, 0))
			* CFrame.Angles(0, 0, math.rad(8)),
		Parent = model,
	})
	weld(b.rightArm, lantern)
	local lanternLight = Instance.new("PointLight")
	lanternLight.Color = Color3.fromRGB(255, 180, 80)
	lanternLight.Brightness = 0.6
	lanternLight.Range = 10
	lanternLight.Parent = lantern
	-- lantern handle
	local lHandle = makePart({
		Name = "LanternHandle",
		Size = Vector3.new(0.05, 0.4, 0.35),
		Color = Color3.fromRGB(80, 70, 30),
		CFrame = CFrame.new(lantern.Position + Vector3.new(0, 0.45, 0)),
		Parent = model,
	})
	weld(lantern, lHandle)

	-- TATTERED CLOAK EDGES ‚Äî irregular blocks hanging off torso bottom
	for i = 1, 5 do
		local tatter = makePart({
			Name = "CloakTatter" .. i,
			Size = Vector3.new(0.4 + math.random() * 0.3, 0.5 + math.random() * 0.4, 0.15),
			Color = Color3.fromRGB(40 + math.random(15), 40 + math.random(15), 40 + math.random(10)),
			CFrame = CFrame.new(b.torsoCenter + Vector3.new((i - 3) * 0.5, -b.torsoSize.Y / 2 - 0.3, 0))
				* CFrame.Angles(0, 0, math.rad((i - 3) * 5)),
			Parent = model,
		})
		weld(b.torso, tatter)
	end

	-- SHOVEL nearby
	local shovelHandle = makePart({
		Name = "ShovelHandle",
		Size = Vector3.new(0.15, 4.5, 0.15),
		Color = Color3.fromRGB(100, 70, 30),
		CFrame = CFrame.new(def.position + Vector3.new(-2, 2.25, 1))
			* CFrame.Angles(0, 0, math.rad(10)),
		Parent = model,
	})
	local shovelBlade = makePart({
		Name = "ShovelBlade",
		Size = Vector3.new(0.8, 0.9, 0.08),
		Color = Color3.fromRGB(100, 100, 100),
		Material = Enum.Material.Metal,
		CFrame = CFrame.new(def.position + Vector3.new(-2, 0.45, 1)),
		Parent = model,
	})
	weld(shovelHandle, shovelBlade)
end

local function buildThessaly(model, def, b)
	-- FACE: evil witch grin
	buildFace(model, b, "evil", {
		skinColor = def.skinColor,
		eyeWhite = Color3.fromRGB(150, 200, 100),
		pupilColor = Color3.fromRGB(20, 60, 10),
		mouthColor = Color3.fromRGB(40, 80, 30),
	})

	-- WARTS on face ‚Äî tiny bumps
	local wartPositions = {
		Vector3.new(0.35, 0.05, -(HEAD_RADIUS * 0.85)),
		Vector3.new(-0.2, -0.15, -(HEAD_RADIUS * 0.82)),
		Vector3.new(0.1, 0.25, -(HEAD_RADIUS * 0.88)),
	}
	for i, wp in wartPositions do
		local wart = makePart({
			Name = "Wart" .. i,
			Shape = Enum.PartType.Ball,
			Size = Vector3.new(0.1, 0.1, 0.1),
			Color = Color3.fromRGB(90, 175, 90),
			CFrame = CFrame.new(b.headPos + wp),
			Parent = model,
		})
		weld(b.head, wart)
	end

	-- Pointed hat (existing)
	local hatBrim = makePart({
		Name = "HatBrim",
		Shape = Enum.PartType.Cylinder,
		Size = Vector3.new(0.2, 2.8, 2.8),
		Color = Color3.fromRGB(60, 20, 80),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS + 0.1, 0))
			* CFrame.Angles(0, 0, math.rad(90)),
		Parent = model,
	})
	weld(b.head, hatBrim)
	local hatMid = makePart({
		Name = "HatMid",
		Shape = Enum.PartType.Cylinder,
		Size = Vector3.new(1.5, 1.6, 1.6),
		Color = Color3.fromRGB(70, 25, 90),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS + 0.95, 0))
			* CFrame.Angles(0, 0, math.rad(90)),
		Parent = model,
	})
	weld(b.head, hatMid)
	local hatTip = makePart({
		Name = "HatTip",
		Shape = Enum.PartType.Cylinder,
		Size = Vector3.new(1.0, 0.6, 0.6),
		Color = Color3.fromRGB(80, 30, 100),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS + 2.0, 0))
			* CFrame.Angles(0, 0, math.rad(90)),
		Parent = model,
	})
	weld(b.head, hatTip)

	-- CROOKED WALKING STICK in left hand
	if b.leftArm then
		local stick = makePart({
			Name = "WalkingStick",
			Size = Vector3.new(0.15, 4.0, 0.15),
			Color = Color3.fromRGB(80, 50, 25),
			CFrame = CFrame.new(b.torsoCenter + Vector3.new(-(b.torsoSize.X / 2 + b.armSize.X / 2 + 0.2), -0.5, 0))
				* CFrame.Angles(0, 0, math.rad(-5)),
			Parent = model,
		})
		weld(b.leftArm, stick)
		-- gnarled top
		local knob = makePart({
			Name = "StickKnob",
			Shape = Enum.PartType.Ball,
			Size = Vector3.new(0.3, 0.3, 0.3),
			Color = Color3.fromRGB(70, 45, 20),
			CFrame = CFrame.new(stick.Position + Vector3.new(0, 2.1, 0)),
			Parent = model,
		})
		weld(stick, knob)
	end

	-- POTION BOTTLES on belt
	local potionColors = {
		Color3.fromRGB(255, 50, 50),
		Color3.fromRGB(50, 50, 255),
		Color3.fromRGB(200, 50, 200),
	}
	for i, pc in potionColors do
		local potion = makePart({
			Name = "Potion" .. i,
			Shape = Enum.PartType.Ball,
			Size = Vector3.new(0.18, 0.18, 0.18),
			Color = pc,
			Material = Enum.Material.Neon,
			CFrame = CFrame.new(b.torsoCenter + Vector3.new((i - 2) * 0.35, -b.torsoSize.Y / 2 + 0.1, -(b.torsoSize.Z / 2 + 0.1))),
			Parent = model,
		})
		weld(b.torso, potion)
	end

	-- Cauldron next to her (existing)
	local cauldron = makePart({
		Name = "Cauldron",
		Shape = Enum.PartType.Cylinder,
		Size = Vector3.new(1.8, 2.2, 2.2),
		Color = Color3.fromRGB(30, 30, 30),
		Material = Enum.Material.Metal,
		CFrame = CFrame.new(def.position + Vector3.new(3, 0.9, 0)) * CFrame.Angles(0, 0, math.rad(90)),
		Parent = model,
	})
	local brew = makePart({
		Name = "Brew",
		Shape = Enum.PartType.Cylinder,
		Size = Vector3.new(0.2, 1.8, 1.8),
		Color = Color3.fromRGB(50, 200, 50),
		Transparency = 0.3,
		CFrame = CFrame.new(def.position + Vector3.new(3, 1.8, 0)) * CFrame.Angles(0, 0, math.rad(90)),
		Parent = model,
	})
	weld(cauldron, brew)
	local brewLight = Instance.new("PointLight")
	brewLight.Color = Color3.fromRGB(50, 200, 50)
	brewLight.Brightness = 0.8
	brewLight.Range = 8
	brewLight.Parent = brew

	-- CAT FAMILIAR nearby!
	local catPos = def.position + Vector3.new(-2, 0, 1.5)
	-- cat body
	local catBody = makePart({
		Name = "CatBody",
		Size = Vector3.new(0.5, 0.4, 1.0),
		Color = Color3.fromRGB(25, 25, 30),
		CFrame = CFrame.new(catPos + Vector3.new(0, 0.5, 0)),
		Parent = model,
	})
	-- cat head
	local catHead = makePart({
		Name = "CatHead",
		Shape = Enum.PartType.Ball,
		Size = Vector3.new(0.4, 0.4, 0.4),
		Color = Color3.fromRGB(25, 25, 30),
		CFrame = CFrame.new(catPos + Vector3.new(0, 0.65, -0.55)),
		Parent = model,
	})
	weld(catBody, catHead)
	-- cat ears
	for _, side in {1, -1} do
		local ear = makePart({
			Name = "CatEar",
			Size = Vector3.new(0.08, 0.15, 0.08),
			Color = Color3.fromRGB(25, 25, 30),
			CFrame = CFrame.new(catHead.Position + Vector3.new(side * 0.12, 0.2, 0)),
			Parent = model,
		})
		weld(catHead, ear)
	end
	-- cat eyes ‚Äî green!
	for _, side in {1, -1} do
		local catEye = makePart({
			Name = "CatEye",
			Shape = Enum.PartType.Ball,
			Size = Vector3.new(0.08, 0.08, 0.08),
			Color = Color3.fromRGB(50, 220, 50),
			Material = Enum.Material.Neon,
			CFrame = CFrame.new(catHead.Position + Vector3.new(side * 0.1, 0.03, -0.18)),
			Parent = model,
		})
		weld(catHead, catEye)
	end
	-- cat tail
	local catTail = makePart({
		Name = "CatTail",
		Size = Vector3.new(0.08, 0.08, 0.7),
		Color = Color3.fromRGB(25, 25, 30),
		CFrame = CFrame.new(catPos + Vector3.new(0, 0.6, 0.7))
			* CFrame.Angles(math.rad(30), 0, 0),
		Parent = model,
	})
	weld(catBody, catTail)
end

local function buildRask(model, def, b)
	-- FACE: evil/menacing
	buildFace(model, b, "evil", {
		skinColor = def.skinColor,
		pupilColor = Color3.fromRGB(40, 20, 10),
	})

	-- EYE PATCH over left eye
	local eyePatch = makePart({
		Name = "EyePatch",
		Size = Vector3.new(0.35, 0.32, 0.12),
		Color = Color3.fromRGB(20, 20, 20),
		CFrame = CFrame.new(b.headPos + Vector3.new(-0.28, 0.08, -(HEAD_RADIUS * 0.85))),
		Parent = model,
	})
	weld(b.head, eyePatch)
	-- eye patch strap
	local patchStrap = makePart({
		Name = "PatchStrap",
		Size = Vector3.new(HEAD_RADIUS * 2.2, 0.08, 0.04),
		Color = Color3.fromRGB(20, 20, 20),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, 0.08, 0)),
		Parent = model,
	})
	weld(b.head, patchStrap)

	-- SCAR across face ‚Äî thin dark red line
	local scar = makePart({
		Name = "Scar",
		Size = Vector3.new(0.06, 0.8, 0.04),
		Color = Color3.fromRGB(140, 30, 30),
		CFrame = CFrame.new(b.headPos + Vector3.new(0.2, 0, -(HEAD_RADIUS * 0.9)))
			* CFrame.Angles(0, 0, math.rad(15)),
		Parent = model,
	})
	weld(b.head, scar)

	-- MOHAWK ‚Äî tall narrow block, red-tipped
	local mohawkBase = makePart({
		Name = "MohawkBase",
		Size = Vector3.new(0.3, 0.8, HEAD_RADIUS * 1.6),
		Color = Color3.fromRGB(30, 30, 30),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.7, 0)),
		Parent = model,
	})
	weld(b.head, mohawkBase)
	local mohawkTip = makePart({
		Name = "MohawkTip",
		Size = Vector3.new(0.25, 0.4, HEAD_RADIUS * 1.2),
		Color = Color3.fromRGB(200, 30, 30),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS + 0.5, 0)),
		Parent = model,
	})
	weld(b.head, mohawkTip)

	-- Bandana on head (existing)
	local bandana = makePart({
		Name = "Bandana",
		Size = Vector3.new(HEAD_RADIUS * 2.3, 0.35, HEAD_RADIUS * 2.3),
		Color = Color3.fromRGB(200, 30, 30),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.4, 0)),
		Parent = model,
	})
	weld(b.head, bandana)

	-- TROPHY NECKLACE ‚Äî small bones/teeth around neck
	for i = 0, 5 do
		local angle = (i / 6) * math.pi * 2
		local boneSize = (i % 2 == 0) and Vector3.new(0.08, 0.2, 0.08) or Vector3.new(0.06, 0.15, 0.06)
		local bone = makePart({
			Name = "Bone" .. i,
			Size = boneSize,
			Color = Color3.fromRGB(220, 210, 190),
			CFrame = CFrame.new(b.torsoCenter + Vector3.new(
				math.cos(angle) * (b.torsoSize.X / 2 + 0.05),
				b.torsoSize.Y / 2 - 0.15,
				math.sin(angle) * (b.torsoSize.Z / 2 + 0.05)
			)),
			Parent = model,
		})
		weld(b.torso, bone)
	end

	-- Right dagger (existing)
	local rDagger = makePart({
		Name = "RightDagger",
		Size = Vector3.new(0.12, 1.6, 0.05),
		Color = Color3.fromRGB(200, 200, 210),
		Material = Enum.Material.Metal,
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(b.torsoSize.X / 2 + b.armSize.X / 2, -b.armSize.Y / 2 - 0.3, 0)),
		Parent = model,
	})
	weld(b.rightArm, rDagger)

	-- Left dagger (existing)
	if b.leftArm then
		local lDagger = makePart({
			Name = "LeftDagger",
			Size = Vector3.new(0.12, 1.6, 0.05),
			Color = Color3.fromRGB(200, 200, 210),
			Material = Enum.Material.Metal,
			CFrame = CFrame.new(b.torsoCenter + Vector3.new(-(b.torsoSize.X / 2 + b.armSize.X / 2), -b.armSize.Y / 2 - 0.3, 0)),
			Parent = model,
		})
		weld(b.leftArm, lDagger)
	end

	-- BELT POUCHES
	local belt = makePart({
		Name = "Belt",
		Size = Vector3.new(b.torsoSize.X + 0.15, 0.25, b.torsoSize.Z + 0.1),
		Color = Color3.fromRGB(60, 40, 15),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(0, -b.torsoSize.Y / 2 + 0.2, 0)),
		Parent = model,
	})
	weld(b.torso, belt)
	for _, side in {1, -1} do
		local pouch = makePart({
			Name = "BeltPouch",
			Size = Vector3.new(0.4, 0.35, 0.3),
			Color = Color3.fromRGB(80, 50, 20),
			CFrame = CFrame.new(b.torsoCenter + Vector3.new(side * (b.torsoSize.X / 2 + 0.05), -b.torsoSize.Y / 2 + 0.15, -0.15)),
			Parent = model,
		})
		weld(b.torso, pouch)
	end
end

local function buildOracle(model, def, b)
	-- FACE: mystical ‚Äî no eyes (blindfolded), serious mouth
	buildFace(model, b, "serious", {
		skinColor = def.skinColor,
		noEyes = true,
		mouthColor = Color3.fromRGB(180, 150, 0),
	})

	-- Blindfold across eyes (existing)
	local blindfold = makePart({
		Name = "Blindfold",
		Size = Vector3.new(HEAD_RADIUS * 2.1, 0.3, HEAD_RADIUS * 0.6),
		Color = Color3.fromRGB(60, 60, 80),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, 0, -(HEAD_RADIUS * 0.7))),
		Parent = model,
	})
	weld(b.head, blindfold)

	-- THIRD EYE GEM on forehead above blindfold
	local thirdEye = makePart({
		Name = "ThirdEye",
		Shape = Enum.PartType.Ball,
		Size = Vector3.new(0.25, 0.25, 0.25),
		Color = Color3.fromRGB(100, 50, 255),
		Material = Enum.Material.Neon,
		CFrame = CFrame.new(b.headPos + Vector3.new(0, 0.25, -(HEAD_RADIUS * 0.88))),
		Parent = model,
	})
	weld(b.head, thirdEye)
	local thirdEyeLight = Instance.new("PointLight")
	thirdEyeLight.Color = Color3.fromRGB(100, 50, 255)
	thirdEyeLight.Brightness = 1.0
	thirdEyeLight.Range = 8
	thirdEyeLight.Parent = thirdEye

	-- FLOWING ROBE LAYERS below torso ‚Äî staggered sizes
	local robeColors = {
		Color3.fromRGB(235, 235, 240),
		Color3.fromRGB(225, 225, 235),
		Color3.fromRGB(215, 215, 230),
		Color3.fromRGB(200, 200, 220),
	}
	for i, rc in robeColors do
		local layer = makePart({
			Name = "RobeLayer" .. i,
			Size = Vector3.new(b.torsoSize.X + 0.2 + i * 0.2, 0.6, b.torsoSize.Z + 0.1 + i * 0.15),
			Color = rc,
			CFrame = CFrame.new(b.torsoCenter + Vector3.new(0, -b.torsoSize.Y / 2 - (i - 1) * 0.5, 0)),
			Parent = model,
		})
		weld(b.torso, layer)
	end

	-- MYSTICAL PARTICLES ‚Äî neon balls floating around at various positions
	local particleColors = {
		Color3.fromRGB(200, 180, 255),
		Color3.fromRGB(255, 220, 100),
		Color3.fromRGB(150, 100, 255),
		Color3.fromRGB(255, 200, 150),
		Color3.fromRGB(180, 255, 200),
		Color3.fromRGB(255, 150, 255),
	}
	for i, pc in particleColors do
		local angle = (i / #particleColors) * math.pi * 2
		local radius = 1.8 + (i % 3) * 0.4
		local yOff = math.sin(i * 1.3) * 1.5
		local particle = makePart({
			Name = "MysticParticle" .. i,
			Shape = Enum.PartType.Ball,
			Size = Vector3.new(0.15, 0.15, 0.15),
			Color = pc,
			Material = Enum.Material.Neon,
			Transparency = 0.3,
			CFrame = CFrame.new(b.torsoCenter + Vector3.new(
				math.cos(angle) * radius,
				yOff,
				math.sin(angle) * radius
			)),
			Parent = model,
		})
		weld(b.torso, particle)
	end

	-- Hide legs behind robe (make them more transparent)
	b.rightLeg.Transparency = 0.8
	b.leftLeg.Transparency = 0.8
end

local function buildGhost(model, def, b)
	-- FACE: spooky hollow eyes
	-- Custom hollow eyes ‚Äî deeper blue, set slightly deeper
	local trans = b.trans
	for _, side in {1, -1} do
		local hollowEye = makePart({
			Name = side == 1 and "HollowEyeR" or "HollowEyeL",
			Shape = Enum.PartType.Ball,
			Size = Vector3.new(0.3, 0.3, 0.2),
			Color = Color3.fromRGB(60, 90, 160),
			CFrame = CFrame.new(b.headPos + Vector3.new(side * 0.28, 0.08, -(HEAD_RADIUS * 0.72))),
			Transparency = trans + 0.1,
			Parent = model,
		})
		weld(b.head, hollowEye)
		-- dim glowing pupil
		local ghostPupil = makePart({
			Name = "GhostPupil",
			Shape = Enum.PartType.Ball,
			Size = Vector3.new(0.12, 0.12, 0.12),
			Color = Color3.fromRGB(180, 200, 255),
			Material = Enum.Material.Neon,
			CFrame = CFrame.new(b.headPos + Vector3.new(side * 0.28, 0.08, -(HEAD_RADIUS * 0.85))),
			Transparency = trans + 0.2,
			Parent = model,
		})
		weld(b.head, ghostPupil)
	end
	-- ghostly serious mouth
	local mouth = makePart({
		Name = "GhostMouth",
		Size = Vector3.new(0.3, 0.06, 0.06),
		Color = Color3.fromRGB(60, 90, 160),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, -0.24, -(HEAD_RADIUS * 0.88))),
		Transparency = trans,
		Parent = model,
	})
	weld(b.head, mouth)

	-- Blue glow from torso (existing)
	local glow = Instance.new("PointLight")
	glow.Color = Color3.fromRGB(100, 150, 255)
	glow.Brightness = 1.5
	glow.Range = 18
	glow.Parent = b.torso

	-- TRANSPARENT SWORD in right hand
	local ghostSword = makePart({
		Name = "GhostSword",
		Size = Vector3.new(0.1, 2.8, 0.35),
		Color = Color3.fromRGB(120, 170, 240),
		Material = Enum.Material.Neon,
		Transparency = 0.5,
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(b.torsoSize.X / 2 + b.armSize.X / 2, -0.5, -0.2)),
		Parent = model,
	})
	weld(b.rightArm, ghostSword)
	local swordHilt = makePart({
		Name = "GhostSwordHilt",
		Size = Vector3.new(0.15, 0.3, 0.6),
		Color = Color3.fromRGB(120, 170, 240),
		Transparency = 0.5,
		CFrame = CFrame.new(ghostSword.Position + Vector3.new(0, 1.5, 0)),
		Parent = model,
	})
	weld(ghostSword, swordHilt)

	-- SHIELD in left hand ‚Äî frame-like blocks, transparent
	if b.leftArm then
		-- shield outer frame
		local shieldPositions = {
			{ Vector3.new(0, 0.5, 0), Vector3.new(1.0, 0.08, 0.08) },
			{ Vector3.new(0, -0.5, 0), Vector3.new(1.0, 0.08, 0.08) },
			{ Vector3.new(-0.5, 0, 0), Vector3.new(0.08, 1.0, 0.08) },
			{ Vector3.new(0.5, 0, 0), Vector3.new(0.08, 1.0, 0.08) },
			-- cross
			{ Vector3.new(0, 0, 0), Vector3.new(0.8, 0.08, 0.08) },
			{ Vector3.new(0, 0, 0), Vector3.new(0.08, 0.8, 0.08) },
		}
		local shieldCenter = b.torsoCenter + Vector3.new(-(b.torsoSize.X / 2 + b.armSize.X + 0.2), 0.2, -0.3)
		for i, sp in shieldPositions do
			local frame = makePart({
				Name = "ShieldFrame" .. i,
				Size = sp[2],
				Color = Color3.fromRGB(120, 170, 240),
				Material = Enum.Material.Neon,
				Transparency = 0.5,
				CFrame = CFrame.new(shieldCenter + sp[1]),
				Parent = model,
			})
			weld(b.leftArm, frame)
		end
	end

	-- CHAINS on wrists
	for _, armPart in { b.rightArm, b.leftArm } do
		if armPart then
			for i = 0, 2 do
				local chain = makePart({
					Name = "Chain" .. i,
					Size = Vector3.new(0.15, 0.1, 0.15),
					Color = Color3.fromRGB(100, 100, 110),
					CFrame = CFrame.new(armPart.Position + Vector3.new(0, -b.armSize.Y / 2 + 0.1 + i * 0.15, 0)),
					Transparency = trans,
					Parent = model,
				})
				weld(armPart, chain)
			end
		end
	end

	-- GHOSTLY TRAIL ‚Äî transparent neon blocks behind
	for i = 1, 4 do
		local trail = makePart({
			Name = "GhostTrail" .. i,
			Shape = Enum.PartType.Ball,
			Size = Vector3.new(0.5 + i * 0.15, 0.5 + i * 0.1, 0.3),
			Color = Color3.fromRGB(100, 150, 220),
			Material = Enum.Material.Neon,
			Transparency = 0.4 + i * 0.1,
			CFrame = CFrame.new(b.torsoCenter + Vector3.new(0, -0.5 * i, b.torsoSize.Z / 2 + i * 0.5)),
			Parent = model,
		})
		weld(b.torso, trail)
	end
end

local function buildCharon(model, def, b)
	-- FACE: dead skull face
	-- dark eye sockets
	for _, side in {1, -1} do
		local socket = makePart({
			Name = side == 1 and "EyeSocketR" or "EyeSocketL",
			Shape = Enum.PartType.Ball,
			Size = Vector3.new(0.3, 0.3, 0.2),
			Color = Color3.fromRGB(10, 10, 10),
			CFrame = CFrame.new(b.headPos + Vector3.new(side * 0.28, 0.08, -(HEAD_RADIUS * 0.78))),
			Parent = model,
		})
		weld(b.head, socket)
		-- faint red glow deep inside
		local innerGlow = makePart({
			Name = "EyeGlow",
			Shape = Enum.PartType.Ball,
			Size = Vector3.new(0.08, 0.08, 0.08),
			Color = Color3.fromRGB(200, 50, 30),
			Material = Enum.Material.Neon,
			CFrame = CFrame.new(b.headPos + Vector3.new(side * 0.28, 0.08, -(HEAD_RADIUS * 0.65))),
			Parent = model,
		})
		weld(b.head, innerGlow)
	end
	-- exposed teeth (dead mouth)
	buildFace(model, b, "dead", {
		skinColor = def.skinColor,
		noEyes = true,
	})

	-- nose cavity
	local noseCavity = makePart({
		Name = "NoseCavity",
		Size = Vector3.new(0.15, 0.15, 0.08),
		Color = Color3.fromRGB(15, 15, 15),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, -0.08, -(HEAD_RADIUS * 0.9))),
		Parent = model,
	})
	weld(b.head, noseCavity)

	-- TATTERED HOOD ‚Äî larger block over head, extending back and down
	local hood = makePart({
		Name = "TatteredHood",
		Size = Vector3.new(HEAD_RADIUS * 2.6, HEAD_RADIUS * 2.0, HEAD_RADIUS * 2.8),
		Color = Color3.fromRGB(15, 15, 15),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.3, HEAD_RADIUS * 0.3)),
		Parent = model,
	})
	weld(b.head, hood)
	-- hood drape down back
	local hoodBack = makePart({
		Name = "HoodBack",
		Size = Vector3.new(HEAD_RADIUS * 2.2, 1.5, 0.15),
		Color = Color3.fromRGB(15, 15, 15),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, -0.5, HEAD_RADIUS + 0.3)),
		Parent = model,
	})
	weld(b.head, hoodBack)

	-- OAR/POLE in right hand
	local oar = makePart({
		Name = "Oar",
		Size = Vector3.new(0.18, 6.0, 0.18),
		Color = Color3.fromRGB(60, 40, 15),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(b.torsoSize.X / 2 + b.armSize.X / 2 + 0.2, 1.5, 0)),
		Parent = model,
	})
	weld(b.rightArm, oar)
	-- oar blade at bottom
	local oarBlade = makePart({
		Name = "OarBlade",
		Size = Vector3.new(0.6, 1.0, 0.08),
		Color = Color3.fromRGB(50, 35, 12),
		CFrame = CFrame.new(oar.Position + Vector3.new(0, -3.5, 0)),
		Parent = model,
	})
	weld(oar, oarBlade)

	-- Boat (existing)
	local boatBase = makePart({
		Name = "Boat",
		Size = Vector3.new(8, 0.5, 3),
		Color = Color3.fromRGB(80, 50, 20),
		CFrame = CFrame.new(def.position + Vector3.new(5, 0.25, 0)),
		Parent = model,
	})
	local boatLeft = makePart({
		Name = "BoatLeft",
		Size = Vector3.new(8, 1.0, 0.3),
		Color = Color3.fromRGB(70, 45, 18),
		CFrame = CFrame.new(def.position + Vector3.new(5, 0.75, 1.5)),
		Parent = model,
	})
	weld(boatBase, boatLeft)
	local boatRight = makePart({
		Name = "BoatRight",
		Size = Vector3.new(8, 1.0, 0.3),
		Color = Color3.fromRGB(70, 45, 18),
		CFrame = CFrame.new(def.position + Vector3.new(5, 0.75, -1.5)),
		Parent = model,
	})
	weld(boatBase, boatRight)

	-- LANTERN on boat bow
	local boatLantern = makePart({
		Name = "BoatLantern",
		Size = Vector3.new(0.4, 0.5, 0.4),
		Color = Color3.fromRGB(80, 60, 20),
		CFrame = CFrame.new(def.position + Vector3.new(8.5, 1.2, 0)),
		Parent = model,
	})
	weld(boatBase, boatLantern)
	local boatLanternGlow = makePart({
		Name = "BoatLanternGlow",
		Shape = Enum.PartType.Ball,
		Size = Vector3.new(0.25, 0.25, 0.25),
		Color = Color3.fromRGB(200, 150, 50),
		Material = Enum.Material.Neon,
		Transparency = 0.3,
		CFrame = CFrame.new(def.position + Vector3.new(8.5, 1.5, 0)),
		Parent = model,
	})
	weld(boatLantern, boatLanternGlow)
	local bll = Instance.new("PointLight")
	bll.Color = Color3.fromRGB(200, 150, 50)
	bll.Brightness = 0.5
	bll.Range = 8
	bll.Parent = boatLanternGlow

	-- Skeletal hands (make hands thinner/darker) ‚Äî small dark blocks at end of arms
	for _, armPart in { b.rightArm, b.leftArm } do
		if armPart then
			local hand = makePart({
				Name = "SkeletalHand",
				Size = Vector3.new(b.armSize.X * 0.8, 0.3, b.armSize.Z * 0.6),
				Color = Color3.fromRGB(160, 160, 140),
				CFrame = CFrame.new(armPart.Position + Vector3.new(0, -b.armSize.Y / 2 - 0.15, 0)),
				Parent = model,
			})
			weld(armPart, hand)
			-- finger bones
			for fi = -1, 1 do
				local finger = makePart({
					Name = "Finger",
					Size = Vector3.new(0.04, 0.25, 0.04),
					Color = Color3.fromRGB(160, 160, 140),
					CFrame = CFrame.new(hand.Position + Vector3.new(fi * 0.1, -0.2, 0)),
					Parent = model,
				})
				weld(hand, finger)
			end
		end
	end
end

local function buildLyra(model, def, b)
	-- FACE: serious/powerful
	buildFace(model, b, "serious", { skinColor = def.skinColor })

	-- LONG FLOWING RED HAIR ‚Äî tall block behind head extending down back
	local hairMain = makePart({
		Name = "HairMain",
		Size = Vector3.new(HEAD_RADIUS * 2.0, 0.3, HEAD_RADIUS * 1.8),
		Color = Color3.fromRGB(180, 40, 20),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.65, 0)),
		Parent = model,
	})
	weld(b.head, hairMain)
	-- flowing hair down back
	local hairBack = makePart({
		Name = "HairBack",
		Size = Vector3.new(HEAD_RADIUS * 1.6, 2.5, 0.2),
		Color = Color3.fromRGB(170, 35, 18),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, -0.8, HEAD_RADIUS * 0.75)),
		Parent = model,
	})
	weld(b.head, hairBack)
	-- side hair strands
	for _, side in {1, -1} do
		local strand = makePart({
			Name = "HairStrand",
			Size = Vector3.new(0.15, 1.5, 0.15),
			Color = Color3.fromRGB(175, 38, 18),
			CFrame = CFrame.new(b.headPos + Vector3.new(side * (HEAD_RADIUS * 0.75), -0.4, 0)),
			Parent = model,
		})
		weld(b.head, strand)
	end

	-- Crown/tiara (existing)
	local crown = makePart({
		Name = "Crown",
		Size = Vector3.new(HEAD_RADIUS * 2.0, 0.5, HEAD_RADIUS * 2.0),
		Color = Color3.fromRGB(230, 200, 50),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS + 0.1, 0)),
		Parent = model,
	})
	weld(b.head, crown)
	for _, angle in {0, 90, 180, 270} do
		local rad = math.rad(angle)
		local gem = makePart({
			Name = "CrownGem",
			Shape = Enum.PartType.Ball,
			Size = Vector3.new(0.25, 0.25, 0.25),
			Color = Color3.fromRGB(220, 30, 30),
			CFrame = CFrame.new(crown.Position + Vector3.new(math.cos(rad) * 0.6, 0.3, math.sin(rad) * 0.6)),
			Parent = model,
		})
		weld(crown, gem)
	end

	-- DRAGON SCALE PAULDRONS ‚Äî angular blocks on shoulders
	for _, side in {1, -1} do
		local pauldron = makePart({
			Name = side == 1 and "PauldronR" or "PauldronL",
			Size = Vector3.new(1.0, 0.5, 1.2),
			Color = Color3.fromRGB(150, 25, 25),
			CFrame = CFrame.new(b.torsoCenter + Vector3.new(side * (b.torsoSize.X / 2 + 0.15), b.torsoSize.Y / 2 - 0.15, 0))
				* CFrame.Angles(0, 0, math.rad(side * -15)),
			Parent = model,
		})
		weld(b.torso, pauldron)
		-- scale ridges
		for j = 1, 3 do
			local ridge = makePart({
				Name = "ScaleRidge" .. j,
				Size = Vector3.new(0.7, 0.08, 0.15),
				Color = Color3.fromRGB(120, 20, 20),
				CFrame = CFrame.new(pauldron.Position + Vector3.new(side * 0.05, 0.15 - j * 0.12, -0.3 + j * 0.15)),
				Parent = model,
			})
			weld(pauldron, ridge)
		end
	end

	-- Gold trim on torso (existing)
	local trimFront = makePart({
		Name = "RobeTrim",
		Size = Vector3.new(0.2, b.torsoSize.Y, b.torsoSize.Z + 0.05),
		Color = Color3.fromRGB(230, 200, 50),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(0, 0, -(b.torsoSize.Z / 2 + 0.05))),
		Parent = model,
	})
	weld(b.torso, trimFront)

	-- DRAGON TOOTH NECKLACE ‚Äî small white angular blocks around neck
	for i = 0, 5 do
		local angle = (i / 6) * math.pi - math.pi / 2
		local tooth = makePart({
			Name = "DragonTooth" .. i,
			Size = Vector3.new(0.1, 0.25, 0.08),
			Color = Color3.fromRGB(240, 235, 220),
			CFrame = CFrame.new(b.torsoCenter + Vector3.new(
				math.cos(angle) * (b.torsoSize.X / 2 - 0.1),
				b.torsoSize.Y / 2 - 0.1,
				math.sin(angle) * (b.torsoSize.Z / 2 + 0.08)
			)) * CFrame.Angles(0, 0, math.rad((i - 2.5) * 10)),
			Parent = model,
		})
		weld(b.torso, tooth)
	end

	-- RITUAL DAGGER on belt
	local dagger = makePart({
		Name = "RitualDagger",
		Size = Vector3.new(0.06, 0.8, 0.2),
		Color = Color3.fromRGB(180, 180, 190),
		Material = Enum.Material.Metal,
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(b.torsoSize.X / 2 + 0.15, -b.torsoSize.Y / 2 - 0.1, 0)),
		Parent = model,
	})
	weld(b.torso, dagger)

	-- GLOWING TATTOO MARKS ‚Äî thin neon red lines on arms
	for _, armPart in { b.rightArm, b.leftArm } do
		if armPart then
			for i = 1, 3 do
				local tattoo = makePart({
					Name = "Tattoo" .. i,
					Size = Vector3.new(b.armSize.X + 0.05, 0.06, b.armSize.Z + 0.05),
					Color = Color3.fromRGB(255, 50, 20),
					Material = Enum.Material.Neon,
					CFrame = CFrame.new(armPart.Position + Vector3.new(0, 0.5 - i * 0.5, 0)),
					Parent = model,
				})
				weld(armPart, tattoo)
			end
		end
	end

	-- FLOWING RED ROBE enhancement ‚Äî extra fabric layers below torso
	for i = 1, 3 do
		local fabric = makePart({
			Name = "RobeFabric" .. i,
			Size = Vector3.new(b.torsoSize.X + i * 0.15, 0.5, b.torsoSize.Z + i * 0.1),
			Color = Color3.fromRGB(180 - i * 15, 30, 30),
			CFrame = CFrame.new(b.torsoCenter + Vector3.new(0, -b.torsoSize.Y / 2 - (i - 1) * 0.4, 0)),
			Parent = model,
		})
		weld(b.torso, fabric)
	end

	-- Fire particles (existing)
	local fire = Instance.new("Fire")
	fire.Size = 3
	fire.Heat = 5
	fire.Color = Color3.fromRGB(255, 100, 0)
	fire.SecondaryColor = Color3.fromRGB(255, 200, 50)
	fire.Parent = b.torso
end

--------------------------------------------------------------------------------
-- BILLBOARD GUI
--------------------------------------------------------------------------------
local function addNameTag(model, def, headPos, torsoSize)
	local bbg = Instance.new("BillboardGui")
	bbg.Name = "OverheadGui"
	bbg.Size = UDim2.new(8, 0, 2.2, 0)
	bbg.StudsOffset = Vector3.new(0, HEAD_RADIUS * 2 + torsoSize.Y / 2 + 2.5, 0)
	bbg.AlwaysOnTop = true
	bbg.Adornee = model.PrimaryPart
	bbg.MaxDistance = 60
	bbg.Parent = model

	local nameLabel = Instance.new("TextLabel")
	nameLabel.Name = "NameLabel"
	nameLabel.Size = UDim2.new(1, 0, 0.55, 0)
	nameLabel.Position = UDim2.new(0, 0, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = def.name
	nameLabel.TextColor3 = Color3.fromRGB(240, 192, 64)
	nameLabel.TextScaled = true
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	nameLabel.TextStrokeTransparency = 0.3
	nameLabel.Parent = bbg

	local roleLabel = Instance.new("TextLabel")
	roleLabel.Name = "RoleLabel"
	roleLabel.Size = UDim2.new(1, 0, 0.35, 0)
	roleLabel.Position = UDim2.new(0, 0, 0.6, 0)
	roleLabel.BackgroundTransparency = 1
	roleLabel.Text = def.role
	roleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	roleLabel.TextScaled = true
	roleLabel.Font = Enum.Font.Gotham
	roleLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	roleLabel.TextStrokeTransparency = 0.4
	roleLabel.Parent = bbg
end

--------------------------------------------------------------------------------
-- MASTER BUILD FUNCTION
--------------------------------------------------------------------------------
local function buildCaptainBlackbeard(model, def, b)
	-- FACE: serious pirate
	buildFace(model, b, "serious", { skinColor = def.skinColor })

	-- BLACK BEARD - multiple parts for thick beard
	local beardMain = makePart({
		Name = "BeardMain",
		Size = Vector3.new(HEAD_RADIUS * 1.6, HEAD_RADIUS * 1.2, HEAD_RADIUS * 0.8),
		Color = Color3.fromRGB(20, 20, 20),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, -HEAD_RADIUS * 0.3, HEAD_RADIUS * 0.4)),
		Parent = model,
	})
	weld(b.head, beardMain)
	
	-- Beard strands for bushiness
	for i = 1, 6 do
		local angle = (i / 6) * math.pi * 2
		local strand = makePart({
			Name = "BeardStrand" .. i,
			Size = Vector3.new(0.3, HEAD_RADIUS * 0.8, 0.2),
			Color = Color3.fromRGB(15, 15, 15),
			CFrame = CFrame.new(b.headPos + Vector3.new(
				math.cos(angle) * HEAD_RADIUS * 0.6, 
				-HEAD_RADIUS * 0.5, 
				HEAD_RADIUS * 0.3 + math.sin(angle) * HEAD_RADIUS * 0.3
			)),
			Parent = model,
		})
		weld(b.head, strand)
	end

	-- TRICORN PIRATE HAT
	local hat = makePart({
		Name = "TricornHat",
		Size = Vector3.new(HEAD_RADIUS * 2.2, HEAD_RADIUS * 0.6, HEAD_RADIUS * 2.2),
		Color = Color3.fromRGB(20, 20, 20),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.8, 0)),
		Parent = model,
	})
	weld(b.head, hat)
	
	-- Hat brim (triangular points)
	for i = 1, 3 do
		local angle = (i / 3) * math.pi * 2
		local brim = makePart({
			Name = "HatBrim" .. i,
			Size = Vector3.new(HEAD_RADIUS * 0.8, HEAD_RADIUS * 0.3, HEAD_RADIUS * 0.8),
			Color = Color3.fromRGB(15, 15, 15),
			CFrame = CFrame.new(b.headPos + Vector3.new(
				math.cos(angle) * HEAD_RADIUS * 0.9,
				HEAD_RADIUS * 0.5,
				math.sin(angle) * HEAD_RADIUS * 0.9
			)),
			Parent = model,
		})
		weld(hat, brim)
	end
	
	-- Skull and crossbones on hat
	local skull = makePart({
		Name = "HatSkull",
		Shape = Enum.PartType.Ball,
		Size = Vector3.new(HEAD_RADIUS * 0.6, HEAD_RADIUS * 0.6, HEAD_RADIUS * 0.4),
		Color = Color3.fromRGB(240, 240, 240),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.9, HEAD_RADIUS * 0.9)),
		Parent = model,
	})
	weld(hat, skull)

	-- EYEPATCH (black part over one eye)
	local eyepatch = makePart({
		Name = "Eyepatch",
		Shape = Enum.PartType.Ball,
		Size = Vector3.new(HEAD_RADIUS * 0.5, HEAD_RADIUS * 0.3, HEAD_RADIUS * 0.2),
		Color = Color3.fromRGB(10, 10, 10),
		CFrame = CFrame.new(b.headPos + Vector3.new(HEAD_RADIUS * 0.3, HEAD_RADIUS * 0.1, HEAD_RADIUS * 0.7)),
		Parent = model,
	})
	weld(b.head, eyepatch)
	
	-- Eyepatch strap
	local strap = makePart({
		Name = "EyepatchStrap",
		Size = Vector3.new(0.1, 0.2, HEAD_RADIUS * 2.2),
		Color = Color3.fromRGB(50, 30, 20),
		CFrame = CFrame.new(b.headPos),
		Parent = model,
	})
	weld(b.head, strap)

	-- RED PIRATE COAT with gold trim
	local coat = makePart({
		Name = "PirateCoat",
		Size = Vector3.new(b.torsoSize.X + 0.6, b.torsoSize.Y + 0.4, b.torsoSize.Z + 0.3),
		Color = Color3.fromRGB(139, 0, 0),
		CFrame = CFrame.new(b.torsoCenter),
		Parent = model,
	})
	weld(b.torso, coat)
	
	-- Gold trim on coat
	local trimFront = makePart({
		Name = "CoatTrimFront",
		Size = Vector3.new(0.3, b.torsoSize.Y, 0.1),
		Color = Color3.fromRGB(255, 215, 0),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(0, 0, b.torsoSize.Z/2 + 0.2)),
		Parent = model,
	})
	weld(coat, trimFront)
	
	-- Coat buttons
	for i = 1, 5 do
		local button = makePart({
			Name = "CoatButton" .. i,
			Shape = Enum.PartType.Ball,
			Size = Vector3.new(0.2, 0.2, 0.1),
			Color = Color3.fromRGB(255, 215, 0),
			CFrame = CFrame.new(b.torsoCenter + Vector3.new(0, b.torsoSize.Y/2 - i * 0.6, b.torsoSize.Z/2 + 0.25)),
			Parent = model,
		})
		weld(coat, button)
	end

	-- CUTLASS in right hand
	local cutlass = makePart({
		Name = "PirateCutlass",
		Size = Vector3.new(0.2, 0.2, 3),
		Color = Color3.fromRGB(192, 192, 192),
		Material = Enum.Material.Metal,
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(b.torsoSize.X/2 + ARM_SIZE.X/2 + 0.4, -0.5, 0)),
		Parent = model,
	})
	weld(b.rightArm, cutlass)
	
	-- Cutlass handle
	local handle = makePart({
		Name = "CutlassHandle",
		Size = Vector3.new(0.3, 0.3, 0.8),
		Color = Color3.fromRGB(139, 69, 19),
		Material = Enum.Material.Wood,
		CFrame = CFrame.new(cutlass.Position + Vector3.new(0, 0, -1.5)),
		Parent = model,
	})
	weld(cutlass, handle)
	
	-- Cutlass guard
	local guard = makePart({
		Name = "CutlassGuard",
		Size = Vector3.new(0.8, 0.1, 0.3),
		Color = Color3.fromRGB(255, 215, 0),
		Material = Enum.Material.Metal,
		CFrame = CFrame.new(cutlass.Position + Vector3.new(0, 0, -1.1)),
		Parent = model,
	})
	weld(cutlass, guard)

	-- PISTOL in left hand
	local pistol = makePart({
		Name = "FlintlockPistol",
		Size = Vector3.new(0.3, 0.3, 1.5),
		Color = Color3.fromRGB(64, 64, 64),
		Material = Enum.Material.Metal,
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(-b.torsoSize.X/2 - ARM_SIZE.X/2 - 0.4, -0.3, 0)),
		Parent = model,
	})
	weld(b.leftArm, pistol)
end

local function buildFrostSageElara(model, def, b)
	-- FACE: mystical/serious
	buildFace(model, b, "mystical", { 
		skinColor = def.skinColor,
		pupilColor = Color3.fromRGB(100, 200, 255)
	})

	-- SILVER/WHITE HAIR
	local hair = makePart({
		Name = "SilverHair",
		Size = Vector3.new(HEAD_RADIUS * 2.4, HEAD_RADIUS * 1.2, HEAD_RADIUS * 2.4),
		Color = Color3.fromRGB(220, 220, 235),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.4, 0)),
		Parent = model,
	})
	weld(b.head, hair)
	
	-- Long flowing hair down back
	local hairBack = makePart({
		Name = "HairBack",
		Size = Vector3.new(HEAD_RADIUS * 1.8, b.torsoSize.Y * 1.2, 0.3),
		Color = Color3.fromRGB(210, 210, 225),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, -b.torsoSize.Y * 0.3, HEAD_RADIUS * 0.8)),
		Parent = model,
	})
	weld(b.head, hairBack)

	-- ICE CROWN/CIRCLET
	local circlet = makePart({
		Name = "IceCirclet",
		Size = Vector3.new(HEAD_RADIUS * 2.2, 0.3, HEAD_RADIUS * 2.2),
		Color = Color3.fromRGB(173, 216, 230),
		Material = Enum.Material.Ice,
		Transparency = 0.2,
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.7, 0)),
		Parent = model,
	})
	weld(b.head, circlet)
	
	-- Ice crystals on circlet
	for i = 1, 6 do
		local angle = (i / 6) * math.pi * 2
		local crystal = makePart({
			Name = "CircletCrystal" .. i,
			Size = Vector3.new(0.2, 0.8, 0.2),
			Color = Color3.fromRGB(150, 200, 255),
			Material = Enum.Material.Neon,
			Transparency = 0.3,
			CFrame = CFrame.new(b.headPos + Vector3.new(
				math.cos(angle) * HEAD_RADIUS * 0.8,
				HEAD_RADIUS * 1.1,
				math.sin(angle) * HEAD_RADIUS * 0.8
			)),
			Parent = model,
		})
		weld(circlet, crystal)
	end

	-- WHITE/BLUE FROST ROBES with silver trim
	local robe = makePart({
		Name = "FrostRobe",
		Size = Vector3.new(b.torsoSize.X + 0.8, b.torsoSize.Y + 0.6, b.torsoSize.Z + 0.4),
		Color = Color3.fromRGB(230, 230, 255),
		CFrame = CFrame.new(b.torsoCenter),
		Parent = model,
	})
	weld(b.torso, robe)
	
	-- Robe trim (silver)
	local robeTrim = makePart({
		Name = "RobeTrim",
		Size = Vector3.new(0.2, b.torsoSize.Y + 0.6, b.torsoSize.Z + 0.45),
		Color = Color3.fromRGB(192, 192, 192),
		CFrame = CFrame.new(b.torsoCenter),
		Parent = model,
	})
	weld(robe, robeTrim)
	
	-- Frost patterns on robe
	for i = 1, 8 do
		local pattern = makePart({
			Name = "FrostPattern" .. i,
			Shape = Enum.PartType.Ball,
			Size = Vector3.new(0.3, 0.3, 0.1),
			Color = Color3.fromRGB(200, 230, 255),
			Material = Enum.Material.Neon,
			Transparency = 0.4,
			CFrame = CFrame.new(b.torsoCenter + Vector3.new(
				math.random(-1, 1) * 0.8,
				math.random(-1, 1) * 1.2,
				b.torsoSize.Z/2 + 0.25
			)),
			Parent = model,
		})
		weld(robe, pattern)
	end

	-- ICE STAFF (blue neon rod)
	local staff = makePart({
		Name = "IceStaff",
		Size = Vector3.new(0.2, 0.2, 5),
		Color = Color3.fromRGB(100, 150, 200),
		Material = Enum.Material.Ice,
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(b.torsoSize.X/2 + ARM_SIZE.X/2 + 0.3, 1, 0)),
		Parent = model,
	})
	weld(b.rightArm, staff)
	
	-- Staff crystal orb
	local orb = makePart({
		Name = "StaffOrb",
		Shape = Enum.PartType.Ball,
		Size = Vector3.new(1, 1, 1),
		Color = Color3.fromRGB(150, 200, 255),
		Material = Enum.Material.Neon,
		Transparency = 0.2,
		CFrame = CFrame.new(staff.Position + Vector3.new(0, 0, 2.8)),
		Parent = model,
	})
	weld(staff, orb)
	
	-- Ice shards orbiting the orb
	for i = 1, 4 do
		local angle = (i / 4) * math.pi * 2
		local shard = makePart({
			Name = "OrbShard" .. i,
			Size = Vector3.new(0.2, 0.6, 0.2),
			Color = Color3.fromRGB(100, 200, 255),
			Material = Enum.Material.Neon,
			Transparency = 0.3,
			CFrame = CFrame.new(orb.Position + Vector3.new(
				math.cos(angle) * 1.2,
				math.sin(angle) * 0.6,
				0
			)),
			Parent = model,
		})
		weld(orb, shard)
	end

	-- FROST AURA around feet
	local aura = makePart({
		Name = "FrostAura",
		Shape = Enum.PartType.Ball,
		Size = Vector3.new(4, 1, 4),
		Color = Color3.fromRGB(200, 230, 255),
		Material = Enum.Material.ForceField,
		Transparency = 0.7,
		CanCollide = false,
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(0, -3, 0)),
		Parent = model,
	})
	weld(b.torso, aura)
	
	-- Frost sparkles
	for i = 1, 12 do
		local sparkle = makePart({
			Name = "FrostSparkle" .. i,
			Shape = Enum.PartType.Ball,
			Size = Vector3.new(0.1, 0.1, 0.1),
			Color = Color3.fromRGB(220, 240, 255),
			Material = Enum.Material.Neon,
			Transparency = 0.3,
			CanCollide = false,
			CFrame = CFrame.new(aura.Position + Vector3.new(
				math.cos(i * 0.5) * 2,
				math.random(-1, 1) * 0.5,
				math.sin(i * 0.5) * 2
			)),
			Parent = model,
		})
		weld(aura, sparkle)
	end
end

local function buildPriestessSolara(model, def, b)
	-- FACE: happy/gentle
	buildFace(model, b, "happy", { skinColor = def.skinColor })

	-- GOLDEN/BLONDE HAIR in elaborate style
	local hair = makePart({
		Name = "GoldenHair",
		Size = Vector3.new(HEAD_RADIUS * 2.2, HEAD_RADIUS * 1.4, HEAD_RADIUS * 2.2),
		Color = Color3.fromRGB(255, 215, 0),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.5, 0)),
		Parent = model,
	})
	weld(b.head, hair)
	
	-- Hair braids
	for i = 1, 2 do
		local side = i == 1 and -1 or 1
		local braid = makePart({
			Name = "HairBraid" .. i,
			Size = Vector3.new(0.4, b.torsoSize.Y, 0.4),
			Color = Color3.fromRGB(240, 200, 0),
			CFrame = CFrame.new(b.headPos + Vector3.new(side * HEAD_RADIUS * 0.8, -b.torsoSize.Y * 0.3, 0)),
			Parent = model,
		})
		weld(b.head, braid)
	end

	-- FLOWER CROWN
	local crownBase = makePart({
		Name = "FlowerCrownBase",
		Size = Vector3.new(HEAD_RADIUS * 2.4, 0.3, HEAD_RADIUS * 2.4),
		Color = Color3.fromRGB(34, 139, 34),
		Material = Enum.Material.Grass,
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.8, 0)),
		Parent = model,
	})
	weld(b.head, crownBase)
	
	-- Flowers on crown (various colors)
	local flowerColors = {
		Color3.fromRGB(255, 192, 203), -- pink
		Color3.fromRGB(255, 255, 0),   -- yellow
		Color3.fromRGB(255, 165, 0),   -- orange  
		Color3.fromRGB(138, 43, 226),  -- purple
		Color3.fromRGB(255, 255, 255)  -- white
	}
	for i = 1, 10 do
		local angle = (i / 10) * math.pi * 2
		local flower = makePart({
			Name = "CrownFlower" .. i,
			Shape = Enum.PartType.Ball,
			Size = Vector3.new(0.4, 0.4, 0.2),
			Color = flowerColors[math.random(1, #flowerColors)],
			CFrame = CFrame.new(b.headPos + Vector3.new(
				math.cos(angle) * HEAD_RADIUS * 0.9,
				HEAD_RADIUS * 0.9,
				math.sin(angle) * HEAD_RADIUS * 0.9
			)),
			Parent = model,
		})
		weld(crownBase, flower)
	end

	-- WHITE/GOLD ROBES
	local robe = makePart({
		Name = "HealerRobe",
		Size = Vector3.new(b.torsoSize.X + 1, b.torsoSize.Y + 0.8, b.torsoSize.Z + 0.5),
		Color = Color3.fromRGB(255, 255, 255),
		CFrame = CFrame.new(b.torsoCenter),
		Parent = model,
	})
	weld(b.torso, robe)
	
	-- Gold trim and holy symbols
	local holySymbol = makePart({
		Name = "HolySymbol",
		Size = Vector3.new(0.8, 0.8, 0.1),
		Color = Color3.fromRGB(255, 215, 0),
		Material = Enum.Material.Neon,
		Transparency = 0.2,
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(0, b.torsoSize.Y * 0.2, b.torsoSize.Z/2 + 0.3)),
		Parent = model,
	})
	weld(robe, holySymbol)
	
	-- Cross pattern on symbol
	local crossV = makePart({
		Name = "CrossVertical",
		Size = Vector3.new(0.2, 0.8, 0.05),
		Color = Color3.fromRGB(255, 255, 255),
		CFrame = CFrame.new(holySymbol.Position + Vector3.new(0, 0, 0.08)),
		Parent = model,
	})
	weld(holySymbol, crossV)
	
	local crossH = makePart({
		Name = "CrossHorizontal", 
		Size = Vector3.new(0.6, 0.2, 0.05),
		Color = Color3.fromRGB(255, 255, 255),
		CFrame = CFrame.new(holySymbol.Position + Vector3.new(0, 0, 0.08)),
		Parent = model,
	})
	weld(holySymbol, crossH)

	-- GLOWING HANDS (neon white)
	local leftGlow = makePart({
		Name = "LeftHandGlow",
		Shape = Enum.PartType.Ball,
		Size = Vector3.new(0.8, 0.8, 0.8),
		Color = Color3.fromRGB(255, 255, 255),
		Material = Enum.Material.Neon,
		Transparency = 0.3,
		CanCollide = false,
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(-b.torsoSize.X/2 - ARM_SIZE.X/2 - 0.2, -1.2, 0)),
		Parent = model,
	})
	weld(b.leftArm, leftGlow)
	
	local rightGlow = makePart({
		Name = "RightHandGlow",
		Shape = Enum.PartType.Ball,
		Size = Vector3.new(0.8, 0.8, 0.8),
		Color = Color3.fromRGB(255, 255, 255),
		Material = Enum.Material.Neon,
		Transparency = 0.3,
		CanCollide = false,
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(b.torsoSize.X/2 + ARM_SIZE.X/2 + 0.2, -1.2, 0)),
		Parent = model,
	})
	weld(b.rightArm, rightGlow)
	
	-- Healing particles around hands
	for hand, glow in pairs({leftGlow, rightGlow}) do
		for i = 1, 6 do
			local particle = makePart({
				Name = "HealParticle" .. i,
				Shape = Enum.PartType.Ball,
				Size = Vector3.new(0.15, 0.15, 0.15),
				Color = Color3.fromRGB(255, 255, 0),
				Material = Enum.Material.Neon,
				Transparency = 0.4,
				CanCollide = false,
				CFrame = CFrame.new(glow.Position + Vector3.new(
					math.cos(i) * 1.2,
					math.sin(i) * 1.2,
					math.cos(i * 0.7) * 0.6
				)),
				Parent = model,
			})
			weld(glow, particle)
		end
	end

	-- PRAYER BOOK in one hand
	local book = makePart({
		Name = "PrayerBook",
		Size = Vector3.new(0.8, 0.2, 1.2),
		Color = Color3.fromRGB(139, 69, 19),
		Material = Enum.Material.Wood,
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(-b.torsoSize.X/2 - ARM_SIZE.X/2 - 0.3, 0.2, 0)),
		Parent = model,
	})
	weld(b.leftArm, book)
	
	-- Book pages
	local pages = makePart({
		Name = "BookPages",
		Size = Vector3.new(0.75, 0.25, 1.15),
		Color = Color3.fromRGB(255, 248, 220),
		CFrame = CFrame.new(book.Position + Vector3.new(0, 0.05, 0)),
		Parent = model,
	})
	weld(book, pages)
end

local function buildArchaeologistRex(model, def, b)
	-- FACE: serious/determined
	buildFace(model, b, "serious", { skinColor = def.skinColor })

	-- BROWN HAIR under fedora
	local hair = makePart({
		Name = "BrownHair",
		Size = Vector3.new(HEAD_RADIUS * 2, HEAD_RADIUS * 0.8, HEAD_RADIUS * 2),
		Color = Color3.fromRGB(101, 67, 33),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.2, 0)),
		Parent = model,
	})
	weld(b.head, hair)

	-- FEDORA HAT
	local fedoraBase = makePart({
		Name = "FedoraBase",
		Size = Vector3.new(HEAD_RADIUS * 1.8, HEAD_RADIUS * 1.2, HEAD_RADIUS * 1.8),
		Color = Color3.fromRGB(101, 67, 33),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.8, 0)),
		Parent = model,
	})
	weld(b.head, fedoraBase)
	
	-- Fedora brim
	local fedoraBrim = makePart({
		Name = "FedoraBrim",
		Size = Vector3.new(HEAD_RADIUS * 2.6, HEAD_RADIUS * 0.2, HEAD_RADIUS * 2.6),
		Color = Color3.fromRGB(90, 60, 30),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.4, 0)),
		Parent = model,
	})
	weld(fedoraBase, fedoraBrim)
	
	-- Hat band
	local hatBand = makePart({
		Name = "HatBand",
		Size = Vector3.new(HEAD_RADIUS * 1.9, HEAD_RADIUS * 0.3, HEAD_RADIUS * 1.9),
		Color = Color3.fromRGB(64, 64, 64),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.6, 0)),
		Parent = model,
	})
	weld(fedoraBase, hatBand)

	-- GLASSES
	local glassesFrame = makePart({
		Name = "GlassesFrame",
		Size = Vector3.new(HEAD_RADIUS * 1.4, HEAD_RADIUS * 0.6, 0.1),
		Color = Color3.fromRGB(64, 64, 64),
		CFrame = CFrame.new(b.headPos + Vector3.new(0, HEAD_RADIUS * 0.1, HEAD_RADIUS * 0.8)),
		Parent = model,
	})
	weld(b.head, glassesFrame)
	
	-- Glass lenses
	for i = 1, 2 do
		local side = i == 1 and -1 or 1
		local lens = makePart({
			Name = "GlassLens" .. i,
			Shape = Enum.PartType.Ball,
			Size = Vector3.new(HEAD_RADIUS * 0.5, HEAD_RADIUS * 0.5, 0.1),
			Color = Color3.fromRGB(200, 200, 255),
			Material = Enum.Material.Glass,
			Transparency = 0.8,
			CFrame = CFrame.new(b.headPos + Vector3.new(side * HEAD_RADIUS * 0.3, HEAD_RADIUS * 0.1, HEAD_RADIUS * 0.85)),
			Parent = model,
		})
		weld(glassesFrame, lens)
	end

	-- BROWN ADVENTURER OUTFIT (vest/jacket)
	local adventureVest = makePart({
		Name = "AdventurerVest", 
		Size = Vector3.new(b.torsoSize.X + 0.4, b.torsoSize.Y + 0.2, b.torsoSize.Z + 0.2),
		Color = Color3.fromRGB(139, 90, 43),
		Material = Enum.Material.Fabric,
		CFrame = CFrame.new(b.torsoCenter),
		Parent = model,
	})
	weld(b.torso, adventureVest)
	
	-- Vest pockets
	for i = 1, 4 do
		local pocketX = (i <= 2) and -0.6 or 0.6
		local pocketY = (i == 1 or i == 3) and 0.5 or -0.5
		local pocket = makePart({
			Name = "VestPocket" .. i,
			Size = Vector3.new(0.6, 0.5, 0.1),
			Color = Color3.fromRGB(120, 80, 40),
			CFrame = CFrame.new(b.torsoCenter + Vector3.new(pocketX, pocketY, b.torsoSize.Z/2 + 0.15)),
			Parent = model,
		})
		weld(adventureVest, pocket)
	end
	
	-- Utility belt
	local belt = makePart({
		Name = "UtilityBelt",
		Size = Vector3.new(b.torsoSize.X + 0.5, 0.4, b.torsoSize.Z + 0.3),
		Color = Color3.fromRGB(64, 64, 64),
		Material = Enum.Material.Leather,
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(0, -b.torsoSize.Y * 0.3, 0)),
		Parent = model,
	})
	weld(b.torso, belt)
	
	-- Belt pouches
	for i = 1, 3 do
		local pouchX = (i - 2) * 0.8
		local pouch = makePart({
			Name = "BeltPouch" .. i,
			Size = Vector3.new(0.5, 0.6, 0.4),
			Color = Color3.fromRGB(101, 67, 33),
			CFrame = CFrame.new(b.torsoCenter + Vector3.new(pouchX, -b.torsoSize.Y * 0.3, b.torsoSize.Z/2 + 0.2)),
			Parent = model,
		})
		weld(belt, pouch)
	end

	-- WHIP in right hand (thin brown part)
	local whipHandle = makePart({
		Name = "WhipHandle",
		Size = Vector3.new(0.2, 0.2, 1),
		Color = Color3.fromRGB(139, 69, 19),
		Material = Enum.Material.Wood,
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(b.torsoSize.X/2 + ARM_SIZE.X/2 + 0.3, -0.8, 0)),
		Parent = model,
	})
	weld(b.rightArm, whipHandle)
	
	-- Whip cord
	for i = 1, 8 do
		local segment = makePart({
			Name = "WhipSegment" .. i,
			Size = Vector3.new(0.1, 0.1, 0.6),
			Color = Color3.fromRGB(101, 67, 33),
			Material = Enum.Material.Fabric,
			CFrame = CFrame.new(whipHandle.Position + Vector3.new(
				math.sin(i * 0.3) * 0.5,
				-i * 0.3,
				i * 0.4
			)),
			Parent = model,
		})
		weld(whipHandle, segment)
	end

	-- TORCH in left hand
	local torchHandle = makePart({
		Name = "TorchHandle",
		Size = Vector3.new(0.3, 0.3, 2),
		Color = Color3.fromRGB(139, 69, 19),
		Material = Enum.Material.Wood,
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(-b.torsoSize.X/2 - ARM_SIZE.X/2 - 0.3, 0.5, 0)),
		Parent = model,
	})
	weld(b.leftArm, torchHandle)
	
	-- Torch flame
	local torchFlame = makePart({
		Name = "TorchFlame",
		Shape = Enum.PartType.Ball,
		Size = Vector3.new(0.6, 1, 0.6),
		Color = Color3.fromRGB(255, 140, 0),
		Material = Enum.Material.Neon,
		Transparency = 0.3,
		CanCollide = false,
		CFrame = CFrame.new(torchHandle.Position + Vector3.new(0, 0, 1.5)),
		Parent = model,
	})
	weld(torchHandle, torchFlame)
	
	-- Torch light
	local torchLight = Instance.new("PointLight")
	torchLight.Color = Color3.fromRGB(255, 140, 0)
	torchLight.Brightness = 2
	torchLight.Range = 8
	torchLight.Parent = torchFlame

	-- SATCHEL across shoulder
	local satchel = makePart({
		Name = "Satchel",
		Size = Vector3.new(1.2, 1.5, 0.8),
		Color = Color3.fromRGB(101, 67, 33),
		Material = Enum.Material.Leather,
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(-0.8, 0, -0.8)),
		Parent = model,
	})
	weld(b.torso, satchel)
	
	-- Satchel strap
	local strap = makePart({
		Name = "SatchelStrap",
		Size = Vector3.new(0.2, b.torsoSize.Y + 1, 0.1),
		Color = Color3.fromRGB(80, 50, 25),
		CFrame = CFrame.new(b.torsoCenter + Vector3.new(0.3, 0, 0)),
		Parent = model,
	})
	weld(b.torso, strap)
end

local accessoryBuilders = {
	["Captain Aldric"] = buildCaptainAldric,
	["Mara the Merchant"] = buildMara,
	["Grimnir the Smith"] = buildGrimnir,
	["Old Bess"] = buildOldBess,
	["Brother Elden"] = buildBrotherElden,
	["Finnick the Fletcher"] = buildFinnick,
	["Scout Wren"] = buildScoutWren,
	["Grave Keeper Morath"] = buildMorath,
	["Witch Thessaly"] = buildThessaly,
	["Bandit King Rask"] = buildRask,
	["The Oracle"] = buildOracle,
	["Ghost of Sir Aldren"] = buildGhost,
	["Ferryman Charon"] = buildCharon,
	["Dragon Priestess Lyra"] = buildLyra,
	["Captain Blackbeard"] = buildCaptainBlackbeard,
	["Frost Sage Elara"] = buildFrostSageElara,
	["Priestess Solara"] = buildPriestessSolara,
	["Archaeologist Rex"] = buildArchaeologistRex,
}

local function buildNPCModel(def)
	local model = Instance.new("Model")
	model.Name = def.name

	-- Build humanoid body
	local body = buildBody(model, def, def.position)

	-- Build NPC-specific accessories
	local builder = accessoryBuilders[def.name]
	if builder then
		builder(model, def, body)
	end

	-- Nametag
	addNameTag(model, def, body.headPos, body.torsoSize)

	-- ClickDetector on ALL parts
	addClickToAll(model, def.name)

	-- Parent to workspace
	local npcFolder = workspace:FindFirstChild("NPCs")
	if not npcFolder then
		npcFolder = Instance.new("Folder")
		npcFolder.Name = "NPCs"
		npcFolder.Parent = workspace
	end
	model.Parent = npcFolder

	return model
end

--------------------------------------------------------------------------------
-- SPAWN ALL NPCs
--------------------------------------------------------------------------------
local spawnedCount = 0
for _, def in NPC_DEFS do
	local ok, err = pcall(function()
		buildNPCModel(def)
	end)
	if ok then
		spawnedCount = spawnedCount + 1
	else
		warn("[NPCManager] FAILED to spawn '" .. def.name .. "': " .. tostring(err))
	end
end

print("[NPCManager] Spawned " .. spawnedCount .. "/" .. #NPC_DEFS .. " NPCs")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="50">
      <Properties>
        <string name="Name">PrayerManager</string>
        <token name="RunContext">0</token>
        <string name="Source">--[[
	PrayerManager.server.lua
	COMPLETE OVERHAUL: 30 prayers in 4 tiers with branching skill tree
	Prayer effects modify combat stats and provide special abilities
]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

print("[PrayerManager] Starting with new 30-prayer system...")

local Config = require(ReplicatedStorage.Modules.Config)
local DataManager = require(ReplicatedStorage.Modules.DataManager)

-- Remotes
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local toggleEvent = Remotes:FindFirstChild("TogglePrayer") or Instance.new("RemoteEvent")
toggleEvent.Name = "TogglePrayer"
toggleEvent.Parent = Remotes

local updateEvent = Remotes:FindFirstChild("PrayerUpdate") or Instance.new("RemoteEvent")
updateEvent.Name = "PrayerUpdate"
updateEvent.Parent = Remotes

local getDataFunc = Remotes:FindFirstChild("GetPrayerData") or Instance.new("RemoteFunction")
getDataFunc.Name = "GetPrayerData"
getDataFunc.Parent = Remotes

local buryBonesEvent = Remotes:FindFirstChild("BuryBones") or Instance.new("RemoteEvent")
buryBonesEvent.Name = "BuryBones"
buryBonesEvent.Parent = Remotes

-- Prayer definitions - 30 prayers in 4 tiers with 3 branches
local PRAYERS = {
	-- TIER 1 ‚Äî NOVICE (Level 1-15) - Foundation prayers
	{id = 1,  name = "Thick Skin",           level = 1,  ppRate = 1, tier = 1, branch = "protector", effects = {defenseBonus = 0.05}, description = "+5% Defense"},
	{id = 2,  name = "Burst of Strength",    level = 1,  ppRate = 1, tier = 1, branch = "warrior",   effects = {strengthBonus = 0.05}, description = "+5% Strength"},
	{id = 3,  name = "Sharp Eye",            level = 1,  ppRate = 1, tier = 1, branch = "ranger",    effects = {rangedAccuracy = 0.05}, description = "+5% Ranged accuracy"},
	{id = 4,  name = "Rock Skin",            level = 5,  ppRate = 2, tier = 1, branch = "protector", effects = {defenseBonus = 0.10}, description = "+10% Defense", prereq = {1}},
	{id = 5,  name = "Clarity of Thought",   level = 8,  ppRate = 2, tier = 1, branch = "warrior",   effects = {allAccuracy = 0.10}, description = "+10% accuracy all styles", prereq = {2}},
	{id = 6,  name = "Mystic Will",          level = 12, ppRate = 2, tier = 1, branch = "ranger",    effects = {allStats = 0.05}, description = "+5% all combat stats", prereq = {3}},

	-- TIER 2 ‚Äî ACOLYTE (Level 16-35) - Intermediate prayers
	{id = 7,  name = "Superhuman Strength",  level = 16, ppRate = 3, tier = 2, branch = "warrior",   effects = {strengthBonus = 0.15}, description = "+15% Strength", prereq = {2}},
	{id = 8,  name = "Improved Reflexes",    level = 18, ppRate = 3, tier = 2, branch = "protector", effects = {defenseBonus = 0.15}, description = "+15% Defense", prereq = {4}},
	{id = 9,  name = "Hawk Eye",             level = 20, ppRate = 3, tier = 2, branch = "ranger",    effects = {rangedBonus = 0.15}, description = "+15% Ranged", prereq = {3}},
	{id = 10, name = "Steel Skin",           level = 22, ppRate = 4, tier = 2, branch = "protector", effects = {defenseBonus = 0.20}, description = "+20% Defense", prereq = {8}},
	{id = 11, name = "Ultimate Strength",    level = 25, ppRate = 4, tier = 2, branch = "warrior",   effects = {strengthBonus = 0.20}, description = "+20% Strength", prereq = {7}},
	{id = 12, name = "Eagle Eye",            level = 28, ppRate = 4, tier = 2, branch = "ranger",    effects = {rangedBonus = 0.20}, description = "+20% Ranged", prereq = {9}},
	{id = 13, name = "Rapid Heal",           level = 30, ppRate = 3, tier = 2, branch = "protector", effects = {hpRegenBoost = 2.0}, description = "2x HP regeneration", prereq = {8}},
	{id = 14, name = "Rapid Restore",        level = 35, ppRate = 2, tier = 2, branch = "protector", effects = {ppRegenBoost = 2.0}, description = "2x PP regeneration", prereq = {13}},

	-- TIER 3 ‚Äî PRIEST (Level 36-60) - Advanced prayers with special effects
	{id = 15, name = "Protect from Melee",   level = 36, ppRate = 6, tier = 3, branch = "protector", effects = {meleeProt = 0.50}, description = "Block 50% melee damage", prereq = {10}},
	{id = 16, name = "Protect from Ranged",  level = 38, ppRate = 6, tier = 3, branch = "protector", effects = {rangedProt = 0.50}, description = "Block 50% ranged damage", prereq = {10}},
	{id = 17, name = "Protect from Magic",   level = 40, ppRate = 6, tier = 3, branch = "protector", effects = {magicProt = 0.50}, description = "Block 50% magic damage", prereq = {10}},
	{id = 18, name = "Retribution",          level = 42, ppRate = 3, tier = 3, branch = "warrior",   effects = {retribution = true}, description = "On death, deal 25% max HP as AoE damage", prereq = {11}},
	{id = 19, name = "Redemption",           level = 45, ppRate = 4, tier = 3, branch = "protector", effects = {redemption = true}, description = "Auto-heal 25% HP when below 10%", prereq = {15}},
	{id = 20, name = "Smite",                level = 48, ppRate = 5, tier = 3, branch = "warrior",   effects = {smite = true}, description = "Drain enemy prayer on hit", prereq = {18}},
	{id = 21, name = "Holy Strength",        level = 52, ppRate = 7, tier = 3, branch = "warrior",   effects = {strengthBonus = 0.25, defenseBonus = 0.10}, description = "+25% Strength, +10% Defense", prereq = {11}},
	{id = 22, name = "Divine Aim",           level = 55, ppRate = 7, tier = 3, branch = "ranger",    effects = {rangedBonus = 0.25, allAccuracy = 0.10}, description = "+25% Ranged, +10% accuracy", prereq = {12}},

	-- TIER 4 ‚Äî HIGH PRIEST (Level 61-99) - Master tier prayers
	{id = 23, name = "Chivalry",             level = 61, ppRate = 8,  tier = 4, branch = "warrior",   effects = {strengthBonus = 0.20, defenseBonus = 0.20, allAccuracy = 0.15}, description = "+20% Strength, +20% Defense, +15% accuracy", prereq = {21}},
	{id = 24, name = "Piety",                level = 70, ppRate = 10, tier = 4, branch = "warrior",   effects = {strengthBonus = 0.25, defenseBonus = 0.25, allAccuracy = 0.20}, description = "+25% Strength, +25% Defense, +20% accuracy", prereq = {23}},
	{id = 25, name = "Rigour",               level = 74, ppRate = 10, tier = 4, branch = "ranger",    effects = {rangedBonus = 0.25, defenseBonus = 0.25}, description = "+25% Ranged, +25% Defense", prereq = {22}},
	{id = 26, name = "Augury",               level = 78, ppRate = 12, tier = 4, branch = "ranger",    effects = {allStats = 0.25, allAccuracy = 0.15}, description = "+25% all stats, +15% accuracy", prereq = {25}},
	{id = 27, name = "Soul Split",           level = 82, ppRate = 12, tier = 4, branch = "protector", effects = {soulSplit = true}, description = "Heal 10% of damage dealt", prereq = {19}},
	{id = 28, name = "Turmoil",              level = 86, ppRate = 15, tier = 4, branch = "warrior",   effects = {strengthBonus = 0.30, defenseBonus = 0.30, turmoil = true}, description = "+30% Strength, +30% Defense, drain enemy stats", prereq = {24}},
	{id = 29, name = "Wrath",                level = 90, ppRate = 5,  tier = 4, branch = "warrior",   effects = {wrath = true}, description = "On death, massive AoE explosion", prereq = {28}},
	{id = 30, name = "Divine Shield",        level = 95, ppRate = 20, tier = 4, branch = "protector", effects = {divineShield = true}, description = "Reduce ALL damage by 40% for 30 seconds, then 5 min cooldown", prereq = {27}},
}

-- Create lookup tables
local prayerById = {}
local prayerByName = {}
for _, p in ipairs(PRAYERS) do
	prayerById[p.id] = p
	prayerByName[p.name] = p
end

-- Per-player state
local playerPrayers = {} -- [player] = {active = {id1=true, id2=true}, pp = 100, lastTick = tick()}
local playerCooldowns = {} -- [player] = {divineShield = endTime}

-- Prayer point system - Max PP = 10 + Prayer Level
local function getMaxPrayerPoints(player)
	local data = DataManager.GetData(player)
	if not data then return 10 end
	local prayerLevel = Config.GetLevelFromXP(data.Skills.Prayer or 0)
	return 10 + prayerLevel
end

-- Get current prayer level
local function getPrayerLevel(player)
	local data = DataManager.GetData(player)
	if not data then return 1 end
	return Config.GetLevelFromXP(data.Skills.Prayer or 0)
end

-- Check if player meets prayer prerequisites
local function canUsePrayer(player, prayerId)
	local prayer = prayerById[prayerId]
	if not prayer then return false end
	
	-- Level requirement
	local playerLevel = getPrayerLevel(player)
	if playerLevel &lt; prayer.level then return false end
	
	-- Prerequisites
	if prayer.prereq then
		local playerState = playerPrayers[player]
		if not playerState then return false end
		
		for _, reqId in ipairs(prayer.prereq) do
			-- Check if player has access to prerequisite (either active or previously unlocked)
			local reqPrayer = prayerById[reqId]
			if reqPrayer and playerLevel &lt; reqPrayer.level then
				return false
			end
		end
	end
	
	return true
end

-- Calculate total PP drain rate
local function getTotalPPDrain(player)
	local playerState = playerPrayers[player]
	if not playerState or not playerState.active then return 0 end
	
	local totalDrain = 0
	for prayerId, active in pairs(playerState.active) do
		if active then
			local prayer = prayerById[prayerId]
			if prayer then
				totalDrain = totalDrain + prayer.ppRate
			end
		end
	end
	
	-- Rapid Restore doubles PP regen, which effectively halves drain
	if playerState.active[14] then -- Rapid Restore
		totalDrain = totalDrain * 0.5
	end
	
	return totalDrain
end

-- Apply prayer effects to player
local function applyPrayerEffects(player)
	local playerState = playerPrayers[player]
	if not playerState or not playerState.active then return end
	
	-- This would integrate with CombatManager to actually modify stats
	-- For now, we'll just store the effects for other systems to query
	local totalEffects = {
		strengthBonus = 0, defenseBonus = 0, rangedBonus = 0,
		allAccuracy = 0, allStats = 0, hpRegenBoost = 1, ppRegenBoost = 1,
		meleeProt = 0, rangedProt = 0, magicProt = 0,
		retribution = false, redemption = false, smite = false,
		soulSplit = false, turmoil = false, wrath = false, divineShield = false
	}
	
	-- Combine effects from all active prayers
	for prayerId, active in pairs(playerState.active) do
		if active then
			local prayer = prayerById[prayerId]
			if prayer then
				for effect, value in pairs(prayer.effects) do
					if type(value) == "number" then
						-- Additive for number effects
						if totalEffects[effect] then
							totalEffects[effect] = totalEffects[effect] + value
						end
					else
						-- Boolean effects
						totalEffects[effect] = value
					end
				end
			end
		end
	end
	
	playerState.effects = totalEffects
end

-- Initialize player prayer state
local function initializePlayer(player)
	playerPrayers[player] = {
		active = {},
		pp = getMaxPrayerPoints(player),
		lastTick = tick(),
		effects = {}
	}
	playerCooldowns[player] = {}
end

-- Handle prayer toggle
toggleEvent.OnServerEvent:Connect(function(player, prayerId)
	if not playerPrayers[player] then
		initializePlayer(player)
	end
	
	local playerState = playerPrayers[player]
	local prayer = prayerById[prayerId]
	
	if not prayer then
		warn("[PrayerManager] Unknown prayer ID:", prayerId)
		return
	end
	
	-- Check if player can use this prayer
	if not canUsePrayer(player, prayerId) then
		print("[PrayerManager] Player cannot use prayer:", prayer.name)
		return
	end
	
	-- Check Divine Shield cooldown
	if prayer.effects.divineShield and playerCooldowns[player].divineShield and 
	   playerCooldowns[player].divineShield > tick() then
		print("[PrayerManager] Divine Shield on cooldown")
		return
	end
	
	-- Toggle the prayer
	local wasActive = playerState.active[prayerId] or false
	playerState.active[prayerId] = not wasActive
	
	print("[PrayerManager] " .. player.Name .. " " .. (wasActive and "disabled" or "enabled") .. " " .. prayer.name)
	
	-- Handle special activation effects
	if not wasActive then -- Just activated
		if prayer.effects.divineShield then
			-- Start Divine Shield duration and cooldown
			task.delay(30, function() -- 30 second duration
				if playerState.active[prayerId] then
					playerState.active[prayerId] = false
					playerCooldowns[player].divineShield = tick() + 300 -- 5 minute cooldown
					applyPrayerEffects(player)
					updateEvent:FireClient(player)
				end
			end)
		end
	end
	
	-- Apply new effects
	applyPrayerEffects(player)
	
	-- Notify client
	updateEvent:FireClient(player)
end)

-- Get prayer data for client
getDataFunc.OnServerInvoke = function(player)
	if not playerPrayers[player] then
		initializePlayer(player)
	end
	
	local playerState = playerPrayers[player]
	local playerLevel = getPrayerLevel(player)
	local maxPP = getMaxPrayerPoints(player)
	local totalDrain = getTotalPPDrain(player)
	
	-- Build prayer availability
	local availablePrayers = {}
	for _, prayer in ipairs(PRAYERS) do
		availablePrayers[prayer.id] = {
			id = prayer.id,
			name = prayer.name,
			level = prayer.level,
			ppRate = prayer.ppRate,
			tier = prayer.tier,
			branch = prayer.branch,
			description = prayer.description,
			prereq = prayer.prereq,
			canUse = canUsePrayer(player, prayer.id),
			active = playerState.active[prayer.id] or false
		}
	end
	
	return {
		prayers = availablePrayers,
		currentPP = math.floor(playerState.pp),
		maxPP = maxPP,
		ppDrainRate = totalDrain,
		playerLevel = playerLevel,
		effects = playerState.effects,
		cooldowns = playerCooldowns[player]
	}
end

-- Handle bone burying for Prayer XP
buryBonesEvent.OnServerEvent:Connect(function(player, boneName)
	local boneXP = {
		["Bones"] = 10,
		["Big Bones"] = 30,
		["Dragon Bones"] = 100
	}
	
	local xp = boneXP[boneName] or 10
	
	-- Check if player has the bones
	local removed = DataManager.RemoveItem(player, boneName, 1)
	if removed then
		-- Give Prayer XP
		DataManager.AddSkillXP(player, "Prayer", xp)
		print("[PrayerManager] " .. player.Name .. " buried " .. boneName .. " for " .. xp .. " Prayer XP")
		
		-- Update max PP if leveled up
		if playerPrayers[player] then
			playerPrayers[player].pp = math.min(playerPrayers[player].pp, getMaxPrayerPoints(player))
		end
	end
end)

-- Prayer point regeneration and drain system
local lastUpdateTime = tick()
RunService.Heartbeat:Connect(function()
	local currentTime = tick()
	local deltaTime = currentTime - lastUpdateTime
	lastUpdateTime = currentTime
	
	-- Update every 6 seconds (10 times per minute)
	if deltaTime &lt; 6 then return end
	
	for player, playerState in pairs(playerPrayers) do
		if not player.Parent then
			-- Clean up disconnected players
			playerPrayers[player] = nil
			playerCooldowns[player] = nil
			continue
		end
		
		local totalDrain = getTotalPPDrain(player)
		local maxPP = getMaxPrayerPoints(player)
		
		if totalDrain > 0 then
			-- Drain PP (rate is per minute, so divide by 10 for 6-second intervals)
			playerState.pp = playerState.pp - (totalDrain / 10)
			
			-- Disable prayers if out of PP
			if playerState.pp &lt;= 0 then
				playerState.pp = 0
				playerState.active = {}
				applyPrayerEffects(player)
				updateEvent:FireClient(player)
				print("[PrayerManager] " .. player.Name .. " ran out of Prayer Points")
			end
		else
			-- Regenerate PP when no prayers active (1 PP per 10 seconds base)
			local regenRate = 0.6 -- 0.6 PP per 6 seconds = 6 PP per minute
			if playerState.active[14] then -- Rapid Restore
				regenRate = regenRate * 2
			end
			
			playerState.pp = math.min(playerState.pp + regenRate, maxPP)
		end
	end
end)

-- Player initialization
local function onPlayerAdded(player)
	player.CharacterAdded:Connect(function()
		task.wait(2) -- Wait for character to fully load
		initializePlayer(player)
	end)
end

-- Existing players
for _, player in ipairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end

-- New players
Players.PlayerAdded:Connect(onPlayerAdded)

-- Cleanup on player leaving
Players.PlayerRemoving:Connect(function(player)
	playerPrayers[player] = nil
	playerCooldowns[player] = nil
end)

print("[PrayerManager] New 30-prayer system ready!")</string>
      </Properties>
    </Item>
    <Item class="Script" referent="51">
      <Properties>
        <string name="Name">QuestManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	QuestManager.server.lua
	Server-side quest system for the RuneScape-inspired MMO.
	Tracks player quest progress, listens for game events, awards rewards.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local DataManager = require(ReplicatedStorage.Modules.DataManager)
local QuestDatabase = require(ReplicatedStorage.Modules.QuestDatabase)

------------------------------------------------------------
-- Remote Events Setup
------------------------------------------------------------
local function getOrCreateRemote(name: string): RemoteEvent
	local existing = ReplicatedStorage:FindFirstChild(name)
	if existing then return existing end
	local remote = Instance.new("RemoteEvent")
	remote.Name = name
	remote.Parent = ReplicatedStorage
	return remote
end

local QuestAcceptEvent = getOrCreateRemote("QuestAccept")
local QuestProgressEvent = getOrCreateRemote("QuestProgress")
local QuestCompleteEvent = getOrCreateRemote("QuestComplete")
local QuestListEvent = getOrCreateRemote("QuestList")

-- Bindable events for other server scripts to fire into the quest system
local function getOrCreateBindable(name: string): BindableEvent
	local existing = ReplicatedStorage:FindFirstChild(name)
	if existing then return existing end
	local b = Instance.new("BindableEvent")
	b.Name = name
	b.Parent = ReplicatedStorage
	return b
end

local GatherEvent = getOrCreateBindable("QuestGatherEvent")
local CraftEvent = getOrCreateBindable("QuestCraftEvent")
local KillEvent = getOrCreateBindable("QuestKillEvent")
local ZoneEvent = getOrCreateBindable("QuestZoneEvent")
local TalkEvent = getOrCreateBindable("QuestTalkEvent")

------------------------------------------------------------
-- Helpers
------------------------------------------------------------

-- Initialise the Quests field on player data if missing
local function ensureQuestData(player: Player)
	local data = DataManager:GetData(player)
	if not data then return end
	if not data.Quests then
		data.Quests = {
			active = {},    -- { [questId] = { objectives = { [index] = currentProgress } } }
			completed = {}, -- { [questId] = true }
		}
	end
	return data
end

-- Check if a player meets quest requirements
local function meetsRequirements(player: Player, quest): boolean
	local data = DataManager:GetData(player)
	if not data then return false end

	-- Level requirements
	for _, req in quest.requirements.level do
		local skills = data.Skills or {}
		local skillData = skills[req.skill] or {}
		local playerLevel = skillData.Level or 1
		if playerLevel < req.level then
			return false
		end
	end

	-- Prerequisite quests
	local questData = data.Quests or {}
	for _, requiredQuestId in quest.requirements.quests do
		if not (questData.completed and questData.completed[requiredQuestId]) then
			return false
		end
	end

	return true
end

-- Send current quest state to a player
local function sendQuestList(player: Player)
	local data = ensureQuestData(player)
	if not data then return end

	local payload = {
		active = {},
		completed = {},
		available = {},
	}

	-- Active quests with progress
	for questId, progress in data.Quests.active do
		local quest = QuestDatabase.ById[questId]
		if quest then
			local objectives = {}
			for i, obj in quest.objectives do
				table.insert(objectives, {
					type = obj.type,
					target = obj.target,
					amount = obj.amount,
					current = progress.objectives[i] or 0,
				})
			end
			payload.active[questId] = {
				name = quest.name,
				description = quest.description,
				objectives = objectives,
				rewards = quest.rewards,
			}
		end
	end

	-- Completed quests
	for questId in data.Quests.completed do
		payload.completed[questId] = true
	end

	-- Available quests (not active, not completed, meets requirements)
	for _, quest in QuestDatabase.Quests do
		if not data.Quests.active[quest.id] and not data.Quests.completed[quest.id] then
			if meetsRequirements(player, quest) then
				table.insert(payload.available, {
					id = quest.id,
					name = quest.name,
					description = quest.description,
					objectives = quest.objectives,
					rewards = quest.rewards,
					requirements = quest.requirements,
				})
			end
		end
	end

	QuestListEvent:FireClient(player, payload)
end

------------------------------------------------------------
-- Quest Accept
------------------------------------------------------------
QuestAcceptEvent.OnServerEvent:Connect(function(player: Player, questId: string)
	local data = ensureQuestData(player)
	if not data then return end

	-- Validate quest exists
	local quest = QuestDatabase.ById[questId]
	if not quest then return end

	-- Already active or completed?
	if data.Quests.active[questId] or data.Quests.completed[questId] then return end

	-- Check requirements
	if not meetsRequirements(player, quest) then return end

	-- Accept the quest
	local objectives = {}
	for i in quest.objectives do
		objectives[i] = 0
	end
	data.Quests.active[questId] = { objectives = objectives }

	print(`[QuestManager] {player.Name} accepted quest: {quest.name}`)
	sendQuestList(player)
end)

------------------------------------------------------------
-- Quest List Request (client asks for current state)
------------------------------------------------------------
QuestListEvent.OnServerEvent:Connect(function(player: Player)
	sendQuestList(player)
end)

------------------------------------------------------------
-- Progress Tracking
------------------------------------------------------------

-- Try to complete a quest if all objectives are met
local function tryComplete(player: Player, questId: string)
	local data = DataManager:GetData(player)
	if not data or not data.Quests then return end

	local progress = data.Quests.active[questId]
	if not progress then return end

	local quest = QuestDatabase.ById[questId]
	if not quest then return end

	-- Check all objectives
	for i, obj in quest.objectives do
		if (progress.objectives[i] or 0) < obj.amount then
			return -- not done yet
		end
	end

	-- Complete! Remove from active, add to completed
	data.Quests.active[questId] = nil
	data.Quests.completed[questId] = true

	-- Award gold
	data.Gold = (data.Gold or 0) + quest.rewards.gold

	-- Award XP
	for _, xpReward in quest.rewards.xp do
		local skills = data.Skills or {}
		if not skills[xpReward.skill] then
			skills[xpReward.skill] = { Level = 1, XP = 0 }
		end
		skills[xpReward.skill].XP += xpReward.amount
		data.Skills = skills
	end

	-- Award items
	local inventory = data.Inventory or {}
	for _, itemName in quest.rewards.items do
		table.insert(inventory, { name = itemName, amount = 1 })
	end
	data.Inventory = inventory

	print(`[QuestManager] {player.Name} completed quest: {quest.name}`)
	QuestCompleteEvent:FireClient(player, questId, quest.rewards)
	sendQuestList(player)
end

-- Update progress for a specific objective type and target
local function updateProgress(player: Player, objectiveType: string, target: string, amount: number)
	local data = DataManager:GetData(player)
	if not data or not data.Quests then return end

	local changed = false

	for questId, progress in data.Quests.active do
		local quest = QuestDatabase.ById[questId]
		if quest then
			for i, obj in quest.objectives do
				if obj.type == objectiveType and obj.target == target then
					local prev = progress.objectives[i] or 0
					if prev < obj.amount then
						progress.objectives[i] = math.min(prev + amount, obj.amount)
						changed = true
					end
				end
			end
		end
	end

	if changed then
		-- Notify client of progress update
		QuestProgressEvent:FireClient(player, {})
		sendQuestList(player)

		-- Check completions
		for questId in data.Quests.active do
			tryComplete(player, questId)
		end
	end
end

------------------------------------------------------------
-- Event Listeners (from other server scripts)
------------------------------------------------------------

-- Gather event: fired when player gathers a resource
-- Args: player, itemName, amount
GatherEvent.Event:Connect(function(player: Player, itemName: string, amount: number?)
	updateProgress(player, "gather", itemName, amount or 1)
end)

-- Craft event: fired when player crafts an item
-- Args: player, itemName, amount
CraftEvent.Event:Connect(function(player: Player, itemName: string, amount: number?)
	updateProgress(player, "craft", itemName, amount or 1)
end)

-- Kill event: fired when player defeats a target
-- Args: player, targetType, amount
KillEvent.Event:Connect(function(player: Player, targetType: string, amount: number?)
	updateProgress(player, "kill", targetType, amount or 1)
end)

-- Zone event: fired when player enters/exits a zone
-- Args: player, zoneName
ZoneEvent.Event:Connect(function(player: Player, zoneName: string)
	updateProgress(player, "visit", zoneName, 1)
end)

-- Talk event: fired when player talks to an NPC
-- Args: player, npcName
TalkEvent.Event:Connect(function(player: Player, npcName: string)
	updateProgress(player, "talk", npcName, 1)
end)

------------------------------------------------------------
-- Player Setup
------------------------------------------------------------
Players.PlayerAdded:Connect(function(player: Player)
	-- Wait for DataManager to load player data
	task.wait(1)
	ensureQuestData(player)
	sendQuestList(player)
end)

print("[QuestManager] Quest system active!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="52">
      <Properties>
        <string name="Name">ShopManager</string>
        <token name="RunContext">0</token>
        <string name="Source">--[[
	ShopManager.server.lua
	Server-side shop system for NPCs with merchant role.
	Handles buying/selling items with gold, 60% sell-back value.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local DataManager = require(ReplicatedStorage.Modules.DataManager)
local ItemDatabase = require(ReplicatedStorage.Modules.ItemDatabase)

------------------------------------------------------------
-- Remote Events
------------------------------------------------------------
local function getOrCreateRemote(name: string): RemoteEvent
	local existing = ReplicatedStorage:FindFirstChild(name)
	if existing then return existing end
	local remote = Instance.new("RemoteEvent")
	remote.Name = name
	remote.Parent = ReplicatedStorage
	return remote
end

local BuyItemEvent = getOrCreateRemote("BuyItem")
local SellItemEvent = getOrCreateRemote("SellItem")

------------------------------------------------------------
-- Shop Inventories by NPC Role
------------------------------------------------------------
local ShopInventories = {
	["Mara the Merchant"] = {
		-- General goods merchant
		{ item = "Bread", stock = 50, basePrice = 10 },
		{ item = "Meat Pie", stock = 25, basePrice = 25 },
		{ item = "Apple", stock = 30, basePrice = 5 },
		{ item = "Fishing Rod", stock = 5, basePrice = 50 },
		{ item = "Pickaxe", stock = 5, basePrice = 75 },
		{ item = "Hatchet", stock = 5, basePrice = 60 },
		{ item = "Rope", stock = 20, basePrice = 15 },
		{ item = "Tinderbox", stock = 10, basePrice = 8 },
	},
	["Captain Blackbeard"] = {
		-- Pirate equipment and supplies
		{ item = "Cutlass", stock = 3, basePrice = 200 },
		{ item = "Pirate Hat", stock = 2, basePrice = 150 },
		{ item = "Rum", stock = 15, basePrice = 30 },
		{ item = "Rope", stock = 10, basePrice = 15 },
		{ item = "Cannon Ball", stock = 25, basePrice = 20 },
		{ item = "Treasure Map", stock = 1, basePrice = 500 },
		{ item = "Spyglass", stock = 2, basePrice = 100 },
	},
	["Priestess Solara"] = {
		-- Prayer and healing items
		{ item = "Prayer Book", stock = 3, basePrice = 100 },
		{ item = "Holy Water", stock = 20, basePrice = 25 },
		{ item = "Blessed Bones", stock = 15, basePrice = 40 },
		{ item = "Healing Potion", stock = 30, basePrice = 35 },
		{ item = "Prayer Beads", stock = 10, basePrice = 60 },
		{ item = "Candle", stock = 25, basePrice = 12 },
		{ item = "Incense", stock = 15, basePrice = 18 },
	},
	["Grimnir the Smith"] = {
		-- Smithing supplies and basic weapons
		{ item = "Hammer", stock = 5, basePrice = 40 },
		{ item = "Copper Bar", stock = 20, basePrice = 25 },
		{ item = "Iron Bar", stock = 15, basePrice = 50 },
		{ item = "Gold Bar", stock = 5, basePrice = 200 },
		{ item = "Bronze Sword", stock = 10, basePrice = 80 },
		{ item = "Iron Sword", stock = 5, basePrice = 150 },
		{ item = "Shield", stock = 8, basePrice = 100 },
		{ item = "Anvil Plans", stock = 1, basePrice = 300 },
	},
	["Old Bess the Cook"] = {
		-- Cooking supplies and cooked food
		{ item = "Cooking Pot", stock = 3, basePrice = 45 },
		{ item = "Flour", stock = 30, basePrice = 8 },
		{ item = "Salt", stock = 25, basePrice = 5 },
		{ item = "Cooked Shrimp", stock = 20, basePrice = 15 },
		{ item = "Cooked Trout", stock = 15, basePrice = 25 },
		{ item = "Bread", stock = 40, basePrice = 10 },
		{ item = "Meat Pie", stock = 20, basePrice = 25 },
		{ item = "Chef's Hat", stock = 2, basePrice = 75 },
	},
	["Fisher Tom"] = {
		-- Fishing supplies and raw fish
		{ item = "Fishing Rod", stock = 8, basePrice = 50 },
		{ item = "Net", stock = 5, basePrice = 80 },
		{ item = "Bait", stock = 50, basePrice = 3 },
		{ item = "Raw Shrimp", stock = 25, basePrice = 8 },
		{ item = "Raw Sardine", stock = 20, basePrice = 12 },
		{ item = "Raw Trout", stock = 15, basePrice = 18 },
		{ item = "Fishing Basket", stock = 10, basePrice = 30 },
	},
	["Woodsman Jake"] = {
		-- Woodcutting and fletching supplies
		{ item = "Hatchet", stock = 6, basePrice = 60 },
		{ item = "Logs", stock = 50, basePrice = 10 },
		{ item = "Oak Logs", stock = 30, basePrice = 20 },
		{ item = "Willow Logs", stock = 15, basePrice = 35 },
		{ item = "Bow String", stock = 20, basePrice = 15 },
		{ item = "Arrow Shaft", stock = 100, basePrice = 2 },
		{ item = "Feather", stock = 50, basePrice = 5 },
	},
}

------------------------------------------------------------
-- Helpers
------------------------------------------------------------
local function getShopInventory(npcName: string)
	return ShopInventories[npcName] or {}
end

local function getItemValue(itemName: string): number
	local itemData = ItemDatabase.Items[itemName]
	return itemData and itemData.value or 1
end

local function canAfford(player: Player, price: number): boolean
	local playerData = DataManager:GetPlayerData(player)
	return playerData.Gold >= price
end

local function addGold(player: Player, amount: number)
	local playerData = DataManager:GetPlayerData(player)
	playerData.Gold = playerData.Gold + amount
	DataManager:SavePlayerData(player)
end

local function removeGold(player: Player, amount: number): boolean
	local playerData = DataManager:GetPlayerData(player)
	if playerData.Gold >= amount then
		playerData.Gold = playerData.Gold - amount
		DataManager:SavePlayerData(player)
		return true
	end
	return false
end

local function addItemToInventory(player: Player, itemName: string, quantity: number): boolean
	local playerData = DataManager:GetPlayerData(player)
	local itemData = ItemDatabase.Items[itemName]
	if not itemData then return false end

	-- Check if item is stackable
	if itemData.stackable then
		-- Find existing stack or create new
		local found = false
		for i, invItem in ipairs(playerData.Inventory) do
			if invItem.name == itemName then
				invItem.quantity = invItem.quantity + quantity
				found = true
				break
			end
		end
		if not found then
			table.insert(playerData.Inventory, {name = itemName, quantity = quantity})
		end
	else
		-- Add individual items for non-stackable
		for i = 1, quantity do
			table.insert(playerData.Inventory, {name = itemName, quantity = 1})
		end
	end

	DataManager:SavePlayerData(player)
	return true
end

local function removeItemFromInventory(player: Player, itemName: string, quantity: number): boolean
	local playerData = DataManager:GetPlayerData(player)
	local totalRemoved = 0

	-- Remove from inventory
	for i = #playerData.Inventory, 1, -1 do
		local invItem = playerData.Inventory[i]
		if invItem.name == itemName then
			local removeFromThisStack = math.min(invItem.quantity, quantity - totalRemoved)
			invItem.quantity = invItem.quantity - removeFromThisStack
			totalRemoved = totalRemoved + removeFromThisStack

			if invItem.quantity &lt;= 0 then
				table.remove(playerData.Inventory, i)
			end

			if totalRemoved >= quantity then
				break
			end
		end
	end

	if totalRemoved >= quantity then
		DataManager:SavePlayerData(player)
		return true
	end

	return false
end

local function countItemInInventory(player: Player, itemName: string): number
	local playerData = DataManager:GetPlayerData(player)
	local count = 0

	for _, invItem in ipairs(playerData.Inventory) do
		if invItem.name == itemName then
			count = count + invItem.quantity
		end
	end

	return count
end

------------------------------------------------------------
-- Buy Item Handler
------------------------------------------------------------
local function onBuyItem(player: Player, npcName: string, itemName: string, quantity: number)
	-- Validate inputs
	if not player or not npcName or not itemName or not quantity then return end
	if quantity &lt;= 0 or quantity > 100 then return end -- Sanity check

	-- Get shop inventory
	local shopItems = getShopInventory(npcName)
	local shopItem = nil
	for _, item in ipairs(shopItems) do
		if item.item == itemName then
			shopItem = item
			break
		end
	end

	if not shopItem then
		warn("[ShopManager] Item not found in shop:", itemName, "for NPC:", npcName)
		return
	end

	-- Check stock
	if shopItem.stock &lt; quantity then
		-- Could send a message to player about insufficient stock
		return
	end

	-- Calculate total price
	local totalPrice = shopItem.basePrice * quantity

	-- Check if player can afford
	if not canAfford(player, totalPrice) then
		-- Could send a message to player about insufficient gold
		return
	end

	-- Process purchase
	if removeGold(player, totalPrice) then
		if addItemToInventory(player, itemName, quantity) then
			-- Reduce shop stock (optional - shops could have unlimited stock)
			shopItem.stock = shopItem.stock - quantity
			print("[ShopManager]", player.Name, "bought", quantity, itemName, "for", totalPrice, "gold from", npcName)
		else
			-- Refund if inventory add failed
			addGold(player, totalPrice)
			warn("[ShopManager] Failed to add item to inventory, refunding")
		end
	end
end

------------------------------------------------------------
-- Sell Item Handler
------------------------------------------------------------
local function onSellItem(player: Player, npcName: string, itemName: string, quantity: number)
	-- Validate inputs
	if not player or not npcName or not itemName or not quantity then return end
	if quantity &lt;= 0 or quantity > 100 then return end

	-- Check if player has enough of the item
	local playerHas = countItemInInventory(player, itemName)
	if playerHas &lt; quantity then
		return
	end

	-- Get item value and calculate sell price (60% of base value)
	local itemValue = getItemValue(itemName)
	local sellPrice = math.floor(itemValue * quantity * 0.6)

	-- Remove items from inventory
	if removeItemFromInventory(player, itemName, quantity) then
		-- Give gold to player
		addGold(player, sellPrice)
		print("[ShopManager]", player.Name, "sold", quantity, itemName, "for", sellPrice, "gold to", npcName)
	else
		warn("[ShopManager] Failed to remove items from inventory")
	end
end

------------------------------------------------------------
-- Event Connections
------------------------------------------------------------
BuyItemEvent.OnServerEvent:Connect(onBuyItem)
SellItemEvent.OnServerEvent:Connect(onSellItem)

print("[ShopManager] Initialized")</string>
      </Properties>
    </Item>
    <Item class="Script" referent="53">
      <Properties>
        <string name="Name">SkillManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- SkillManager.server.lua
-- Handles resource gathering (mining, woodcutting, fishing)

print("[SkillManager] Starting...")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Modules = ReplicatedStorage:WaitForChild("Modules", 10)
print("[SkillManager] Modules folder found: " .. tostring(Modules ~= nil))

local ok1, Config = pcall(function() return require(Modules:WaitForChild("Config", 10)) end)
print("[SkillManager] Config loaded: " .. tostring(ok1))

local ok2, ItemDB = pcall(function() return require(Modules:WaitForChild("ItemDatabase", 10)) end)
print("[SkillManager] ItemDB loaded: " .. tostring(ok2))

local ok3, DataManager = pcall(function() return require(Modules:WaitForChild("DataManager", 10)) end)
print("[SkillManager] DataManager loaded: " .. tostring(ok3))

if not ok1 or not ok2 or not ok3 then
	warn("[SkillManager] FAILED to load modules! Config=" .. tostring(ok1) .. " ItemDB=" .. tostring(ok2) .. " DataManager=" .. tostring(ok3))
	return
end

-- Create a remote for gather feedback
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
local gatherRemote = Instance.new("RemoteEvent")
gatherRemote.Name = "GatherFeedback"
gatherRemote.Parent = Remotes

-- Skill mapping
local skillMap = {
	Rock = "Mining",
	Tree = "Woodcutting",
	FishingSpot = "Fishing",
}

-- === RESOURCE NODE SETUP ===
local function createResourceNode(name, nodeType, position, parent, levelReq, itemDrop, xpReward, quantity)
	-- Use a Model to group all parts together
	local model = Instance.new("Model")
	model.Name = name
	model.Parent = parent

	local mainPart -- the part that gets the ClickDetector

	if nodeType == "Rock" then
		-- Determine ore color based on item drop
		local oreColors = {
			["Copper Ore"] = {main = Color3.fromRGB(140, 90, 50), vein = Color3.fromRGB(184, 115, 51)},
			["Iron Ore"] = {main = Color3.fromRGB(80, 80, 85), vein = Color3.fromRGB(160, 160, 170)},
			["Gold Ore"] = {main = Color3.fromRGB(100, 95, 75), vein = Color3.fromRGB(218, 165, 32)},
			["Runite Ore"] = {main = Color3.fromRGB(50, 80, 80), vein = Color3.fromRGB(0, 170, 170)},
		}
		local colors = oreColors[itemDrop] or {main = Color3.fromRGB(90, 90, 90), vein = Color3.fromRGB(150, 150, 150)}

		mainPart = Instance.new("Part")
		mainPart.Name = "Rock"
		mainPart.Size = Vector3.new(3, 2.5, 3)
		mainPart.Position = position + Vector3.new(0, 1.25, 0)
		mainPart.Anchored = true
		mainPart.CanCollide = true
		mainPart.Color = colors.main
		mainPart.Material = Enum.Material.Slate
		mainPart.Parent = model

		-- Smaller rock next to it
		local rock2 = Instance.new("Part")
		rock2.Name = "RockSmall"
		rock2.Size = Vector3.new(1.8, 1.6, 1.8)
		rock2.Position = position + Vector3.new(2, 0.8, 0.8)
		rock2.Anchored = true
		rock2.CanCollide = true
		rock2.Color = colors.main
		rock2.Material = Enum.Material.Rock
		rock2.Parent = model

		-- Colored ore vein on surface
		local vein = Instance.new("Part")
		vein.Name = "OreVein"
		vein.Size = Vector3.new(1.2, 0.8, 0.2)
		vein.Position = position + Vector3.new(0, 1.5, 1.5)
		vein.Anchored = true
		vein.CanCollide = false
		vein.Color = colors.vein
		vein.Material = Enum.Material.SmoothPlastic
		vein.Parent = model

	elseif nodeType == "Tree" then
		-- Determine tree size based on item drop
		local treeSizes = {
			["Oak Log"] = {trunk = Vector3.new(1.5, 6, 1.5), canopy = Vector3.new(5, 4, 5), canopyY = 7, glow = false},
			["Willow Log"] = {trunk = Vector3.new(1.8, 7, 1.8), canopy = Vector3.new(6, 4.5, 6), canopyY = 8, glow = false},
			["Yew Log"] = {trunk = Vector3.new(2, 8, 2), canopy = Vector3.new(7, 5, 7), canopyY = 9, glow = false},
			["Magic Log"] = {trunk = Vector3.new(2.2, 10, 2.2), canopy = Vector3.new(8, 6, 8), canopyY = 11, glow = true},
		}
		local treeInfo = treeSizes[itemDrop] or treeSizes["Oak Log"]

		-- Trunk
		mainPart = Instance.new("Part")
		mainPart.Name = "Trunk"
		mainPart.Size = treeInfo.trunk
		mainPart.Position = position + Vector3.new(0, treeInfo.trunk.Y / 2, 0)
		mainPart.Anchored = true
		mainPart.CanCollide = true
		mainPart.Color = Color3.fromRGB(101, 67, 33)
		mainPart.Material = Enum.Material.Wood
		mainPart.Parent = model

		-- Canopy
		local leaves = Instance.new("Part")
		leaves.Name = "Leaves"
		leaves.Shape = Enum.PartType.Ball
		leaves.Size = treeInfo.canopy
		leaves.Position = position + Vector3.new(0, treeInfo.canopyY, 0)
		leaves.Anchored = true
		leaves.CanCollide = false
		leaves.Color = Color3.fromRGB(34, 100, 34)
		leaves.Material = Enum.Material.Grass
		leaves.Parent = model

		-- Magic trees get a subtle glow
		if treeInfo.glow then
			local glow = Instance.new("PointLight")
			glow.Color = Color3.fromRGB(100, 200, 255)
			glow.Brightness = 1.5
			glow.Range = 14
			glow.Parent = leaves
		end

		-- ClickDetector on leaves too
		local leavesClick = Instance.new("ClickDetector")
		leavesClick.MaxActivationDistance = 12
		leavesClick.Parent = leaves
		leaves:SetAttribute("IsGatherNode", true)

	elseif nodeType == "FishingSpot" then
		-- Transparent blue ring on water surface
		mainPart = Instance.new("Part")
		mainPart.Name = "FishingSpot"
		mainPart.Shape = Enum.PartType.Cylinder
		mainPart.Size = Vector3.new(0.3, 6, 6)
		mainPart.CFrame = CFrame.new(position + Vector3.new(0, 0.15, 0)) * CFrame.Angles(0, 0, math.rad(90))
		mainPart.Anchored = true
		mainPart.CanCollide = false
		mainPart.Color = Color3.fromRGB(65, 130, 175)
		mainPart.Material = Enum.Material.Water
		mainPart.Transparency = 0.5
		mainPart.Parent = model

		-- Bobber (small bright sphere)
		local bobber = Instance.new("Part")
		bobber.Name = "Bobber"
		bobber.Shape = Enum.PartType.Ball
		bobber.Size = Vector3.new(0.8, 0.8, 0.8)
		bobber.Position = position + Vector3.new(0, 0.6, 0)
		bobber.Anchored = true
		bobber.CanCollide = false
		bobber.Color = Color3.fromRGB(255, 80, 20)
		bobber.Material = Enum.Material.SmoothPlastic
		bobber.Parent = model

		-- Splash particle effect
		local emitter = Instance.new("ParticleEmitter")
		emitter.Color = ColorSequence.new(Color3.fromRGB(200, 220, 255))
		emitter.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.3), NumberSequenceKeypoint.new(1, 0)})
		emitter.Lifetime = NumberRange.new(0.3, 0.8)
		emitter.Rate = 5
		emitter.Speed = NumberRange.new(1, 3)
		emitter.SpreadAngle = Vector2.new(30, 30)
		emitter.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.3), NumberSequenceKeypoint.new(1, 1)})
		emitter.Parent = bobber
	end

	if not mainPart then
		warn("[SkillManager] Failed to create main part for " .. name)
		return
	end

	-- ClickDetector on main part
	local clickDetector = Instance.new("ClickDetector")
	clickDetector.MaxActivationDistance = 12
	clickDetector.Parent = mainPart

	-- Floating label showing what it is
	local billboard = Instance.new("BillboardGui")
	billboard.Size = UDim2.new(5, 0, 1, 0)
	billboard.StudsOffset = Vector3.new(0, 3, 0)
	billboard.Parent = mainPart

	-- Node state (must be before label so we can reference charges)
	local maxCharges = quantity or 1
	local nodeData = { active = true, charges = maxCharges }

	local skillEmojis = {Rock = "‚õèÔ∏è", Tree = "ü™ì", FishingSpot = "üé£"}
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	local chargeText = maxCharges > 1 and (" [" .. nodeData.charges .. "/" .. maxCharges .. "]") or ""
	label.Text = (skillEmojis[nodeType] or "") .. " " .. itemDrop .. " (Lv " .. levelReq .. ")" .. chargeText
	label.TextColor3 = Color3.fromRGB(255, 223, 120)
	label.TextScaled = true
	label.Font = Enum.Font.GothamBold
	label.TextStrokeTransparency = 0.5
	label.Parent = billboard

	-- Tool type required per node type
	local toolRequired = {Rock = "pickaxe", Tree = "axe", FishingSpot = "fishing_rod"}

	-- Track who is currently gathering this node
	local gatheringPlayers = {}

	-- Gather handler
	local function onGather(player)
		if not nodeData.active then return end
		if gatheringPlayers[player.UserId] then return end -- already gathering

		local skill = skillMap[nodeType]
		if not skill then return end

		-- Check level requirement
		local playerLevel = DataManager.GetSkillLevel(player, skill)
		if playerLevel < levelReq then
			gatherRemote:FireClient(player, "level", itemDrop, levelReq)
			return
		end

		-- Check for required tool (in equipment Tool slot OR inventory)
		local requiredToolType = toolRequired[nodeType]
		local toolSpeed = 1.0 -- default (no tool = slowest, but we require tool)
		local hasTool = false

		local data = DataManager.GetData(player)
		if data then
			-- Check equipped tool first
			local equippedTool = data.Equipment and data.Equipment.Tool or ""
			if equippedTool ~= "" then
				local toolInfo = ItemDB.GetItem(equippedTool)
				if toolInfo and toolInfo.toolType == requiredToolType and playerLevel >= (toolInfo.levelReq or 1) then
					hasTool = true
					toolSpeed = toolInfo.gatherSpeed or 1.0
				end
			end

			-- If no equipped tool, check inventory for best tool
			if not hasTool and data.Inventory then
				local bestSpeed = 999
				for _, slot in ipairs(data.Inventory) do
					local itemInfo = ItemDB.GetItem(slot.name)
					if itemInfo and itemInfo.toolType == requiredToolType and playerLevel >= (itemInfo.levelReq or 1) then
						local spd = itemInfo.gatherSpeed or 1.0
						if spd < bestSpeed then
							bestSpeed = spd
							hasTool = true
							toolSpeed = spd
						end
					end
				end
			end
		end

		if not hasTool then
			-- Tell client they need a tool
			local toolNames = {pickaxe = "pickaxe", axe = "axe", fishing_rod = "fishing rod"}
			gatherRemote:FireClient(player, "notool", toolNames[requiredToolType] or "tool", 0)
			return
		end

		-- Calculate gather time: base time depends on node level, reduced by tool speed and player level
		-- Base time: 2-8 seconds based on levelReq of the node
		local baseTime = 2 + (levelReq / 15) -- Lv1=2.07s, Lv15=3s, Lv40=4.7s, Lv70=6.7s, Lv85=7.7s
		-- Tool multiplier (0.3 to 1.0)
		local gatherTime = baseTime * toolSpeed
		-- Player level bonus: up to 30% faster at high levels
		local levelBonus = math.min(0.3, (playerLevel - levelReq) * 0.005)
		gatherTime = gatherTime * (1 - levelBonus)
		-- Minimum 1 second
		gatherTime = math.max(1, gatherTime)

		-- Mark player as gathering
		gatheringPlayers[player.UserId] = true

		-- Tell client gathering started (with duration)
		gatherRemote:FireClient(player, "start", itemDrop, gatherTime)

		-- Wait for gather time (check player is still near the node)
		local startPos = model.PrimaryPart and model.PrimaryPart.Position or model:GetChildren()[1].Position
		local elapsed = 0
		local cancelled = false
		while elapsed < gatherTime do
			task.wait(0.25)
			elapsed = elapsed + 0.25
			-- Check if node depleted by someone else
			if not nodeData.active then
				cancelled = true
				break
			end
			-- Check if player moved too far (>20 studs)
			local char = player.Character
			if char then
				local root = char:FindFirstChild("HumanoidRootPart")
				if root and (root.Position - startPos).Magnitude > 20 then
					cancelled = true
					break
				end
			else
				cancelled = true
				break
			end
		end

		gatheringPlayers[player.UserId] = nil

		if cancelled then
			gatherRemote:FireClient(player, "cancel", itemDrop, 0)
			return
		end
		if not nodeData.active then return end

		-- Check inventory space
		local added = DataManager.AddToInventory(player, itemDrop, 1)
		if not added then
			gatherRemote:FireClient(player, "full", itemDrop, 0)
			return
		end

		-- Award XP
		DataManager.AddSkillXP(player, skill, xpReward)

		-- Notify client
		gatherRemote:FireClient(player, "gather", itemDrop, xpReward)

		-- Update client inventory
		local invRemote = Remotes:FindFirstChild("InventoryUpdate")
		if invRemote then
			local data = DataManager.GetData(player)
			invRemote:FireClient(player, data.Inventory)
		end

		-- Use a charge
		nodeData.charges = nodeData.charges - 1

		-- Update label with remaining charges
		if maxCharges > 1 then
			label.Text = (skillEmojis[nodeType] or "") .. " " .. itemDrop .. " (Lv " .. levelReq .. ") [" .. nodeData.charges .. "/" .. maxCharges .. "]"
		end

		-- Deplete if out of charges
		if nodeData.charges <= 0 then
			nodeData.active = false
			for _, child in ipairs(model:GetChildren()) do
				if child:IsA("BasePart") then
					child.Transparency = 0.8
				end
			end
			label.TextTransparency = 1

			-- Respawn
			local respawnTime = Config.ResourceRespawnTime[nodeType] or 15
			task.delay(respawnTime, function()
				nodeData.active = true
				nodeData.charges = maxCharges
				for _, child in ipairs(model:GetChildren()) do
					if child:IsA("BasePart") then
						if child.Name == "FishingSpot" then
							child.Transparency = 0.3
						elseif child.Name == "Leaves" then
							child.Transparency = 0
						else
							child.Transparency = 0
						end
					end
				end
				label.TextTransparency = 0
				if maxCharges > 1 then
					label.Text = (skillEmojis[nodeType] or "") .. " " .. itemDrop .. " (Lv " .. levelReq .. ") [" .. maxCharges .. "/" .. maxCharges .. "]"
				end
			end)
		end
	end

	-- Connect main click
	clickDetector.MouseClick:Connect(onGather)

	-- Connect leaf clicks for trees
	if nodeType == "Tree" then
		for _, child in ipairs(model:GetChildren()) do
			local childClick = child:FindFirstChild("ClickDetector")
			if childClick and child ~= mainPart then
				childClick.MouseClick:Connect(onGather)
			end
		end
	end

	return model
end

-- === SPAWN RESOURCE NODES ===
local WS = game:GetService("Workspace")

-- Wait for MapSetup to run
task.wait(2)
local resourceFolder = WS:FindFirstChild("ResourceNodes")
if not resourceFolder then
	resourceFolder = Instance.new("Folder")
	resourceFolder.Name = "ResourceNodes"
	resourceFolder.Parent = WS
end
print("[SkillManager] ResourceNodes folder ready, spawning nodes...")

-- ============================================================
-- SAFE ZONE RESOURCES
-- ============================================================

-- === HAVEN MINE (copper + iron rocks inside cave) ===
createResourceNode("CopperRock1", "Rock", Vector3.new(-105, 0, 20), resourceFolder, 1, "Copper Ore", 20, 5)
createResourceNode("CopperRock2", "Rock", Vector3.new(-100, 0, 10), resourceFolder, 1, "Copper Ore", 20, 4)
createResourceNode("CopperRock3", "Rock", Vector3.new(-95, 0, 5), resourceFolder, 1, "Copper Ore", 20, 3)
createResourceNode("CopperRock4", "Rock", Vector3.new(-88, 0, 15), resourceFolder, 1, "Copper Ore", 20, 6)
createResourceNode("CopperRock5", "Rock", Vector3.new(-82, 0, 8), resourceFolder, 1, "Copper Ore", 20, 4)

createResourceNode("IronRock1", "Rock", Vector3.new(-105, 0, 3), resourceFolder, 15, "Iron Ore", 35, 3)
createResourceNode("IronRock2", "Rock", Vector3.new(-85, 0, 2), resourceFolder, 15, "Iron Ore", 35, 4)
createResourceNode("IronRock3", "Rock", Vector3.new(-93, 0, 0), resourceFolder, 15, "Iron Ore", 35, 3)

-- A few rocks outside the mine too
createResourceNode("CopperRockOutside1", "Rock", Vector3.new(-80, 0, 40), resourceFolder, 1, "Copper Ore", 20, 3)
createResourceNode("IronRockOutside1", "Rock", Vector3.new(-75, 0, 50), resourceFolder, 15, "Iron Ore", 35, 2)

-- === HAVEN FOREST (oak + willow trees) ===
createResourceNode("OakTree1", "Tree", Vector3.new(100, 0, 25), resourceFolder, 1, "Oak Log", 18, 4)
createResourceNode("OakTree2", "Tree", Vector3.new(112, 0, 35), resourceFolder, 1, "Oak Log", 18, 5)
createResourceNode("OakTree3", "Tree", Vector3.new(125, 0, 20), resourceFolder, 1, "Oak Log", 18, 3)
createResourceNode("OakTree4", "Tree", Vector3.new(108, 0, 45), resourceFolder, 1, "Oak Log", 18, 6)
createResourceNode("OakTree5", "Tree", Vector3.new(135, 0, 50), resourceFolder, 1, "Oak Log", 18, 4)
createResourceNode("OakTree6", "Tree", Vector3.new(140, 0, 30), resourceFolder, 1, "Oak Log", 18, 5)

createResourceNode("WillowTree1", "Tree", Vector3.new(150, 0, 25), resourceFolder, 20, "Willow Log", 40, 3)
createResourceNode("WillowTree2", "Tree", Vector3.new(155, 0, 45), resourceFolder, 20, "Willow Log", 40, 4)
createResourceNode("WillowTree3", "Tree", Vector3.new(145, 0, 60), resourceFolder, 20, "Willow Log", 40, 3)

-- === HAVEN POND (shrimp + trout fishing) ===
createResourceNode("ShrimpSpot1", "FishingSpot", Vector3.new(75, 0, 82), resourceFolder, 1, "Shrimp", 15, 6)
createResourceNode("ShrimpSpot2", "FishingSpot", Vector3.new(85, 0, 78), resourceFolder, 1, "Shrimp", 15, 5)
createResourceNode("ShrimpSpot3", "FishingSpot", Vector3.new(80, 0, 88), resourceFolder, 1, "Shrimp", 15, 7)
createResourceNode("TroutSpot1", "FishingSpot", Vector3.new(72, 0, 75), resourceFolder, 20, "Trout", 35, 4)
createResourceNode("TroutSpot2", "FishingSpot", Vector3.new(88, 0, 85), resourceFolder, 20, "Trout", 35, 3)

-- Lily pond has trout too
createResourceNode("TroutSpot3", "FishingSpot", Vector3.new(108, 0, 58), resourceFolder, 20, "Trout", 35, 4)
createResourceNode("TroutSpot4", "FishingSpot", Vector3.new(114, 0, 62), resourceFolder, 20, "Trout", 35, 5)

-- ============================================================
-- WILDERNESS RESOURCES ‚Äî better loot, more risk
-- ============================================================

-- Gold Rocks (scattered in mid-wilderness)
createResourceNode("GoldRock1", "Rock", Vector3.new(30, 0, -130), resourceFolder, 40, "Gold Ore", 65, 3)
createResourceNode("GoldRock2", "Rock", Vector3.new(45, 0, -145), resourceFolder, 40, "Gold Ore", 65, 2)
createResourceNode("GoldRock3", "Rock", Vector3.new(-20, 0, -135), resourceFolder, 40, "Gold Ore", 65, 4)

-- Runite Rocks (deep wilderness ‚Äî high risk, high reward)
createResourceNode("RuniteRock1", "Rock", Vector3.new(55, 0, -200), resourceFolder, 70, "Runite Ore", 125, 2)
createResourceNode("RuniteRock2", "Rock", Vector3.new(-40, 0, -230), resourceFolder, 70, "Runite Ore", 125, 2)
createResourceNode("RuniteRock3", "Rock", Vector3.new(10, 0, -270), resourceFolder, 70, "Runite Ore", 125, 3)

-- Yew Trees (mid wilderness)
createResourceNode("YewTree1", "Tree", Vector3.new(-30, 0, -130), resourceFolder, 50, "Yew Log", 80, 3)
createResourceNode("YewTree2", "Tree", Vector3.new(-45, 0, -155), resourceFolder, 50, "Yew Log", 80, 4)
createResourceNode("YewTree3", "Tree", Vector3.new(40, 0, -140), resourceFolder, 50, "Yew Log", 80, 3)

-- Magic Trees (deep wilderness ‚Äî rarest resource)
createResourceNode("MagicTree1", "Tree", Vector3.new(-55, 0, -205), resourceFolder, 75, "Magic Log", 150, 2)
createResourceNode("MagicTree2", "Tree", Vector3.new(70, 0, -240), resourceFolder, 75, "Magic Log", 150, 2)

-- Lobster Spots (mid wilderness)
createResourceNode("LobsterSpot1", "FishingSpot", Vector3.new(20, 0, -140), resourceFolder, 40, "Lobster", 60, 4)
createResourceNode("LobsterSpot2", "FishingSpot", Vector3.new(-15, 0, -150), resourceFolder, 40, "Lobster", 60, 3)

-- Dark Crab (deep wilderness dark pond)
createResourceNode("DarkCrabSpot1", "FishingSpot", Vector3.new(-55, 0, -208), resourceFolder, 70, "Dark Crab", 130, 2)
createResourceNode("DarkCrabSpot2", "FishingSpot", Vector3.new(-65, 0, -214), resourceFolder, 70, "Dark Crab", 130, 3)

-- ============================================================
-- NEW AREA RESOURCES
-- ============================================================

-- === HAVEN LAKE (fishing) ===
createResourceNode("LakeShrimpSpot1", "FishingSpot", Vector3.new(-140, 0, 155), resourceFolder, 1, "Shrimp", 15, 8)
createResourceNode("LakeShrimpSpot2", "FishingSpot", Vector3.new(-160, 0, 160), resourceFolder, 1, "Shrimp", 15, 6)
createResourceNode("LakeTroutSpot1", "FishingSpot", Vector3.new(-145, 0, 145), resourceFolder, 20, "Trout", 35, 4)
createResourceNode("LakeTroutSpot2", "FishingSpot", Vector3.new(-130, 0, 150), resourceFolder, 20, "Trout", 35, 5)
createResourceNode("LakeTroutSpot3", "FishingSpot", Vector3.new(-165, 0, 148), resourceFolder, 20, "Trout", 35, 3)

-- === ANCIENT GROVE (willow trees among the ancient ones) ===
createResourceNode("GroveWillow1", "Tree", Vector3.new(-190, 0, 20), resourceFolder, 20, "Willow Log", 40, 4)
createResourceNode("GroveWillow2", "Tree", Vector3.new(-170, 0, 40), resourceFolder, 20, "Willow Log", 40, 3)
createResourceNode("GroveWillow3", "Tree", Vector3.new(-150, 0, 10), resourceFolder, 20, "Willow Log", 40, 5)
createResourceNode("GroveOak1", "Tree", Vector3.new(-200, 0, -10), resourceFolder, 1, "Oak Log", 18, 5)
createResourceNode("GroveOak2", "Tree", Vector3.new(-230, 0, 30), resourceFolder, 1, "Oak Log", 18, 4)

-- === FARMLANDS (a few rocks in the fields) ===
createResourceNode("FarmCopper1", "Rock", Vector3.new(220, 0, 160), resourceFolder, 1, "Copper Ore", 20, 4)
createResourceNode("FarmCopper2", "Rock", Vector3.new(200, 0, 190), resourceFolder, 1, "Copper Ore", 20, 5)

-- === DRAGON'S SPINE (deep wilderness mining ‚Äî gold + runite) ===
createResourceNode("MtnGold1", "Rock", Vector3.new(-140, 2, -290), resourceFolder, 40, "Gold Ore", 65, 3)
createResourceNode("MtnGold2", "Rock", Vector3.new(-110, 2, -310), resourceFolder, 40, "Gold Ore", 65, 4)
createResourceNode("MtnRunite1", "Rock", Vector3.new(-130, 2, -340), resourceFolder, 70, "Runite Ore", 125, 2)
createResourceNode("MtnRunite2", "Rock", Vector3.new(-100, 2, -350), resourceFolder, 70, "Runite Ore", 125, 3)

-- === CURSED SWAMP (dark crabs + lobsters) ===
createResourceNode("SwampLobster1", "FishingSpot", Vector3.new(100, 0, -310), resourceFolder, 40, "Lobster", 60, 4)
createResourceNode("SwampLobster2", "FishingSpot", Vector3.new(130, 0, -330), resourceFolder, 40, "Lobster", 60, 3)
createResourceNode("SwampDarkCrab1", "FishingSpot", Vector3.new(150, 0, -350), resourceFolder, 70, "Dark Crab", 130, 2)

-- === DARK FOREST (yew + magic trees) ===
createResourceNode("DFYew1", "Tree", Vector3.new(100, 0, -160), resourceFolder, 50, "Yew Log", 80, 3)
createResourceNode("DFYew2", "Tree", Vector3.new(150, 0, -180), resourceFolder, 50, "Yew Log", 80, 4)
createResourceNode("DFMagic1", "Tree", Vector3.new(130, 0, -200), resourceFolder, 75, "Magic Log", 150, 2)

-- === THE ABYSS (runite rocks ‚Äî highest risk/reward) ===
createResourceNode("AbyssRunite1", "Rock", Vector3.new(-30, 0, -460), resourceFolder, 70, "Runite Ore", 125, 3)
createResourceNode("AbyssRunite2", "Rock", Vector3.new(30, 0, -480), resourceFolder, 70, "Runite Ore", 125, 2)
createResourceNode("AbyssRunite3", "Rock", Vector3.new(0, 0, -500), resourceFolder, 70, "Runite Ore", 125, 4)

-- === NEW THEMED AREAS (MapSetup4) ===
-- ============================================================

-- === WHISPERING WOODS (X: 200-350, Z: 50-200) - Woodcutting ===
createResourceNode("WWOak1", "Tree", Vector3.new(220, 0, 70), resourceFolder, 1, "Oak Log", 18, 5)
createResourceNode("WWOak2", "Tree", Vector3.new(250, 0, 90), resourceFolder, 1, "Oak Log", 18, 4)
createResourceNode("WWOak3", "Tree", Vector3.new(280, 0, 120), resourceFolder, 1, "Oak Log", 18, 6)
createResourceNode("WWOak4", "Tree", Vector3.new(310, 0, 150), resourceFolder, 1, "Oak Log", 18, 5)
createResourceNode("WWWillow1", "Tree", Vector3.new(230, 0, 110), resourceFolder, 20, "Willow Log", 40, 4)
createResourceNode("WWWillow2", "Tree", Vector3.new(270, 0, 160), resourceFolder, 20, "Willow Log", 40, 3)
createResourceNode("WWWillow3", "Tree", Vector3.new(320, 0, 180), resourceFolder, 20, "Willow Log", 40, 4)

-- === DEEP MINE (X: -300 to -200, Z: -50 to 50) - Mining ===
createResourceNode("DMCopper1", "Rock", Vector3.new(-280, 0, -30), resourceFolder, 1, "Copper Ore", 20, 6)
createResourceNode("DMCopper2", "Rock", Vector3.new(-260, 0, -10), resourceFolder, 1, "Copper Ore", 20, 5)
createResourceNode("DMCopper3", "Rock", Vector3.new(-240, 0, 20), resourceFolder, 1, "Copper Ore", 20, 4)
createResourceNode("DMIron1", "Rock", Vector3.new(-290, 0, 10), resourceFolder, 15, "Iron Ore", 35, 4)
createResourceNode("DMIron2", "Rock", Vector3.new(-270, 0, 30), resourceFolder, 15, "Iron Ore", 35, 3)
createResourceNode("DMIron3", "Rock", Vector3.new(-220, 0, -20), resourceFolder, 15, "Iron Ore", 35, 4)
createResourceNode("DMGold1", "Rock", Vector3.new(-285, 0, 0), resourceFolder, 40, "Gold Ore", 65, 3)
createResourceNode("DMGold2", "Rock", Vector3.new(-250, 0, 40), resourceFolder, 40, "Gold Ore", 65, 2)

-- === CRYSTAL CAVERN (X: -350 to -250, Z: -150 to -80) - Mining ===
createResourceNode("CCGold1", "Rock", Vector3.new(-330, 0, -120), resourceFolder, 40, "Gold Ore", 65, 3)
createResourceNode("CCGold2", "Rock", Vector3.new(-300, 0, -100), resourceFolder, 40, "Gold Ore", 65, 4)
createResourceNode("CCRunite1", "Rock", Vector3.new(-320, 0, -140), resourceFolder, 70, "Runite Ore", 125, 2)
createResourceNode("CCRunite2", "Rock", Vector3.new(-280, 0, -120), resourceFolder, 70, "Runite Ore", 125, 3)

-- === MOONLIT POND (X: 250-320, Z: -50 to 20) - Fishing ===
createResourceNode("MPShrimp1", "FishingSpot", Vector3.new(270, 0, -30), resourceFolder, 1, "Shrimp", 15, 7)
createResourceNode("MPShrimp2", "FishingSpot", Vector3.new(290, 0, -10), resourceFolder, 1, "Shrimp", 15, 6)
createResourceNode("MPTrout1", "FishingSpot", Vector3.new(280, 0, 0), resourceFolder, 20, "Trout", 35, 5)
createResourceNode("MPTrout2", "FishingSpot", Vector3.new(300, 0, -20), resourceFolder, 20, "Trout", 35, 4)
createResourceNode("MPLobster1", "FishingSpot", Vector3.new(285, 0, -15), resourceFolder, 40, "Lobster", 60, 3)

-- === THORNWOOD THICKET (X: -200 to -100, Z: 200-350) - Woodcutting ===
createResourceNode("TTOak1", "Tree", Vector3.new(-180, 0, 220), resourceFolder, 1, "Oak Log", 18, 4)
createResourceNode("TTOak2", "Tree", Vector3.new(-150, 0, 250), resourceFolder, 1, "Oak Log", 18, 5)
createResourceNode("TTWillow1", "Tree", Vector3.new(-170, 0, 280), resourceFolder, 20, "Willow Log", 40, 3)
createResourceNode("TTWillow2", "Tree", Vector3.new(-130, 0, 310), resourceFolder, 20, "Willow Log", 40, 4)
createResourceNode("TTYew1", "Tree", Vector3.new(-160, 0, 330), resourceFolder, 50, "Yew Log", 80, 3)

-- === SUNFLOWER FIELDS (X: 100-250, Z: 250-380) - Low level nodes ===
createResourceNode("SFCopper1", "Rock", Vector3.new(130, 0, 280), resourceFolder, 1, "Copper Ore", 20, 4)
createResourceNode("SFCopper2", "Rock", Vector3.new(180, 0, 320), resourceFolder, 1, "Copper Ore", 20, 3)
createResourceNode("SFOak1", "Tree", Vector3.new(150, 0, 360), resourceFolder, 1, "Oak Log", 18, 5)
createResourceNode("SFOak2", "Tree", Vector3.new(200, 0, 340), resourceFolder, 1, "Oak Log", 18, 4)

-- === ABANDONED QUARRY (X: -150 to -50, Z: -250 to -150) - Mining ===
createResourceNode("AQIron1", "Rock", Vector3.new(-130, 0, -220), resourceFolder, 15, "Iron Ore", 35, 4)
createResourceNode("AQIron2", "Rock", Vector3.new(-100, 0, -200), resourceFolder, 15, "Iron Ore", 35, 3)
createResourceNode("AQIron3", "Rock", Vector3.new(-80, 0, -230), resourceFolder, 15, "Iron Ore", 35, 5)
createResourceNode("AQGold1", "Rock", Vector3.new(-120, 0, -180), resourceFolder, 40, "Gold Ore", 65, 3)
createResourceNode("AQGold2", "Rock", Vector3.new(-90, 0, -210), resourceFolder, 40, "Gold Ore", 65, 2)

local totalNodes = 0
for _, _ in ipairs(resourceFolder:GetChildren()) do totalNodes = totalNodes + 1 end
print("[SkillManager] Resource nodes spawned - " .. totalNodes .. " nodes total")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="54">
      <Properties>
        <string name="Name">SmithingManager</string>
        <token name="RunContext">0</token>
        <string name="Source">--[[
	SmithingManager.server.lua
	Server-side smithing system for the Wilderness MMO.
	Smelt ores into bars at furnace, smith bars into equipment at anvil.
	Gives Smithing XP and skill progression.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local DataManager = require(ReplicatedStorage.Modules.DataManager)
local ItemDatabase = require(ReplicatedStorage.Modules.ItemDatabase)

------------------------------------------------------------
-- Remote Events
------------------------------------------------------------
local function getOrCreateRemote(name: string): RemoteEvent
	local existing = ReplicatedStorage:FindFirstChild(name)
	if existing then return existing end
	local remote = Instance.new("RemoteEvent")
	remote.Name = name
	remote.Parent = ReplicatedStorage
	return remote
end

local StartSmithingEvent = getOrCreateRemote("StartSmithing")
local SmithingProgressEvent = getOrCreateRemote("SmithingProgress")
local SmithingCompleteEvent = getOrCreateRemote("SmithingComplete")

------------------------------------------------------------
-- Smithing Recipes
------------------------------------------------------------

-- Smelting: Ore -> Bar
local SmeltingRecipes = {
	["Copper Ore"] = {
		result = "Copper Bar",
		baseTime = 4,
		baseXP = 17.5,
		levelRequired = 1,
	},
	["Iron Ore"] = {
		result = "Iron Bar",
		baseTime = 5,
		baseXP = 25,
		levelRequired = 15,
	},
	["Gold Ore"] = {
		result = "Gold Bar",
		baseTime = 6,
		baseXP = 56.2,
		levelRequired = 40,
	},
	["Runite Ore"] = {
		result = "Runite Bar",
		baseTime = 8,
		baseXP = 125,
		levelRequired = 85,
	},
}

-- Smithing: Bar -> Equipment
local SmithingRecipes = {
	-- Copper Equipment
	["Copper Bar"] = {
		{ result = "Copper Sword", bars = 1, baseTime = 5, baseXP = 37.5, levelRequired = 1 },
		{ result = "Copper Dagger", bars = 1, baseTime = 3, baseXP = 25, levelRequired = 1 },
		{ result = "Copper Axe", bars = 1, baseTime = 4, baseXP = 31.2, levelRequired = 1 },
		{ result = "Copper Mace", bars = 1, baseTime = 4, baseXP = 31.2, levelRequired = 2 },
		{ result = "Copper Shield", bars = 2, baseTime = 6, baseXP = 50, levelRequired = 3 },
	},
	-- Iron Equipment
	["Iron Bar"] = {
		{ result = "Iron Sword", bars = 1, baseTime = 6, baseXP = 50, levelRequired = 19 },
		{ result = "Iron Dagger", bars = 1, baseTime = 4, baseXP = 37.5, levelRequired = 15 },
		{ result = "Iron Axe", bars = 1, baseTime = 5, baseXP = 43.7, levelRequired = 16 },
		{ result = "Iron Mace", bars = 1, baseTime = 5, baseXP = 43.7, levelRequired = 17 },
		{ result = "Iron Shield", bars = 2, baseTime = 7, baseXP = 75, levelRequired = 18 },
		{ result = "Iron Helmet", bars = 1, baseTime = 5, baseXP = 43.7, levelRequired = 20 },
		{ result = "Iron Platebody", bars = 3, baseTime = 8, baseXP = 112.5, levelRequired = 23 },
	},
	-- Gold Equipment (decorative/special)
	["Gold Bar"] = {
		{ result = "Gold Ring", bars = 1, baseTime = 3, baseXP = 75, levelRequired = 40 },
		{ result = "Gold Amulet", bars = 1, baseTime = 4, baseXP = 87.5, levelRequired = 45 },
		{ result = "Gold Bracelet", bars = 1, baseTime = 3, baseXP = 75, levelRequired = 42 },
	},
	-- Runite Equipment (highest tier)
	["Runite Bar"] = {
		{ result = "Runite Sword", bars = 1, baseTime = 10, baseXP = 200, levelRequired = 89 },
		{ result = "Runite Dagger", bars = 1, baseTime = 8, baseXP = 175, levelRequired = 85 },
		{ result = "Runite Axe", bars = 1, baseTime = 9, baseXP = 187.5, levelRequired = 86 },
		{ result = "Runite Shield", bars = 2, baseTime = 12, baseXP = 350, levelRequired = 90 },
		{ result = "Runite Helmet", bars = 1, baseTime = 9, baseXP = 187.5, levelRequired = 87 },
		{ result = "Runite Platebody", bars = 3, baseTime = 15, baseXP = 525, levelRequired = 95 },
	},
}

------------------------------------------------------------
-- Active Smithing Sessions
------------------------------------------------------------
local activeSmithingSessions = {} -- [player] = { recipe, startTime, station, totalTime, type }

------------------------------------------------------------
-- Helpers
------------------------------------------------------------
local function getSkillLevel(player: Player, skillName: string): number
	local playerData = DataManager:GetPlayerData(player)
	if not playerData or not playerData.Skills or not playerData.Skills[skillName] then
		return 1
	end
	local xp = playerData.Skills[skillName]
	local level = 1
	local totalXP = 0
	while totalXP &lt; xp and level &lt; 99 do
		level = level + 1
		totalXP = totalXP + math.floor(level * 10.5)
	end
	return level - 1
end

local function addSmithingXP(player: Player, xp: number)
	local playerData = DataManager:GetPlayerData(player)
	if not playerData then return end

	playerData.Skills = playerData.Skills or {}
	playerData.Skills.Smithing = (playerData.Skills.Smithing or 0) + xp

	local xpUpdateEvent = ReplicatedStorage:FindFirstChild("XPUpdate")
	if xpUpdateEvent and xpUpdateEvent:IsA("RemoteEvent") then
		xpUpdateEvent:FireClient(player, "Smithing", xp)
	end

	DataManager:SavePlayerData(player)
end

local function hasItem(player: Player, itemName: string, quantity: number): boolean
	local playerData = DataManager:GetPlayerData(player)
	if not playerData or not playerData.Inventory then return false end

	local count = 0
	for _, invItem in ipairs(playerData.Inventory) do
		if invItem.name == itemName then
			count = count + invItem.quantity
		end
	end
	return count >= quantity
end

local function removeItem(player: Player, itemName: string, quantity: number): boolean
	local playerData = DataManager:GetPlayerData(player)
	if not playerData or not playerData.Inventory then return false end

	local removed = 0
	for i = #playerData.Inventory, 1, -1 do
		local invItem = playerData.Inventory[i]
		if invItem.name == itemName then
			local removeFromThis = math.min(invItem.quantity, quantity - removed)
			invItem.quantity = invItem.quantity - removeFromThis
			removed = removed + removeFromThis

			if invItem.quantity &lt;= 0 then
				table.remove(playerData.Inventory, i)
			end

			if removed >= quantity then
				break
			end
		end
	end

	if removed >= quantity then
		DataManager:SavePlayerData(player)
		return true
	end
	return false
end

local function addItem(player: Player, itemName: string, quantity: number)
	local playerData = DataManager:GetPlayerData(player)
	if not playerData then return end

	playerData.Inventory = playerData.Inventory or {}
	
	local itemData = ItemDatabase.Items[itemName]
	if itemData and itemData.stackable then
		local found = false
		for _, invItem in ipairs(playerData.Inventory) do
			if invItem.name == itemName then
				invItem.quantity = invItem.quantity + quantity
				found = true
				break
			end
		end
		if not found then
			table.insert(playerData.Inventory, {name = itemName, quantity = quantity})
		end
	else
		for i = 1, quantity do
			table.insert(playerData.Inventory, {name = itemName, quantity = 1})
		end
	end

	DataManager:SavePlayerData(player)
end

local function findNearbyFurnace(player: Player): Part?
	local character = player.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") then return nil end

	local position = character.HumanoidRootPart.Position
	local furnaces = workspace:FindFirstChild("SmithingStations")
	if not furnaces then return nil end

	for _, station in ipairs(furnaces:GetChildren()) do
		if station:IsA("Part") and station.Name:find("Furnace") then
			local distance = (station.Position - position).Magnitude
			if distance &lt;= 5 then
				return station
			end
		end
	end
	return nil
end

local function findNearbyAnvil(player: Player): Part?
	local character = player.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") then return nil end

	local position = character.HumanoidRootPart.Position
	local anvils = workspace:FindFirstChild("SmithingStations")
	if not anvils then return nil end

	for _, station in ipairs(anvils:GetChildren()) do
		if station:IsA("Part") and station.Name:find("Anvil") then
			local distance = (station.Position - position).Magnitude
			if distance &lt;= 5 then
				return station
			end
		end
	end
	return nil
end

------------------------------------------------------------
-- Smithing Logic
------------------------------------------------------------
local function startSmelting(player: Player, oreItemName: string)
	if activeSmithingSessions[player] then return end

	local recipe = SmeltingRecipes[oreItemName]
	if not recipe then return end

	local smithingLevel = getSkillLevel(player, "Smithing")
	if smithingLevel &lt; recipe.levelRequired then return end

	if not hasItem(player, oreItemName, 1) then return end

	local furnace = findNearbyFurnace(player)
	if not furnace then return end

	if not removeItem(player, oreItemName, 1) then return end

	local totalTime = recipe.baseTime
	activeSmithingSessions[player] = {
		recipe = recipe,
		startTime = tick(),
		station = furnace,
		totalTime = totalTime,
		sourceItem = oreItemName,
		type = "smelting"
	}

	SmithingProgressEvent:FireClient(player, {
		action = "start",
		totalTime = totalTime,
		itemName = oreItemName,
		type = "smelting"
	})

	print("[SmithingManager]", player.Name, "started smelting", oreItemName)
end

local function startSmithing(player: Player, barItemName: string, equipmentName: string)
	if activeSmithingSessions[player] then return end

	local recipes = SmithingRecipes[barItemName]
	if not recipes then return end

	local recipe = nil
	for _, r in ipairs(recipes) do
		if r.result == equipmentName then
			recipe = r
			break
		end
	end
	if not recipe then return end

	local smithingLevel = getSkillLevel(player, "Smithing")
	if smithingLevel &lt; recipe.levelRequired then return end

	if not hasItem(player, barItemName, recipe.bars) then return end

	local anvil = findNearbyAnvil(player)
	if not anvil then return end

	if not removeItem(player, barItemName, recipe.bars) then return end

	local totalTime = recipe.baseTime
	activeSmithingSessions[player] = {
		recipe = recipe,
		startTime = tick(),
		station = anvil,
		totalTime = totalTime,
		sourceItem = barItemName,
		type = "smithing"
	}

	SmithingProgressEvent:FireClient(player, {
		action = "start",
		totalTime = totalTime,
		itemName = equipmentName,
		type = "smithing"
	})

	print("[SmithingManager]", player.Name, "started smithing", equipmentName)
end

local function completeSmithing(player: Player, session)
	local recipe = session.recipe
	local resultItem = recipe.result
	local xpGained = recipe.baseXP

	addItem(player, resultItem, 1)
	addSmithingXP(player, xpGained)

	SmithingCompleteEvent:FireClient(player, {
		result = resultItem,
		xpGained = xpGained,
		type = session.type
	})

	-- Fire quest event
	local questCraftEvent = ReplicatedStorage:FindFirstChild("QuestCraftEvent")
	if questCraftEvent and questCraftEvent:IsA("BindableEvent") then
		questCraftEvent:Fire(player, resultItem, 1)
	end

	print("[SmithingManager]", player.Name, "completed", session.type, ":", resultItem, "XP:", xpGained)
end

------------------------------------------------------------
-- Update Loop
------------------------------------------------------------
local function updateSmithingSessions()
	local currentTime = tick()

	for player, session in pairs(activeSmithingSessions) do
		local elapsed = currentTime - session.startTime
		local progress = elapsed / session.totalTime

		-- Check if player is still near the station
		local character = player.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			local distance = (character.HumanoidRootPart.Position - session.station.Position).Magnitude
			if distance > 10 then
				-- Player moved too far, cancel
				activeSmithingSessions[player] = nil
				SmithingProgressEvent:FireClient(player, {action = "cancel"})
				-- Return materials
				if session.type == "smelting" then
					addItem(player, session.sourceItem, 1)
				else
					addItem(player, session.sourceItem, session.recipe.bars)
				end
				continue
			end
		end

		if progress >= 1 then
			completeSmithing(player, session)
			activeSmithingSessions[player] = nil
		else
			SmithingProgressEvent:FireClient(player, {
				action = "progress",
				progress = progress
			})
		end
	end
end

RunService.Heartbeat:Connect(updateSmithingSessions)

------------------------------------------------------------
-- Event Handlers
------------------------------------------------------------
StartSmithingEvent.OnServerEvent:Connect(function(player: Player, actionType: string, sourceItem: string, targetItem: string?)
	if actionType == "smelt" then
		startSmelting(player, sourceItem)
	elseif actionType == "smith" then
		startSmithing(player, sourceItem, targetItem)
	end
end)

Players.PlayerRemoving:Connect(function(player: Player)
	activeSmithingSessions[player] = nil
end)

print("[SmithingManager] Smithing system initialized")</string>
      </Properties>
    </Item>
    <Item class="Script" referent="55">
      <Properties>
        <string name="Name">StatsPanelHandler</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	StatsPanelHandler.server.lua
	Handles GetStatsPanel RemoteFunction + GetSkillData RemoteFunction
	Returns player skills, inventory, equipment, and combat level
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DataManager = require(ReplicatedStorage.Modules.DataManager)
local Config = require(ReplicatedStorage.Modules.Config)
local ItemDatabase = require(ReplicatedStorage.Modules.ItemDatabase)

-- Wait for remotes
task.wait(2)

local GetStatsPanel = ReplicatedStorage.Remotes:WaitForChild("GetStatsPanel", 10)
local GetSkillData = ReplicatedStorage.Remotes:WaitForChild("GetSkillData", 10)

--------------------------------------------------------------------------------
-- SKILL NAMES
--------------------------------------------------------------------------------
local SKILL_NAMES = {"Mining", "Woodcutting", "Fishing", "Smithing", "Cooking", "Strength", "Defense", "Ranged", "Fletching", "Prayer"}

--------------------------------------------------------------------------------
-- GetStatsPanel ‚Üí returns full panel data
--------------------------------------------------------------------------------
if GetStatsPanel then
	GetStatsPanel.OnServerInvoke = function(player)
		local data = DataManager.GetData(player)
		if not data then return nil end

		-- Skills (return flat level numbers ‚Äî client expects numbers not tables)
		local skills = {}
		for _, skillName in SKILL_NAMES do
			local level = 1
			if data.Skills and data.Skills[skillName] ~= nil then
				level = Config.GetLevelFromXP(data.Skills[skillName])
			end
			skills[skillName] = level
		end

		-- Inventory (format for client: {name, count, rarity})
		-- DataManager stores Inventory as array of {name=, quantity=}
		local inventory = {}
		local inv = data.Inventory or {}
		for _, slot in ipairs(inv) do
			if slot.name and slot.quantity and slot.quantity > 0 then
				local itemDef = ItemDatabase.Items[slot.name]
				local rarity = "common"
				local itemType = "resource"
				if itemDef then
					rarity = itemDef.rarity or "common"
					itemType = itemDef.type or "resource"
				end
				table.insert(inventory, {
					name = slot.name,
					count = slot.quantity,
					rarity = rarity,
					itemType = itemType,
				})
			end
		end

		-- Equipment (placeholder ‚Äî expand when equip system is built)
		local equipment = data.Equipment or {
			Head = "",
			Body = "",
			Legs = "",
			Weapon = "",
			Shield = "",
		}

		-- Combat level (simple: average of all skill levels, or dedicated combat level)
		local combatLevel = data.CombatLevel or 1
		if not data.CombatLevel then
			local total = 0
			local count = 0
			for _, lvl in pairs(skills) do
				total = total + lvl
				count = count + 1
			end
			combatLevel = math.floor(total / math.max(count, 1))
		end

		-- Gold
		local gold = data.Gold or 0

		return {
			skills = skills,
			inventory = inventory,
			equipment = equipment,
			combatLevel = combatLevel,
			gold = gold,
			hotbar = data.Hotbar or {},
		}
	end
	print("[StatsPanelHandler] GetStatsPanel ready")
end

--------------------------------------------------------------------------------
-- GetSkillData ‚Üí returns skill tree data (for SkillTreeUI)
--------------------------------------------------------------------------------
if GetSkillData then
	GetSkillData.OnServerInvoke = function(player)
		local data = DataManager.GetData(player)
		if not data then return nil end

		local skills = {}
		for _, skillName in SKILL_NAMES do
			local level = 1
			local xp = 0
			if data.Skills and data.Skills[skillName] ~= nil then
				xp = data.Skills[skillName]
				level = Config.GetLevelFromXP(xp)
			end
			skills[skillName] = {
				level = level,
				xp = xp,
			}
		end
		return skills
	end
	print("[StatsPanelHandler] GetSkillData ready")
end
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="56">
      <Properties>
        <string name="Name">TradeManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	TradeManager.server.lua
	Server-side trading system for a RuneScape-inspired full-loot PvP MMO.
	Handles trade requests, validation, item swapping, and timeouts.
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Ensure Remotes folder exists
local Remotes = ReplicatedStorage:FindFirstChild("Remotes")
if not Remotes then
	Remotes = Instance.new("Folder")
	Remotes.Name = "Remotes"
	Remotes.Parent = ReplicatedStorage
end

-- Create remote events
local remoteNames = { "TradeRequest", "TradeResponse", "TradeUpdate", "TradeConfirm", "TradeCancel", "TradeComplete" }
local remotes = {}
for _, name in remoteNames do
	local existing = Remotes:FindFirstChild(name)
	if existing then
		remotes[name] = existing
	else
		local re = Instance.new("RemoteEvent")
		re.Name = name
		re.Parent = Remotes
		remotes[name] = re
	end
end

-- DataManager module for inventory operations
local DataManager = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("DataManager"))

--------------------------------------------------------------------------------
-- Types & State
--------------------------------------------------------------------------------

type TradeSession = {
	player1: Player,
	player2: Player,
	items1: { [string]: number },  -- itemName -> quantity
	items2: { [string]: number },
	confirmed1: boolean,
	confirmed2: boolean,
	lastActivity: number,
}

-- Active trades keyed by a canonical trade ID (sorted UserId pair)
local activeTrades: { [string]: TradeSession } = {}

-- Map each player to their current trade ID (one trade at a time)
local playerTrade: { [number]: string } = {}

-- Pending trade requests: requester -> target UserId
local pendingRequests: { [number]: number } = {}

local TRADE_TIMEOUT = 60  -- seconds of inactivity before auto-cancel
local WILDERNESS_Z_THRESHOLD = -100

--------------------------------------------------------------------------------
-- Helpers
--------------------------------------------------------------------------------

--- Build a deterministic trade ID from two players.
local function tradeId(p1: Player, p2: Player): string
	local a, b = math.min(p1.UserId, p2.UserId), math.max(p1.UserId, p2.UserId)
	return `{a}_{b}`
end

--- Check if a player is in the wilderness (Z < -100).
local function isInWilderness(player: Player): boolean
	local char = player.Character
	if not char then return true end
	local root = char:FindFirstChild("HumanoidRootPart")
	if not root then return true end
	return root.Position.Z < WILDERNESS_Z_THRESHOLD
end

--- Validate that a player actually owns all offered items.
local function validateItems(player: Player, items: { [string]: number }): boolean
	local data = DataManager.GetData(player)
	if not data then return false end
	local inventory = data.Inventory or data.inventory or {}
	for itemName, qty in items do
		if qty <= 0 then return false end
		local owned = inventory[itemName] or 0
		if owned < qty then return false end
	end
	return true
end

--- Send a trade state snapshot to both players.
local function broadcastTradeState(session: TradeSession)
	local payload = {
		items1 = session.items1,
		items2 = session.items2,
		confirmed1 = session.confirmed1,
		confirmed2 = session.confirmed2,
		partner1 = session.player1.Name,
		partner2 = session.player2.Name,
	}
	remotes.TradeUpdate:FireClient(session.player1, payload)
	remotes.TradeUpdate:FireClient(session.player2, payload)
end

--- Cancel and clean up a trade session.
local function cancelTrade(id: string, reason: string?)
	local session = activeTrades[id]
	if not session then return end

	activeTrades[id] = nil
	playerTrade[session.player1.UserId] = nil
	playerTrade[session.player2.UserId] = nil

	local msg = reason or "Trade cancelled."
	pcall(function() remotes.TradeCancel:FireClient(session.player1, msg) end)
	pcall(function() remotes.TradeCancel:FireClient(session.player2, msg) end)
end

--- Execute a confirmed trade: swap items between players.
local function executeTrade(id: string)
	local session = activeTrades[id]
	if not session then return end

	local p1, p2 = session.player1, session.player2

	-- Final validation
	if isInWilderness(p1) or isInWilderness(p2) then
		cancelTrade(id, "Cannot trade in the Wilderness!")
		return
	end
	if not validateItems(p1, session.items1) then
		cancelTrade(id, `{p1.Name} no longer has the offered items.`)
		return
	end
	if not validateItems(p2, session.items2) then
		cancelTrade(id, `{p2.Name} no longer has the offered items.`)
		return
	end

	-- Remove items from both players
	for itemName, qty in session.items1 do
		DataManager.RemoveFromInventory(p1, itemName, qty)
	end
	for itemName, qty in session.items2 do
		DataManager.RemoveFromInventory(p2, itemName, qty)
	end

	-- Add swapped items
	for itemName, qty in session.items1 do
		DataManager.AddToInventory(p2, itemName, qty)
	end
	for itemName, qty in session.items2 do
		DataManager.AddToInventory(p1, itemName, qty)
	end

	-- Clean up and notify
	activeTrades[id] = nil
	playerTrade[p1.UserId] = nil
	playerTrade[p2.UserId] = nil

	local summary = { items1 = session.items1, items2 = session.items2 }
	pcall(function() remotes.TradeComplete:FireClient(p1, summary) end)
	pcall(function() remotes.TradeComplete:FireClient(p2, summary) end)

	print(`[TradeManager] Trade completed: {p1.Name} <-> {p2.Name}`)
end

--------------------------------------------------------------------------------
-- Remote Event Handlers
--------------------------------------------------------------------------------

-- TradeRequest: player requests to trade with targetPlayer (by UserId)
remotes.TradeRequest.OnServerEvent:Connect(function(player: Player, targetUserId: number)
	-- Validate inputs
	if typeof(targetUserId) ~= "number" then return end
	local target = Players:GetPlayerByUserId(targetUserId)
	if not target or target == player then return end

	-- Can't trade if either player is already in a trade
	if playerTrade[player.UserId] then
		remotes.TradeCancel:FireClient(player, "You are already in a trade.")
		return
	end
	if playerTrade[target.UserId] then
		remotes.TradeCancel:FireClient(player, `{target.Name} is already trading.`)
		return
	end

	-- Wilderness check
	if isInWilderness(player) or isInWilderness(target) then
		remotes.TradeCancel:FireClient(player, "Cannot trade in the Wilderness!")
		return
	end

	-- Store pending request and notify target
	pendingRequests[player.UserId] = target.UserId
	remotes.TradeRequest:FireClient(target, player.UserId, player.Name)
	print(`[TradeManager] {player.Name} sent trade request to {target.Name}`)
end)

-- TradeResponse: target accepts or declines a pending request
remotes.TradeResponse.OnServerEvent:Connect(function(player: Player, requesterUserId: number, accepted: boolean)
	if typeof(requesterUserId) ~= "number" or typeof(accepted) ~= "boolean" then return end

	local requester = Players:GetPlayerByUserId(requesterUserId)
	if not requester then return end

	-- Verify the pending request exists and matches
	if pendingRequests[requesterUserId] ~= player.UserId then return end
	pendingRequests[requesterUserId] = nil

	if not accepted then
		remotes.TradeCancel:FireClient(requester, `{player.Name} declined your trade request.`)
		return
	end

	-- Re-check availability
	if playerTrade[player.UserId] or playerTrade[requester.UserId] then
		remotes.TradeCancel:FireClient(requester, "Trade no longer available.")
		remotes.TradeCancel:FireClient(player, "Trade no longer available.")
		return
	end

	-- Create the trade session
	local id = tradeId(requester, player)
	local session: TradeSession = {
		player1 = requester,
		player2 = player,
		items1 = {},
		items2 = {},
		confirmed1 = false,
		confirmed2 = false,
		lastActivity = os.clock(),
	}
	activeTrades[id] = session
	playerTrade[requester.UserId] = id
	playerTrade[player.UserId] = id

	broadcastTradeState(session)
	print(`[TradeManager] Trade started: {requester.Name} <-> {player.Name}`)
end)

-- TradeUpdate: player adds or removes an item from their offer
-- payload: { action = "add" | "remove", item = string, quantity = number }
remotes.TradeUpdate.OnServerEvent:Connect(function(player: Player, payload)
	if typeof(payload) ~= "table" then return end

	local id = playerTrade[player.UserId]
	if not id then return end
	local session = activeTrades[id]
	if not session then return end

	local action = payload.action
	local itemName = payload.item
	local qty = payload.quantity

	if typeof(action) ~= "string" or typeof(itemName) ~= "string" or typeof(qty) ~= "number" then return end
	qty = math.floor(qty)
	if qty <= 0 then return end

	-- Determine which side this player is on
	local items = if player == session.player1 then session.items1 else session.items2

	if action == "add" then
		items[itemName] = (items[itemName] or 0) + qty
		-- Validate the total offered doesn't exceed owned
		if not validateItems(player, if player == session.player1 then session.items1 else session.items2) then
			items[itemName] = (items[itemName] :: number) - qty
			if items[itemName] <= 0 then items[itemName] = nil end
			return
		end
	elseif action == "remove" then
		if not items[itemName] then return end
		items[itemName] = math.max(0, (items[itemName] :: number) - qty)
		if items[itemName] <= 0 then items[itemName] = nil end
	else
		return
	end

	-- Any item change resets both confirmations
	session.confirmed1 = false
	session.confirmed2 = false
	session.lastActivity = os.clock()

	broadcastTradeState(session)
end)

-- TradeConfirm: player confirms their side of the trade
remotes.TradeConfirm.OnServerEvent:Connect(function(player: Player)
	local id = playerTrade[player.UserId]
	if not id then return end
	local session = activeTrades[id]
	if not session then return end

	if player == session.player1 then
		session.confirmed1 = true
	else
		session.confirmed2 = true
	end
	session.lastActivity = os.clock()

	broadcastTradeState(session)

	-- If both confirmed, execute
	if session.confirmed1 and session.confirmed2 then
		executeTrade(id)
	end
end)

-- TradeCancel: player cancels the trade
remotes.TradeCancel.OnServerEvent:Connect(function(player: Player)
	local id = playerTrade[player.UserId]
	if not id then return end
	cancelTrade(id, `{player.Name} cancelled the trade.`)
end)

--------------------------------------------------------------------------------
-- Timeout Loop
--------------------------------------------------------------------------------

RunService.Heartbeat:Connect(function()
	local now = os.clock()
	for id, session in activeTrades do
		if now - session.lastActivity >= TRADE_TIMEOUT then
			cancelTrade(id, "Trade timed out due to inactivity.")
		end
	end
end)

--------------------------------------------------------------------------------
-- Player cleanup on disconnect
--------------------------------------------------------------------------------

Players.PlayerRemoving:Connect(function(player: Player)
	-- Cancel active trade
	local id = playerTrade[player.UserId]
	if id then
		cancelTrade(id, `{player.Name} disconnected.`)
	end
	-- Clear pending requests
	pendingRequests[player.UserId] = nil
end)

print("[TradeManager] Trade system active!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="57">
      <Properties>
        <string name="Name">VisualEquipment</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local DataManager = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("DataManager"))

-- Create a BindableEvent for other scripts to signal equipment changes
local equipChanged = Instance.new("BindableEvent")
equipChanged.Name = "EquipmentChanged"
equipChanged.Parent = ReplicatedStorage

-- Also listen to the equip/unequip remotes directly
local equipItemEvent = ReplicatedStorage:FindFirstChild("EquipItem") or (ReplicatedStorage:FindFirstChild("Remotes") and ReplicatedStorage.Remotes:FindFirstChild("EquipItem"))
local unequipItemEvent = ReplicatedStorage:FindFirstChild("UnequipItem") or (ReplicatedStorage:FindFirstChild("Remotes") and ReplicatedStorage.Remotes:FindFirstChild("UnequipItem"))

if not equipItemEvent then
	equipItemEvent = ReplicatedStorage:WaitForChild("EquipItem", 15)
end
if not unequipItemEvent then
	unequipItemEvent = ReplicatedStorage:WaitForChild("UnequipItem", 15)
end

--------------------------------------------------------------------------------
-- Helpers
--------------------------------------------------------------------------------

local function clearVisual(character, tag)
	for _, child in ipairs(character:GetChildren()) do
		if child.Name == tag then
			child:Destroy()
		end
	end
end

local function clearBodyColors(character, partNames)
	for _, name in ipairs(partNames) do
		local part = character:FindFirstChild(name)
		if part and part:IsA("BasePart") then
			local orig = part:FindFirstChild("_OriginalColor")
			if orig then
				part.Color = Color3.new(orig.Value.X, orig.Value.Y, orig.Value.Z)
			end
		end
	end
end

local function saveOriginalColor(part)
	if not part:FindFirstChild("_OriginalColor") then
		local v = Instance.new("Vector3Value")
		v.Name = "_OriginalColor"
		v.Value = Vector3.new(part.Color.R, part.Color.G, part.Color.B)
		v.Parent = part
	end
end

local function createAttachedPart(character, attachTo, tag, size, color, offset)
	clearVisual(character, tag)
	local limb = character:FindFirstChild(attachTo)
	if not limb then return nil end

	local part = Instance.new("Part")
	part.Name = tag
	part.Size = size
	part.Color = color
	part.Material = Enum.Material.SmoothPlastic
	part.CanCollide = false
	part.Massless = true
	part.Anchored = false
	part.CFrame = limb.CFrame * offset
	part.Parent = character

	local weld = Instance.new("WeldConstraint")
	weld.Part0 = limb
	weld.Part1 = part
	weld.Parent = part

	return part
end

-- Create a part welded to another part (not the limb directly)
local function createSubPart(parent, rootPart, name, size, color, offset, material)
	local part = Instance.new("Part")
	part.Name = name
	part.Size = size
	part.Color = color
	part.Material = material or Enum.Material.SmoothPlastic
	part.CanCollide = false
	part.Massless = true
	part.Anchored = false
	part.CFrame = rootPart.CFrame * offset
	part.Parent = parent

	local weld = Instance.new("WeldConstraint")
	weld.Part0 = rootPart
	weld.Part1 = part
	weld.Parent = part

	return part
end

-- Create a multi-part model welded to a limb, tagged with tag
local function createModelOnLimb(character, attachTo, tag, builderFn, skipFlip)
	clearVisual(character, tag)
	local limb = character:FindFirstChild(attachTo)
	if not limb then return nil end

	local model = Instance.new("Model")
	model.Name = tag
	model.Parent = character

	local rootPart = builderFn(model, limb)
	if rootPart then
		if skipFlip then
			-- Helmets/shields: position directly on limb without weapon flip
			rootPart.CFrame = limb.CFrame * rootPart.CFrame
		else
			-- Weapons: Flip 180 on Z so blade points UP (away from hand), not down
			rootPart.CFrame = limb.CFrame * CFrame.Angles(0, 0, math.rad(180)) * rootPart.CFrame
		end
		local weld = Instance.new("WeldConstraint")
		weld.Part0 = limb
		weld.Part1 = rootPart
		weld.Parent = rootPart
	end

	return model
end

-- Utility: add PointLight to a part
local function addGlow(part, color, brightness, range)
	local light = Instance.new("PointLight")
	light.Color = color or part.Color
	light.Brightness = brightness or 1.5
	light.Range = range or 8
	light.Parent = part
end

-- Utility: add fire effect
local function addFire(part, color, secondColor, size)
	local fire = Instance.new("Fire")
	fire.Color = color or Color3.fromRGB(255, 80, 20)
	fire.SecondaryColor = secondColor or Color3.fromRGB(255, 160, 40)
	fire.Size = size or 3
	fire.Heat = 5
	fire.Parent = part
end

-- Utility: add sparkle/particle
local function addSparkles(part, color)
	local sparkle = Instance.new("Sparkles")
	sparkle.SparkleColor = color or part.Color
	sparkle.Parent = part
end

--------------------------------------------------------------------------------
-- WEAPON BUILDERS (multi-part swords)
--------------------------------------------------------------------------------

local function buildCopperSword(model, limb)
	-- Handle at hand position, blade extends downward
	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Size = Vector3.new(0.18, 0.9, 0.18)
	handle.Color = Color3.fromRGB(90, 55, 20)
	handle.Material = Enum.Material.Wood
	handle.CanCollide = false
	handle.Massless = true
	handle.Anchored = false
	handle.CFrame = CFrame.new(0, 0, 0)
	handle.Parent = model

	-- Pommel (top of handle, above hand)
	local pommel = createSubPart(model, handle, "Pommel",
		Vector3.new(0.25, 0.2, 0.25), Color3.fromRGB(160, 90, 35),
		CFrame.new(0, 0.55, 0), Enum.Material.Metal)

	-- Crossguard (below hand)
	local guard = createSubPart(model, handle, "Crossguard",
		Vector3.new(0.7, 0.15, 0.25), Color3.fromRGB(160, 90, 35),
		CFrame.new(0, -0.5, 0), Enum.Material.Metal)

	-- Blade (extends down from crossguard)
	local blade = createSubPart(model, handle, "Blade",
		Vector3.new(0.22, 2.2, 0.1), Color3.fromRGB(190, 115, 50),
		CFrame.new(0, -1.7, 0), Enum.Material.Metal)
	blade.Reflectance = 0.15

	return handle
end

local function buildIronSword(model, limb)
	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Size = Vector3.new(0.18, 1.0, 0.18)
	handle.Color = Color3.fromRGB(70, 45, 20)
	handle.Material = Enum.Material.Fabric
	handle.CanCollide = false
	handle.Massless = true
	handle.Anchored = false
	handle.CFrame = CFrame.new(0, 0, 0)
	handle.Parent = model

	local pommel = createSubPart(model, handle, "Pommel",
		Vector3.new(0.28, 0.22, 0.28), Color3.fromRGB(140, 140, 150),
		CFrame.new(0, 0.6, 0), Enum.Material.Metal)

	local guard = createSubPart(model, handle, "Crossguard",
		Vector3.new(0.9, 0.16, 0.28), Color3.fromRGB(160, 160, 170),
		CFrame.new(0, -0.55, 0), Enum.Material.Metal)

	local blade = createSubPart(model, handle, "Blade",
		Vector3.new(0.28, 2.8, 0.1), Color3.fromRGB(190, 190, 200),
		CFrame.new(0, -2.0, 0), Enum.Material.Metal)
	blade.Reflectance = 0.25

	return handle
end

local function buildSteelSword(model, limb)
	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Size = Vector3.new(0.18, 1.0, 0.18)
	handle.Color = Color3.fromRGB(60, 40, 22)
	handle.Material = Enum.Material.Fabric
	handle.CanCollide = false
	handle.Massless = true
	handle.Anchored = false
	handle.CFrame = CFrame.new(0, 0, 0)
	handle.Parent = model

	local pommel = createSubPart(model, handle, "Pommel",
		Vector3.new(0.3, 0.22, 0.3), Color3.fromRGB(130, 130, 145),
		CFrame.new(0, 0.6, 0), Enum.Material.Metal)

	local guard = createSubPart(model, handle, "Crossguard",
		Vector3.new(1.0, 0.18, 0.3), Color3.fromRGB(140, 140, 155),
		CFrame.new(0, -0.55, 0), Enum.Material.Metal)

	local blade = createSubPart(model, handle, "Blade",
		Vector3.new(0.3, 3.0, 0.1), Color3.fromRGB(170, 170, 185),
		CFrame.new(0, -2.1, 0), Enum.Material.Metal)
	blade.Reflectance = 0.4

	-- Fuller (groove detail)
	local fuller = createSubPart(model, blade, "Fuller",
		Vector3.new(0.1, 2.4, 0.12), Color3.fromRGB(130, 130, 145),
		CFrame.new(0, 0.1, 0), Enum.Material.Metal)
	fuller.Reflectance = 0.2

	return handle
end

local function buildGoldSword(model, limb)
	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Size = Vector3.new(0.2, 1.0, 0.2)
	handle.Color = Color3.fromRGB(80, 40, 15)
	handle.Material = Enum.Material.Fabric
	handle.CanCollide = false
	handle.Massless = true
	handle.Anchored = false
	handle.CFrame = CFrame.new(0, 0, 0)
	handle.Parent = model

	-- Pommel with gem (above hand)
	local pommel = createSubPart(model, handle, "Pommel",
		Vector3.new(0.35, 0.25, 0.35), Color3.fromRGB(255, 200, 50),
		CFrame.new(0, 0.62, 0), Enum.Material.Metal)
	pommel.Reflectance = 0.3

	local gem = createSubPart(model, pommel, "Gem",
		Vector3.new(0.15, 0.15, 0.15), Color3.fromRGB(200, 20, 20),
		CFrame.new(0, 0.1, 0), Enum.Material.Neon)

	local guard = createSubPart(model, handle, "Crossguard",
		Vector3.new(1.2, 0.2, 0.32), Color3.fromRGB(255, 200, 50),
		CFrame.new(0, -0.55, 0), Enum.Material.Metal)
	guard.Reflectance = 0.3

	local blade = createSubPart(model, handle, "Blade",
		Vector3.new(0.32, 3.0, 0.12), Color3.fromRGB(255, 210, 70),
		CFrame.new(0, -2.1, 0), Enum.Material.Metal)
	blade.Reflectance = 0.35

	return handle
end

local function buildRuniteSword(model, limb)
	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Size = Vector3.new(0.2, 1.1, 0.2)
	handle.Color = Color3.fromRGB(30, 80, 80)
	handle.Material = Enum.Material.Fabric
	handle.CanCollide = false
	handle.Massless = true
	handle.Anchored = false
	handle.CFrame = CFrame.new(0, 0, 0)
	handle.Parent = model

	local pommel = createSubPart(model, handle, "Pommel",
		Vector3.new(0.32, 0.25, 0.32), Color3.fromRGB(0, 180, 180),
		CFrame.new(0, 0.65, 0), Enum.Material.Glass)
	pommel.Transparency = 0.3

	local guard = createSubPart(model, handle, "Crossguard",
		Vector3.new(1.1, 0.2, 0.3), Color3.fromRGB(0, 200, 200),
		CFrame.new(0, -0.6, 0), Enum.Material.Glass)
	guard.Transparency = 0.2

	local blade = createSubPart(model, handle, "Blade",
		Vector3.new(0.32, 3.2, 0.12), Color3.fromRGB(0, 210, 210),
		CFrame.new(0, -2.3, 0), Enum.Material.Glass)
	blade.Transparency = 0.15
	blade.Reflectance = 0.3
	addGlow(blade, Color3.fromRGB(0, 220, 220), 2, 12)
	addSparkles(blade, Color3.fromRGB(0, 255, 255))

	return handle
end

local function buildDragonSword(model, limb)
	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Size = Vector3.new(0.22, 1.2, 0.22)
	handle.Color = Color3.fromRGB(30, 10, 10)
	handle.Material = Enum.Material.Fabric
	handle.CanCollide = false
	handle.Massless = true
	handle.Anchored = false
	handle.CFrame = CFrame.new(0, 0, 0)
	handle.Parent = model

	local pommel = createSubPart(model, handle, "Pommel",
		Vector3.new(0.35, 0.28, 0.35), Color3.fromRGB(200, 30, 30),
		CFrame.new(0, 0.7, 0), Enum.Material.Metal)

	local guard = createSubPart(model, handle, "Crossguard",
		Vector3.new(1.3, 0.22, 0.35), Color3.fromRGB(180, 20, 20),
		CFrame.new(0, -0.65, 0), Enum.Material.Metal)

	-- Main blade (extends downward)
	local blade = createSubPart(model, handle, "Blade",
		Vector3.new(0.35, 3.6, 0.14), Color3.fromRGB(210, 30, 30),
		CFrame.new(0, -2.5, 0), Enum.Material.Metal)
	blade.Reflectance = 0.2

	-- Serrated edges (jagged shapes on both sides)
	for i = 0, 4 do
		local side = (i % 2 == 0) and 1 or -1
		local tooth = createSubPart(model, blade, "Serration" .. i,
			Vector3.new(0.15, 0.3, 0.14), Color3.fromRGB(60, 10, 10),
			CFrame.new(side * 0.2, 1.2 - i * 0.6, 0) * CFrame.Angles(0, 0, math.rad(side * 30)),
			Enum.Material.Metal)
	end

	addGlow(blade, Color3.fromRGB(255, 50, 20), 1.5, 10)
	addFire(blade, Color3.fromRGB(255, 50, 20), Color3.fromRGB(255, 140, 30), 2)

	return handle
end

local WEAPON_BUILDERS = {
	["Copper Sword"] = buildCopperSword,
	["Iron Sword"] = buildIronSword,
	["Steel Sword"] = buildSteelSword,
	["Gold Sword"] = buildGoldSword,
	["Runite Sword"] = buildRuniteSword,
	["Dragon Sword"] = buildDragonSword,
}

--------------------------------------------------------------------------------
-- BOW BUILDERS (attach to back)
--------------------------------------------------------------------------------

local function buildBow(model, limb, limbWidth, color, material, stringColor, stringGlow, height)
	-- Bow body (curved via angled segments)
	local mid = Instance.new("Part")
	mid.Name = "BowGrip"
	mid.Size = Vector3.new(0.15, height * 0.3, 0.3)
	mid.Color = color
	mid.Material = material or Enum.Material.Wood
	mid.CanCollide = false
	mid.Massless = true
	mid.Anchored = false
	mid.CFrame = CFrame.new(0.6, 0, -0.5)
	mid.Parent = model

	-- Upper limb
	local upper = createSubPart(model, mid, "UpperLimb",
		Vector3.new(0.12, height * 0.4, 0.2), color,
		CFrame.new(0, height * 0.32, -0.15) * CFrame.Angles(math.rad(-12), 0, 0),
		material or Enum.Material.Wood)

	-- Lower limb
	local lower = createSubPart(model, mid, "LowerLimb",
		Vector3.new(0.12, height * 0.4, 0.2), color,
		CFrame.new(0, -height * 0.32, -0.15) * CFrame.Angles(math.rad(12), 0, 0),
		material or Enum.Material.Wood)

	-- Bowstring
	local str = createSubPart(model, mid, "String",
		Vector3.new(0.04, height * 0.85, 0.04), stringColor or Color3.fromRGB(200, 190, 170),
		CFrame.new(0, 0, 0.12), Enum.Material.Neon)
	if stringGlow then
		str.Material = Enum.Material.Neon
		addGlow(str, stringColor, 1, 6)
	else
		str.Material = Enum.Material.Fabric
	end

	return mid
end

local BOW_BUILDERS = {
	["Oak Shortbow"] = function(model, limb)
		return buildBow(model, limb, 0, Color3.fromRGB(160, 120, 60), Enum.Material.Wood, nil, false, 2.5)
	end,
	["Willow Longbow"] = function(model, limb)
		return buildBow(model, limb, 0, Color3.fromRGB(140, 110, 50), Enum.Material.Wood, nil, false, 3.5)
	end,
	["Yew Longbow"] = function(model, limb)
		return buildBow(model, limb, 0, Color3.fromRGB(90, 55, 30), Enum.Material.Wood, nil, false, 3.8)
	end,
	["Magic Longbow"] = function(model, limb)
		return buildBow(model, limb, 0, Color3.fromRGB(100, 30, 140), Enum.Material.Wood,
			Color3.fromRGB(180, 80, 255), true, 4.0)
	end,
	["Dragon Crossbow"] = function(model, limb)
		-- Crossbow: horizontal limb + stock
		local stock = Instance.new("Part")
		stock.Name = "Stock"
		stock.Size = Vector3.new(0.2, 2.0, 0.35)
		stock.Color = Color3.fromRGB(180, 20, 20)
		stock.Material = Enum.Material.Metal
		stock.CanCollide = false
		stock.Massless = true
		stock.Anchored = false
		stock.CFrame = CFrame.new(0.6, 0, -0.5)
		stock.Parent = model

		local crossLimb = createSubPart(model, stock, "CrossLimb",
			Vector3.new(2.2, 0.12, 0.25), Color3.fromRGB(160, 15, 15),
			CFrame.new(0, 0.9, -0.1), Enum.Material.Metal)

		local str = createSubPart(model, crossLimb, "String",
			Vector3.new(1.8, 0.04, 0.04), Color3.fromRGB(80, 10, 10),
			CFrame.new(0, 0, 0.12), Enum.Material.Fabric)

		local mech = createSubPart(model, stock, "Mechanism",
			Vector3.new(0.25, 0.4, 0.3), Color3.fromRGB(50, 10, 10),
			CFrame.new(0, 0.5, 0), Enum.Material.Metal)

		return stock
	end,
}

--------------------------------------------------------------------------------
-- SHIELD BUILDERS
--------------------------------------------------------------------------------

local function buildWoodenShield(model, limb)
	-- Main round body (approximate with a slightly wider part)
	local body = Instance.new("Part")
	body.Name = "ShieldBody"
	body.Size = Vector3.new(0.25, 2.0, 1.8)
	body.Color = Color3.fromRGB(150, 100, 45)
	body.Material = Enum.Material.Wood
	body.CanCollide = false
	body.Massless = true
	body.Anchored = false
	body.CFrame = CFrame.new(-0.8, 0, 0)
	body.Parent = model

	-- Iron rim (top)
	local rimTop = createSubPart(model, body, "RimTop",
		Vector3.new(0.27, 0.12, 1.85), Color3.fromRGB(140, 140, 150),
		CFrame.new(0, 1.0, 0), Enum.Material.Metal)
	-- Iron rim (bottom)
	local rimBot = createSubPart(model, body, "RimBot",
		Vector3.new(0.27, 0.12, 1.85), Color3.fromRGB(140, 140, 150),
		CFrame.new(0, -1.0, 0), Enum.Material.Metal)

	-- Boss (center bump)
	local boss = createSubPart(model, body, "Boss",
		Vector3.new(0.3, 0.5, 0.5), Color3.fromRGB(130, 130, 140),
		CFrame.new(-0.15, 0, 0), Enum.Material.Metal)

	return body
end

local function buildIronShield(model, limb)
	-- Kite/heater shape - taller
	local body = Instance.new("Part")
	body.Name = "ShieldBody"
	body.Size = Vector3.new(0.22, 2.5, 1.7)
	body.Color = Color3.fromRGB(180, 180, 190)
	body.Material = Enum.Material.Metal
	body.CanCollide = false
	body.Massless = true
	body.Anchored = false
	body.CFrame = CFrame.new(-0.8, 0, 0)
	body.Parent = model
	body.Reflectance = 0.15

	-- Darker trim border (top and sides)
	local trim = createSubPart(model, body, "Trim",
		Vector3.new(0.24, 2.55, 1.75), Color3.fromRGB(100, 100, 110),
		CFrame.new(-0.02, 0, 0), Enum.Material.Metal)

	-- Boss
	local boss = createSubPart(model, body, "Boss",
		Vector3.new(0.3, 0.55, 0.55), Color3.fromRGB(160, 160, 170),
		CFrame.new(-0.15, 0, 0), Enum.Material.Metal)
	boss.Reflectance = 0.2

	return body
end

local function buildGoldShield(model, limb)
	local body = Instance.new("Part")
	body.Name = "ShieldBody"
	body.Size = Vector3.new(0.22, 2.5, 1.8)
	body.Color = Color3.fromRGB(255, 210, 60)
	body.Material = Enum.Material.Metal
	body.CanCollide = false
	body.Massless = true
	body.Anchored = false
	body.CFrame = CFrame.new(-0.8, 0, 0)
	body.Reflectance = 0.3
	body.Parent = model

	-- Golden trim
	local trim = createSubPart(model, body, "Trim",
		Vector3.new(0.24, 2.55, 1.85), Color3.fromRGB(200, 160, 30),
		CFrame.new(-0.02, 0, 0), Enum.Material.Metal)
	trim.Reflectance = 0.25

	-- Embossed cross pattern
	local cross1 = createSubPart(model, body, "Emboss1",
		Vector3.new(0.25, 2.0, 0.15), Color3.fromRGB(220, 175, 40),
		CFrame.new(-0.03, 0, 0), Enum.Material.Metal)
	local cross2 = createSubPart(model, body, "Emboss2",
		Vector3.new(0.25, 0.15, 1.3), Color3.fromRGB(220, 175, 40),
		CFrame.new(-0.03, 0, 0), Enum.Material.Metal)

	-- Boss with gem
	local boss = createSubPart(model, body, "Boss",
		Vector3.new(0.3, 0.5, 0.5), Color3.fromRGB(255, 220, 80),
		CFrame.new(-0.15, 0, 0), Enum.Material.Metal)
	boss.Reflectance = 0.35

	return body
end

local function buildRuniteShield(model, limb)
	local body = Instance.new("Part")
	body.Name = "ShieldBody"
	body.Size = Vector3.new(0.22, 2.6, 1.8)
	body.Color = Color3.fromRGB(0, 190, 190)
	body.Material = Enum.Material.Glass
	body.CanCollide = false
	body.Massless = true
	body.Anchored = false
	body.Transparency = 0.2
	body.CFrame = CFrame.new(-0.8, 0, 0)
	body.Parent = model

	local trim = createSubPart(model, body, "Trim",
		Vector3.new(0.24, 2.65, 1.85), Color3.fromRGB(0, 140, 140),
		CFrame.new(-0.02, 0, 0), Enum.Material.Glass)
	trim.Transparency = 0.4

	addGlow(body, Color3.fromRGB(0, 220, 220), 2, 10)
	addSparkles(body, Color3.fromRGB(0, 255, 255))

	return body
end

local function buildDragonShield(model, limb)
	local body = Instance.new("Part")
	body.Name = "ShieldBody"
	body.Size = Vector3.new(0.25, 2.7, 2.0)
	body.Color = Color3.fromRGB(200, 25, 25)
	body.Material = Enum.Material.Metal
	body.CanCollide = false
	body.Massless = true
	body.Anchored = false
	body.CFrame = CFrame.new(-0.8, 0, 0)
	body.Reflectance = 0.15
	body.Parent = model

	-- Black border
	local trim = createSubPart(model, body, "Trim",
		Vector3.new(0.27, 2.75, 2.05), Color3.fromRGB(30, 10, 10),
		CFrame.new(-0.02, 0, 0), Enum.Material.Metal)

	-- Spikes on edges
	for i = -1, 1, 1 do
		local spike = createSubPart(model, body, "Spike" .. i,
			Vector3.new(0.15, 0.5, 0.15), Color3.fromRGB(40, 10, 10),
			CFrame.new(-0.15, i * 0.9, 1.0) * CFrame.Angles(0, 0, math.rad(45)),
			Enum.Material.Metal)
		local spike2 = createSubPart(model, body, "SpikeR" .. i,
			Vector3.new(0.15, 0.5, 0.15), Color3.fromRGB(40, 10, 10),
			CFrame.new(-0.15, i * 0.9, -1.0) * CFrame.Angles(0, 0, math.rad(-45)),
			Enum.Material.Metal)
	end

	-- Dragon emblem (contrasting center piece)
	local emblem = createSubPart(model, body, "Emblem",
		Vector3.new(0.28, 1.0, 0.8), Color3.fromRGB(30, 10, 10),
		CFrame.new(-0.04, 0, 0), Enum.Material.Metal)

	addGlow(body, Color3.fromRGB(255, 40, 20), 1, 8)

	return body
end

local SHIELD_BUILDERS = {
	["Wooden Shield"] = buildWoodenShield,
	["Iron Shield"] = buildIronShield,
	["Gold Shield"] = buildGoldShield,
	["Runite Shield"] = buildRuniteShield,
	["Dragon Shield"] = buildDragonShield,
}

--------------------------------------------------------------------------------
-- HELMET BUILDERS
--------------------------------------------------------------------------------

local function buildBronzeHelmet(model, limb)
	local base = Instance.new("Part")
	base.Name = "HelmetBase"
	base.Size = Vector3.new(1.25, 0.7, 1.25)
	base.Color = Color3.fromRGB(170, 115, 55)
	base.Material = Enum.Material.Metal
	base.CanCollide = false
	base.Massless = true
	base.Anchored = false
	base.CFrame = CFrame.new(0, 0.85, 0)
	base.Parent = model

	-- Nose guard
	local nose = createSubPart(model, base, "NoseGuard",
		Vector3.new(0.1, 0.7, 0.12), Color3.fromRGB(160, 105, 45),
		CFrame.new(0, -0.5, -0.6), Enum.Material.Metal)

	return base
end

local function buildIronHelmet(model, limb)
	local base = Instance.new("Part")
	base.Name = "HelmetBase"
	base.Size = Vector3.new(1.3, 0.8, 1.3)
	base.Color = Color3.fromRGB(180, 180, 190)
	base.Material = Enum.Material.Metal
	base.CanCollide = false
	base.Massless = true
	base.Anchored = false
	base.CFrame = CFrame.new(0, 0.85, 0)
	base.Reflectance = 0.15
	base.Parent = model

	-- Cheek guards
	local cheekL = createSubPart(model, base, "CheekL",
		Vector3.new(0.15, 0.6, 0.5), Color3.fromRGB(165, 165, 175),
		CFrame.new(-0.65, -0.45, -0.2), Enum.Material.Metal)
	local cheekR = createSubPart(model, base, "CheekR",
		Vector3.new(0.15, 0.6, 0.5), Color3.fromRGB(165, 165, 175),
		CFrame.new(0.65, -0.45, -0.2), Enum.Material.Metal)

	-- Nose guard
	local nose = createSubPart(model, base, "NoseGuard",
		Vector3.new(0.1, 0.5, 0.12), Color3.fromRGB(170, 170, 180),
		CFrame.new(0, -0.45, -0.6), Enum.Material.Metal)

	return base
end

local function buildGoldHelmet(model, limb)
	local base = Instance.new("Part")
	base.Name = "HelmetBase"
	base.Size = Vector3.new(1.3, 0.6, 1.3)
	base.Color = Color3.fromRGB(255, 205, 55)
	base.Material = Enum.Material.Metal
	base.CanCollide = false
	base.Massless = true
	base.Anchored = false
	base.CFrame = CFrame.new(0, 0.82, 0)
	base.Reflectance = 0.3
	base.Parent = model

	-- Crown points
	for i = 0, 4 do
		local angle = math.rad(i * 72)
		local px = math.cos(angle) * 0.5
		local pz = math.sin(angle) * 0.5
		local point = createSubPart(model, base, "Crown" .. i,
			Vector3.new(0.15, 0.4, 0.15), Color3.fromRGB(255, 210, 60),
			CFrame.new(px, 0.45, pz), Enum.Material.Metal)
		point.Reflectance = 0.3
	end

	-- Gem in front
	local gem = createSubPart(model, base, "Gem",
		Vector3.new(0.18, 0.18, 0.18), Color3.fromRGB(200, 20, 20),
		CFrame.new(0, 0.15, -0.65), Enum.Material.Neon)

	return base
end

local function buildRuniteHelmet(model, limb)
	local base = Instance.new("Part")
	base.Name = "HelmetBase"
	base.Size = Vector3.new(1.35, 0.9, 1.35)
	base.Color = Color3.fromRGB(0, 185, 185)
	base.Material = Enum.Material.Glass
	base.CanCollide = false
	base.Massless = true
	base.Anchored = false
	base.Transparency = 0.15
	base.CFrame = CFrame.new(0, 0.85, 0)
	base.Parent = model

	-- Full face plate
	local face = createSubPart(model, base, "FacePlate",
		Vector3.new(1.1, 0.8, 0.12), Color3.fromRGB(0, 160, 160),
		CFrame.new(0, -0.3, -0.65), Enum.Material.Glass)
	face.Transparency = 0.3

	-- Visor slit (glowing)
	local visor = createSubPart(model, face, "Visor",
		Vector3.new(0.8, 0.1, 0.14), Color3.fromRGB(0, 255, 255),
		CFrame.new(0, 0.1, -0.02), Enum.Material.Neon)
	addGlow(visor, Color3.fromRGB(0, 255, 255), 2, 8)

	return base
end

local function buildDragonHelmet(model, limb)
	local base = Instance.new("Part")
	base.Name = "HelmetBase"
	base.Size = Vector3.new(1.35, 0.9, 1.35)
	base.Color = Color3.fromRGB(200, 25, 25)
	base.Material = Enum.Material.Metal
	base.CanCollide = false
	base.Massless = true
	base.Anchored = false
	base.CFrame = CFrame.new(0, 0.85, 0)
	base.Reflectance = 0.1
	base.Parent = model

	-- Face plate
	local face = createSubPart(model, base, "FacePlate",
		Vector3.new(1.15, 0.85, 0.12), Color3.fromRGB(40, 10, 10),
		CFrame.new(0, -0.3, -0.65), Enum.Material.Metal)

	-- Menacing visor slit
	local visor = createSubPart(model, face, "Visor",
		Vector3.new(0.85, 0.08, 0.14), Color3.fromRGB(255, 40, 20),
		CFrame.new(0, 0.1, -0.02), Enum.Material.Neon)
	addGlow(visor, Color3.fromRGB(255, 40, 20), 1.5, 6)

	-- Horns
	local hornL = createSubPart(model, base, "HornL",
		Vector3.new(0.15, 0.8, 0.15), Color3.fromRGB(50, 10, 10),
		CFrame.new(-0.5, 0.6, -0.2) * CFrame.Angles(math.rad(-20), 0, math.rad(-25)),
		Enum.Material.Metal)
	local hornR = createSubPart(model, base, "HornR",
		Vector3.new(0.15, 0.8, 0.15), Color3.fromRGB(50, 10, 10),
		CFrame.new(0.5, 0.6, -0.2) * CFrame.Angles(math.rad(-20), 0, math.rad(25)),
		Enum.Material.Metal)

	return base
end

local HELMET_BUILDERS = {
	["Bronze Helmet"] = buildBronzeHelmet,
	["Iron Helmet"] = buildIronHelmet,
	["Gold Helmet"] = buildGoldHelmet,
	["Runite Helmet"] = buildRuniteHelmet,
	["Dragon Helmet"] = buildDragonHelmet,
}

--------------------------------------------------------------------------------
-- BODY ARMOR VISUALS (color + overlay parts)
--------------------------------------------------------------------------------

local BODY_VISUALS = {
	["Goblin Mail"] = { color = Color3.fromRGB(50, 100, 40) },
	["Wizard Robe"] = { color = Color3.fromRGB(120, 40, 160) },
	["Iron Platebody"] = { color = Color3.fromRGB(180, 180, 190) },
	["Gold Platebody"] = { color = Color3.fromRGB(255, 200, 50) },
	["Runite Platebody"] = { color = Color3.fromRGB(0, 180, 180) },
	["Dragon Platebody"] = { color = Color3.fromRGB(200, 30, 30) },
}

-- Overlay builders for body armor (create extra parts on torso)
local function buildBodyOverlay(character, bodyName)
	clearVisual(character, "VisualEquip_BodyOverlay")
	local torsoName = character:FindFirstChild("UpperTorso") and "UpperTorso" or "Torso"
	local torso = character:FindFirstChild(torsoName)
	if not torso then return end

	local model = Instance.new("Model")
	model.Name = "VisualEquip_BodyOverlay"
	model.Parent = character

	if bodyName == "Goblin Mail" then
		-- Chain mail overlay with tattered bottom
		local chain = Instance.new("Part")
		chain.Name = "ChainBody"
		chain.Size = Vector3.new(2.05, 1.6, 1.05)
		chain.Color = Color3.fromRGB(60, 110, 45)
		chain.Material = Enum.Material.Fabric
		chain.Transparency = 0.1
		chain.CanCollide = false
		chain.Massless = true
		chain.Anchored = false
		chain.CFrame = torso.CFrame * CFrame.new(0, -0.1, 0)
		chain.Parent = model
		local w = Instance.new("WeldConstraint")
		w.Part0 = torso
		w.Part1 = chain
		w.Parent = chain

		-- Tattered bottom strip
		local tatter = createSubPart(model, chain, "Tatter",
			Vector3.new(1.8, 0.3, 0.9), Color3.fromRGB(45, 85, 35),
			CFrame.new(0, -0.9, 0), Enum.Material.Fabric)

	elseif bodyName == "Wizard Robe" then
		local robe = Instance.new("Part")
		robe.Name = "RobeBody"
		robe.Size = Vector3.new(2.1, 1.65, 1.1)
		robe.Color = Color3.fromRGB(120, 40, 160)
		robe.Material = Enum.Material.Fabric
		robe.CanCollide = false
		robe.Massless = true
		robe.Anchored = false
		robe.CFrame = torso.CFrame * CFrame.new(0, -0.1, 0)
		robe.Parent = model
		local w = Instance.new("WeldConstraint")
		w.Part0 = torso
		w.Part1 = robe
		w.Parent = robe

		-- Gold trim line
		local trimFront = createSubPart(model, robe, "TrimFront",
			Vector3.new(0.08, 1.6, 0.08), Color3.fromRGB(255, 200, 50),
			CFrame.new(0, 0, -0.55), Enum.Material.Neon)
		local trimBottom = createSubPart(model, robe, "TrimBottom",
			Vector3.new(2.0, 0.06, 1.0), Color3.fromRGB(255, 200, 50),
			CFrame.new(0, -0.8, 0), Enum.Material.Neon)

		-- Hood piece on head
		local head = character:FindFirstChild("Head")
		if head then
			local hood = Instance.new("Part")
			hood.Name = "VisualEquip_BodyOverlay"
			hood.Size = Vector3.new(1.4, 0.8, 1.4)
			hood.Color = Color3.fromRGB(110, 35, 145)
			hood.Material = Enum.Material.Fabric
			hood.CanCollide = false
			hood.Massless = true
			hood.Anchored = false
			hood.CFrame = head.CFrame * CFrame.new(0, 0.5, 0.1)
			hood.Parent = character  -- separate part, same tag for cleanup
			local hw = Instance.new("WeldConstraint")
			hw.Part0 = head
			hw.Part1 = hood
			hw.Parent = hood
		end

	elseif bodyName == "Iron Platebody" then
		local plate = Instance.new("Part")
		plate.Name = "PlateBody"
		plate.Size = Vector3.new(2.08, 1.65, 1.08)
		plate.Color = Color3.fromRGB(185, 185, 195)
		plate.Material = Enum.Material.Metal
		plate.Reflectance = 0.2
		plate.CanCollide = false
		plate.Massless = true
		plate.Anchored = false
		plate.CFrame = torso.CFrame
		plate.Parent = model
		local w = Instance.new("WeldConstraint")
		w.Part0 = torso
		w.Part1 = plate
		w.Parent = plate

		-- Shoulder pads
		local shoulderL = createSubPart(model, plate, "ShoulderL",
			Vector3.new(0.6, 0.3, 0.8), Color3.fromRGB(170, 170, 180),
			CFrame.new(-1.1, 0.7, 0), Enum.Material.Metal)
		local shoulderR = createSubPart(model, plate, "ShoulderR",
			Vector3.new(0.6, 0.3, 0.8), Color3.fromRGB(170, 170, 180),
			CFrame.new(1.1, 0.7, 0), Enum.Material.Metal)

	elseif bodyName == "Gold Platebody" then
		local plate = Instance.new("Part")
		plate.Name = "PlateBody"
		plate.Size = Vector3.new(2.08, 1.65, 1.08)
		plate.Color = Color3.fromRGB(255, 210, 60)
		plate.Material = Enum.Material.Metal
		plate.Reflectance = 0.3
		plate.CanCollide = false
		plate.Massless = true
		plate.Anchored = false
		plate.CFrame = torso.CFrame
		plate.Parent = model
		local w = Instance.new("WeldConstraint")
		w.Part0 = torso
		w.Part1 = plate
		w.Parent = plate

		local shoulderL = createSubPart(model, plate, "ShoulderL",
			Vector3.new(0.65, 0.35, 0.85), Color3.fromRGB(240, 190, 40),
			CFrame.new(-1.1, 0.7, 0), Enum.Material.Metal)
		shoulderL.Reflectance = 0.3
		local shoulderR = createSubPart(model, plate, "ShoulderR",
			Vector3.new(0.65, 0.35, 0.85), Color3.fromRGB(240, 190, 40),
			CFrame.new(1.1, 0.7, 0), Enum.Material.Metal)
		shoulderR.Reflectance = 0.3

		-- Chest emblem
		local emblem = createSubPart(model, plate, "Emblem",
			Vector3.new(0.1, 0.5, 0.5), Color3.fromRGB(200, 155, 25),
			CFrame.new(0, 0.1, -0.55), Enum.Material.Metal)

	elseif bodyName == "Runite Platebody" then
		local plate = Instance.new("Part")
		plate.Name = "PlateBody"
		plate.Size = Vector3.new(2.1, 1.68, 1.1)
		plate.Color = Color3.fromRGB(0, 190, 190)
		plate.Material = Enum.Material.Glass
		plate.Transparency = 0.15
		plate.CanCollide = false
		plate.Massless = true
		plate.Anchored = false
		plate.CFrame = torso.CFrame
		plate.Parent = model
		local w = Instance.new("WeldConstraint")
		w.Part0 = torso
		w.Part1 = plate
		w.Parent = plate
		addGlow(plate, Color3.fromRGB(0, 220, 220), 1, 8)

		local shoulderL = createSubPart(model, plate, "ShoulderL",
			Vector3.new(0.65, 0.35, 0.85), Color3.fromRGB(0, 160, 160),
			CFrame.new(-1.1, 0.7, 0), Enum.Material.Glass)
		shoulderL.Transparency = 0.2
		local shoulderR = createSubPart(model, plate, "ShoulderR",
			Vector3.new(0.65, 0.35, 0.85), Color3.fromRGB(0, 160, 160),
			CFrame.new(1.1, 0.7, 0), Enum.Material.Glass)
		shoulderR.Transparency = 0.2

	elseif bodyName == "Dragon Platebody" then
		local plate = Instance.new("Part")
		plate.Name = "PlateBody"
		plate.Size = Vector3.new(2.12, 1.7, 1.12)
		plate.Color = Color3.fromRGB(200, 25, 25)
		plate.Material = Enum.Material.Metal
		plate.Reflectance = 0.15
		plate.CanCollide = false
		plate.Massless = true
		plate.Anchored = false
		plate.CFrame = torso.CFrame
		plate.Parent = model
		local w = Instance.new("WeldConstraint")
		w.Part0 = torso
		w.Part1 = plate
		w.Parent = plate

		-- Black trim
		local trimBottom = createSubPart(model, plate, "TrimBottom",
			Vector3.new(2.15, 0.1, 1.15), Color3.fromRGB(30, 10, 10),
			CFrame.new(0, -0.82, 0), Enum.Material.Metal)

		-- Spiked shoulders
		local shoulderL = createSubPart(model, plate, "ShoulderL",
			Vector3.new(0.7, 0.4, 0.9), Color3.fromRGB(180, 20, 20),
			CFrame.new(-1.1, 0.7, 0), Enum.Material.Metal)
		local spikeL = createSubPart(model, shoulderL, "SpikeL",
			Vector3.new(0.15, 0.5, 0.15), Color3.fromRGB(40, 10, 10),
			CFrame.new(0, 0.35, 0), Enum.Material.Metal)
		local shoulderR = createSubPart(model, plate, "ShoulderR",
			Vector3.new(0.7, 0.4, 0.9), Color3.fromRGB(180, 20, 20),
			CFrame.new(1.1, 0.7, 0), Enum.Material.Metal)
		local spikeR = createSubPart(model, shoulderR, "SpikeR",
			Vector3.new(0.15, 0.5, 0.15), Color3.fromRGB(40, 10, 10),
			CFrame.new(0, 0.35, 0), Enum.Material.Metal)

		addGlow(plate, Color3.fromRGB(255, 40, 20), 0.8, 6)
	end
end

--------------------------------------------------------------------------------
-- LEGS VISUALS
--------------------------------------------------------------------------------

local LEGS_VISUALS = {
	["Iron Legs"] = { color = Color3.fromRGB(180, 180, 190) },
	["Gold Legs"] = { color = Color3.fromRGB(255, 200, 50) },
	["Runite Legs"] = { color = Color3.fromRGB(0, 180, 180) },
	["Dragon Legs"] = { color = Color3.fromRGB(200, 30, 30) },
}

--------------------------------------------------------------------------------
-- TOOL BUILDERS (pickaxes, axes, fishing rods)
--------------------------------------------------------------------------------

local TOOL_TIER_COLORS = {
	["Copper"] = Color3.fromRGB(180, 100, 40),
	["Iron"] = Color3.fromRGB(180, 180, 190),
	["Steel"] = Color3.fromRGB(140, 140, 155),
	["Gold"] = Color3.fromRGB(255, 200, 50),
	["Runite"] = Color3.fromRGB(0, 180, 180),
	["Dragon"] = Color3.fromRGB(200, 30, 30),
}

local function getToolTierColor(toolName)
	for tier, col in pairs(TOOL_TIER_COLORS) do
		if string.find(toolName, tier) then
			return col
		end
	end
	return Color3.fromRGB(140, 100, 50)
end

local function buildPickaxe(model, limb, toolName)
	local tierColor = getToolTierColor(toolName)

	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Size = Vector3.new(0.2, 2.8, 0.2)
	handle.Color = Color3.fromRGB(120, 80, 35)
	handle.Material = Enum.Material.Wood
	handle.CanCollide = false
	handle.Massless = true
	handle.Anchored = false
	handle.CFrame = CFrame.new(0.7, 0, 0.5) * CFrame.Angles(0, 0, math.rad(30))
	handle.Parent = model

	-- Pickaxe head (wedge-like)
	local head = createSubPart(model, handle, "PickHead",
		Vector3.new(0.15, 0.3, 1.2), tierColor,
		CFrame.new(0, 1.3, 0.3), Enum.Material.Metal)
	head.Reflectance = 0.15

	-- Back spike
	local spike = createSubPart(model, handle, "BackSpike",
		Vector3.new(0.12, 0.2, 0.6), tierColor,
		CFrame.new(0, 1.3, -0.3), Enum.Material.Metal)

	if string.find(toolName, "Runite") then addGlow(head, tierColor, 1, 5) end
	if string.find(toolName, "Dragon") then addGlow(head, tierColor, 0.8, 4) end

	return handle
end

local function buildAxe(model, limb, toolName)
	local tierColor = getToolTierColor(toolName)

	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Size = Vector3.new(0.2, 2.5, 0.2)
	handle.Color = Color3.fromRGB(120, 80, 35)
	handle.Material = Enum.Material.Wood
	handle.CanCollide = false
	handle.Massless = true
	handle.Anchored = false
	handle.CFrame = CFrame.new(0.7, 0, 0.5) * CFrame.Angles(0, 0, math.rad(30))
	handle.Parent = model

	-- Axe head (flat blade)
	local head = createSubPart(model, handle, "AxeHead",
		Vector3.new(0.12, 0.8, 0.9), tierColor,
		CFrame.new(0, 1.1, 0.35), Enum.Material.Metal)
	head.Reflectance = 0.15

	if string.find(toolName, "Runite") then addGlow(head, tierColor, 1, 5) end
	if string.find(toolName, "Dragon") then addGlow(head, tierColor, 0.8, 4) end

	return handle
end

local function buildFishingRod(model, limb, toolName)
	local tierColor = getToolTierColor(toolName)

	local rod = Instance.new("Part")
	rod.Name = "Rod"
	rod.Size = Vector3.new(0.1, 3.5, 0.1)
	rod.Color = tierColor
	rod.Material = Enum.Material.Wood
	rod.CanCollide = false
	rod.Massless = true
	rod.Anchored = false
	rod.CFrame = CFrame.new(0.7, 0.3, 0.5) * CFrame.Angles(0, 0, math.rad(15))
	rod.Parent = model

	-- Reel
	local reel = createSubPart(model, rod, "Reel",
		Vector3.new(0.2, 0.25, 0.25), Color3.fromRGB(100, 100, 110),
		CFrame.new(0.1, -1.0, 0), Enum.Material.Metal)

	-- Fishing line (thin neon)
	local line = createSubPart(model, rod, "Line",
		Vector3.new(0.03, 1.2, 0.03), Color3.fromRGB(220, 220, 230),
		CFrame.new(0, 2.2, 0), Enum.Material.Neon)

	return rod
end

local function buildTool(character, toolName)
	clearVisual(character, "VisualEquip_Tool")
	local torsoName = character:FindFirstChild("UpperTorso") and "UpperTorso" or "Torso"
	local torso = character:FindFirstChild(torsoName)
	if not torso then return end

	local model = Instance.new("Model")
	model.Name = "VisualEquip_Tool"
	model.Parent = character

	local rootPart
	if string.find(toolName, "Pickaxe") or string.find(toolName, "pickaxe") then
		rootPart = buildPickaxe(model, torso, toolName)
	elseif string.find(toolName, "Axe") or string.find(toolName, "axe") then
		rootPart = buildAxe(model, torso, toolName)
	elseif string.find(toolName, "Rod") or string.find(toolName, "rod") or string.find(toolName, "Fishing") then
		rootPart = buildFishingRod(model, torso, toolName)
	else
		-- Generic tool (stick)
		rootPart = Instance.new("Part")
		rootPart.Name = "ToolGeneric"
		rootPart.Size = Vector3.new(0.25, 2.5, 0.25)
		rootPart.Color = getToolTierColor(toolName)
		rootPart.Material = Enum.Material.Wood
		rootPart.CanCollide = false
		rootPart.Massless = true
		rootPart.Anchored = false
		rootPart.CFrame = CFrame.new(0.7, 0, 0.5) * CFrame.Angles(0, 0, math.rad(30))
		rootPart.Parent = model
	end

	if rootPart then
		rootPart.CFrame = torso.CFrame * rootPart.CFrame
		local weld = Instance.new("WeldConstraint")
		weld.Part0 = torso
		weld.Part1 = rootPart
		weld.Parent = rootPart
	end
end

--------------------------------------------------------------------------------
-- Apply visuals for a single player
--------------------------------------------------------------------------------

local function applyVisuals(player)
	local character = player.Character
	if not character then return end
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid or humanoid.Health <= 0 then return end

	local data = DataManager.GetData(player)
	if not data or not data.Equipment then return end

	local equip = data.Equipment

	-- WEAPON (Right Arm / RightHand) or BOW (back)
	local weaponName = equip.Weapon
	clearVisual(character, "VisualEquip_Weapon")
	if weaponName and weaponName ~= "" then
		local builder = WEAPON_BUILDERS[weaponName]
		local bowBuilder = BOW_BUILDERS[weaponName]

		if builder then
			-- Multi-part sword
			local attachTo = character:FindFirstChild("RightHand") and "RightHand" or "Right Arm"
			createModelOnLimb(character, attachTo, "VisualEquip_Weapon", function(model, limb)
				return builder(model, limb)
			end)
			print("[VisualEquip] Weapon attached: " .. weaponName .. " to " .. attachTo)
		elseif bowBuilder then
			-- Bows go on back
			local attachTo = character:FindFirstChild("UpperTorso") and "UpperTorso" or "Torso"
			createModelOnLimb(character, attachTo, "VisualEquip_Weapon", function(model, limb)
				return bowBuilder(model, limb)
			end)
			print("[VisualEquip] Bow attached: " .. weaponName .. " to back")
		else
			-- Fallback: basic blade
			local attachTo = character:FindFirstChild("RightHand") and "RightHand" or "Right Arm"
			local offset = CFrame.new(0, -2.0, 0)
			local part = createAttachedPart(character, attachTo, "VisualEquip_Weapon",
				Vector3.new(0.3, 3, 0.15), Color3.fromRGB(180, 180, 180), offset)
			if part then
				part.Material = Enum.Material.Metal
			end
		end
	end

	-- HEAD
	local headName = equip.Head
	clearVisual(character, "VisualEquip_Head")
	if headName and headName ~= "" then
		local builder = HELMET_BUILDERS[headName]
		if builder then
			createModelOnLimb(character, "Head", "VisualEquip_Head", function(model, limb)
				return builder(model, limb)
			end, true)
		else
			-- Fallback: simple block
			local offset = CFrame.new(0, 0.8, 0)
			createAttachedPart(character, "Head", "VisualEquip_Head",
				Vector3.new(1.3, 0.8, 1.3), Color3.fromRGB(180, 180, 180), offset)
		end
	end

	-- BODY (color torso + overlay parts)
	local torsoName = character:FindFirstChild("UpperTorso") and "UpperTorso" or "Torso"
	local lowerTorso = character:FindFirstChild("LowerTorso")
	local bodyParts = { torsoName }
	if lowerTorso then table.insert(bodyParts, "LowerTorso") end

	local bodyName = equip.Body
	clearBodyColors(character, bodyParts)
	clearVisual(character, "VisualEquip_BodyOverlay")
	if bodyName and bodyName ~= "" then
		local vis = BODY_VISUALS[bodyName]
		if vis then
			for _, pName in ipairs(bodyParts) do
				local part = character:FindFirstChild(pName)
				if part and part:IsA("BasePart") then
					saveOriginalColor(part)
					part.Color = vis.color
				end
			end
		end
		-- Build overlay parts
		buildBodyOverlay(character, bodyName)
	end

	-- LEGS (color legs)
	local legParts = {}
	for _, name in ipairs({"Left Leg", "Right Leg", "LeftUpperLeg", "RightUpperLeg", "LeftLowerLeg", "RightLowerLeg", "LeftFoot", "RightFoot"}) do
		if character:FindFirstChild(name) then
			table.insert(legParts, name)
		end
	end

	local legsName = equip.Legs
	clearBodyColors(character, legParts)
	if legsName and LEGS_VISUALS[legsName] then
		local vis = LEGS_VISUALS[legsName]
		for _, pName in ipairs(legParts) do
			local part = character:FindFirstChild(pName)
			if part and part:IsA("BasePart") then
				saveOriginalColor(part)
				part.Color = vis.color
			end
		end
	end

	-- SHIELD (Left Arm)
	local shieldName = equip.Shield
	clearVisual(character, "VisualEquip_Shield")
	if shieldName and shieldName ~= "" then
		local builder = SHIELD_BUILDERS[shieldName]
		if builder then
			local attachTo = character:FindFirstChild("LeftHand") and "LeftLowerArm" or "Left Arm"
			createModelOnLimb(character, attachTo, "VisualEquip_Shield", function(model, limb)
				return builder(model, limb)
			end, true)
		else
			-- Fallback
			local attachTo = character:FindFirstChild("LeftHand") and "LeftLowerArm" or "Left Arm"
			local offset = CFrame.new(-0.8, 0, 0)
			createAttachedPart(character, attachTo, "VisualEquip_Shield",
				Vector3.new(0.3, 2.2, 1.6), Color3.fromRGB(140, 90, 40), offset)
		end
	end

	-- TOOL (visual on back)
	local toolName = equip.Tool
	clearVisual(character, "VisualEquip_Tool")
	if toolName and toolName ~= "" then
		buildTool(character, toolName)
	end

	print("[VisualEquip] Applied visuals for " .. player.Name .. " | Weapon=" .. tostring(equip.Weapon) .. " Head=" .. tostring(equip.Head) .. " Shield=" .. tostring(equip.Shield))
end

--------------------------------------------------------------------------------
-- Connections
--------------------------------------------------------------------------------

local function setupPlayer(player)
	player.CharacterAdded:Connect(function(character)
		character:WaitForChild("Humanoid")
		task.wait(0.5)
		applyVisuals(player)
	end)

	if player.Character then
		applyVisuals(player)
	end
end

Players.PlayerAdded:Connect(setupPlayer)
for _, player in ipairs(Players:GetPlayers()) do
	setupPlayer(player)
end

equipChanged.Event:Connect(function(player)
	if player and player:IsA("Player") then
		task.wait(0.1)
		applyVisuals(player)
	end
end)

if equipItemEvent then
	equipItemEvent.OnServerEvent:Connect(function(player)
		task.wait(0.2)
		applyVisuals(player)
	end)
end

if unequipItemEvent then
	unequipItemEvent.OnServerEvent:Connect(function(player)
		task.wait(0.2)
		applyVisuals(player)
	end)
end
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="58">
      <Properties>
        <string name="Name">WildernessManager</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- WildernessManager.server.lua
-- Handles PvP zone detection, full-loot death, and loot drops

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local Config = require(ReplicatedStorage.Modules.Config)

local DataManager = require(ReplicatedStorage.Modules.DataManager)

-- Track which players are in the wilderness
local playersInWilderness = {}

-- Wilderness boundary (Z < -100)
local WILDERNESS_Z = -100

-- === ZONE DETECTION ===
local function isInWilderness(position)
	return position.Z < WILDERNESS_Z
end

print("[WildernessManager] Waiting for Remotes...")
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
if not Remotes then
	warn("[WildernessManager] ERROR: Remotes folder not found!")
end
local zoneRemote = Remotes and Remotes:WaitForChild("ZoneChanged", 10)
if not zoneRemote then
	warn("[WildernessManager] ERROR: ZoneChanged remote not found!")
end
print("[WildernessManager] Remotes connected!")

-- Monitor player positions
task.spawn(function()
	while true do
		task.wait(0.5)
		for _, player in ipairs(Players:GetPlayers()) do
			local character = player.Character
			if character then
				local root = character:FindFirstChild("HumanoidRootPart")
				if root then
					local wasInWild = playersInWilderness[player.UserId]
					local isInWild = isInWilderness(root.Position)

					if isInWild and not wasInWild then
						-- Entered wilderness
						playersInWilderness[player.UserId] = true
						zoneRemote:FireClient(player, "Wilderness")
						print("[Wilderness] " .. player.Name .. " entered the Wilderness!")
					elseif not isInWild and wasInWild then
						-- Left wilderness
						playersInWilderness[player.UserId] = false
						zoneRemote:FireClient(player, "SafeZone")
						print("[Wilderness] " .. player.Name .. " returned to safety.")
					end
				end
			end
		end
	end
end)

-- === LOOT DROP SYSTEM ===

local function createLootPile(position, items, killerName)
	if #items == 0 then return end

	local lootPart = Instance.new("Part")
	lootPart.Name = "LootPile"
	lootPart.Size = Vector3.new(3, 1, 3)
	lootPart.Position = position + Vector3.new(0, 1, 0)
	lootPart.Anchored = true
	lootPart.CanCollide = false
	lootPart.BrickColor = BrickColor.new("Bright yellow")
	lootPart.Material = Enum.Material.Neon
	lootPart.Shape = Enum.PartType.Cylinder
	lootPart.Transparency = 0.3
	lootPart.Parent = Workspace

	-- Floating text
	local billboard = Instance.new("BillboardGui")
	billboard.Size = UDim2.new(4, 0, 1, 0)
	billboard.StudsOffset = Vector3.new(0, 3, 0)
	billboard.Parent = lootPart

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = "üíÄ Loot Pile (" .. #items .. " items)"
	label.TextColor3 = Color3.fromRGB(255, 215, 0)
	label.TextScaled = true
	label.Font = Enum.Font.GothamBold
	label.Parent = billboard

	-- Click to loot
	local clickDetector = Instance.new("ClickDetector")
	clickDetector.MaxActivationDistance = 10
	clickDetector.Parent = lootPart

	local looted = false
	clickDetector.MouseClick:Connect(function(player)
		if looted then return end
		looted = true

		-- Give all items to the player who clicked
		local itemsGiven = 0
		for _, item in ipairs(items) do
			local added = DataManager.AddToInventory(player, item.name, item.quantity)
			if added then
				itemsGiven = itemsGiven + 1
			end
		end

		-- Update their inventory UI
		local invRemote = ReplicatedStorage.Remotes:FindFirstChild("InventoryUpdate")
		if invRemote then
			local data = DataManager.GetData(player)
			invRemote:FireClient(player, data.Inventory)
		end

		print("[Loot] " .. player.Name .. " looted " .. itemsGiven .. " items from a pile")
		lootPart:Destroy()
	end)

	-- Auto-despawn after duration
	task.delay(Config.LootDropDuration, function()
		if lootPart and lootPart.Parent then
			lootPart:Destroy()
			print("[Loot] A loot pile despawned")
		end
	end)
end

-- === PVP DEATH HANDLER ===

local function onCharacterDied(player, character)
	if not DataManager then return end

	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoid then return end

	-- Check if player died in wilderness
	local root = character:FindFirstChild("HumanoidRootPart")
	if not root then return end

	if not isInWilderness(root.Position) then
		-- Died in safe zone ‚Äî no loot drop
		return
	end

	-- FULL LOOT DROP ‚Äî drop everything!
	local droppedItems = DataManager.GetAndClearInventory(player)
	
	if #droppedItems > 0 then
		-- Find who killed them (for tracking)
		local killerName = "Unknown"
		-- Check the damage tag
		local tag = humanoid:FindFirstChild("creator")
		if tag and tag.Value then
			killerName = tag.Value.Name
			-- Award kill to the killer
			local killerData = DataManager.GetData(tag.Value)
			if killerData then
				killerData.TotalKills = killerData.TotalKills + 1
			end
		end

		-- Create loot pile at death location
		createLootPile(root.Position, droppedItems, killerName)
		
		print("[PvP] " .. player.Name .. " was killed by " .. killerName .. " ‚Äî dropped " .. #droppedItems .. " item stacks!")
	end

	-- Update victim's empty inventory
	local invRemote = ReplicatedStorage.Remotes:FindFirstChild("InventoryUpdate")
	if invRemote then
		invRemote:FireClient(player, {})
	end
end

-- === PLAYER SETUP ===

Players.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function(character)
		local humanoid = character:WaitForChild("Humanoid")
		humanoid.Died:Connect(function()
			onCharacterDied(player, character)
		end)
	end)
end)

-- Cleanup on leave
Players.PlayerRemoving:Connect(function(player)
	playersInWilderness[player.UserId] = nil
end)

print("[WildernessManager] Full-loot PvP system active!")
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="59">
      <Properties>
        <string name="Name">WorldAnimations</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[--[[
	WorldAnimations.server.lua
	ServerScriptService

	Makes the world feel alive with ambient animations:
	- Torch flame flicker (size + brightness)
	- Water shimmer (transparency oscillation)
	- NPC idle breathing (torso scale pulse) + head turns
	- Tree canopy gentle sway
]]

local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

task.wait(6) -- let MapSetup + NPCManager finish

print("[WorldAnimations] Starting ambient animations...")

--------------------------------------------------------------------------------
-- TORCH FLICKER
--------------------------------------------------------------------------------
local function animateTorchFlames()
	local flames = {}
	-- Find all TorchFlame parts in workspace (recursive)
	for _, obj in Workspace:GetDescendants() do
		if obj:IsA("BasePart") and obj.Name == "TorchFlame" then
			table.insert(flames, obj)
		end
	end

	print("[WorldAnimations] Found " .. #flames .. " torch flames")

	for _, flame in ipairs(flames) do
		task.spawn(function()
			local baseSize = flame.Size
			local baseTransparency = flame.Transparency
			local light = flame:FindFirstChildOfClass("PointLight")
			local baseBrightness = light and light.Brightness or 2
			local baseRange = light and light.Range or 20

			while flame and flame.Parent do
				-- Random flicker target
				local scaleFactor = 0.85 + math.random() * 0.3
				local transFactor = baseTransparency + (math.random() * 0.2 - 0.05)
				local duration = 0.1 + math.random() * 0.2

				local tween = TweenService:Create(flame, TweenInfo.new(duration, Enum.EasingStyle.Sine), {
					Size = Vector3.new(
						baseSize.X * scaleFactor,
						baseSize.Y * (0.8 + math.random() * 0.4),
						baseSize.Z * scaleFactor
					),
					Transparency = math.clamp(transFactor, 0.05, 0.5),
				})
				tween:Play()

				if light then
					local lightTween = TweenService:Create(light, TweenInfo.new(duration, Enum.EasingStyle.Sine), {
						Brightness = baseBrightness * (0.7 + math.random() * 0.6),
						Range = baseRange * (0.85 + math.random() * 0.3),
					})
					lightTween:Play()
				end

				task.wait(duration + 0.02)
			end
		end)
	end
end

--------------------------------------------------------------------------------
-- FORGE FIRE FLICKER (same idea but for ForgeFire)
--------------------------------------------------------------------------------
local function animateForges()
	for _, obj in Workspace:GetDescendants() do
		if obj:IsA("BasePart") and (obj.Name == "ForgeFire" or obj.Name == "CookingRange") then
			task.spawn(function()
				local baseTransparency = obj.Transparency
				while obj and obj.Parent do
					local t = 0.15 + math.random() * 0.2
					TweenService:Create(obj, TweenInfo.new(t, Enum.EasingStyle.Sine), {
						Transparency = baseTransparency + math.random() * 0.15,
					}):Play()
					task.wait(t + 0.05)
				end
			end)
		end
	end
end

--------------------------------------------------------------------------------
-- WATER SHIMMER
--------------------------------------------------------------------------------
local function animateWater()
	local waterParts = {}
	local waterNames = {
		PondWater = true, LilyPond = true, FountainWater = true,
		FountainTopWater = true, LakeWater = true, DarkPondWater = true,
		SwampWater = true, WellWater = true, Waterfall = true,
	}

	for _, obj in Workspace:GetDescendants() do
		if obj:IsA("BasePart") and waterNames[obj.Name] then
			table.insert(waterParts, obj)
		end
	end

	print("[WorldAnimations] Found " .. #waterParts .. " water surfaces")

	for _, water in ipairs(waterParts) do
		task.spawn(function()
			local baseTransparency = water.Transparency
			local phase = math.random() * math.pi * 2

			while water and water.Parent do
				phase = phase + 0.03
				local newTrans = baseTransparency + math.sin(phase) * 0.08
				water.Transparency = math.clamp(newTrans, 0.1, 0.7)
				task.wait(0.05)
			end
		end)
	end
end

--------------------------------------------------------------------------------
-- LAVA PULSE
--------------------------------------------------------------------------------
local function animateLava()
	for _, obj in Workspace:GetDescendants() do
		if obj:IsA("BasePart") and (obj.Name == "LavaPit" or obj.Name:find("LavaRiver")) then
			task.spawn(function()
				local baseTransparency = obj.Transparency
				local phase = math.random() * math.pi * 2
				local light = obj:FindFirstChildOfClass("PointLight")

				while obj and obj.Parent do
					phase = phase + 0.04
					obj.Transparency = baseTransparency + math.sin(phase) * 0.1

					if light then
						light.Brightness = 4 + math.sin(phase * 1.3) * 1.5
					end
					task.wait(0.06)
				end
			end)
		end
	end
end

--------------------------------------------------------------------------------
-- NPC IDLE BREATHING + HEAD TURNS
--------------------------------------------------------------------------------
local function animateNPCs()
	local npcsFolder = Workspace:FindFirstChild("NPCs")
	if not npcsFolder then
		print("[WorldAnimations] No NPCs folder found, skipping NPC animations")
		return
	end

	for _, npc in npcsFolder:GetChildren() do
		if not npc:IsA("Model") then continue end

		local torso = npc:FindFirstChild("Torso")
		local head = npc:FindFirstChild("Head")

		if torso then
			-- Breathing: gentle Y-scale pulse on torso
			task.spawn(function()
				local basePos = torso.Position
				local breathPhase = math.random() * math.pi * 2

				while torso and torso.Parent do
					breathPhase = breathPhase + 0.06
					local breathOffset = math.sin(breathPhase) * 0.04
					torso.Position = Vector3.new(basePos.X, basePos.Y + breathOffset, basePos.Z)
					task.wait(0.05)
				end
			end)
		end

		if head then
			-- Occasional head turns
			task.spawn(function()
				local baseCF = head.CFrame

				while head and head.Parent do
					-- Wait 3-8 seconds between head turns
					task.wait(3 + math.random() * 5)

					if not head or not head.Parent then break end

					-- Turn head slightly left or right
					local turnAngle = (math.random() * 30 - 15)
					local targetCF = baseCF * CFrame.Angles(0, math.rad(turnAngle), 0)

					TweenService:Create(head, TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
						CFrame = targetCF,
					}):Play()

					-- Hold for a moment, then return
					task.wait(1.5 + math.random() * 2)

					if head and head.Parent then
						TweenService:Create(head, TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
							CFrame = baseCF,
						}):Play()
					end
				end
			end)
		end
	end
end

--------------------------------------------------------------------------------
-- TREE CANOPY GENTLE SWAY
--------------------------------------------------------------------------------
local function animateTreeCanopies()
	local canopyParts = {}

	-- Find leaf/canopy parts in Forest and Grove areas
	for _, obj in Workspace:GetDescendants() do
		if obj:IsA("BasePart") and (obj.Name == "SLeaf" or obj.Name == "Leaves" or obj.Name:find("AncientCanopy")) then
			table.insert(canopyParts, obj)
		end
	end

	print("[WorldAnimations] Found " .. #canopyParts .. " tree canopies to sway")

	-- Only animate a subset to keep performance reasonable
	local maxAnimated = 30
	local count = 0

	for _, leaf in ipairs(canopyParts) do
		if count >= maxAnimated then break end
		count = count + 1

		task.spawn(function()
			local basePos = leaf.Position
			local phase = math.random() * math.pi * 2
			local swayAmount = 0.15 + math.random() * 0.1
			local speed = 0.02 + math.random() * 0.01

			while leaf and leaf.Parent do
				phase = phase + speed
				local offsetX = math.sin(phase) * swayAmount
				local offsetZ = math.cos(phase * 0.7) * swayAmount * 0.6
				leaf.Position = Vector3.new(basePos.X + offsetX, basePos.Y, basePos.Z + offsetZ)
				task.wait(0.08)
			end
		end)
	end
end

--------------------------------------------------------------------------------
-- GLOWING MUSHROOM PULSE
--------------------------------------------------------------------------------
local function animateMushrooms()
	for _, obj in Workspace:GetDescendants() do
		if obj:IsA("BasePart") and (obj.Name:find("Mushroom") or obj.Name:find("BlueMushroom")) then
			task.spawn(function()
				local baseTransparency = obj.Transparency
				local light = obj:FindFirstChildOfClass("PointLight")
				local baseBrightness = light and light.Brightness or 1
				local phase = math.random() * math.pi * 2

				while obj and obj.Parent do
					phase = phase + 0.04
					obj.Transparency = baseTransparency + math.sin(phase) * 0.12

					if light then
						light.Brightness = baseBrightness + math.sin(phase) * 0.4
					end
					task.wait(0.06)
				end
			end)
		end
	end
end

--------------------------------------------------------------------------------
-- CRYSTAL FLOAT (Abyss crystals bob up and down)
--------------------------------------------------------------------------------
local function animateCrystals()
	for _, obj in Workspace:GetDescendants() do
		if obj:IsA("BasePart") and obj.Name:find("Crystal") and obj.Parent and obj.Parent.Name == "TheAbyss" then
			task.spawn(function()
				local basePos = obj.Position
				local phase = math.random() * math.pi * 2
				local bobAmount = 0.3 + math.random() * 0.4

				while obj and obj.Parent do
					phase = phase + 0.025
					obj.Position = Vector3.new(basePos.X, basePos.Y + math.sin(phase) * bobAmount, basePos.Z)
					task.wait(0.06)
				end
			end)
		end
	end
end

--------------------------------------------------------------------------------
-- CAULDRON BUBBLE (Thessaly's brew)
--------------------------------------------------------------------------------
local function animateCauldrons()
	for _, obj in Workspace:GetDescendants() do
		if obj:IsA("BasePart") and obj.Name == "Brew" then
			task.spawn(function()
				local baseTransparency = obj.Transparency
				local phase = 0

				while obj and obj.Parent do
					phase = phase + 0.08
					obj.Transparency = baseTransparency + math.sin(phase) * 0.1
					task.wait(0.05)
				end
			end)
		end
	end
end

--------------------------------------------------------------------------------
-- STAINED GLASS SHIMMER (Chapel windows)
--------------------------------------------------------------------------------
local function animateStainedGlass()
	for _, obj in Workspace:GetDescendants() do
		if obj:IsA("BasePart") and obj.Name:find("StainedGlass") then
			task.spawn(function()
				local baseTransparency = obj.Transparency
				local phase = math.random() * math.pi * 2

				while obj and obj.Parent do
					phase = phase + 0.02
					obj.Transparency = baseTransparency + math.sin(phase) * 0.08
					task.wait(0.1)
				end
			end)
		end
	end
end

--------------------------------------------------------------------------------
-- LAUNCH ALL ANIMATIONS
--------------------------------------------------------------------------------
task.spawn(animateTorchFlames)
task.spawn(animateForges)
task.spawn(animateWater)
task.spawn(animateLava)
task.spawn(animateNPCs)
task.spawn(animateTreeCanopies)
task.spawn(animateMushrooms)
task.spawn(animateCrystals)
task.spawn(animateCauldrons)
task.spawn(animateStainedGlass)

print("[WorldAnimations] All ambient animations started!")
]]></string>
      </Properties>
    </Item>
  </Item>
  <Item class="StarterGui" referent="60">
    <Properties>
      <string name="Name">StarterGui</string>
    </Properties>
  </Item>
  <Item class="StarterPlayer" referent="61">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="62">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="LocalScript" referent="63">
        <Properties>
          <string name="Name">AttackAnimations</string>
          <string name="Source"><![CDATA[--[[
	AttackAnimations.client.lua
	StarterPlayerScripts

	Comprehensive combat animation system for Roscape Runeblocks.
	Uses TweenService to animate character limbs (no rbxassetid).
	Handles: player attacks, monster attack visuals, hit effects,
	damage numbers, death animations, combo counter, cooldown UI.
]]

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Debris = game:GetService("Debris")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local camera = workspace.CurrentCamera

--------------------------------------------------------------------------------
-- REMOTE EVENTS
--------------------------------------------------------------------------------
local Remotes = ReplicatedStorage:WaitForChild("Remotes")

local function waitForRemote(name)
	-- Try Remotes folder first, then root ReplicatedStorage
	local r = Remotes:FindFirstChild(name)
	if r then return r end
	r = ReplicatedStorage:FindFirstChild(name)
	if r then return r end
	-- Wait briefly
	r = Remotes:FindFirstChild(name) or ReplicatedStorage:WaitForChild(name, 5)
	return r
end

local MonsterDamageEvent = waitForRemote("MonsterDamage")
local MonsterDeathEvent = waitForRemote("MonsterDeath")
local AttackVisualEvent = waitForRemote("AttackVisual")
local HitEffectEvent = waitForRemote("HitEffect")
local MonsterAttackVisualEvent = waitForRemote("MonsterAttackVisual")

--------------------------------------------------------------------------------
-- SCREEN GUI for damage numbers, cooldown, combo
--------------------------------------------------------------------------------
local combatGui = Instance.new("ScreenGui")
combatGui.Name = "CombatEffectsUI"
combatGui.ResetOnSpawn = false
combatGui.DisplayOrder = 10
combatGui.Parent = playerGui

--------------------------------------------------------------------------------
-- STATE
--------------------------------------------------------------------------------
local isAnimating = false
local lastAttackTime = 0
local ATTACK_COOLDOWN = 0.6
local punchHand = "right" -- alternates
local comboCount = 0
local lastComboTime = 0
local COMBO_TIMEOUT = 3

--------------------------------------------------------------------------------
-- UTILITY
--------------------------------------------------------------------------------
local function getCharacter()
	return player.Character
end

local function getHumanoidRootPart()
	local char = getCharacter()
	return char and char:FindFirstChild("HumanoidRootPart")
end

-- Find Motor6D inside a limb part (R15)
local function findMotor(character, limbName)
	local limb = character:FindFirstChild(limbName)
	if not limb then return nil, nil end
	local motor = limb:FindFirstChildOfClass("Motor6D")
	return motor, limb
end

-- Safe tween that doesn't error if object is destroyed
local function safeTween(obj, info, props)
	if not obj or not obj.Parent then return nil end
	local t = TweenService:Create(obj, info, props)
	t:Play()
	return t
end

--------------------------------------------------------------------------------
-- CAMERA SHAKE
--------------------------------------------------------------------------------
local shakeAmount = 0
local shakeDecay = 0

local function applyScreenShake(intensity, duration)
	shakeAmount = intensity
	shakeDecay = intensity / duration
end

RunService.RenderStepped:Connect(function(dt)
	if shakeAmount > 0.001 then
		local offsetX = (math.random() - 0.5) * 2 * shakeAmount
		local offsetY = (math.random() - 0.5) * 2 * shakeAmount
		camera.CFrame = camera.CFrame * CFrame.new(offsetX, offsetY, 0)
		shakeAmount = math.max(0, shakeAmount - shakeDecay * dt)
	end
end)

--------------------------------------------------------------------------------
-- COMBO COUNTER UI
--------------------------------------------------------------------------------
local comboFrame = Instance.new("Frame")
comboFrame.Name = "ComboCounter"
comboFrame.Size = UDim2.new(0, 120, 0, 60)
comboFrame.Position = UDim2.new(1, -140, 0.35, 0)
comboFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
comboFrame.BackgroundTransparency = 0.4
comboFrame.BorderSizePixel = 0
comboFrame.Visible = false
comboFrame.Parent = combatGui

local comboCorner = Instance.new("UICorner")
comboCorner.CornerRadius = UDim.new(0, 8)
comboCorner.Parent = comboFrame

local comboStroke = Instance.new("UIStroke")
comboStroke.Color = Color3.fromRGB(255, 200, 50)
comboStroke.Thickness = 2
comboStroke.Parent = comboFrame

local comboLabel = Instance.new("TextLabel")
comboLabel.Name = "Count"
comboLabel.Size = UDim2.new(1, 0, 0.65, 0)
comboLabel.Position = UDim2.new(0, 0, 0, 0)
comboLabel.BackgroundTransparency = 1
comboLabel.Text = "0"
comboLabel.TextColor3 = Color3.fromRGB(255, 220, 50)
comboLabel.TextScaled = true
comboLabel.Font = Enum.Font.GothamBold
comboLabel.Parent = comboFrame

local comboSubLabel = Instance.new("TextLabel")
comboSubLabel.Name = "Sub"
comboSubLabel.Size = UDim2.new(1, 0, 0.35, 0)
comboSubLabel.Position = UDim2.new(0, 0, 0.65, 0)
comboSubLabel.BackgroundTransparency = 1
comboSubLabel.Text = "COMBO"
comboSubLabel.TextColor3 = Color3.fromRGB(200, 180, 100)
comboSubLabel.TextScaled = true
comboSubLabel.Font = Enum.Font.Gotham
comboSubLabel.Parent = comboFrame

local function updateCombo()
	local now = tick()
	if now - lastComboTime > COMBO_TIMEOUT then
		comboCount = 0
	end
	comboCount = comboCount + 1
	lastComboTime = now
	comboLabel.Text = tostring(comboCount)
	comboFrame.Visible = true

	-- Pulse effect
	comboFrame.Size = UDim2.new(0, 140, 0, 70)
	safeTween(comboFrame, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, 120, 0, 60)
	})

	-- Color based on combo
	if comboCount >= 10 then
		comboLabel.TextColor3 = Color3.fromRGB(255, 50, 50)
		comboStroke.Color = Color3.fromRGB(255, 50, 50)
	elseif comboCount >= 5 then
		comboLabel.TextColor3 = Color3.fromRGB(255, 150, 50)
		comboStroke.Color = Color3.fromRGB(255, 150, 50)
	else
		comboLabel.TextColor3 = Color3.fromRGB(255, 220, 50)
		comboStroke.Color = Color3.fromRGB(255, 200, 50)
	end
end

-- Combo timeout check
task.spawn(function()
	while true do
		task.wait(0.5)
		if comboCount > 0 and tick() - lastComboTime > COMBO_TIMEOUT then
			comboCount = 0
			comboFrame.Visible = false
		end
	end
end)

--------------------------------------------------------------------------------
-- COOLDOWN INDICATOR (circular timer near center)
--------------------------------------------------------------------------------
local cooldownFrame = Instance.new("Frame")
cooldownFrame.Name = "CooldownIndicator"
cooldownFrame.Size = UDim2.new(0, 30, 0, 30)
cooldownFrame.Position = UDim2.new(0.5, -15, 0.55, 0)
cooldownFrame.BackgroundColor3 = Color3.fromRGB(200, 200, 200)
cooldownFrame.BackgroundTransparency = 0.7
cooldownFrame.BorderSizePixel = 0
cooldownFrame.Visible = false
cooldownFrame.Parent = combatGui

local cdCorner = Instance.new("UICorner")
cdCorner.CornerRadius = UDim.new(0.5, 0)
cdCorner.Parent = cooldownFrame

local cdStroke = Instance.new("UIStroke")
cdStroke.Color = Color3.fromRGB(255, 255, 255)
cdStroke.Thickness = 2
cdStroke.Transparency = 0.5
cdStroke.Parent = cooldownFrame

local function showCooldown()
	cooldownFrame.Visible = true
	cooldownFrame.BackgroundTransparency = 0.3
	cooldownFrame.Size = UDim2.new(0, 30, 0, 30)
	safeTween(cooldownFrame, TweenInfo.new(ATTACK_COOLDOWN, Enum.EasingStyle.Linear), {
		BackgroundTransparency = 0.9,
		Size = UDim2.new(0, 10, 0, 10),
	})
	task.delay(ATTACK_COOLDOWN, function()
		cooldownFrame.Visible = false
		cooldownFrame.Position = UDim2.new(0.5, -15, 0.55, 0)
	end)
end

--------------------------------------------------------------------------------
-- DAMAGE NUMBERS (3D billboard style)
--------------------------------------------------------------------------------
local function showDamageNumber3D(position, text, color, isCritical)
	local part = Instance.new("Part")
	part.Name = "DmgNum"
	part.Size = Vector3.new(0.1, 0.1, 0.1)
	part.Transparency = 1
	part.Anchored = true
	part.CanCollide = false
	part.Position = position + Vector3.new((math.random() - 0.5) * 2, 2, (math.random() - 0.5) * 2)
	part.Parent = workspace

	local bbg = Instance.new("BillboardGui")
	bbg.Size = isCritical and UDim2.new(6, 0, 2, 0) or UDim2.new(4, 0, 1.5, 0)
	bbg.StudsOffset = Vector3.new(0, 0, 0)
	bbg.AlwaysOnTop = true
	bbg.Adornee = part
	bbg.Parent = part

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = text
	label.TextColor3 = color
	label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	label.TextStrokeTransparency = 0
	label.TextScaled = true
	label.Font = Enum.Font.GothamBold
	label.Parent = bbg

	-- Scale up on critical
	if isCritical then
		label.TextSize = 28
		label.Text = "üí• " .. text .. " üí•"
	end

	-- Float up and fade
	local startPos = part.Position
	local endPos = startPos + Vector3.new(0, 4, 0)

	safeTween(part, TweenInfo.new(1.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Position = endPos,
	})

	task.delay(0.6, function()
		safeTween(label, TweenInfo.new(0.6), {
			TextTransparency = 1,
			TextStrokeTransparency = 1,
		})
	end)

	Debris:AddItem(part, 1.5)
end

--------------------------------------------------------------------------------
-- HIT FLASH (white flash on target)
--------------------------------------------------------------------------------
local function applyHitFlash(model)
	if not model or not model.Parent then return end
	local originalColors = {}

	for _, part in ipairs(model:GetDescendants()) do
		if part:IsA("BasePart") and part.Name ~= "DmgNum" then
			originalColors[part] = part.Color
			part.Color = Color3.fromRGB(255, 255, 255)
		end
	end

	task.delay(0.08, function()
		for part, color in pairs(originalColors) do
			if part and part.Parent then
				part.Color = color
			end
		end
	end)
end

--------------------------------------------------------------------------------
-- BLOOD/HIT PARTICLES
--------------------------------------------------------------------------------
local function spawnHitParticles(position, color, count)
	color = color or Color3.fromRGB(200, 50, 50)
	count = count or 6

	for i = 1, count do
		local particle = Instance.new("Part")
		particle.Name = "HitParticle"
		particle.Size = Vector3.new(0.2, 0.2, 0.2)
		particle.Shape = Enum.PartType.Ball
		particle.Anchored = true
		particle.CanCollide = false
		particle.Material = Enum.Material.Neon
		particle.Color = color
		particle.Transparency = 0.2
		particle.Position = position
		particle.Parent = workspace

		local dir = Vector3.new(
			(math.random() - 0.5) * 6,
			math.random() * 4 + 1,
			(math.random() - 0.5) * 6
		)

		safeTween(particle, TweenInfo.new(0.4 + math.random() * 0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			Position = position + dir,
			Size = Vector3.new(0.05, 0.05, 0.05),
			Transparency = 1,
		})

		Debris:AddItem(particle, 0.8)
	end
end

--------------------------------------------------------------------------------
-- SPARK PARTICLES (for shield block / metallic impacts)
--------------------------------------------------------------------------------
local function spawnSparks(position, count)
	count = count or 8
	for i = 1, count do
		local spark = Instance.new("Part")
		spark.Name = "Spark"
		spark.Size = Vector3.new(0.15, 0.15, 0.15)
		spark.Shape = Enum.PartType.Ball
		spark.Anchored = true
		spark.CanCollide = false
		spark.Material = Enum.Material.Neon
		spark.Color = Color3.fromRGB(255, 220 + math.random(35), math.random(100))
		spark.Transparency = 0
		spark.Position = position
		spark.Parent = workspace

		local dir = Vector3.new(
			(math.random() - 0.5) * 5,
			math.random() * 3 + 1,
			(math.random() - 0.5) * 5
		)

		safeTween(spark, TweenInfo.new(0.2 + math.random() * 0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			Position = position + dir,
			Size = Vector3.new(0.03, 0.03, 0.03),
			Transparency = 1,
		})

		Debris:AddItem(spark, 0.5)
	end
end

--------------------------------------------------------------------------------
-- SWOOSH TRAIL (sword arc effect)
--------------------------------------------------------------------------------
local function createSwooshTrail(character, isLeftSwing)
	local root = character:FindFirstChild("HumanoidRootPart")
	if not root then return end

	local startAngle = isLeftSwing and -60 or 60
	local endAngle = isLeftSwing and 60 or -60

	local slashColors = {
		Color3.fromRGB(255, 255, 255),
		Color3.fromRGB(200, 220, 255),
		Color3.fromRGB(150, 180, 255),
	}

	for idx, color in ipairs(slashColors) do
		local delay = (idx - 1) * 0.025
		task.delay(delay, function()
			if not root or not root.Parent then return end
			local slash = Instance.new("Part")
			slash.Name = "SwordSwoosh"
			slash.Size = Vector3.new(0.1, 0.3, 4 + idx * 0.3)
			slash.Anchored = true
			slash.CanCollide = false
			slash.Material = Enum.Material.Neon
			slash.Color = color
			slash.Transparency = 0.1 + (idx * 0.15)
			slash.CFrame = root.CFrame * CFrame.new(0, 0.5, -2.5) * CFrame.Angles(0, 0, math.rad(startAngle))
			slash.Parent = workspace

			safeTween(slash, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				CFrame = root.CFrame * CFrame.new(0, 0.5, -2.5) * CFrame.Angles(0, 0, math.rad(endAngle)),
				Transparency = 1,
				Size = Vector3.new(0.03, 0.1, 5),
			})

			Debris:AddItem(slash, 0.3)
		end)
	end
end

--------------------------------------------------------------------------------
-- PLAYER ATTACK ANIMATIONS
--------------------------------------------------------------------------------

-- SWORD SWING (R15 Motor6D based)
local function playSwordSwing(character, isCritical)
	local rightShoulder = findMotor(character, "RightUpperArm")
	local torsoMotor = findMotor(character, "UpperTorso")

	local swingAngle = isCritical and -120 or -90
	local swingDuration = isCritical and 0.15 or 0.2
	local returnDelay = isCritical and 0.2 or 0.3

	-- Alternate swing direction
	local isLeftSwing = (comboCount % 2 == 0)

	-- Swing right arm
	if rightShoulder then
		local originalC0 = rightShoulder.C0
		local swingCF = originalC0 * CFrame.Angles(math.rad(swingAngle), math.rad(isLeftSwing and -20 or 20), 0)

		safeTween(rightShoulder, TweenInfo.new(swingDuration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			C0 = swingCF,
		})

		task.delay(returnDelay, function()
			if rightShoulder and rightShoulder.Parent then
				safeTween(rightShoulder, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
					C0 = originalC0,
				})
			end
		end)
	end

	-- Lean torso into swing
	if torsoMotor then
		local originalC0 = torsoMotor.C0
		local leanAngle = isCritical and -15 or -8
		local leanCF = originalC0 * CFrame.Angles(math.rad(leanAngle), math.rad(isLeftSwing and -5 or 5), 0)

		safeTween(torsoMotor, TweenInfo.new(swingDuration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			C0 = leanCF,
		})

		task.delay(returnDelay, function()
			if torsoMotor and torsoMotor.Parent then
				safeTween(torsoMotor, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
					C0 = originalC0,
				})
			end
		end)
	end

	-- Swoosh trail
	createSwooshTrail(character, isLeftSwing)

	-- Camera shake on critical
	if isCritical then
		applyScreenShake(0.4, 0.3)
	else
		applyScreenShake(0.1, 0.15)
	end
end

-- BOW SHOT
local function playBowShot(character, targetPosition)
	local leftShoulder = findMotor(character, "LeftUpperArm")
	local rightShoulder = findMotor(character, "RightUpperArm")

	-- Draw bow (left arm pulls back)
	if leftShoulder then
		local originalC0 = leftShoulder.C0
		local drawCF = originalC0 * CFrame.Angles(math.rad(-70), math.rad(30), 0)

		safeTween(leftShoulder, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			C0 = drawCF,
		})

		-- Release
		task.delay(0.3, function()
			if leftShoulder and leftShoulder.Parent then
				local releaseCF = originalC0 * CFrame.Angles(math.rad(-90), 0, 0)
				safeTween(leftShoulder, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					C0 = releaseCF,
				})
			end
		end)

		-- Return
		task.delay(0.5, function()
			if leftShoulder and leftShoulder.Parent then
				safeTween(leftShoulder, TweenInfo.new(0.2), { C0 = originalC0 })
			end
		end)
	end

	-- Right arm aims forward
	if rightShoulder then
		local originalC0 = rightShoulder.C0
		local aimCF = originalC0 * CFrame.Angles(math.rad(-80), 0, 0)

		safeTween(rightShoulder, TweenInfo.new(0.15), { C0 = aimCF })

		task.delay(0.5, function()
			if rightShoulder and rightShoulder.Parent then
				safeTween(rightShoulder, TweenInfo.new(0.2), { C0 = originalC0 })
			end
		end)
	end

	-- Fire projectile arrow
	task.delay(0.3, function()
		local root = character:FindFirstChild("HumanoidRootPart")
		if not root or not targetPosition then return end

		local arrow = Instance.new("Part")
		arrow.Name = "Arrow"
		arrow.Size = Vector3.new(0.1, 0.1, 2)
		arrow.Anchored = true
		arrow.CanCollide = false
		arrow.Material = Enum.Material.Wood
		arrow.Color = Color3.fromRGB(139, 90, 43)
		arrow.CFrame = CFrame.new(root.Position + Vector3.new(0, 1.5, 0), targetPosition)
		arrow.Parent = workspace

		-- Arrow tip
		local tip = Instance.new("Part")
		tip.Name = "ArrowTip"
		tip.Size = Vector3.new(0.15, 0.15, 0.3)
		tip.Anchored = true
		tip.CanCollide = false
		tip.Material = Enum.Material.Metal
		tip.Color = Color3.fromRGB(150, 150, 150)
		tip.CFrame = arrow.CFrame * CFrame.new(0, 0, -1.1)
		tip.Parent = workspace

		-- Fly to target
		local dist = (targetPosition - root.Position).Magnitude
		local flyTime = math.clamp(dist / 80, 0.1, 0.8)

		local targetCF = CFrame.new(targetPosition, targetPosition + (targetPosition - root.Position).Unit)

		safeTween(arrow, TweenInfo.new(flyTime, Enum.EasingStyle.Linear), {
			CFrame = targetCF,
		})
		safeTween(tip, TweenInfo.new(flyTime, Enum.EasingStyle.Linear), {
			CFrame = targetCF * CFrame.new(0, 0, -1.1),
		})

		-- Stick and fade
		task.delay(flyTime + 0.5, function()
			safeTween(arrow, TweenInfo.new(0.5), { Transparency = 1 })
			safeTween(tip, TweenInfo.new(0.5), { Transparency = 1 })
		end)

		Debris:AddItem(arrow, flyTime + 1.5)
		Debris:AddItem(tip, flyTime + 1.5)
	end)
end

-- UNARMED PUNCH
local function playPunchAnimation(character)
	local isRight = (punchHand == "right")
	punchHand = isRight and "left" or "right"

	local limbName = isRight and "RightUpperArm" or "LeftUpperArm"
	local shoulder = findMotor(character, limbName)

	if shoulder then
		local originalC0 = shoulder.C0
		local punchCF = originalC0 * CFrame.Angles(math.rad(-90), 0, math.rad(isRight and -10 or 10))

		-- Quick jab
		safeTween(shoulder, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			C0 = punchCF,
		})

		-- Retract
		task.delay(0.15, function()
			if shoulder and shoulder.Parent then
				safeTween(shoulder, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
					C0 = originalC0,
				})
			end
		end)
	end

	-- Lean into punch
	local torsoMotor = findMotor(character, "UpperTorso")
	if torsoMotor then
		local originalC0 = torsoMotor.C0
		local leanCF = originalC0 * CFrame.Angles(math.rad(-5), math.rad(isRight and 5 or -5), 0)
		safeTween(torsoMotor, TweenInfo.new(0.1), { C0 = leanCF })
		task.delay(0.2, function()
			if torsoMotor and torsoMotor.Parent then
				safeTween(torsoMotor, TweenInfo.new(0.15), { C0 = originalC0 })
			end
		end)
	end

	applyScreenShake(0.05, 0.1)
end

-- SHIELD BLOCK
local function playShieldBlock(character)
	local leftShoulder = findMotor(character, "LeftUpperArm")

	if leftShoulder then
		local originalC0 = leftShoulder.C0
		local blockCF = originalC0 * CFrame.Angles(math.rad(-70), math.rad(40), math.rad(-20))

		safeTween(leftShoulder, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			C0 = blockCF,
		})

		-- Shield flash effect
		local root = character:FindFirstChild("HumanoidRootPart")
		if root then
			local flash = Instance.new("Part")
			flash.Name = "ShieldFlash"
			flash.Size = Vector3.new(2.5, 3, 0.3)
			flash.Anchored = true
			flash.CanCollide = false
			flash.Material = Enum.Material.Neon
			flash.Color = Color3.fromRGB(200, 220, 255)
			flash.Transparency = 0.3
			flash.CFrame = root.CFrame * CFrame.new(-0.8, 0.5, -1.5)
			flash.Parent = workspace

			safeTween(flash, TweenInfo.new(0.2), {
				Transparency = 1,
				Size = Vector3.new(3, 3.5, 0.5),
			})
			Debris:AddItem(flash, 0.3)

			spawnSparks(root.Position + root.CFrame.LookVector * -1.5 + Vector3.new(0, 1, 0), 6)
		end

		-- Lower back
		task.delay(0.3, function()
			if leftShoulder and leftShoulder.Parent then
				safeTween(leftShoulder, TweenInfo.new(0.2), { C0 = originalC0 })
			end
		end)
	end
end

--------------------------------------------------------------------------------
-- DETECT WEAPON TYPE (cached from server EquipmentInfo event)
--------------------------------------------------------------------------------
local cachedWeaponType = "fist"
local cachedWeaponName = ""
local cachedHasShield = false

-- Listen for equipment info from server
local EquipmentInfoEvent = ReplicatedStorage:FindFirstChild("EquipmentInfo")
if not EquipmentInfoEvent then
	EquipmentInfoEvent = ReplicatedStorage:WaitForChild("EquipmentInfo", 10)
end
if EquipmentInfoEvent then
	EquipmentInfoEvent.OnClientEvent:Connect(function(info)
		if info then
			cachedWeaponType = info.weaponType or "fist"
			cachedWeaponName = info.weaponName or ""
			cachedHasShield = info.hasShield or false
		end
	end)
end

local function getWeaponType()
	-- Use cached weapon type from server EquipmentInfo
	local wt = cachedWeaponType
	if wt == "bow" or wt == "crossbow" then
		return "ranged"
	elseif wt == "sword" then
		return "melee"
	end

	-- Fallback: check for visual weapon on character
	local char = getCharacter()
	if char then
		local visualWeapon = char:FindFirstChild("VisualEquip_Weapon")
		if visualWeapon then
			return "melee"
		end
	end

	return "unarmed"
end

--------------------------------------------------------------------------------
-- MAIN PLAYER ATTACK FUNCTION
--------------------------------------------------------------------------------
local function performPlayerAttack(targetModel, isCritical)
	local character = getCharacter()
	if not character then return end
	if isAnimating then return end

	local now = tick()
	if now - lastAttackTime < ATTACK_COOLDOWN then return end
	lastAttackTime = now
	isAnimating = true

	showCooldown()
	updateCombo()

	local weaponType = getWeaponType()
	local targetPos = nil
	if targetModel and targetModel.PrimaryPart then
		targetPos = targetModel.PrimaryPart.Position
	elseif targetModel and targetModel:IsA("BasePart") then
		targetPos = targetModel.Position
	end

	if weaponType == "ranged" then
		playBowShot(character, targetPos)
	elseif weaponType == "melee" then
		playSwordSwing(character, isCritical)
	else
		playPunchAnimation(character)
	end

	-- Impact effects at target
	if targetPos then
		task.delay(weaponType == "ranged" and 0.4 or 0.15, function()
			spawnHitParticles(targetPos + Vector3.new(0, 1, 0), nil, isCritical and 10 or 5)
		end)
	end

	task.delay(0.35, function()
		isAnimating = false
	end)
end

--------------------------------------------------------------------------------
-- MONSTER ATTACK ANIMATIONS (client-side visuals)
--------------------------------------------------------------------------------

-- Map monster names to attack types
local MONSTER_ATTACK_TYPES = {
	["Goblin"] = "melee_lunge",
	["Guard Dog"] = "bite",
	["Skeleton"] = "melee_lunge",
	["Demon"] = "melee_lunge",
	["Giant Rat"] = "bite",
	["Chicken"] = "bite",
	["Cow"] = "bite",
	["Dark Wizard"] = "magic_cast",
	["Shadow Dragon"] = "dragon_breath",
	["Training Dummy"] = nil,
}

local function animateMeleeLunge(model, targetPos)
	if not model or not model.PrimaryPart then return end
	local body = model.PrimaryPart
	local originalCF = body.CFrame

	-- Calculate lunge direction
	local dir = (targetPos - body.Position) * Vector3.new(1, 0, 1)
	if dir.Magnitude < 0.1 then return end
	local lungeOffset = dir.Unit * 2

	-- Lunge forward
	local lungeCF = CFrame.new(body.Position + lungeOffset, body.Position + lungeOffset + dir.Unit)

	-- Move body forward
	safeTween(body, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		CFrame = lungeCF,
	})

	-- Move extra parts too
	for _, child in ipairs(model:GetChildren()) do
		if child:IsA("BasePart") and child ~= body then
			safeTween(child, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				Position = child.Position + lungeOffset,
			})
		end
	end

	-- Snap back
	task.delay(0.25, function()
		if not model or not model.Parent or not body or not body.Parent then return end
		safeTween(body, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
			CFrame = originalCF,
		})
		-- Return children
		local returnOffset = originalCF.Position - (body.Position)
		for _, child in ipairs(model:GetChildren()) do
			if child:IsA("BasePart") and child ~= body then
				safeTween(child, TweenInfo.new(0.2), {
					Position = child.Position + returnOffset,
				})
			end
		end
	end)

	-- Animate arms/claws if they exist
	local armL = model:FindFirstChild("ArmL") or model:FindFirstChild("ClawL")
	local armR = model:FindFirstChild("ArmR") or model:FindFirstChild("ClawR")

	if armL then
		local origPos = armL.Position
		safeTween(armL, TweenInfo.new(0.12), {
			Position = origPos + lungeOffset * 0.5 + Vector3.new(0, 0.3, 0),
		})
		task.delay(0.25, function()
			if armL and armL.Parent then
				safeTween(armL, TweenInfo.new(0.2), { Position = origPos })
			end
		end)
	end

	if armR then
		local origPos = armR.Position
		safeTween(armR, TweenInfo.new(0.12), {
			Position = origPos + lungeOffset * 0.5 + Vector3.new(0, 0.3, 0),
		})
		task.delay(0.25, function()
			if armR and armR.Parent then
				safeTween(armR, TweenInfo.new(0.2), { Position = origPos })
			end
		end)
	end
end

local function animateBite(model, targetPos)
	if not model or not model.PrimaryPart then return end
	local body = model.PrimaryPart
	local head = model:FindFirstChild("Head")
	if not head then return end

	local dir = (targetPos - body.Position) * Vector3.new(1, 0, 1)
	if dir.Magnitude < 0.1 then return end
	local biteOffset = dir.Unit * 1.5

	local origHeadPos = head.Position
	local origBodyCF = body.CFrame

	-- Head lunges forward
	safeTween(head, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Position = origHeadPos + biteOffset + Vector3.new(0, -0.3, 0),
	})

	-- Body follows slightly
	safeTween(body, TweenInfo.new(0.12), {
		CFrame = CFrame.new(body.Position + biteOffset * 0.3, body.Position + biteOffset * 0.3 + dir.Unit),
	})

	-- Snap back
	task.delay(0.2, function()
		if head and head.Parent then
			safeTween(head, TweenInfo.new(0.15), { Position = origHeadPos })
		end
		if body and body.Parent then
			safeTween(body, TweenInfo.new(0.15), { CFrame = origBodyCF })
		end
		-- Return all children
		for _, child in ipairs(model:GetChildren()) do
			if child:IsA("BasePart") and child ~= body and child ~= head then
				safeTween(child, TweenInfo.new(0.15), {
					Position = child.Position - biteOffset * 0.3,
				})
			end
		end
	end)

	-- Snout/mouth parts animate
	local snout = model:FindFirstChild("Snout")
	if snout then
		local origSnoutPos = snout.Position
		safeTween(snout, TweenInfo.new(0.1), {
			Position = origSnoutPos + biteOffset * 0.8,
		})
		task.delay(0.2, function()
			if snout and snout.Parent then
				safeTween(snout, TweenInfo.new(0.15), { Position = origSnoutPos })
			end
		end)
	end
end

local function animateMagicCast(model, targetPos)
	if not model or not model.PrimaryPart then return end
	local body = model.PrimaryPart

	-- Find staff orb
	local staffOrb = model:FindFirstChild("StaffOrb")
	local handL = model:FindFirstChild("HandL")

	-- Arms raise (move arm parts up)
	local armParts = {}
	for _, name in ipairs({"HandL", "HandR", "Staff", "StaffOrb", "StaffRing"}) do
		local p = model:FindFirstChild(name)
		if p then
			table.insert(armParts, {part = p, origPos = p.Position})
			safeTween(p, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				Position = p.Position + Vector3.new(0, 1.5, 0),
			})
		end
	end

	-- Staff orb glows brighter and scales
	if staffOrb then
		local origSize = staffOrb.Size
		local origTransparency = staffOrb.Transparency
		safeTween(staffOrb, TweenInfo.new(0.3), {
			Size = origSize * 1.8,
			Transparency = 0,
		})

		-- Fire projectile
		task.delay(0.4, function()
			if not staffOrb or not staffOrb.Parent then return end

			-- Reset orb
			safeTween(staffOrb, TweenInfo.new(0.3), {
				Size = origSize,
				Transparency = origTransparency or 0,
			})

			-- Create magic projectile
			local projectile = Instance.new("Part")
			projectile.Name = "MagicProjectile"
			projectile.Size = Vector3.new(1.2, 1.2, 1.2)
			projectile.Shape = Enum.PartType.Ball
			projectile.Anchored = true
			projectile.CanCollide = false
			projectile.Material = Enum.Material.Neon
			projectile.Color = Color3.fromRGB(180, 50, 255)
			projectile.Position = staffOrb.Position
			projectile.Parent = workspace

			local light = Instance.new("PointLight")
			light.Color = Color3.fromRGB(180, 50, 255)
			light.Brightness = 3
			light.Range = 12
			light.Parent = projectile

			-- Fly to target
			local dist = (targetPos - staffOrb.Position).Magnitude
			local flyTime = math.clamp(dist / 60, 0.15, 1.0)

			safeTween(projectile, TweenInfo.new(flyTime, Enum.EasingStyle.Linear), {
				Position = targetPos + Vector3.new(0, 2, 0),
			})

			-- Trail particles behind projectile
			task.spawn(function()
				local elapsed = 0
				while elapsed < flyTime and projectile and projectile.Parent do
					local trail = Instance.new("Part")
					trail.Size = Vector3.new(0.4, 0.4, 0.4)
					trail.Shape = Enum.PartType.Ball
					trail.Anchored = true
					trail.CanCollide = false
					trail.Material = Enum.Material.Neon
					trail.Color = Color3.fromRGB(140, 30, 200)
					trail.Transparency = 0.3
					trail.Position = projectile.Position
					trail.Parent = workspace

					safeTween(trail, TweenInfo.new(0.3), {
						Size = Vector3.new(0.05, 0.05, 0.05),
						Transparency = 1,
					})
					Debris:AddItem(trail, 0.4)

					task.wait(0.03)
					elapsed = elapsed + 0.03
				end
			end)

			-- Impact effect
			task.delay(flyTime, function()
				if projectile and projectile.Parent then
					-- Purple flash
					local flash = Instance.new("Part")
					flash.Name = "MagicImpact"
					flash.Size = Vector3.new(3, 3, 3)
					flash.Shape = Enum.PartType.Ball
					flash.Anchored = true
					flash.CanCollide = false
					flash.Material = Enum.Material.Neon
					flash.Color = Color3.fromRGB(180, 50, 255)
					flash.Transparency = 0.3
					flash.Position = projectile.Position
					flash.Parent = workspace

					safeTween(flash, TweenInfo.new(0.3), {
						Size = Vector3.new(6, 6, 6),
						Transparency = 1,
					})
					Debris:AddItem(flash, 0.4)

					projectile:Destroy()

					-- Screen effect if hit local player
					local root = getHumanoidRootPart()
					if root then
						local d = (root.Position - targetPos).Magnitude
						if d < 8 then
							applyScreenShake(0.3, 0.3)
						end
					end
				end
			end)

			Debris:AddItem(projectile, flyTime + 0.5)
		end)
	end

	-- Return arms after cast
	task.delay(0.8, function()
		for _, data in ipairs(armParts) do
			if data.part and data.part.Parent then
				safeTween(data.part, TweenInfo.new(0.3), {
					Position = data.origPos,
				})
			end
		end
	end)
end

local function animateDragonBreath(model, targetPos)
	if not model or not model.PrimaryPart then return end
	local body = model.PrimaryPart
	local head = model:FindFirstChild("Head")
	if not head then return end

	local origHeadPos = head.Position

	-- Head rears back
	safeTween(head, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Position = origHeadPos + Vector3.new(0, 2, 0) + body.CFrame.LookVector * -2,
	})

	-- Then breath attack
	task.delay(0.4, function()
		if not head or not head.Parent then return end

		-- Head snaps forward
		safeTween(head, TweenInfo.new(0.15), {
			Position = origHeadPos + body.CFrame.LookVector * 1,
		})

		-- Purple fire stream
		local breathDir = (targetPos - head.Position) * Vector3.new(1, 0, 1)
		if breathDir.Magnitude < 0.1 then
			breathDir = body.CFrame.LookVector * 10
		end
		local breathUnit = breathDir.Unit

		-- Stream of fire particles
		task.spawn(function()
			for i = 1, 20 do
				if not head or not head.Parent then break end
				local firePos = head.Position + breathUnit * (i * 0.8)

				local fire = Instance.new("Part")
				fire.Size = Vector3.new(1 + i * 0.2, 1 + i * 0.2, 1 + i * 0.2)
				fire.Shape = Enum.PartType.Ball
				fire.Anchored = true
				fire.CanCollide = false
				fire.Material = Enum.Material.Neon
				fire.Color = Color3.fromRGB(
					120 + math.random(60),
					10 + math.random(40),
					180 + math.random(75)
				)
				fire.Transparency = 0.2
				fire.Position = firePos + Vector3.new(
					(math.random() - 0.5) * i * 0.3,
					(math.random() - 0.5) * i * 0.2,
					(math.random() - 0.5) * i * 0.3
				)
				fire.Parent = workspace

				safeTween(fire, TweenInfo.new(0.5), {
					Size = Vector3.new(0.2, 0.2, 0.2),
					Transparency = 1,
					Position = fire.Position + Vector3.new(0, 2, 0),
				})
				Debris:AddItem(fire, 0.6)

				task.wait(0.02)
			end
		end)

		-- AoE circle on ground at target
		task.delay(0.3, function()
			local aoeCircle = Instance.new("Part")
			aoeCircle.Name = "AoECircle"
			aoeCircle.Size = Vector3.new(8, 0.1, 8)
			aoeCircle.Shape = Enum.PartType.Cylinder
			aoeCircle.Anchored = true
			aoeCircle.CanCollide = false
			aoeCircle.Material = Enum.Material.Neon
			aoeCircle.Color = Color3.fromRGB(150, 30, 200)
			aoeCircle.Transparency = 0.4
			aoeCircle.CFrame = CFrame.new(targetPos.X, 0.05, targetPos.Z) * CFrame.Angles(0, 0, math.rad(90))
			aoeCircle.Parent = workspace

			safeTween(aoeCircle, TweenInfo.new(1.5), {
				Size = Vector3.new(12, 0.1, 12),
				Transparency = 1,
			})
			Debris:AddItem(aoeCircle, 2)

			-- Screen shake if near
			local root = getHumanoidRootPart()
			if root then
				local d = (root.Position - targetPos).Magnitude
				if d < 15 then
					applyScreenShake(0.5, 0.5)
				end
			end
		end)
	end)

	-- Return head
	task.delay(1.0, function()
		if head and head.Parent then
			safeTween(head, TweenInfo.new(0.4), { Position = origHeadPos })
		end
	end)
end

local function animateRangedAttack(model, targetPos)
	if not model or not model.PrimaryPart then return end
	local body = model.PrimaryPart

	-- Simple arm pullback
	local armR = model:FindFirstChild("ArmR")
	if armR then
		local origPos = armR.Position
		safeTween(armR, TweenInfo.new(0.2), {
			Position = origPos + Vector3.new(0, 0.5, 0) - body.CFrame.LookVector * 0.5,
		})
		task.delay(0.3, function()
			if armR and armR.Parent then
				safeTween(armR, TweenInfo.new(0.1), { Position = origPos + body.CFrame.LookVector * 0.3 })
			end
		end)
		task.delay(0.5, function()
			if armR and armR.Parent then
				safeTween(armR, TweenInfo.new(0.2), { Position = origPos })
			end
		end)
	end

	-- Fire arrow
	task.delay(0.3, function()
		if not body or not body.Parent then return end
		local arrow = Instance.new("Part")
		arrow.Name = "MonsterArrow"
		arrow.Size = Vector3.new(0.08, 0.08, 1.5)
		arrow.Anchored = true
		arrow.CanCollide = false
		arrow.Material = Enum.Material.Wood
		arrow.Color = Color3.fromRGB(100, 70, 35)
		arrow.CFrame = CFrame.new(body.Position + Vector3.new(0, 1, 0), targetPos)
		arrow.Parent = workspace

		local dist = (targetPos - body.Position).Magnitude
		local flyTime = math.clamp(dist / 70, 0.1, 1.0)

		safeTween(arrow, TweenInfo.new(flyTime, Enum.EasingStyle.Linear), {
			CFrame = CFrame.new(targetPos, targetPos + (targetPos - body.Position).Unit),
		})

		task.delay(flyTime + 0.3, function()
			safeTween(arrow, TweenInfo.new(0.4), { Transparency = 1 })
		end)
		Debris:AddItem(arrow, flyTime + 1)
	end)
end

local function playMonsterAttackAnimation(model, targetPos, attackType)
	if not model or not model.Parent then return end

	if attackType == "melee_lunge" then
		animateMeleeLunge(model, targetPos)
	elseif attackType == "bite" then
		animateBite(model, targetPos)
	elseif attackType == "magic_cast" then
		animateMagicCast(model, targetPos)
	elseif attackType == "dragon_breath" then
		animateDragonBreath(model, targetPos)
	elseif attackType == "ranged" then
		animateRangedAttack(model, targetPos)
	else
		-- Default: simple lunge
		animateMeleeLunge(model, targetPos)
	end
end

--------------------------------------------------------------------------------
-- DEATH ANIMATION
--------------------------------------------------------------------------------
local function playDeathAnimation(model)
	if not model or not model.Parent then return end

	local parts = {}
	for _, child in ipairs(model:GetChildren()) do
		if child:IsA("BasePart") then
			table.insert(parts, child)
		end
	end

	-- Destroy billboard/humanoid immediately
	local bbg = model:FindFirstChild("OverheadGui")
	if bbg then bbg:Destroy() end
	local hum = model:FindFirstChildOfClass("Humanoid")
	if hum then hum:Destroy() end

	-- Fall over: tilt body parts
	local body = model.PrimaryPart
	if body then
		local fallDir = body.CFrame.LookVector * -1 -- fall backwards
		safeTween(body, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
			CFrame = body.CFrame * CFrame.Angles(math.rad(90), 0, 0) + Vector3.new(0, -body.Size.Y / 2, 0) + fallDir * 1,
		})
	end

	-- Scatter parts slightly and fade
	for _, part in ipairs(parts) do
		local randomOffset = Vector3.new(
			(math.random() - 0.5) * 3,
			math.random() * 1.5,
			(math.random() - 0.5) * 3
		)

		task.delay(0.2, function()
			if part and part.Parent then
				safeTween(part, TweenInfo.new(0.8, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					Position = part.Position + randomOffset,
					Transparency = 1,
					Size = part.Size * 0.5,
				})
			end
		end)
	end

	-- Hit particles at death location
	if body then
		spawnHitParticles(body.Position, Color3.fromRGB(200, 50, 50), 12)
	end

	-- Clean up model after animation
	Debris:AddItem(model, 1.5)
end

--------------------------------------------------------------------------------
-- CONNECT TO EVENTS
--------------------------------------------------------------------------------

-- Monster takes damage (from any player attacking)
if MonsterDamageEvent then
	MonsterDamageEvent.OnClientEvent:Connect(function(model, damage, currentHP, maxHP, attackerPlayer)
		if not model or not model.Parent then return end

		local pos = model.PrimaryPart and model.PrimaryPart.Position or model:GetBoundingBox().Position

		-- Determine if critical (>= 20% of max HP in one hit)
		local isCritical = damage >= (maxHP * 0.2)

		-- Damage number
		local color = isCritical and Color3.fromRGB(255, 215, 0) or Color3.fromRGB(255, 255, 255)
		showDamageNumber3D(pos, tostring(damage), color, isCritical)

		-- Hit flash
		applyHitFlash(model)

		-- Hit particles
		spawnHitParticles(pos + Vector3.new(0, 1, 0), Color3.fromRGB(200, 50, 50), isCritical and 8 or 4)

		-- Play attack animation for local player if they dealt the damage
		if attackerPlayer == player then
			performPlayerAttack(model, isCritical)
		end
	end)
end

-- Monster dies
if MonsterDeathEvent then
	MonsterDeathEvent.OnClientEvent:Connect(function(model, killerPlayer, drops)
		-- The server will destroy the model, but we try to animate first
		-- Since server destroys it, we clone quickly for death animation
		if not model or not model.Parent then return end

		local deathPos = model.PrimaryPart and model.PrimaryPart.Position or Vector3.new(0, 0, 0)

		-- Clone for death animation (original gets destroyed by server)
		local clone = model:Clone()
		-- Remove click detectors and humanoid from clone
		for _, desc in ipairs(clone:GetDescendants()) do
			if desc:IsA("ClickDetector") then desc:Destroy() end
		end
		clone.Parent = workspace

		-- Play death animation on clone
		playDeathAnimation(clone)

		-- Screen shake for nearby kills
		local root = getHumanoidRootPart()
		if root then
			local d = (root.Position - deathPos).Magnitude
			if d < 20 then
				applyScreenShake(0.2, 0.3)
			end
		end
	end)
end

-- Monster attack visual (server tells clients to show monster attacking)
if MonsterAttackVisualEvent then
	MonsterAttackVisualEvent.OnClientEvent:Connect(function(model, targetPlayer, monsterName)
		if not model or not model.Parent then return end

		local attackType = MONSTER_ATTACK_TYPES[monsterName] or "melee_lunge"

		-- Get target position
		local targetPos = nil
		if targetPlayer then
			local char = targetPlayer.Character
			if char then
				local hrp = char:FindFirstChild("HumanoidRootPart")
				if hrp then
					targetPos = hrp.Position
				end
			end
		end

		if not targetPos then return end

		playMonsterAttackAnimation(model, targetPos, attackType)

		-- If we're the target, show damage received effects
		if targetPlayer == player then
			-- Red flash on screen edge
			local dmgOverlay = Instance.new("Frame")
			dmgOverlay.Name = "DamageOverlay"
			dmgOverlay.Size = UDim2.new(1, 0, 1, 0)
			dmgOverlay.BackgroundColor3 = Color3.fromRGB(200, 0, 0)
			dmgOverlay.BackgroundTransparency = 0.7
			dmgOverlay.BorderSizePixel = 0
			dmgOverlay.Parent = combatGui

			safeTween(dmgOverlay, TweenInfo.new(0.3), {
				BackgroundTransparency = 1,
			})
			Debris:AddItem(dmgOverlay, 0.4)

			applyScreenShake(0.15, 0.2)
		end
	end)
end

-- Hit effect event (server sends specific hit effects)
if HitEffectEvent then
	HitEffectEvent.OnClientEvent:Connect(function(position, damage, effectType, isCritical)
		if not position then return end

		if effectType == "shield_block" then
			spawnSparks(position, 10)
			showDamageNumber3D(position, "BLOCKED", Color3.fromRGB(150, 200, 255), false)

			-- Play shield block animation on local player
			local char = getCharacter()
			if char then
				playShieldBlock(char)
			end
		elseif effectType == "damage_taken" then
			showDamageNumber3D(position, tostring(damage), Color3.fromRGB(255, 50, 50), isCritical)
			if isCritical then
				applyScreenShake(0.3, 0.3)
			end
		elseif effectType == "damage_dealt" then
			showDamageNumber3D(position, tostring(damage), Color3.fromRGB(255, 255, 255), isCritical)
		end
	end)
end

-- AttackVisual event (server broadcasts player attacks to all clients)
if AttackVisualEvent then
	AttackVisualEvent.OnClientEvent:Connect(function(attackerPlayer, targetModel, weaponType, isCritical)
		-- Don't replay our own attack animation
		if attackerPlayer == player then return end

		local char = attackerPlayer.Character
		if not char then return end

		if weaponType == "ranged" then
			local targetPos = targetModel and targetModel.PrimaryPart and targetModel.PrimaryPart.Position
			playBowShot(char, targetPos)
		elseif weaponType == "melee" then
			playSwordSwing(char, isCritical)
		else
			playPunchAnimation(char)
		end
	end)
end

--------------------------------------------------------------------------------
-- MOUSE INPUT ‚Äî ATTACK MONSTERS
-- (Replaces the old attack code in UIController)
--------------------------------------------------------------------------------
local mouse = player:GetMouse()
local attackRemote = Remotes:WaitForChild("Attack")

mouse.Button1Down:Connect(function()
	local target = mouse.Target
	if not target then return end

	local character = getCharacter()
	if not character then return end
	local root = character:FindFirstChild("HumanoidRootPart")
	if not root then return end

	-- Check if clicking a monster (TargetClick ClickDetector)
	local monsterModel = nil
	if target:FindFirstChild("TargetClick") then
		monsterModel = target.Parent
	elseif target.Parent and target.Parent:FindFirstChild("TargetClick") then
		monsterModel = target.Parent.Parent or target.Parent
	elseif target.Parent and target.Parent.PrimaryPart and target.Parent.PrimaryPart:FindFirstChild("TargetClick") then
		monsterModel = target.Parent
	end

	-- Monster attack
	if monsterModel and monsterModel:FindFirstChildOfClass("Humanoid") then
		-- Check it's not a player character
		local isPlayerChar = Players:GetPlayerFromCharacter(monsterModel)
		if not isPlayerChar then
			performPlayerAttack(monsterModel, false)
			-- The actual ClickDetector handles the server-side damage
			return
		end
	end

	-- Player vs Player attack
	local targetChar = target.Parent
	if targetChar then
		local targetPlayer = Players:GetPlayerFromCharacter(targetChar)
		if targetPlayer and targetPlayer ~= player then
			performPlayerAttack(targetChar, false)
			attackRemote:FireServer(targetPlayer)
			return
		end
	end
end)

--------------------------------------------------------------------------------
-- EXPOSE API for other scripts (e.g. UIController)
--------------------------------------------------------------------------------
shared.AttackAnimations = {
	ShowDamageNumber = showDamageNumber3D,
	ApplyHitFlash = applyHitFlash,
	SpawnHitParticles = spawnHitParticles,
	SpawnSparks = spawnSparks,
	ScreenShake = applyScreenShake,
	PlayShieldBlock = playShieldBlock,
	ResetCombo = function()
		comboCount = 0
		comboFrame.Visible = false
	end,
}

print("[AttackAnimations] Combat animation system loaded!")
]]></string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="64">
        <Properties>
          <string name="Name">BankUI</string>
          <string name="Source"><![CDATA[-- BankUI.client.lua
-- Full bank interface with deposit/withdraw

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local Remotes = ReplicatedStorage:WaitForChild("Remotes")

-- Wait for bank remotes (created by BankManager)
local bankOpenRemote
local bankActionRemote
local bankUpdateRemote

task.spawn(function()
	bankOpenRemote = Remotes:WaitForChild("BankOpen", 15)
	bankActionRemote = Remotes:WaitForChild("BankAction", 15)
	bankUpdateRemote = Remotes:WaitForChild("BankUpdate", 15)
	if bankOpenRemote and bankActionRemote and bankUpdateRemote then
		print("[BankUI] Bank remotes connected")
	else
		warn("[BankUI] Some bank remotes not found!")
	end
end)

-- === COLORS ===
local COLORS = {
	bg = Color3.fromRGB(15, 15, 25),
	panel = Color3.fromRGB(25, 25, 40),
	item = Color3.fromRGB(35, 35, 55),
	itemHover = Color3.fromRGB(50, 50, 75),
	gold = Color3.fromRGB(255, 215, 0),
	white = Color3.fromRGB(220, 220, 220),
	green = Color3.fromRGB(80, 200, 80),
	red = Color3.fromRGB(200, 80, 80),
	blue = Color3.fromRGB(80, 130, 220),
	dimText = Color3.fromRGB(140, 140, 160),
}

-- === MAIN SCREEN GUI ===
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "BankUI"
screenGui.ResetOnSpawn = false
screenGui.DisplayOrder = 10
screenGui.Parent = playerGui

-- === BANK WINDOW (hidden by default) ===
local bankFrame = Instance.new("Frame")
bankFrame.Name = "BankWindow"
bankFrame.Size = UDim2.new(0, 700, 0, 500)
bankFrame.Position = UDim2.new(0.5, -350, 0.5, -250)
bankFrame.BackgroundColor3 = COLORS.bg
bankFrame.BackgroundTransparency = 0.05
bankFrame.BorderSizePixel = 0
bankFrame.Visible = false
bankFrame.Parent = screenGui

local bankCorner = Instance.new("UICorner")
bankCorner.CornerRadius = UDim.new(0, 12)
bankCorner.Parent = bankFrame

-- Gold border effect
local bankStroke = Instance.new("UIStroke")
bankStroke.Color = COLORS.gold
bankStroke.Thickness = 2
bankStroke.Transparency = 0.3
bankStroke.Parent = bankFrame

-- === TITLE BAR ===
local titleBar = Instance.new("Frame")
titleBar.Size = UDim2.new(1, 0, 0, 45)
titleBar.BackgroundColor3 = COLORS.panel
titleBar.BorderSizePixel = 0
titleBar.Parent = bankFrame

local titleCorner = Instance.new("UICorner")
titleCorner.CornerRadius = UDim.new(0, 12)
titleCorner.Parent = titleBar

-- Fix bottom corners of title bar
local titleFix = Instance.new("Frame")
titleFix.Size = UDim2.new(1, 0, 0, 12)
titleFix.Position = UDim2.new(0, 0, 1, -12)
titleFix.BackgroundColor3 = COLORS.panel
titleFix.BorderSizePixel = 0
titleFix.Parent = titleBar

local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(1, -50, 1, 0)
titleLabel.Position = UDim2.new(0, 15, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "üè¶ BANK OF WILDERNESS"
titleLabel.TextColor3 = COLORS.gold
titleLabel.TextScaled = true
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = titleBar

-- Close button
local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, 35, 0, 35)
closeBtn.Position = UDim2.new(1, -40, 0, 5)
closeBtn.BackgroundColor3 = COLORS.red
closeBtn.Text = "‚úï"
closeBtn.TextColor3 = COLORS.white
closeBtn.TextScaled = true
closeBtn.Font = Enum.Font.GothamBold
closeBtn.BorderSizePixel = 0
closeBtn.Parent = titleBar

local closeBtnCorner = Instance.new("UICorner")
closeBtnCorner.CornerRadius = UDim.new(0, 6)
closeBtnCorner.Parent = closeBtn

closeBtn.MouseButton1Click:Connect(function()
	bankFrame.Visible = false
end)

-- === STATUS BAR ===
local statusBar = Instance.new("TextLabel")
statusBar.Size = UDim2.new(1, -20, 0, 25)
statusBar.Position = UDim2.new(0, 10, 0, 48)
statusBar.BackgroundTransparency = 1
statusBar.Text = ""
statusBar.TextColor3 = COLORS.dimText
statusBar.TextScaled = true
statusBar.Font = Enum.Font.Gotham
statusBar.TextXAlignment = Enum.TextXAlignment.Left
statusBar.Parent = bankFrame

-- === TWO COLUMNS: BANK (left) + INVENTORY (right) ===

-- BANK PANEL (left)
local bankPanel = Instance.new("Frame")
bankPanel.Name = "BankPanel"
bankPanel.Size = UDim2.new(0.5, -15, 1, -120)
bankPanel.Position = UDim2.new(0, 10, 0, 78)
bankPanel.BackgroundColor3 = COLORS.panel
bankPanel.BackgroundTransparency = 0.3
bankPanel.BorderSizePixel = 0
bankPanel.Parent = bankFrame

local bankPanelCorner = Instance.new("UICorner")
bankPanelCorner.CornerRadius = UDim.new(0, 8)
bankPanelCorner.Parent = bankPanel

local bankTitle = Instance.new("TextLabel")
bankTitle.Size = UDim2.new(1, 0, 0, 30)
bankTitle.BackgroundTransparency = 1
bankTitle.Text = "üè¶ BANK (0/100)"
bankTitle.TextColor3 = COLORS.gold
bankTitle.TextScaled = true
bankTitle.Font = Enum.Font.GothamBold
bankTitle.Parent = bankPanel

local bankScroll = Instance.new("ScrollingFrame")
bankScroll.Size = UDim2.new(1, -10, 1, -35)
bankScroll.Position = UDim2.new(0, 5, 0, 32)
bankScroll.BackgroundTransparency = 1
bankScroll.ScrollBarThickness = 4
bankScroll.ScrollBarImageColor3 = COLORS.gold
bankScroll.Parent = bankPanel

local bankLayout = Instance.new("UIListLayout")
bankLayout.Padding = UDim.new(0, 3)
bankLayout.Parent = bankScroll

-- INVENTORY PANEL (right)
local invPanel = Instance.new("Frame")
invPanel.Name = "InvPanel"
invPanel.Size = UDim2.new(0.5, -15, 1, -120)
invPanel.Position = UDim2.new(0.5, 5, 0, 78)
invPanel.BackgroundColor3 = COLORS.panel
invPanel.BackgroundTransparency = 0.3
invPanel.BorderSizePixel = 0
invPanel.Parent = bankFrame

local invPanelCorner = Instance.new("UICorner")
invPanelCorner.CornerRadius = UDim.new(0, 8)
invPanelCorner.Parent = invPanel

local invTitle = Instance.new("TextLabel")
invTitle.Size = UDim2.new(1, 0, 0, 30)
invTitle.BackgroundTransparency = 1
invTitle.Text = "üéí INVENTORY (0/28)"
invTitle.TextColor3 = COLORS.gold
invTitle.TextScaled = true
invTitle.Font = Enum.Font.GothamBold
invTitle.Parent = invPanel

local invScroll = Instance.new("ScrollingFrame")
invScroll.Size = UDim2.new(1, -10, 1, -35)
invScroll.Position = UDim2.new(0, 5, 0, 32)
invScroll.BackgroundTransparency = 1
invScroll.ScrollBarThickness = 4
invScroll.ScrollBarImageColor3 = COLORS.gold
invScroll.Parent = invPanel

local invLayout = Instance.new("UIListLayout")
invLayout.Padding = UDim.new(0, 3)
invLayout.Parent = invScroll

-- === BOTTOM BUTTONS ===
local buttonBar = Instance.new("Frame")
buttonBar.Size = UDim2.new(1, -20, 0, 40)
buttonBar.Position = UDim2.new(0, 10, 1, -48)
buttonBar.BackgroundTransparency = 1
buttonBar.Parent = bankFrame

local buttonLayout = Instance.new("UIListLayout")
buttonLayout.FillDirection = Enum.FillDirection.Horizontal
buttonLayout.Padding = UDim.new(0, 10)
buttonLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
buttonLayout.Parent = buttonBar

local function createButton(text, color, parent)
	local btn = Instance.new("TextButton")
	btn.Size = UDim2.new(0, 180, 0, 36)
	btn.BackgroundColor3 = color
	btn.Text = text
	btn.TextColor3 = COLORS.white
	btn.TextScaled = true
	btn.Font = Enum.Font.GothamBold
	btn.BorderSizePixel = 0
	btn.Parent = parent

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = btn

	-- Hover effect
	btn.MouseEnter:Connect(function()
		TweenService:Create(btn, TweenInfo.new(0.15), {
			BackgroundColor3 = Color3.new(
				math.min(color.R * 1.2, 1),
				math.min(color.G * 1.2, 1),
				math.min(color.B * 1.2, 1)
			)
		}):Play()
	end)
	btn.MouseLeave:Connect(function()
		TweenService:Create(btn, TweenInfo.new(0.15), { BackgroundColor3 = color }):Play()
	end)

	return btn
end

local depositAllBtn = createButton("üì• Deposit All", COLORS.green, buttonBar)
local closeBottomBtn = createButton("‚úï Close Bank", COLORS.red, buttonBar)

closeBottomBtn.MouseButton1Click:Connect(function()
	bankFrame.Visible = false
end)

-- === ITEM ROW CREATION ===
local function createItemRow(itemName, quantity, parent, actionType)
	local row = Instance.new("TextButton")
	row.Size = UDim2.new(1, -5, 0, 32)
	row.BackgroundColor3 = COLORS.item
	row.BorderSizePixel = 0
	row.Text = ""
	row.AutoButtonColor = false
	row.Parent = parent

	local rowCorner = Instance.new("UICorner")
	rowCorner.CornerRadius = UDim.new(0, 6)
	rowCorner.Parent = row

	-- Item name
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(0.6, 0, 1, 0)
	nameLabel.Position = UDim2.new(0, 10, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = itemName
	nameLabel.TextColor3 = COLORS.white
	nameLabel.TextScaled = true
	nameLabel.Font = Enum.Font.Gotham
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.Parent = row

	-- Quantity
	local qtyLabel = Instance.new("TextLabel")
	qtyLabel.Size = UDim2.new(0, 40, 1, 0)
	qtyLabel.Position = UDim2.new(0.6, 5, 0, 0)
	qtyLabel.BackgroundTransparency = 1
	qtyLabel.Text = "x" .. quantity
	qtyLabel.TextColor3 = COLORS.dimText
	qtyLabel.TextScaled = true
	qtyLabel.Font = Enum.Font.Gotham
	qtyLabel.Parent = row

	-- Action button
	local actionBtn = Instance.new("TextButton")
	actionBtn.Size = UDim2.new(0, 70, 0, 24)
	actionBtn.Position = UDim2.new(1, -78, 0.5, -12)
	actionBtn.BorderSizePixel = 0
	actionBtn.TextScaled = true
	actionBtn.Font = Enum.Font.GothamBold
	actionBtn.Parent = row

	local actionCorner = Instance.new("UICorner")
	actionCorner.CornerRadius = UDim.new(0, 4)
	actionCorner.Parent = actionBtn

	if actionType == "withdraw" then
		actionBtn.Text = "üì§ Take"
		actionBtn.BackgroundColor3 = COLORS.blue
		actionBtn.TextColor3 = COLORS.white
		actionBtn.MouseButton1Click:Connect(function()
			if bankActionRemote then
				bankActionRemote:FireServer("withdraw", itemName, 1)
			end
		end)
	else
		actionBtn.Text = "üì• Store"
		actionBtn.BackgroundColor3 = COLORS.green
		actionBtn.TextColor3 = COLORS.white
		actionBtn.MouseButton1Click:Connect(function()
			if bankActionRemote then
				bankActionRemote:FireServer("deposit", itemName, 1)
			end
		end)
	end

	-- Hover effects
	row.MouseEnter:Connect(function()
		TweenService:Create(row, TweenInfo.new(0.1), { BackgroundColor3 = COLORS.itemHover }):Play()
	end)
	row.MouseLeave:Connect(function()
		TweenService:Create(row, TweenInfo.new(0.1), { BackgroundColor3 = COLORS.item }):Play()
	end)

	return row
end

-- === UPDATE DISPLAY ===
local function updateBankDisplay(bankData, invData)
	-- Clear existing rows
	for _, child in ipairs(bankScroll:GetChildren()) do
		if child:IsA("TextButton") then child:Destroy() end
	end
	for _, child in ipairs(invScroll:GetChildren()) do
		if child:IsA("TextButton") then child:Destroy() end
	end

	-- Update bank items
	bankTitle.Text = "üè¶ BANK (" .. #bankData .. "/100)"
	for _, slot in ipairs(bankData) do
		createItemRow(slot.name, slot.quantity, bankScroll, "withdraw")
	end
	bankScroll.CanvasSize = UDim2.new(0, 0, 0, #bankData * 35)

	-- Update inventory items
	invTitle.Text = "üéí INVENTORY (" .. #invData .. "/28)"
	for _, slot in ipairs(invData) do
		createItemRow(slot.name, slot.quantity, invScroll, "deposit")
	end
	invScroll.CanvasSize = UDim2.new(0, 0, 0, #invData * 35)

	-- Empty state messages
	if #bankData == 0 then
		local emptyLabel = Instance.new("TextLabel")
		emptyLabel.Size = UDim2.new(1, 0, 0, 50)
		emptyLabel.BackgroundTransparency = 1
		emptyLabel.Text = "Bank is empty\nDeposit items to keep them safe!"
		emptyLabel.TextColor3 = COLORS.dimText
		emptyLabel.TextScaled = true
		emptyLabel.Font = Enum.Font.Gotham
		emptyLabel.Parent = bankScroll
	end

	if #invData == 0 then
		local emptyLabel = Instance.new("TextLabel")
		emptyLabel.Size = UDim2.new(1, 0, 0, 50)
		emptyLabel.BackgroundTransparency = 1
		emptyLabel.Text = "Inventory is empty\nGather resources first!"
		emptyLabel.TextColor3 = COLORS.dimText
		emptyLabel.TextScaled = true
		emptyLabel.Font = Enum.Font.Gotham
		emptyLabel.Parent = invScroll
	end
end

-- === SHOW STATUS MESSAGE ===
local function showStatus(text, color)
	statusBar.Text = text
	statusBar.TextColor3 = color or COLORS.dimText
	task.delay(3, function()
		if statusBar.Text == text then
			statusBar.Text = ""
		end
	end)
end

-- === CONNECT REMOTES ===
task.spawn(function()
	-- Wait for remotes to be available
	task.wait(2)

	if bankOpenRemote then
		bankOpenRemote.OnClientEvent:Connect(function(bankData, invData)
			updateBankDisplay(bankData, invData)
			bankFrame.Visible = true
			showStatus("Welcome to the Bank of Wilderness!", COLORS.gold)
		end)
	end

	if bankUpdateRemote then
		bankUpdateRemote.OnClientEvent:Connect(function(bankData, invData, success, action)
			updateBankDisplay(bankData, invData)
			if success then
				if action == "deposit" then
					showStatus("‚úÖ Item deposited successfully!", COLORS.green)
				elseif action == "withdraw" then
					showStatus("‚úÖ Item withdrawn successfully!", COLORS.green)
				elseif action == "deposit_all" then
					showStatus("‚úÖ All items deposited!", COLORS.green)
				end
			else
				if action == "deposit" or action == "deposit_all" then
					showStatus("‚ùå Bank is full or item not found!", COLORS.red)
				elseif action == "withdraw" then
					showStatus("‚ùå Inventory full or item not found!", COLORS.red)
				end
			end
		end)
	end
end)

-- Deposit All button
depositAllBtn.MouseButton1Click:Connect(function()
	if bankActionRemote then
		bankActionRemote:FireServer("deposit_all", "all", 1)
	end
end)

-- Close bank when player moves too far
task.spawn(function()
	while true do
		task.wait(1)
		if bankFrame.Visible then
			local character = player.Character
			if character then
				local root = character:FindFirstChild("HumanoidRootPart")
				if root then
					local bankNPC = game.Workspace:FindFirstChild("SafeZone")
					if bankNPC then
						local npc = bankNPC:FindFirstChild("BankNPC")
						if npc then
							local npcRoot = npc:FindFirstChild("HumanoidRootPart")
							if npcRoot then
								local dist = (root.Position - npcRoot.Position).Magnitude
								if dist > 15 then
									bankFrame.Visible = false
									showStatus("You walked too far from the bank.", COLORS.red)
								end
							end
						end
					end
				end
			end
		end
	end
end)

print("[BankUI] Bank interface loaded!")
]]></string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="65">
        <Properties>
          <string name="Name">CraftingUI</string>
          <string name="Source"><![CDATA[--[[
	CraftingUI.client.lua
	Crafting menu UI for Smithing & Cooking stations.
	Dark theme with gold accents. Shows recipes, ingredients, progress bar.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local CraftRequest  = ReplicatedStorage:WaitForChild("CraftRequest")
local CraftComplete = ReplicatedStorage:WaitForChild("CraftComplete")
local CraftUpdate   = ReplicatedStorage:WaitForChild("CraftUpdate")

----------------------------------------------------------------------
-- Theme
----------------------------------------------------------------------
local THEME = {
	bg        = Color3.fromHex("#1a1a2e"),
	bgLight   = Color3.fromHex("#22223a"),
	bgDark    = Color3.fromHex("#131320"),
	gold      = Color3.fromHex("#f0c040"),
	goldDim   = Color3.fromHex("#a8872e"),
	text      = Color3.fromHex("#e8e8e8"),
	textDim   = Color3.fromHex("#888898"),
	green     = Color3.fromHex("#40d060"),
	red       = Color3.fromHex("#e04040"),
	barBg     = Color3.fromHex("#2a2a40"),
}

local CRAFT_TIME = 1.5 -- seconds per craft

----------------------------------------------------------------------
-- State
----------------------------------------------------------------------
local currentStation: string? = nil
local currentRecipes: { any } = {}
local selectedRecipe: any = nil
local isCrafting = false

----------------------------------------------------------------------
-- UI Construction
----------------------------------------------------------------------
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CraftingUI"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Enabled = false
screenGui.Parent = playerGui

-- Main frame
local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.fromOffset(520, 440)
mainFrame.Position = UDim2.fromScale(0.5, 0.5)
mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
mainFrame.BackgroundColor3 = THEME.bg
mainFrame.BorderSizePixel = 0
mainFrame.Parent = screenGui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 10)
corner.Parent = mainFrame

local stroke = Instance.new("UIStroke")
stroke.Color = THEME.gold
stroke.Thickness = 2
stroke.Parent = mainFrame

-- Title bar
local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.Size = UDim2.new(1, 0, 0, 40)
titleBar.BackgroundColor3 = THEME.bgDark
titleBar.BorderSizePixel = 0
titleBar.Parent = mainFrame
Instance.new("UICorner", titleBar).CornerRadius = UDim.new(0, 10)

-- Patch bottom corners of title bar
local titlePatch = Instance.new("Frame")
titlePatch.Size = UDim2.new(1, 0, 0, 12)
titlePatch.Position = UDim2.new(0, 0, 1, -12)
titlePatch.BackgroundColor3 = THEME.bgDark
titlePatch.BorderSizePixel = 0
titlePatch.Parent = titleBar

local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Size = UDim2.new(1, -50, 1, 0)
titleLabel.Position = UDim2.fromOffset(14, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "Crafting"
titleLabel.TextColor3 = THEME.gold
titleLabel.TextSize = 20
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = titleBar

-- Close button
local closeBtn = Instance.new("TextButton")
closeBtn.Name = "Close"
closeBtn.Size = UDim2.fromOffset(32, 32)
closeBtn.Position = UDim2.new(1, -36, 0, 4)
closeBtn.BackgroundColor3 = THEME.red
closeBtn.Text = "‚úï"
closeBtn.TextColor3 = THEME.text
closeBtn.TextSize = 16
closeBtn.Font = Enum.Font.GothamBold
closeBtn.BorderSizePixel = 0
closeBtn.Parent = titleBar
Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0, 6)

-- Recipe list (left panel)
local listFrame = Instance.new("ScrollingFrame")
listFrame.Name = "RecipeList"
listFrame.Size = UDim2.new(0, 210, 1, -50)
listFrame.Position = UDim2.fromOffset(6, 46)
listFrame.BackgroundColor3 = THEME.bgDark
listFrame.BorderSizePixel = 0
listFrame.ScrollBarThickness = 4
listFrame.ScrollBarImageColor3 = THEME.goldDim
listFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
listFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
listFrame.Parent = mainFrame
Instance.new("UICorner", listFrame).CornerRadius = UDim.new(0, 8)

local listLayout = Instance.new("UIListLayout")
listLayout.Padding = UDim.new(0, 4)
listLayout.SortOrder = Enum.SortOrder.LayoutOrder
listLayout.Parent = listFrame
local lp = Instance.new("UIPadding")
lp.PaddingTop = UDim.new(0, 4)
lp.PaddingBottom = UDim.new(0, 4)
lp.PaddingLeft = UDim.new(0, 4)
lp.PaddingRight = UDim.new(0, 4)
lp.Parent = listFrame

-- Detail panel (right)
local detailFrame = Instance.new("Frame")
detailFrame.Name = "Detail"
detailFrame.Size = UDim2.new(1, -226, 1, -50)
detailFrame.Position = UDim2.fromOffset(222, 46)
detailFrame.BackgroundColor3 = THEME.bgDark
detailFrame.BorderSizePixel = 0
detailFrame.Parent = mainFrame
Instance.new("UICorner", detailFrame).CornerRadius = UDim.new(0, 8)

-- Detail content
local detailPadding = Instance.new("UIPadding")
detailPadding.PaddingTop = UDim.new(0, 12)
detailPadding.PaddingLeft = UDim.new(0, 14)
detailPadding.PaddingRight = UDim.new(0, 14)
detailPadding.Parent = detailFrame

local productLabel = Instance.new("TextLabel")
productLabel.Name = "ProductName"
productLabel.Size = UDim2.new(1, 0, 0, 28)
productLabel.BackgroundTransparency = 1
productLabel.Text = "Select a recipe"
productLabel.TextColor3 = THEME.gold
productLabel.TextSize = 18
productLabel.Font = Enum.Font.GothamBold
productLabel.TextXAlignment = Enum.TextXAlignment.Left
productLabel.Parent = detailFrame

local skillLabel = Instance.new("TextLabel")
skillLabel.Name = "SkillReq"
skillLabel.Size = UDim2.new(1, 0, 0, 20)
skillLabel.Position = UDim2.fromOffset(0, 30)
skillLabel.BackgroundTransparency = 1
skillLabel.Text = ""
skillLabel.TextColor3 = THEME.textDim
skillLabel.TextSize = 14
skillLabel.Font = Enum.Font.Gotham
skillLabel.TextXAlignment = Enum.TextXAlignment.Left
skillLabel.Parent = detailFrame

local xpLabel = Instance.new("TextLabel")
xpLabel.Name = "XP"
xpLabel.Size = UDim2.new(1, 0, 0, 20)
xpLabel.Position = UDim2.fromOffset(0, 50)
xpLabel.BackgroundTransparency = 1
xpLabel.Text = ""
xpLabel.TextColor3 = THEME.gold
xpLabel.TextSize = 14
xpLabel.Font = Enum.Font.Gotham
xpLabel.TextXAlignment = Enum.TextXAlignment.Left
xpLabel.Parent = detailFrame

-- Ingredients list
local ingredientsLabel = Instance.new("TextLabel")
ingredientsLabel.Name = "IngredientsHeader"
ingredientsLabel.Size = UDim2.new(1, 0, 0, 22)
ingredientsLabel.Position = UDim2.fromOffset(0, 80)
ingredientsLabel.BackgroundTransparency = 1
ingredientsLabel.Text = "Ingredients:"
ingredientsLabel.TextColor3 = THEME.text
ingredientsLabel.TextSize = 14
ingredientsLabel.Font = Enum.Font.GothamBold
ingredientsLabel.TextXAlignment = Enum.TextXAlignment.Left
ingredientsLabel.Parent = detailFrame

local ingredientsFrame = Instance.new("Frame")
ingredientsFrame.Name = "Ingredients"
ingredientsFrame.Size = UDim2.new(1, 0, 0, 80)
ingredientsFrame.Position = UDim2.fromOffset(0, 104)
ingredientsFrame.BackgroundTransparency = 1
ingredientsFrame.Parent = detailFrame

local ingredLayout = Instance.new("UIListLayout")
ingredLayout.Padding = UDim.new(0, 2)
ingredLayout.Parent = ingredientsFrame

-- Progress bar
local progressBg = Instance.new("Frame")
progressBg.Name = "ProgressBg"
progressBg.Size = UDim2.new(1, 0, 0, 18)
progressBg.Position = UDim2.new(0, 0, 1, -100)
progressBg.BackgroundColor3 = THEME.barBg
progressBg.BorderSizePixel = 0
progressBg.Visible = false
progressBg.Parent = detailFrame
Instance.new("UICorner", progressBg).CornerRadius = UDim.new(0, 6)

local progressFill = Instance.new("Frame")
progressFill.Name = "Fill"
progressFill.Size = UDim2.new(0, 0, 1, 0)
progressFill.BackgroundColor3 = THEME.gold
progressFill.BorderSizePixel = 0
progressFill.Parent = progressBg
Instance.new("UICorner", progressFill).CornerRadius = UDim.new(0, 6)

local progressText = Instance.new("TextLabel")
progressText.Size = UDim2.fromScale(1, 1)
progressText.BackgroundTransparency = 1
progressText.Text = ""
progressText.TextColor3 = THEME.bgDark
progressText.TextSize = 12
progressText.Font = Enum.Font.GothamBold
progressText.ZIndex = 2
progressText.Parent = progressBg

-- Buttons
local function makeButton(name: string, text: string, posY: number): TextButton
	local btn = Instance.new("TextButton")
	btn.Name = name
	btn.Size = UDim2.new(0.48, 0, 0, 36)
	btn.Position = UDim2.new(0, 0, 1, posY)
	btn.BackgroundColor3 = THEME.gold
	btn.TextColor3 = THEME.bgDark
	btn.Text = text
	btn.TextSize = 15
	btn.Font = Enum.Font.GothamBold
	btn.BorderSizePixel = 0
	btn.AutoButtonColor = true
	btn.Parent = detailFrame
	Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 8)
	return btn
end

local craftBtn    = makeButton("CraftBtn", "Craft", -60)
local craftAllBtn = makeButton("CraftAllBtn", "Craft All", -60)
craftAllBtn.Position = UDim2.new(0.52, 0, 1, -60)

----------------------------------------------------------------------
-- UI Logic
----------------------------------------------------------------------

local function clearList()
	for _, child in listFrame:GetChildren() do
		if child:IsA("TextButton") then child:Destroy() end
	end
end

local function clearIngredients()
	for _, child in ingredientsFrame:GetChildren() do
		if child:IsA("TextLabel") then child:Destroy() end
	end
end

local function selectRecipe(recipe: any)
	selectedRecipe = recipe
	productLabel.Text = recipe.product
	skillLabel.Text = string.format("Requires: %s Lv. %d", recipe.skill, recipe.level)
	xpLabel.Text = string.format("+%d %s XP", recipe.xp, recipe.skill)

	if not recipe.canCraft then
		skillLabel.TextColor3 = THEME.red
	else
		skillLabel.TextColor3 = THEME.textDim
	end

	-- Ingredients
	clearIngredients()
	for _, ing in recipe.ingredients do
		local lbl = Instance.new("TextLabel")
		lbl.Size = UDim2.new(1, 0, 0, 18)
		lbl.BackgroundTransparency = 1
		lbl.TextSize = 13
		lbl.Font = Enum.Font.Gotham
		lbl.TextXAlignment = Enum.TextXAlignment.Left
		lbl.Text = string.format("  %s  %d / %d", ing.name, ing.have, ing.required)
		lbl.TextColor3 = if ing.have >= ing.required then THEME.green else THEME.red
		lbl.Parent = ingredientsFrame
	end

	-- Button state
	local canDo = recipe.canCraft and recipe.maxCraft > 0
	craftBtn.BackgroundColor3 = if canDo then THEME.gold else THEME.textDim
	craftAllBtn.BackgroundColor3 = if canDo then THEME.gold else THEME.textDim
end

local function populateList(recipes: { any })
	clearList()
	currentRecipes = recipes

	for i, recipe in recipes do
		local btn = Instance.new("TextButton")
		btn.Name = recipe.id
		btn.Size = UDim2.new(1, 0, 0, 34)
		btn.LayoutOrder = i
		btn.BackgroundColor3 = if recipe.canCraft then THEME.bgLight else THEME.bgDark
		btn.TextColor3 = if recipe.canCraft then THEME.text else THEME.textDim
		btn.Text = recipe.product
		btn.TextSize = 14
		btn.Font = Enum.Font.GothamBold
		btn.BorderSizePixel = 0
		btn.AutoButtonColor = true
		btn.Parent = listFrame
		Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)

		-- Max craft count badge
		if recipe.maxCraft > 0 then
			local badge = Instance.new("TextLabel")
			badge.Size = UDim2.fromOffset(28, 18)
			badge.Position = UDim2.new(1, -32, 0.5, -9)
			badge.BackgroundColor3 = THEME.gold
			badge.TextColor3 = THEME.bgDark
			badge.Text = tostring(recipe.maxCraft)
			badge.TextSize = 11
			badge.Font = Enum.Font.GothamBold
			badge.Parent = btn
			Instance.new("UICorner", badge).CornerRadius = UDim.new(0, 4)
		end

		btn.MouseButton1Click:Connect(function()
			selectRecipe(recipe)
		end)
	end

	-- Auto-select first
	if #recipes > 0 then
		selectRecipe(recipes[1])
	end
end

local function openUI(station: string, recipes: { any })
	currentStation = station

	-- Set title based on station
	local stationTitles = {
		Anvil = "‚öíÔ∏è  Anvil ‚Äî Smithing",
		Forge = "üî•  Forge ‚Äî Smelting",
		CookingRange = "üç≥  Cooking Range",
	}
	titleLabel.Text = stationTitles[station] or "Crafting"

	populateList(recipes)
	progressBg.Visible = false
	isCrafting = false
	screenGui.Enabled = true
end

local function closeUI()
	screenGui.Enabled = false
	currentStation = nil
	selectedRecipe = nil
	isCrafting = false
end

----------------------------------------------------------------------
-- Craft Actions
----------------------------------------------------------------------

local function doCraft(quantity: number)
	if not selectedRecipe or isCrafting then return end
	if not selectedRecipe.canCraft or selectedRecipe.maxCraft <= 0 then return end

	isCrafting = true
	local qty = math.min(quantity, selectedRecipe.maxCraft)

	-- Show progress bar
	progressBg.Visible = true
	progressFill.Size = UDim2.new(0, 0, 1, 0)
	progressText.Text = string.format("0 / %d", qty)

	CraftRequest:FireServer(selectedRecipe.id, qty)
end

craftBtn.MouseButton1Click:Connect(function()
	doCraft(1)
end)

craftAllBtn.MouseButton1Click:Connect(function()
	if selectedRecipe then
		doCraft(selectedRecipe.maxCraft)
	end
end)

closeBtn.MouseButton1Click:Connect(closeUI)

----------------------------------------------------------------------
-- Server Events
----------------------------------------------------------------------

CraftUpdate.OnClientEvent:Connect(function(data)
	if data.action == "open" then
		-- Server tells us to open crafting UI
		openUI(data.station, data.recipes)
		return
	end

	-- Progress update during crafting
	if data.current and data.total then
		local pct = data.current / data.total
		TweenService:Create(progressFill, TweenInfo.new(CRAFT_TIME, Enum.EasingStyle.Linear), {
			Size = UDim2.new(pct, 0, 1, 0),
		}):Play()
		progressText.Text = string.format("%d / %d", data.current, data.total)
	end
end)

CraftComplete.OnClientEvent:Connect(function(data)
	isCrafting = false
	progressBg.Visible = false

	if data.success then
		-- Flash gold on product label
		productLabel.TextColor3 = THEME.green
		productLabel.Text = data.message
		task.delay(1.5, function()
			productLabel.TextColor3 = THEME.gold
			if selectedRecipe then
				productLabel.Text = selectedRecipe.product
			end
		end)

		-- Re-request recipe list to refresh counts
		-- (Server will re-send via CraftUpdate with action=open if station is still valid)
		-- For now just close if station gone
	else
		productLabel.TextColor3 = THEME.red
		productLabel.Text = data.message or "Crafting failed."
		task.delay(2, function()
			productLabel.TextColor3 = THEME.gold
			if selectedRecipe then
				productLabel.Text = selectedRecipe.product
			end
		end)
	end
end)

----------------------------------------------------------------------
-- Close on Escape
----------------------------------------------------------------------
local UserInputService = game:GetService("UserInputService")
UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end
	if input.KeyCode == Enum.KeyCode.Escape and screenGui.Enabled then
		closeUI()
	end
end)

----------------------------------------------------------------------
print("[CraftingUI] Loaded!")
]]></string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="66">
        <Properties>
          <string name="Name">HealthBar</string>
          <string name="Source"><![CDATA[--[[
	HealthBar.client.lua
	Main player health bar (top center, large and visible)
	+ overhead health bars for other players
]]

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer

--------------------------------------------------------------------------------
-- LOCAL PLAYER HEALTH BAR (big, top center)
--------------------------------------------------------------------------------
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "HealthBarUI"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

-- Main container
local container = Instance.new("Frame")
container.Name = "HealthContainer"
container.Size = UDim2.new(0, 300, 0, 40)
container.Position = UDim2.new(0.5, -150, 0, 10)
container.BackgroundColor3 = Color3.fromRGB(20, 20, 35)
container.BorderSizePixel = 0
container.Parent = screenGui

local containerCorner = Instance.new("UICorner")
containerCorner.CornerRadius = UDim.new(0, 8)
containerCorner.Parent = container

local containerStroke = Instance.new("UIStroke")
containerStroke.Color = Color3.fromRGB(240, 192, 64)
containerStroke.Thickness = 2
containerStroke.Parent = container

-- Health bar background
local barBg = Instance.new("Frame")
barBg.Name = "BarBg"
barBg.Size = UDim2.new(1, -16, 0, 20)
barBg.Position = UDim2.new(0, 8, 0, 14)
barBg.BackgroundColor3 = Color3.fromRGB(40, 10, 10)
barBg.BorderSizePixel = 0
barBg.Parent = container

local barBgCorner = Instance.new("UICorner")
barBgCorner.CornerRadius = UDim.new(0, 6)
barBgCorner.Parent = barBg

-- Health fill
local barFill = Instance.new("Frame")
barFill.Name = "Fill"
barFill.Size = UDim2.new(1, 0, 1, 0)
barFill.BackgroundColor3 = Color3.fromRGB(0, 200, 0)
barFill.BorderSizePixel = 0
barFill.Parent = barBg

local fillCorner = Instance.new("UICorner")
fillCorner.CornerRadius = UDim.new(0, 6)
fillCorner.Parent = barFill

-- Health text overlay
local hpText = Instance.new("TextLabel")
hpText.Name = "HPText"
hpText.Size = UDim2.new(1, 0, 1, 0)
hpText.BackgroundTransparency = 1
hpText.Text = "100 / 100"
hpText.TextColor3 = Color3.fromRGB(255, 255, 255)
hpText.Font = Enum.Font.GothamBold
hpText.TextSize = 14
hpText.TextStrokeTransparency = 0.3
hpText.ZIndex = 2
hpText.Parent = barBg

-- Player name label above bar
local nameLabel = Instance.new("TextLabel")
nameLabel.Name = "NameLabel"
nameLabel.Size = UDim2.new(1, 0, 0, 14)
nameLabel.Position = UDim2.new(0, 0, 0, 0)
nameLabel.BackgroundTransparency = 1
nameLabel.Text = LocalPlayer.DisplayName
nameLabel.TextColor3 = Color3.fromRGB(240, 192, 64)
nameLabel.Font = Enum.Font.GothamBold
nameLabel.TextSize = 12
nameLabel.Parent = container

-- Damage flash overlay
local flashOverlay = Instance.new("Frame")
flashOverlay.Name = "Flash"
flashOverlay.Size = UDim2.new(1, 0, 1, 0)
flashOverlay.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
flashOverlay.BackgroundTransparency = 1
flashOverlay.BorderSizePixel = 0
flashOverlay.ZIndex = 3
flashOverlay.Parent = barBg

local flashCorner = Instance.new("UICorner")
flashCorner.CornerRadius = UDim.new(0, 6)
flashCorner.Parent = flashOverlay

local function getBarColor(pct)
	if pct > 0.6 then
		return Color3.fromRGB(0, 200, 0)
	elseif pct > 0.3 then
		return Color3.fromRGB(220, 180, 0)
	else
		return Color3.fromRGB(200, 30, 30)
	end
end

local lastHP = -1

local function updateLocalHP()
	local character = LocalPlayer.Character
	if not character then return end
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end

	local hp = math.floor(humanoid.Health)
	local maxHP = math.floor(humanoid.MaxHealth)
	local pct = math.clamp(hp / maxHP, 0, 1)

	-- Smooth tween the bar
	TweenService:Create(barFill, TweenInfo.new(0.3, Enum.EasingStyle.Quad), {
		Size = UDim2.new(pct, 0, 1, 0),
		BackgroundColor3 = getBarColor(pct),
	}):Play()

	hpText.Text = hp .. " / " .. maxHP

	-- Flash red on damage
	if lastHP > 0 and hp < lastHP then
		flashOverlay.BackgroundTransparency = 0.3
		TweenService:Create(flashOverlay, TweenInfo.new(0.4), {
			BackgroundTransparency = 1,
		}):Play()
	end

	lastHP = hp
end

-- Connect to character
local function setupCharacter(character)
	local humanoid = character:WaitForChild("Humanoid", 10)
	if not humanoid then return end

	updateLocalHP()
	humanoid.HealthChanged:Connect(updateLocalHP)
	humanoid:GetPropertyChangedSignal("MaxHealth"):Connect(updateLocalHP)
end

if LocalPlayer.Character then
	task.spawn(setupCharacter, LocalPlayer.Character)
end
LocalPlayer.CharacterAdded:Connect(function(char)
	task.spawn(setupCharacter, char)
end)

--------------------------------------------------------------------------------
-- OTHER PLAYER OVERHEAD BARS (smaller, above heads)
--------------------------------------------------------------------------------
local activeBillboards = {}

local function setupOverheadBar(player, character)
	local old = activeBillboards[player]
	if old then old:Destroy() end

	local head = character:WaitForChild("Head", 5)
	local humanoid = character:WaitForChild("Humanoid", 5)
	if not head or not humanoid then return end

	local bb = Instance.new("BillboardGui")
	bb.Name = "OverheadBar"
	bb.Adornee = head
	bb.Size = UDim2.fromScale(4, 0.8)
	bb.StudsOffset = Vector3.new(0, 3, 0)
	bb.AlwaysOnTop = false
	bb.MaxDistance = 80
	bb.Parent = head
	activeBillboards[player] = bb

	local oName = Instance.new("TextLabel")
	oName.Size = UDim2.new(1, 0, 0.45, 0)
	oName.BackgroundTransparency = 1
	oName.Font = Enum.Font.GothamBold
	oName.TextColor3 = Color3.new(1, 1, 1)
	oName.TextStrokeTransparency = 0.4
	oName.TextScaled = true
	oName.Text = player.DisplayName
	oName.Parent = bb

	local oBar = Instance.new("Frame")
	oBar.Size = UDim2.new(1, 0, 0.35, 0)
	oBar.Position = UDim2.fromScale(0, 0.5)
	oBar.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	oBar.BorderSizePixel = 0
	oBar.Parent = bb

	local oCorner = Instance.new("UICorner")
	oCorner.CornerRadius = UDim.new(0.3, 0)
	oCorner.Parent = oBar

	local oFill = Instance.new("Frame")
	oFill.Name = "Fill"
	oFill.Size = UDim2.fromScale(1, 1)
	oFill.BackgroundColor3 = Color3.fromRGB(0, 200, 0)
	oFill.BorderSizePixel = 0
	oFill.Parent = oBar

	local oFillCorner = Instance.new("UICorner")
	oFillCorner.CornerRadius = UDim.new(0.3, 0)
	oFillCorner.Parent = oFill

	humanoid.HealthChanged:Connect(function()
		if not bb.Parent then return end
		local pct = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
		oFill.Size = UDim2.fromScale(pct, 1)
		oFill.BackgroundColor3 = getBarColor(pct)
	end)
end

local function onPlayerAdded(player)
	if player == LocalPlayer then return end
	if player.Character then
		task.spawn(setupOverheadBar, player, player.Character)
	end
	player.CharacterAdded:Connect(function(char)
		task.spawn(setupOverheadBar, player, char)
	end)
end

for _, p in Players:GetPlayers() do
	task.spawn(onPlayerAdded, p)
end
Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(function(player)
	local bb = activeBillboards[player]
	if bb then bb:Destroy() end
	activeBillboards[player] = nil
end)

print("[HealthBar] Loaded ‚Äî main HP bar + overhead bars")
]]></string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="67">
        <Properties>
          <string name="Name">Hotbar</string>
          <string name="Source">--[[
	Hotbar.client.lua
	RuneScape/MMO-style hotbar at the bottom center of the screen
	9 slots (keys 1-9) for quick item access and usage
]]

local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[Hotbar] Starting...")

-- Modules and Remotes
local Modules = ReplicatedStorage:WaitForChild("Modules", 10)
local ItemDatabase = require(Modules:WaitForChild("ItemDatabase"))
local ItemVisuals = require(Modules:WaitForChild("ItemVisuals"))
local DataManager = require(Modules:WaitForChild("DataManager"))

local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
local EquipItemRemote = Remotes:WaitForChild("EquipItem", 10)
local UseItemRemote = Remotes:WaitForChild("UseItem", 10) -- Will be created in HotbarHandler
local GetStatsPanel = Remotes:WaitForChild("GetStatsPanel", 10)

-- Colors (Dark theme)
local BG = Color3.fromRGB(26, 26, 46)
local GOLD = Color3.fromRGB(240, 192, 64)
local DARK = Color3.fromRGB(17, 17, 34)
local TEXT = Color3.fromRGB(220, 220, 210)
local GREEN = Color3.fromRGB(0, 255, 0)  -- Equipped weapon
local BLUE = Color3.fromRGB(0, 150, 255)  -- Equipped armor

-- Hotbar state
local hotbarSlots = {}
local hotbarData = {} -- Persistent hotbar assignment data
local cooldowns = {} -- Cooldown tracking
local currentEquipment = {} -- Track current equipment for highlighting

-- Constants
local SLOT_SIZE = 50
local SLOT_COUNT = 9
local COOLDOWN_TIME = 1.5

-----------------------------------------------------------------------
-- CREATE HOTBAR GUI
-----------------------------------------------------------------------
local gui = Instance.new("ScreenGui")
gui.Name = "HotbarGui"
gui.ResetOnSpawn = false
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
gui.Parent = playerGui

-- Main hotbar frame
local hotbarFrame = Instance.new("Frame")
hotbarFrame.Name = "Hotbar"
hotbarFrame.Size = UDim2.new(0, (SLOT_SIZE + 4) * SLOT_COUNT + 10, 0, SLOT_SIZE + 10)
hotbarFrame.Position = UDim2.new(0.5, -((SLOT_SIZE + 4) * SLOT_COUNT + 10) / 2, 1, -70)
hotbarFrame.BackgroundColor3 = BG
hotbarFrame.BackgroundTransparency = 0.1
hotbarFrame.Parent = gui

local hfc = Instance.new("UICorner")
hfc.CornerRadius = UDim.new(0, 8)
hfc.Parent = hotbarFrame

local hfs = Instance.new("UIStroke")
hfs.Color = GOLD
hfs.Thickness = 2
hfs.Parent = hotbarFrame

-- Create 9 hotbar slots
for i = 1, SLOT_COUNT do
	local slot = Instance.new("Frame")
	slot.Name = "Slot" .. i
	slot.Size = UDim2.new(0, SLOT_SIZE, 0, SLOT_SIZE)
	slot.Position = UDim2.new(0, 5 + (i - 1) * (SLOT_SIZE + 4), 0, 5)
	slot.BackgroundColor3 = DARK
	slot.Parent = hotbarFrame
	
	local sc = Instance.new("UICorner")
	sc.CornerRadius = UDim.new(0, 6)
	sc.Parent = slot
	
	-- Slot border (for equipment highlighting)
	local slotStroke = Instance.new("UIStroke")
	slotStroke.Name = "SlotStroke"
	slotStroke.Color = GOLD
	slotStroke.Thickness = 2
	slotStroke.Transparency = 0.7
	slotStroke.Parent = slot
	
	-- Slot number (top-left corner)
	local slotNumber = Instance.new("TextLabel")
	slotNumber.Size = UDim2.new(0, 15, 0, 15)
	slotNumber.Position = UDim2.new(0, 2, 0, 2)
	slotNumber.BackgroundTransparency = 1
	slotNumber.Text = tostring(i)
	slotNumber.TextSize = 10
	slotNumber.Font = Enum.Font.GothamBold
	slotNumber.TextColor3 = Color3.fromRGB(150, 150, 150)
	slotNumber.Parent = slot
	
	-- Item emoji/icon
	local itemIcon = Instance.new("TextLabel")
	itemIcon.Name = "Icon"
	itemIcon.Size = UDim2.new(1, -4, 0, 24)
	itemIcon.Position = UDim2.new(0, 2, 0, 8)
	itemIcon.BackgroundTransparency = 1
	itemIcon.Text = "+"
	itemIcon.TextSize = 20
	itemIcon.Font = Enum.Font.GothamBold
	itemIcon.TextColor3 = Color3.fromRGB(100, 100, 100)
	itemIcon.Parent = slot
	
	-- Item name
	local itemName = Instance.new("TextLabel")
	itemName.Name = "ItemName"
	itemName.Size = UDim2.new(1, -4, 0, 10)
	itemName.Position = UDim2.new(0, 2, 0, 32)
	itemName.BackgroundTransparency = 1
	itemName.Text = ""
	itemName.TextSize = 7
	itemName.Font = Enum.Font.Gotham
	itemName.TextColor3 = TEXT
	itemName.TextTruncate = Enum.TextTruncate.AtEnd
	itemName.Parent = slot
	
	-- Quantity badge
	local quantityLabel = Instance.new("TextLabel")
	quantityLabel.Name = "Quantity"
	quantityLabel.Size = UDim2.new(0, 20, 0, 12)
	quantityLabel.Position = UDim2.new(1, -22, 1, -14)
	quantityLabel.BackgroundTransparency = 1
	quantityLabel.Text = ""
	quantityLabel.TextSize = 8
	quantityLabel.Font = Enum.Font.GothamBold
	quantityLabel.TextColor3 = GOLD
	quantityLabel.Parent = slot
	
	-- Click button
	local clickBtn = Instance.new("TextButton")
	clickBtn.Size = UDim2.new(1, 0, 1, 0)
	clickBtn.BackgroundTransparency = 1
	clickBtn.Text = ""
	clickBtn.Parent = slot
	
	-- Cooldown overlay
	local cooldownOverlay = Instance.new("Frame")
	cooldownOverlay.Name = "Cooldown"
	cooldownOverlay.Size = UDim2.new(1, 0, 1, 0)
	cooldownOverlay.Position = UDim2.new(0, 0, 0, 0)
	cooldownOverlay.BackgroundColor3 = Color3.fromRGB(64, 64, 64)
	cooldownOverlay.BackgroundTransparency = 0.4
	cooldownOverlay.Visible = false
	cooldownOverlay.ZIndex = 5
	cooldownOverlay.Parent = slot
	local cdc = Instance.new("UICorner")
	cdc.CornerRadius = UDim.new(0, 6)
	cdc.Parent = cooldownOverlay
	
	-- Store slot references
	hotbarSlots[i] = {
		frame = slot,
		icon = itemIcon,
		name = itemName,
		quantity = quantityLabel,
		button = clickBtn,
		stroke = slotStroke,
		cooldown = cooldownOverlay,
		itemName = nil,
		itemData = nil
	}
	
	-- Click handler for slot assignment
	clickBtn.MouseButton1Click:Connect(function()
		onHotbarSlotClick(i)
	end)
end

-----------------------------------------------------------------------
-- TOOLTIP
-----------------------------------------------------------------------
local tooltip = Instance.new("Frame")
tooltip.Name = "Tooltip"
tooltip.Size = UDim2.new(0, 180, 0, 80)
tooltip.BackgroundColor3 = Color3.fromRGB(15, 15, 30)
tooltip.BackgroundTransparency = 0.05
tooltip.Visible = false
tooltip.ZIndex = 100
tooltip.Parent = gui

local ttCorner = Instance.new("UICorner")
ttCorner.CornerRadius = UDim.new(0, 6)
ttCorner.Parent = tooltip

local ttStroke = Instance.new("UIStroke")
ttStroke.Color = GOLD
ttStroke.Thickness = 2
ttStroke.Parent = tooltip

local ttPadding = Instance.new("UIPadding")
ttPadding.PaddingLeft = UDim.new(0, 6)
ttPadding.PaddingRight = UDim.new(0, 6)
ttPadding.PaddingTop = UDim.new(0, 4)
ttPadding.PaddingBottom = UDim.new(0, 4)
ttPadding.Parent = tooltip

local ttName = Instance.new("TextLabel")
ttName.Size = UDim2.new(1, 0, 0, 16)
ttName.BackgroundTransparency = 1
ttName.Text = "Item Name"
ttName.TextSize = 12
ttName.Font = Enum.Font.GothamBold
ttName.TextColor3 = GOLD
ttName.TextXAlignment = Enum.TextXAlignment.Left
ttName.ZIndex = 101
ttName.Parent = tooltip

local ttType = Instance.new("TextLabel")
ttType.Size = UDim2.new(1, 0, 0, 12)
ttType.Position = UDim2.new(0, 0, 0, 16)
ttType.BackgroundTransparency = 1
ttType.Text = "Type"
ttType.TextSize = 10
ttType.Font = Enum.Font.Gotham
ttType.TextColor3 = TEXT
ttType.TextXAlignment = Enum.TextXAlignment.Left
ttType.ZIndex = 101
ttType.Parent = tooltip

local ttStats = Instance.new("TextLabel")
ttStats.Size = UDim2.new(1, 0, 0, 24)
ttStats.Position = UDim2.new(0, 0, 0, 30)
ttStats.BackgroundTransparency = 1
ttStats.Text = ""
ttStats.TextSize = 9
ttStats.Font = Enum.Font.Gotham
ttStats.TextColor3 = Color3.fromRGB(0, 255, 0)
ttStats.TextXAlignment = Enum.TextXAlignment.Left
ttStats.TextWrapped = true
ttStats.ZIndex = 101
ttStats.Parent = tooltip

local ttAction = Instance.new("TextLabel")
ttAction.Size = UDim2.new(1, 0, 0, 14)
ttAction.Position = UDim2.new(0, 0, 1, -16)
ttAction.BackgroundTransparency = 1
ttAction.Text = "Left click to use"
ttAction.TextSize = 9
ttAction.Font = Enum.Font.GothamBold
ttAction.TextColor3 = Color3.fromRGB(150, 150, 150)
ttAction.TextXAlignment = Enum.TextXAlignment.Left
ttAction.ZIndex = 101
ttAction.Parent = tooltip

-----------------------------------------------------------------------
-- HOTBAR LOGIC
-----------------------------------------------------------------------

-- Update visual display of a hotbar slot
local function updateHotbarSlot(slotIndex)
	local slot = hotbarSlots[slotIndex]
	local assignedItem = hotbarData[slotIndex]
	
	if assignedItem and assignedItem.name then
		-- Get item visuals and data
		local visual = ItemVisuals.GetVisual(assignedItem.name)
		local itemDef = ItemDatabase.GetItem(assignedItem.name)
		
		slot.icon.Text = visual.emoji
		slot.icon.TextColor3 = visual.color
		slot.name.Text = assignedItem.name
		slot.quantity.Text = (assignedItem.quantity and assignedItem.quantity > 1) and tostring(assignedItem.quantity) or ""
		
		-- Highlight if currently equipped
		if currentEquipment.Weapon == assignedItem.name then
			slot.stroke.Color = GREEN
			slot.stroke.Transparency = 0
		elseif itemDef and itemDef.equipSlot and itemDef.equipSlot ~= "Weapon" and currentEquipment[itemDef.equipSlot] == assignedItem.name then
			slot.stroke.Color = BLUE
			slot.stroke.Transparency = 0
		else
			slot.stroke.Color = GOLD
			slot.stroke.Transparency = 0.7
		end
		
		slot.itemName = assignedItem.name
		slot.itemData = itemDef
	else
		-- Empty slot
		slot.icon.Text = "+"
		slot.icon.TextColor3 = Color3.fromRGB(100, 100, 100)
		slot.name.Text = ""
		slot.quantity.Text = ""
		slot.stroke.Color = GOLD
		slot.stroke.Transparency = 0.7
		slot.itemName = nil
		slot.itemData = nil
	end
end

-- Use item in hotbar slot
local function useHotbarItem(slotIndex)
	local assignedItem = hotbarData[slotIndex]
	if not assignedItem or not assignedItem.name then return end
	
	local itemDef = ItemDatabase.GetItem(assignedItem.name)
	if not itemDef then return end
	
	-- Check cooldown
	if cooldowns[slotIndex] and cooldowns[slotIndex] > tick() then return end
	
	-- Handle different item types
	if itemDef.equipSlot then
		-- Weapon/armor: equip via EquipItem remote
		print("[Hotbar] Equipping " .. assignedItem.name .. " to " .. itemDef.equipSlot)
		EquipItemRemote:FireServer(itemDef.equipSlot, assignedItem.name)
	elseif itemDef.type == "food" then
		-- Food: use via UseItem remote and start cooldown
		print("[Hotbar] Using food " .. assignedItem.name)
		UseItemRemote:FireServer(assignedItem.name)
		
		-- Start cooldown
		cooldowns[slotIndex] = tick() + COOLDOWN_TIME
		local slot = hotbarSlots[slotIndex]
		slot.cooldown.Visible = true
		
		-- Animate cooldown
		local tween = TweenService:Create(slot.cooldown, TweenInfo.new(COOLDOWN_TIME, Enum.EasingStyle.Linear), {
			BackgroundTransparency = 1
		})
		tween:Play()
		tween.Completed:Connect(function()
			slot.cooldown.Visible = false
			slot.cooldown.BackgroundTransparency = 0.4
		end)
	end
	
	-- Refresh data after a short delay
	task.wait(0.2)
	refreshHotbarData()
end

-- Handle hotbar slot clicks ‚Äî if inventory item pending, assign it; otherwise use
function onHotbarSlotClick(slotIndex)
	-- Check if StatsPanel has a pending item for hotbar assignment
	if _G.PendingHotbarItem then
		local pending = _G.PendingHotbarItem
		assignItemToHotbar(slotIndex, pending.name, pending.quantity)
		print("[Hotbar] Assigned " .. pending.name .. " to slot " .. slotIndex)
		_G.PendingHotbarItem = nil
		-- Clear visual highlight in inventory
		if _G.ClearInventorySelection then
			_G.ClearInventorySelection()
		end
		return
	end
	useHotbarItem(slotIndex)
end

-- Load hotbar configuration from player data
local function loadHotbarData()
	local ok, data = pcall(function()
		return GetStatsPanel:InvokeServer()
	end)
	if ok and data and data.hotbar then
		hotbarData = data.hotbar
	else
		-- Initialize empty hotbar
		hotbarData = {}
		for i = 1, SLOT_COUNT do
			hotbarData[i] = nil
		end
	end
	
	-- Update current equipment info
	if data and data.equipment then
		currentEquipment = data.equipment
	end
end

-- Save hotbar configuration to player data
local function saveHotbarData()
	-- This would typically be handled server-side
	-- For now, we'll let the server manage persistence
end

-- Refresh hotbar display and data
function refreshHotbarData()
	loadHotbarData()
	for i = 1, SLOT_COUNT do
		updateHotbarSlot(i)
	end
end

-- Assign item from inventory to hotbar slot (called from outside)
function assignItemToHotbar(slotIndex, itemName, quantity)
	hotbarData[slotIndex] = {
		name = itemName,
		quantity = quantity
	}
	updateHotbarSlot(slotIndex)
	saveHotbarData()
end

-----------------------------------------------------------------------
-- INPUT HANDLING
-----------------------------------------------------------------------
UIS.InputBegan:Connect(function(input, processed)
	if processed then return end
	
	-- Handle number keys 1-9
	if input.KeyCode == Enum.KeyCode.One then
		useHotbarItem(1)
	elseif input.KeyCode == Enum.KeyCode.Two then
		useHotbarItem(2)
	elseif input.KeyCode == Enum.KeyCode.Three then
		useHotbarItem(3)
	elseif input.KeyCode == Enum.KeyCode.Four then
		useHotbarItem(4)
	elseif input.KeyCode == Enum.KeyCode.Five then
		useHotbarItem(5)
	elseif input.KeyCode == Enum.KeyCode.Six then
		useHotbarItem(6)
	elseif input.KeyCode == Enum.KeyCode.Seven then
		useHotbarItem(7)
	elseif input.KeyCode == Enum.KeyCode.Eight then
		useHotbarItem(8)
	elseif input.KeyCode == Enum.KeyCode.Nine then
		useHotbarItem(9)
	end
end)

-----------------------------------------------------------------------
-- TOOLTIP HANDLING
-----------------------------------------------------------------------
for i = 1, SLOT_COUNT do
	local slot = hotbarSlots[i]
	
	slot.button.MouseEnter:Connect(function()
		if not slot.itemName or not slot.itemData then
			tooltip.Visible = false
			return
		end
		
		ttName.Text = slot.itemName
		
		if slot.itemData.type == "weapon" then
			ttType.Text = "Weapon"
			ttStats.Text = "Damage: " .. (slot.itemData.damage or 0)
			ttAction.Text = "Left click to equip"
		elseif slot.itemData.type == "armor" then
			ttType.Text = "Armor (" .. (slot.itemData.equipSlot or "Unknown") .. ")"
			ttStats.Text = "Defense: " .. (slot.itemData.defense or 0)
			ttAction.Text = "Left click to equip"
		elseif slot.itemData.type == "food" then
			ttType.Text = "Food"
			ttStats.Text = "Heals: " .. (slot.itemData.healAmount or 0) .. " HP"
			ttAction.Text = "Left click to eat"
		elseif slot.itemData.type == "tool" then
			ttType.Text = "Tool"
			ttStats.Text = "Level: " .. (slot.itemData.levelReq or 1) .. " " .. (slot.itemData.skill or "")
			ttAction.Text = "Left click to equip"
		else
			ttType.Text = slot.itemData.type or "Item"
			ttStats.Text = ""
			ttAction.Text = "Left click to use"
		end
		
		-- Position tooltip above hotbar
		local slotPos = slot.frame.AbsolutePosition
		tooltip.Position = UDim2.fromOffset(slotPos.X, slotPos.Y - 90)
		tooltip.Visible = true
	end)
	
	slot.button.MouseLeave:Connect(function()
		tooltip.Visible = false
	end)
end

-----------------------------------------------------------------------
-- INTEGRATION WITH STATS PANEL
-----------------------------------------------------------------------
-- Listen for inventory updates
local invRemote = Remotes:FindFirstChild("InventoryUpdate")
if invRemote then
	invRemote.OnClientEvent:Connect(refreshHotbarData)
end

local equipRemote = Remotes:FindFirstChild("EquipmentUpdate")
if equipRemote then
	equipRemote.OnClientEvent:Connect(refreshHotbarData)
end

-----------------------------------------------------------------------
-- INITIALIZATION
-----------------------------------------------------------------------
task.spawn(function()
	task.wait(2) -- Wait for other systems to load
	refreshHotbarData()
	print("[Hotbar] Ready! Use keys 1-9 to use hotbar items.")
end)

-- Make functions global for Stats Panel integration
_G.HotbarAssignItem = assignItemToHotbar
_G.HotbarRefresh = refreshHotbarData</string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="68">
        <Properties>
          <string name="Name">LootUI</string>
          <string name="Source"><![CDATA[--[[
	LootUI.client.lua
	Client-side loot bag interface for the full-loot PvP system.
	Opens a dark-themed window when clicking a loot bag, showing items
	with Take/Take All buttons. Auto-closes on distance.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Remotes
local LootBagOpen = ReplicatedStorage:WaitForChild("LootBagOpen")
local LootBagTake = ReplicatedStorage:WaitForChild("LootBagTake")
local LootBagUpdate = ReplicatedStorage:WaitForChild("LootBagUpdate")

-- Theme
local Theme = {
	Background = Color3.fromRGB(26, 26, 46),    -- #1a1a2e
	Panel = Color3.fromRGB(36, 36, 66),
	Gold = Color3.fromRGB(240, 192, 64),         -- #f0c040
	Text = Color3.fromRGB(230, 230, 230),
	ButtonHover = Color3.fromRGB(60, 60, 100),
	Red = Color3.fromRGB(200, 60, 60),
	Corner = UDim.new(0, 6),
}

local MAX_LOOT_DISTANCE = 15

-- State
local currentBagId: string? = nil
local currentBagPosition: Vector3? = nil
local distanceConn: RBXScriptConnection? = nil

--------------------------------------------------------------------------------
-- UI Construction
--------------------------------------------------------------------------------

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "LootUI"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

-- Main frame
local frame = Instance.new("Frame")
frame.Name = "LootFrame"
frame.Size = UDim2.new(0, 320, 0, 400)
frame.Position = UDim2.new(0.5, -160, 0.5, -200)
frame.BackgroundColor3 = Theme.Background
frame.BorderSizePixel = 0
frame.Visible = false
frame.Parent = screenGui

local frameCorner = Instance.new("UICorner")
frameCorner.CornerRadius = UDim.new(0, 8)
frameCorner.Parent = frame

local frameStroke = Instance.new("UIStroke")
frameStroke.Color = Theme.Gold
frameStroke.Thickness = 2
frameStroke.Parent = frame

-- Header
local header = Instance.new("Frame")
header.Name = "Header"
header.Size = UDim2.new(1, 0, 0, 40)
header.BackgroundColor3 = Theme.Panel
header.BorderSizePixel = 0
header.Parent = frame

local headerCorner = Instance.new("UICorner")
headerCorner.CornerRadius = UDim.new(0, 8)
headerCorner.Parent = header

local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Size = UDim2.new(1, -40, 1, 0)
titleLabel.Position = UDim2.new(0, 10, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "üíÄ Loot Bag"
titleLabel.TextColor3 = Theme.Gold
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextSize = 18
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = header

local closeBtn = Instance.new("TextButton")
closeBtn.Name = "Close"
closeBtn.Size = UDim2.new(0, 30, 0, 30)
closeBtn.Position = UDim2.new(1, -35, 0, 5)
closeBtn.BackgroundColor3 = Theme.Red
closeBtn.Text = "‚úï"
closeBtn.TextColor3 = Color3.new(1, 1, 1)
closeBtn.Font = Enum.Font.GothamBold
closeBtn.TextSize = 14
closeBtn.BorderSizePixel = 0
closeBtn.Parent = header

Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0, 4)

-- Scroll area for items
local scrollFrame = Instance.new("ScrollingFrame")
scrollFrame.Name = "ItemList"
scrollFrame.Size = UDim2.new(1, -20, 1, -100)
scrollFrame.Position = UDim2.new(0, 10, 0, 50)
scrollFrame.BackgroundTransparency = 1
scrollFrame.BorderSizePixel = 0
scrollFrame.ScrollBarThickness = 4
scrollFrame.ScrollBarImageColor3 = Theme.Gold
scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
scrollFrame.Parent = frame

local listLayout = Instance.new("UIListLayout")
listLayout.SortOrder = Enum.SortOrder.LayoutOrder
listLayout.Padding = UDim.new(0, 4)
listLayout.Parent = scrollFrame

-- Take All button
local takeAllBtn = Instance.new("TextButton")
takeAllBtn.Name = "TakeAll"
takeAllBtn.Size = UDim2.new(1, -20, 0, 36)
takeAllBtn.Position = UDim2.new(0, 10, 1, -46)
takeAllBtn.BackgroundColor3 = Theme.Gold
takeAllBtn.Text = "Take All"
takeAllBtn.TextColor3 = Theme.Background
takeAllBtn.Font = Enum.Font.GothamBold
takeAllBtn.TextSize = 16
takeAllBtn.BorderSizePixel = 0
takeAllBtn.Parent = frame

Instance.new("UICorner", takeAllBtn).CornerRadius = UDim.new(0, 6)

--------------------------------------------------------------------------------
-- Item Row Builder
--------------------------------------------------------------------------------

local function createItemRow(item: { itemId: string, name: string, quantity: number }, index: number): Frame
	local row = Instance.new("Frame")
	row.Name = "Item_" .. index
	row.Size = UDim2.new(1, 0, 0, 36)
	row.BackgroundColor3 = Theme.Panel
	row.BorderSizePixel = 0
	row.LayoutOrder = index

	Instance.new("UICorner", row).CornerRadius = UDim.new(0, 4)

	-- Item name + quantity
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, -80, 1, 0)
	label.Position = UDim2.new(0, 10, 0, 0)
	label.BackgroundTransparency = 1
	label.Text = string.format("%s x%d", item.name or item.itemId, item.quantity or 1)
	label.TextColor3 = Theme.Text
	label.Font = Enum.Font.Gotham
	label.TextSize = 14
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Parent = row

	-- Take button
	local takeBtn = Instance.new("TextButton")
	takeBtn.Name = "Take"
	takeBtn.Size = UDim2.new(0, 60, 0, 26)
	takeBtn.Position = UDim2.new(1, -70, 0, 5)
	takeBtn.BackgroundColor3 = Theme.Gold
	takeBtn.Text = "Take"
	takeBtn.TextColor3 = Theme.Background
	takeBtn.Font = Enum.Font.GothamBold
	takeBtn.TextSize = 12
	takeBtn.BorderSizePixel = 0
	takeBtn.Parent = row

	Instance.new("UICorner", takeBtn).CornerRadius = UDim.new(0, 4)

	takeBtn.MouseButton1Click:Connect(function()
		if currentBagId then
			LootBagTake:FireServer(currentBagId, index)
		end
	end)

	return row
end

--------------------------------------------------------------------------------
-- UI Logic
--------------------------------------------------------------------------------

local function closeLootWindow()
	frame.Visible = false
	currentBagId = nil
	currentBagPosition = nil

	if distanceConn then
		distanceConn:Disconnect()
		distanceConn = nil
	end

	-- Clear item list
	for _, child in scrollFrame:GetChildren() do
		if child:IsA("Frame") then
			child:Destroy()
		end
	end
end

local function populateItems(contents: { { itemId: string, name: string, quantity: number } })
	-- Clear existing
	for _, child in scrollFrame:GetChildren() do
		if child:IsA("Frame") then
			child:Destroy()
		end
	end

	for i, item in contents do
		local row = createItemRow(item, i)
		row.Parent = scrollFrame
	end
end

local function openLootWindow(bagId: string, contents: { any }, ownerName: string)
	currentBagId = bagId

	-- Find the bag model in workspace to track position
	local bagModel = workspace:FindFirstChild("LootBag_" .. bagId)
	if bagModel and bagModel.PrimaryPart then
		currentBagPosition = bagModel.PrimaryPart.Position
	end

	titleLabel.Text = string.format("üíÄ %s's Loot", ownerName)
	populateItems(contents)
	frame.Visible = true

	-- Distance check loop
	if distanceConn then distanceConn:Disconnect() end
	distanceConn = RunService.Heartbeat:Connect(function()
		if not currentBagPosition then
			closeLootWindow()
			return
		end

		local character = player.Character
		if not character or not character:FindFirstChild("HumanoidRootPart") then return end

		local dist = (character.HumanoidRootPart.Position - currentBagPosition).Magnitude
		if dist > MAX_LOOT_DISTANCE then
			closeLootWindow()
		end
	end)
end

--------------------------------------------------------------------------------
-- Event Connections
--------------------------------------------------------------------------------

-- Server tells us to open a bag
LootBagOpen.OnClientEvent:Connect(function(bagId: string, contents, ownerName: string)
	openLootWindow(bagId, contents, ownerName)
end)

-- Server sends bag content updates (or nil = bag gone)
LootBagUpdate.OnClientEvent:Connect(function(bagId: string, contents)
	if bagId ~= currentBagId then return end

	if contents == nil then
		closeLootWindow()
	else
		populateItems(contents)
	end
end)

-- Close button
closeBtn.MouseButton1Click:Connect(closeLootWindow)

-- Take All: fire take for index 1 repeatedly (server removes from front)
takeAllBtn.MouseButton1Click:Connect(function()
	if not currentBagId then return end

	-- Count current items and take from index 1 each time
	local itemCount = 0
	for _, child in scrollFrame:GetChildren() do
		if child:IsA("Frame") then
			itemCount += 1
		end
	end

	for _ = 1, itemCount do
		LootBagTake:FireServer(currentBagId, 1)
		task.wait(0.05) -- slight throttle to avoid race conditions
	end
end)

print("[LootUI] Loaded!")
]]></string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="69">
        <Properties>
          <string name="Name">MiniMap</string>
          <string name="Source"><![CDATA[--[[
	MiniMap.client.lua
	Circular minimap HUD for Roscape Runeblocks.
	Player-centric, heading-up rotation. Shows players, NPCs,
	monsters, resource nodes, loot drops, and a legend.
	Click to zoom, M to toggle, drag to move.
]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Config
local MAP_SIZE = 200
local HALF = MAP_SIZE / 2
local RADIUS = HALF
local UPDATE_INTERVAL = 0.08
local DOT_SIZE = 8
local SMALL_DOT = 6
local ARROW_SIZE = 16

local viewRadius = 180
local zoomed = false
local visible = true

-- Colors
local COLOR_BG = Color3.fromRGB(15, 15, 30)
local COLOR_BORDER = Color3.fromRGB(240, 192, 64)
local COLOR_GOLD = Color3.fromRGB(240, 192, 64)
local COLOR_WHITE = Color3.fromRGB(255, 255, 255)
local COLOR_GREEN = Color3.fromRGB(40, 200, 60)
local COLOR_RED = Color3.fromRGB(220, 50, 50)
local COLOR_BROWN = Color3.fromRGB(200, 140, 60)
local COLOR_TREE_GREEN = Color3.fromRGB(30, 180, 50)
local COLOR_BLUE = Color3.fromRGB(60, 150, 255)
local COLOR_YELLOW = Color3.fromRGB(255, 220, 40)
local COLOR_COMPASS = Color3.fromRGB(200, 200, 210)
local COLOR_NPC_GREEN = Color3.fromRGB(50, 255, 80)
local COLOR_MONSTER_RED = Color3.fromRGB(255, 60, 60)
local COLOR_PLAYER_CYAN = Color3.fromRGB(80, 220, 255)

local WILDERNESS_Z = -100

------------------------------------------------------------------------
-- UI Construction
------------------------------------------------------------------------

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MiniMapGui"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.DisplayOrder = 10
screenGui.Parent = PlayerGui

-- Container for minimap + zone label + legend
local container = Instance.new("Frame")
container.Name = "MiniMapContainer"
container.Size = UDim2.fromOffset(MAP_SIZE + 20, MAP_SIZE + 100)
container.Position = UDim2.new(1, -(MAP_SIZE + 30), 0, 10)
container.BackgroundTransparency = 1
container.Parent = screenGui

-- Circular frame with darker BG
local frame = Instance.new("Frame")
frame.Name = "MiniMapFrame"
frame.Size = UDim2.fromOffset(MAP_SIZE, MAP_SIZE)
frame.Position = UDim2.fromOffset(10, 10)
frame.BackgroundColor3 = COLOR_BG
frame.BorderSizePixel = 0
frame.ClipsDescendants = true
frame.Parent = container

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(1, 0)
corner.Parent = frame

local stroke = Instance.new("UIStroke")
stroke.Color = COLOR_BORDER
stroke.Thickness = 3
stroke.Parent = frame

-- Inner ring for depth effect
local innerRing = Instance.new("Frame")
innerRing.Name = "InnerRing"
innerRing.Size = UDim2.new(1, -8, 1, -8)
innerRing.Position = UDim2.fromOffset(4, 4)
innerRing.BackgroundTransparency = 1
innerRing.Parent = frame
local innerCorner = Instance.new("UICorner")
innerCorner.CornerRadius = UDim.new(1, 0)
innerCorner.Parent = innerRing
local innerStroke = Instance.new("UIStroke")
innerStroke.Color = Color3.fromRGB(50, 50, 80)
innerStroke.Thickness = 1
innerStroke.Parent = innerRing

-- Click button overlay for zoom toggle
local clickBtn = Instance.new("TextButton")
clickBtn.Name = "ClickOverlay"
clickBtn.Size = UDim2.fromScale(1, 1)
clickBtn.BackgroundTransparency = 1
clickBtn.Text = ""
clickBtn.ZIndex = 20
clickBtn.Parent = frame

-- Cardinal direction labels
local compassLabels = {}
local compassOffsets = {
	N = {angle = 0, color = COLOR_GOLD},
	E = {angle = math.pi / 2, color = COLOR_COMPASS},
	S = {angle = math.pi, color = COLOR_COMPASS},
	W = {angle = -math.pi / 2, color = COLOR_COMPASS},
}

for letter, data in compassOffsets do
	local cl = Instance.new("TextLabel")
	cl.Name = "Compass_" .. letter
	cl.Size = UDim2.fromOffset(16, 16)
	cl.BackgroundTransparency = 1
	cl.Text = letter
	cl.TextColor3 = data.color
	cl.TextSize = 13
	cl.Font = Enum.Font.GothamBold
	cl.ZIndex = 15
	cl.Parent = frame
	compassLabels[letter] = {label = cl, baseAngle = data.angle}
end

-- Player arrow (gold triangle)
local selfArrow = Instance.new("ImageLabel")
selfArrow.Name = "SelfArrow"
selfArrow.Size = UDim2.fromOffset(ARROW_SIZE, ARROW_SIZE)
selfArrow.Position = UDim2.fromOffset(HALF - ARROW_SIZE / 2, HALF - ARROW_SIZE / 2)
selfArrow.BackgroundTransparency = 1
selfArrow.ImageColor3 = COLOR_GOLD
selfArrow.Image = "rbxassetid://6031075938"
selfArrow.ZIndex = 10
selfArrow.Rotation = 0
selfArrow.Parent = frame

-- Zone indicator below minimap
local zoneLabel = Instance.new("TextLabel")
zoneLabel.Name = "ZoneLabel"
zoneLabel.Size = UDim2.new(1, 0, 0, 22)
zoneLabel.Position = UDim2.fromOffset(0, MAP_SIZE + 14)
zoneLabel.BackgroundTransparency = 1
zoneLabel.Text = "SAFE ZONE"
zoneLabel.TextColor3 = COLOR_GREEN
zoneLabel.TextSize = 14
zoneLabel.Font = Enum.Font.GothamBold
zoneLabel.TextXAlignment = Enum.TextXAlignment.Center
zoneLabel.Parent = container

-- Zoom indicator
local zoomLabel = Instance.new("TextLabel")
zoomLabel.Name = "ZoomLabel"
zoomLabel.Size = UDim2.fromOffset(50, 16)
zoomLabel.Position = UDim2.fromOffset(MAP_SIZE - 40, MAP_SIZE + 14)
zoomLabel.BackgroundTransparency = 1
zoomLabel.Text = "1x"
zoomLabel.TextColor3 = Color3.fromRGB(150, 150, 170)
zoomLabel.TextSize = 10
zoomLabel.Font = Enum.Font.Gotham
zoomLabel.TextXAlignment = Enum.TextXAlignment.Right
zoomLabel.Parent = container

-- === LEGEND ===
local legendFrame = Instance.new("Frame")
legendFrame.Name = "Legend"
legendFrame.Size = UDim2.new(1, -10, 0, 56)
legendFrame.Position = UDim2.fromOffset(5, MAP_SIZE + 38)
legendFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 35)
legendFrame.BackgroundTransparency = 0.3
legendFrame.BorderSizePixel = 0
legendFrame.Parent = container

local legendCorner = Instance.new("UICorner")
legendCorner.CornerRadius = UDim.new(0, 6)
legendCorner.Parent = legendFrame

local legendItems = {
	{color = COLOR_PLAYER_CYAN, text = "Player"},
	{color = COLOR_NPC_GREEN, text = "NPC"},
	{color = COLOR_MONSTER_RED, text = "Enemy"},
	{color = COLOR_BROWN, text = "Mine"},
	{color = COLOR_TREE_GREEN, text = "Tree"},
	{color = COLOR_BLUE, text = "Fish"},
	{color = COLOR_YELLOW, text = "Loot"},
}

-- Layout: 4 on top row, 3 on bottom
local legendPad = 4
local colWidth = (MAP_SIZE + 10) / 4

for i, item in ipairs(legendItems) do
	local row = i <= 4 and 0 or 1
	local col = i <= 4 and (i - 1) or (i - 5)
	local x = legendPad + col * colWidth
	local y = 4 + row * 26

	local dot = Instance.new("Frame")
	dot.Size = UDim2.fromOffset(8, 8)
	dot.Position = UDim2.fromOffset(x, y + 4)
	dot.BackgroundColor3 = item.color
	dot.BorderSizePixel = 0
	dot.Parent = legendFrame
	local dc = Instance.new("UICorner")
	dc.CornerRadius = UDim.new(1, 0)
	dc.Parent = dot

	local lbl = Instance.new("TextLabel")
	lbl.Size = UDim2.fromOffset(colWidth - 16, 16)
	lbl.Position = UDim2.fromOffset(x + 12, y + 1)
	lbl.BackgroundTransparency = 1
	lbl.Text = item.text
	lbl.TextColor3 = Color3.fromRGB(200, 200, 210)
	lbl.TextSize = 9
	lbl.Font = Enum.Font.Gotham
	lbl.TextXAlignment = Enum.TextXAlignment.Left
	lbl.Parent = legendFrame
end

-- Tooltip label (shows on hover near dots)
local tooltip = Instance.new("TextLabel")
tooltip.Name = "Tooltip"
tooltip.Size = UDim2.fromOffset(120, 20)
tooltip.BackgroundColor3 = Color3.fromRGB(30, 30, 50)
tooltip.BackgroundTransparency = 0.2
tooltip.TextColor3 = COLOR_WHITE
tooltip.TextSize = 10
tooltip.Font = Enum.Font.GothamBold
tooltip.TextStrokeTransparency = 0.5
tooltip.Visible = false
tooltip.ZIndex = 25
tooltip.Parent = frame
local ttCorner = Instance.new("UICorner")
ttCorner.CornerRadius = UDim.new(0, 4)
ttCorner.Parent = tooltip

------------------------------------------------------------------------
-- Dot Pool
------------------------------------------------------------------------

local dotPool = {}
local activeDots = 0
local dotData = {} -- index -> {px, py, name, kind}

local function getDot()
	activeDots += 1
	local dot = dotPool[activeDots]
	if not dot then
		dot = Instance.new("Frame")
		dot.BorderSizePixel = 0
		dot.ZIndex = 5
		local c = Instance.new("UICorner")
		c.CornerRadius = UDim.new(1, 0)
		c.Parent = dot
		dot.Parent = frame
		dotPool[activeDots] = dot
	end
	dot.Visible = true
	dot.BackgroundTransparency = 0
	return dot
end

local function resetDots()
	for i = 1, activeDots do
		dotPool[i].Visible = false
	end
	activeDots = 0
	dotData = {}
end

------------------------------------------------------------------------
-- Helpers
------------------------------------------------------------------------

local function getRoot(player)
	local char = player.Character
	if not char then return nil end
	return char:FindFirstChild("HumanoidRootPart")
end

local function worldToMap(myPos, worldPos, heading, scale)
	local dx = worldPos.X - myPos.X
	local dz = worldPos.Z - myPos.Z
	local cosH = math.cos(-heading)
	local sinH = math.sin(-heading)
	local rx = dx * cosH - dz * sinH
	local ry = dx * sinH + dz * cosH
	local px = HALF + rx * scale
	local py = HALF + ry * scale
	return px, py
end

local function isInCircle(px, py)
	local cx = px - HALF
	local cy = py - HALF
	return (cx * cx + cy * cy) <= (RADIUS * RADIUS)
end

local function placeDot(dot, px, py, size, color)
	dot.Size = UDim2.fromOffset(size, size)
	dot.Position = UDim2.fromOffset(px - size / 2, py - size / 2)
	dot.BackgroundColor3 = color
end

local function getResourceInfo(obj)
	local name = obj.Name:lower()
	if name:find("rock") or name:find("ore") or name:find("mine") or obj:HasTag("Rock") then
		return COLOR_BROWN, "rock"
	end
	if name:find("tree") or name:find("wood") or obj:HasTag("Tree") then
		return COLOR_TREE_GREEN, "tree"
	end
	if name:find("fish") or obj:HasTag("FishingSpot") then
		return COLOR_BLUE, "fish"
	end
	return nil, nil
end

------------------------------------------------------------------------
-- Compass Update
------------------------------------------------------------------------

local function updateCompass(heading)
	local compassRadius = HALF - 12
	for _, data in compassLabels do
		local angle = data.baseAngle - heading
		local x = HALF + math.sin(angle) * compassRadius - 8
		local y = HALF - math.cos(angle) * compassRadius - 8
		data.label.Position = UDim2.fromOffset(x, y)
	end
end

------------------------------------------------------------------------
-- Loot pulse state
------------------------------------------------------------------------

local lootPulseTime = 0

------------------------------------------------------------------------
-- Main Update
------------------------------------------------------------------------

local elapsed = 0

local function update(dt)
	local root = getRoot(LocalPlayer)
	if not root then return end

	local myPos = root.Position
	local lookVector = root.CFrame.LookVector
	local heading = math.atan2(lookVector.X, -lookVector.Z)
	local scale = HALF / viewRadius

	resetDots()

	selfArrow.Rotation = 0
	updateCompass(heading)

	-- Zone indicator
	if myPos.Z < WILDERNESS_Z then
		zoneLabel.Text = "‚ö†Ô∏è WILDERNESS ‚ö†Ô∏è"
		zoneLabel.TextColor3 = COLOR_RED
	else
		zoneLabel.Text = "üè∞ SAFE ZONE"
		zoneLabel.TextColor3 = COLOR_GREEN
	end

	-- Wilderness border line (red dashed line at Z=-100)
	-- Draw it as a series of small red dots across the map
	local borderZ = WILDERNESS_Z
	for bx = -viewRadius, viewRadius, 8 do
		local worldBorderPos = Vector3.new(myPos.X + bx, 0, borderZ)
		local px, py = worldToMap(myPos, worldBorderPos, heading, scale)
		if isInCircle(px, py) then
			local dot = getDot()
			placeDot(dot, px, py, 3, COLOR_RED)
			dot.BackgroundTransparency = 0.3
		end
	end

	-- Loot pulse
	lootPulseTime += dt
	local lootAlpha = 0.5 + 0.5 * math.sin(lootPulseTime * 6)

	-- Other players
	for _, player in Players:GetPlayers() do
		if player == LocalPlayer then continue end
		local otherRoot = getRoot(player)
		if not otherRoot then continue end
		local dist = (otherRoot.Position - myPos).Magnitude
		if dist > viewRadius then continue end
		local px, py = worldToMap(myPos, otherRoot.Position, heading, scale)
		if not isInCircle(px, py) then continue end
		local dot = getDot()
		placeDot(dot, px, py, DOT_SIZE, COLOR_PLAYER_CYAN)
		dotData[activeDots] = {px = px, py = py, name = player.DisplayName, kind = "Player"}
	end

	-- NPCs
	local npcsFolder = Workspace:FindFirstChild("NPCs")
	if npcsFolder then
		for _, npc in npcsFolder:GetChildren() do
			local npcPart = npc:FindFirstChild("Torso") or npc:FindFirstChild("HumanoidRootPart") or npc:FindFirstChildWhichIsA("BasePart")
			if not npcPart then continue end
			local dist = (npcPart.Position - myPos).Magnitude
			if dist > viewRadius then continue end
			local px, py = worldToMap(myPos, npcPart.Position, heading, scale)
			if not isInCircle(px, py) then continue end
			local dot = getDot()
			placeDot(dot, px, py, DOT_SIZE + 2, COLOR_NPC_GREEN)
			dotData[activeDots] = {px = px, py = py, name = npc.Name, kind = "NPC"}
		end
	end

	-- Monsters
	local monstersFolder = Workspace:FindFirstChild("Monsters") or Workspace:FindFirstChild("Enemies")
	if monstersFolder then
		for _, mob in monstersFolder:GetChildren() do
			local mobPart = mob:FindFirstChild("Body") or mob:FindFirstChild("HumanoidRootPart") or mob:FindFirstChildWhichIsA("BasePart")
			if not mobPart then continue end
			local dist = (mobPart.Position - myPos).Magnitude
			if dist > viewRadius then continue end
			local px, py = worldToMap(myPos, mobPart.Position, heading, scale)
			if not isInCircle(px, py) then continue end
			local dot = getDot()
			-- Boss gets bigger dot
			local isBoss = mob.Name == "Shadow Dragon"
			placeDot(dot, px, py, isBoss and (DOT_SIZE + 4) or DOT_SIZE, COLOR_MONSTER_RED)
			dotData[activeDots] = {px = px, py = py, name = mob.Name, kind = "Monster"}
		end
	end

	-- Resource nodes (only show Models, not individual parts to avoid duplicates)
	local resourcesFolder = Workspace:FindFirstChild("ResourceNodes") or Workspace:FindFirstChild("Resources")
	if resourcesFolder then
		for _, obj in resourcesFolder:GetChildren() do
			if not obj:IsA("Model") then continue end
			local primary = obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")
			if not primary then continue end
			local color, kind = getResourceInfo(obj)
			if not color then continue end
			local pos = primary.Position
			local dist = (pos - myPos).Magnitude
			if dist > viewRadius then continue end
			local px, py = worldToMap(myPos, pos, heading, scale)
			if not isInCircle(px, py) then continue end
			local dot = getDot()
			-- Use diamond shape for resources (slightly bigger)
			placeDot(dot, px, py, SMALL_DOT, color)
			dotData[activeDots] = {px = px, py = py, name = obj.Name, kind = kind}
		end
	end

	-- Loot drops
	for _, obj in Workspace:GetChildren() do
		if not obj:IsA("BasePart") then continue end
		if obj.Name:sub(1, 9) ~= "LootDrop_" then continue end
		local dist = (obj.Position - myPos).Magnitude
		if dist > viewRadius then continue end
		local px, py = worldToMap(myPos, obj.Position, heading, scale)
		if not isInCircle(px, py) then continue end
		local dot = getDot()
		placeDot(dot, px, py, DOT_SIZE, COLOR_YELLOW)
		dot.BackgroundTransparency = 1 - lootAlpha
		local itemName = obj.Name:sub(10) -- strip "LootDrop_"
		dotData[activeDots] = {px = px, py = py, name = itemName, kind = "Loot"}
	end
end

------------------------------------------------------------------------
-- Tooltip on mouse hover
------------------------------------------------------------------------

local function updateTooltip()
	local mouse = UserInputService:GetMouseLocation()
	local framePos = frame.AbsolutePosition
	local mx = mouse.X - framePos.X
	local my = mouse.Y - framePos.Y

	-- Check if mouse is inside minimap circle
	local cx = mx - HALF
	local cy = my - HALF
	if (cx * cx + cy * cy) > (RADIUS * RADIUS) then
		tooltip.Visible = false
		return
	end

	-- Find nearest dot
	local bestDist = 15 -- pixel threshold
	local bestData = nil
	for i, data in dotData do
		local dx = mx - data.px
		local dy = my - data.py
		local d = math.sqrt(dx * dx + dy * dy)
		if d < bestDist then
			bestDist = d
			bestData = data
		end
	end

	if bestData then
		tooltip.Text = " " .. bestData.name .. " "
		tooltip.Position = UDim2.fromOffset(
			math.clamp(mx - 60, 0, MAP_SIZE - 120),
			math.clamp(my - 24, 0, MAP_SIZE - 20)
		)
		tooltip.Visible = true
	else
		tooltip.Visible = false
	end
end

------------------------------------------------------------------------
-- Input
------------------------------------------------------------------------

clickBtn.MouseButton1Click:Connect(function()
	if zoomed then
		viewRadius = 180
		zoomed = false
		zoomLabel.Text = "1x"
	else
		viewRadius = 400
		zoomed = true
		zoomLabel.Text = "2x"
	end
end)

UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end
	if input.KeyCode == Enum.KeyCode.M then
		visible = not visible
		container.Visible = visible
	end
end)

------------------------------------------------------------------------
-- Heartbeat
------------------------------------------------------------------------

RunService.Heartbeat:Connect(function(dt)
	if not visible then return end
	elapsed += dt
	if elapsed >= UPDATE_INTERVAL then
		local passed = elapsed
		elapsed = 0
		update(passed)
		updateTooltip()
	end
end)

print("[MiniMap] Loaded!")
]]></string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="70">
        <Properties>
          <string name="Name">NPCDialogUI</string>
          <string name="Source"><![CDATA[--[[
	NPCDialogUI.client.lua
	StarterPlayerScripts

	Shows a dialog box when the player clicks an NPC.
	Typewriter text effect, quest info, shop buttons.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

--------------------------------------------------------------------------------
-- WAIT FOR REMOTE
--------------------------------------------------------------------------------
local NPCInteractEvent = ReplicatedStorage:WaitForChild("NPCInteract", 30)
if not NPCInteractEvent then
	warn("[NPCDialogUI] NPCInteract event not found")
	return
end

--------------------------------------------------------------------------------
-- NPC DIALOG DATA
--------------------------------------------------------------------------------
local NPC_DIALOGS = {
	["Captain Aldric"] = {
		greeting = "Welcome to Haven, stranger. The world beyond these walls isn't kind. But I see something in you... perhaps you can help us.",
		npcType = "quest",
	},
	["Mara the Merchant"] = {
		greeting = "Looking to buy or sell? I've got a bit of everything!",
		npcType = "shop",
		shopType = "general",
	},
	["Grimnir the Smith"] = {
		greeting = "See this arm? Gone. Lost it to a dragon ten years back. But I can still forge better than any two-armed smith in the kingdom.",
		npcType = "shop",
		shopType = "weapons",
	},
	["Old Bess"] = {
		greeting = "Sit down, dear. You look hungry. I've got stew, bread, and something stronger if you need it.",
		npcType = "shop",
		shopType = "food",
	},
	["Brother Elden"] = {
		greeting = "The Light protects Haven... for now. But the darkness grows bolder each day. Perhaps you can help stem the tide.",
		npcType = "quest",
	},
	["Finnick the Fletcher"] = {
		greeting = "Best bows in Haven! Well... only bows in Haven. But they're still pretty good!",
		npcType = "shop",
		shopType = "ranged",
	},
	["Scout Wren"] = {
		greeting = "I watch the Wilderness from up here. It's getting worse. The undead are restless, and I've seen bandit patrols doubling.",
		npcType = "quest",
	},
	["Grave Keeper Morath"] = {
		greeting = "They won't stay buried... I've been keeper here for forty years, and I've never seen the dead so restless.",
		npcType = "quest",
	},
	["Witch Thessaly"] = {
		greeting = "You dare enter my forest? Hmm... you smell of Haven. Desperate, are we?",
		npcType = "quest",
	},
	["Bandit King Rask"] = {
		greeting = "Another hero? How boring. But wait... maybe we can make a deal instead.",
		npcType = "quest",
	},
	["The Oracle"] = {
		greeting = "I see beyond sight. You carry a heavy fate, adventurer. Three paths lie before you, and none are easy.",
		npcType = "quest",
	},
	["Ghost of Sir Aldren"] = {
		greeting = "I failed... the dragon consumed me, and my blade shattered. But you... you might succeed where I did not.",
		npcType = "quest",
	},
	["Ferryman Charon"] = {
		greeting = "100 coins to cross. No refunds. The waters are dark and deep, and what lies beyond... well, that's your problem.",
		npcType = "quest",
	},
	["Dragon Priestess Lyra"] = {
		greeting = "The dragon stirs beneath the mountain. Can you feel it? The ground trembles with each breath it takes.",
		npcType = "quest",
	},
}

--------------------------------------------------------------------------------
-- UI CREATION
--------------------------------------------------------------------------------
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "NPCDialogGui"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

-- Main dialog frame
local dialogFrame = Instance.new("Frame")
dialogFrame.Name = "DialogFrame"
dialogFrame.Size = UDim2.new(0.5, 0, 0.3, 0)
dialogFrame.Position = UDim2.new(0.25, 0, 0.65, 0)
dialogFrame.BackgroundColor3 = Color3.fromRGB(26, 26, 46)
dialogFrame.BorderSizePixel = 0
dialogFrame.Visible = false
dialogFrame.Parent = screenGui

-- Gold border via UIStroke
local stroke = Instance.new("UIStroke")
stroke.Color = Color3.fromRGB(255, 215, 0)
stroke.Thickness = 2
stroke.Parent = dialogFrame

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = dialogFrame

-- NPC name label
local npcNameLabel = Instance.new("TextLabel")
npcNameLabel.Name = "NPCName"
npcNameLabel.Size = UDim2.new(0.8, 0, 0.15, 0)
npcNameLabel.Position = UDim2.new(0.1, 0, 0.02, 0)
npcNameLabel.BackgroundTransparency = 1
npcNameLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
npcNameLabel.TextScaled = true
npcNameLabel.Font = Enum.Font.GothamBold
npcNameLabel.Text = ""
npcNameLabel.Parent = dialogFrame

-- Dialog text
local dialogText = Instance.new("TextLabel")
dialogText.Name = "DialogText"
dialogText.Size = UDim2.new(0.9, 0, 0.45, 0)
dialogText.Position = UDim2.new(0.05, 0, 0.18, 0)
dialogText.BackgroundTransparency = 1
dialogText.TextColor3 = Color3.fromRGB(220, 220, 220)
dialogText.TextScaled = false
dialogText.TextSize = 16
dialogText.TextWrapped = true
dialogText.TextXAlignment = Enum.TextXAlignment.Left
dialogText.TextYAlignment = Enum.TextYAlignment.Top
dialogText.Font = Enum.Font.Gotham
dialogText.Text = ""
dialogText.Parent = dialogFrame

-- Button container
local buttonFrame = Instance.new("Frame")
buttonFrame.Name = "Buttons"
buttonFrame.Size = UDim2.new(0.9, 0, 0.25, 0)
buttonFrame.Position = UDim2.new(0.05, 0, 0.7, 0)
buttonFrame.BackgroundTransparency = 1
buttonFrame.Parent = dialogFrame

local buttonLayout = Instance.new("UIListLayout")
buttonLayout.FillDirection = Enum.FillDirection.Horizontal
buttonLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
buttonLayout.Padding = UDim.new(0, 10)
buttonLayout.Parent = buttonFrame

-- Close button (always present, top right)
local closeBtn = Instance.new("TextButton")
closeBtn.Name = "CloseBtn"
closeBtn.Size = UDim2.new(0, 30, 0, 30)
closeBtn.Position = UDim2.new(1, -35, 0, 5)
closeBtn.BackgroundColor3 = Color3.fromRGB(150, 30, 30)
closeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
closeBtn.Text = "X"
closeBtn.TextScaled = true
closeBtn.Font = Enum.Font.GothamBold
closeBtn.Parent = dialogFrame

local closeCorner = Instance.new("UICorner")
closeCorner.CornerRadius = UDim.new(0, 4)
closeCorner.Parent = closeBtn

--------------------------------------------------------------------------------
-- HELPERS
--------------------------------------------------------------------------------
local currentTypingThread = nil

local function clearButtons()
	for _, child in buttonFrame:GetChildren() do
		if child:IsA("TextButton") then
			child:Destroy()
		end
	end
end

local function makeButton(text, callback)
	local btn = Instance.new("TextButton")
	btn.Size = UDim2.new(0, 120, 1, 0)
	btn.BackgroundColor3 = Color3.fromRGB(40, 40, 70)
	btn.TextColor3 = Color3.fromRGB(255, 215, 0)
	btn.Text = text
	btn.TextScaled = true
	btn.Font = Enum.Font.GothamBold
	btn.Parent = buttonFrame

	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 4)
	btnCorner.Parent = btn

	local btnStroke = Instance.new("UIStroke")
	btnStroke.Color = Color3.fromRGB(255, 215, 0)
	btnStroke.Thickness = 1
	btnStroke.Parent = btn

	btn.MouseButton1Click:Connect(callback)
	return btn
end

local function typeText(label, fullText, speed)
	speed = speed or 0.03
	if currentTypingThread then
		task.cancel(currentTypingThread)
	end
	label.Text = ""
	currentTypingThread = task.spawn(function()
		for i = 1, #fullText do
			label.Text = string.sub(fullText, 1, i)
			task.wait(speed)
		end
		currentTypingThread = nil
	end)
end

local function closeDialog()
	dialogFrame.Visible = false
	dialogText.Text = ""
	npcNameLabel.Text = ""
	clearButtons()
	if currentTypingThread then
		task.cancel(currentTypingThread)
		currentTypingThread = nil
	end
end

closeBtn.MouseButton1Click:Connect(closeDialog)

--------------------------------------------------------------------------------
-- SHOP UI (simple overlay)
--------------------------------------------------------------------------------
local SHOP_ITEMS = {
	general = {
		{name = "Bread", price = 10},
		{name = "Rope", price = 25},
		{name = "Torch", price = 15},
		{name = "Bandage", price = 20},
		{name = "Map Fragment", price = 50},
		{name = "Bronze Pickaxe", price = 50},
		{name = "Bronze Axe", price = 50},
		{name = "Wooden Rod", price = 50},
	},
	tools = {
		{name = "Bronze Pickaxe", price = 50},
		{name = "Iron Pickaxe", price = 250},
		{name = "Gold Pickaxe", price = 1000},
		{name = "Runite Pickaxe", price = 5000},
		{name = "Bronze Axe", price = 50},
		{name = "Iron Axe", price = 250},
		{name = "Gold Axe", price = 1000},
		{name = "Runite Axe", price = 5000},
		{name = "Wooden Rod", price = 50},
		{name = "Iron Rod", price = 250},
		{name = "Gold Rod", price = 1000},
		{name = "Runite Rod", price = 5000},
	},
	weapons = {
		{name = "Copper Sword", price = 100},
		{name = "Iron Sword", price = 500},
		{name = "Steel Sword", price = 2000},
		{name = "Bronze Helmet", price = 75},
		{name = "Iron Helmet", price = 400},
		{name = "Iron Pickaxe", price = 250},
		{name = "Iron Axe", price = 250},
		{name = "Gold Pickaxe", price = 1000},
		{name = "Gold Axe", price = 1000},
		{name = "Runite Pickaxe", price = 5000},
		{name = "Runite Axe", price = 5000},
	},
	food = {
		{name = "Stew", price = 15},
		{name = "Bread", price = 10},
		{name = "Cooked Shrimp", price = 20},
		{name = "Cooked Trout", price = 40},
		{name = "Ale", price = 5},
	},
	ranged = {
		{name = "Shortbow", price = 80},
		{name = "Longbow", price = 300},
		{name = "Bronze Arrows x20", price = 40},
		{name = "Iron Arrows x20", price = 100},
		{name = "Crossbow", price = 600},
	},
}

local function openShop(shopType)
	clearButtons()
	local items = SHOP_ITEMS[shopType] or SHOP_ITEMS.general
	dialogText.Text = ""

	local text = "--- SHOP ---\n"
	for _, item in items do
		text = text .. item.name .. " - " .. item.price .. " gold\n"
	end
	text = text .. "\n(Shop purchases coming soon!)"
	dialogText.Text = text

	makeButton("Close", closeDialog)
end

--------------------------------------------------------------------------------
-- NPC INTERACTION HANDLER
--------------------------------------------------------------------------------
NPCInteractEvent.OnClientEvent:Connect(function(npcName)
	local data = NPC_DIALOGS[npcName]
	if not data then
		data = {greeting = "...", npcType = "none"}
	end

	dialogFrame.Visible = true
	npcNameLabel.Text = npcName
	clearButtons()

	typeText(dialogText, data.greeting)

	if data.npcType == "shop" then
		makeButton("Shop", function()
			openShop(data.shopType or "general")
		end)
		makeButton("Close", closeDialog)
	elseif data.npcType == "quest" then
		makeButton("Quests", function()
			clearButtons()
			dialogText.Text = "Quest system active! Check your quest log for available quests from " .. npcName .. "."
			makeButton("Close", closeDialog)
		end)
		makeButton("Close", closeDialog)
	else
		makeButton("Close", closeDialog)
	end
end)

print("[NPCDialogUI] Initialized")
]]></string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="71">
        <Properties>
          <string name="Name">PrayerUI</string>
          <string name="Source">--[[
	PrayerUI.client.lua
	COMPLETE OVERHAUL: Visual skill tree with 30 prayers in 4 tiers
	3 branching paths: Warrior (left), Protector (center), Ranger (right)
	Toggle with P key, full-screen overlay
]]

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[PrayerUI] Starting new visual skill tree...")

-- Remotes
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local toggleEvent = Remotes:WaitForChild("TogglePrayer")
local updateEvent = Remotes:WaitForChild("PrayerUpdate")
local getDataFunc = Remotes:WaitForChild("GetPrayerData")

-- Colors (Dark medieval theme)
local BG_COLOR = Color3.fromRGB(15, 15, 25)
local GOLD = Color3.fromRGB(240, 192, 64)
local DARK_GOLD = Color3.fromRGB(120, 96, 32)
local WHITE = Color3.fromRGB(255, 255, 255)
local GREEN = Color3.fromRGB(0, 255, 0)
local RED = Color3.fromRGB(255, 100, 100)
local LOCKED_COLOR = Color3.fromRGB(60, 60, 60)
local ACTIVE_COLOR = Color3.fromRGB(0, 255, 0)
local AVAILABLE_COLOR = Color3.fromRGB(240, 192, 64)

-- Prayer tree layout - positioned in 3 columns with tiers as rows
local PRAYER_POSITIONS = {
	-- TIER 1 - Novice (Level 1-15)
	[1] = {x = 0.25, y = 0.15}, -- Thick Skin (Protector)
	[2] = {x = 0.15, y = 0.15}, -- Burst of Strength (Warrior)  
	[3] = {x = 0.35, y = 0.15}, -- Sharp Eye (Ranger)
	[4] = {x = 0.25, y = 0.22}, -- Rock Skin (Protector)
	[5] = {x = 0.15, y = 0.22}, -- Clarity of Thought (Warrior)
	[6] = {x = 0.35, y = 0.22}, -- Mystic Will (Ranger)
	
	-- TIER 2 - Acolyte (Level 16-35)
	[7] = {x = 0.15, y = 0.35}, -- Superhuman Strength (Warrior)
	[8] = {x = 0.25, y = 0.35}, -- Improved Reflexes (Protector)
	[9] = {x = 0.35, y = 0.35}, -- Hawk Eye (Ranger)
	[10] = {x = 0.25, y = 0.42}, -- Steel Skin (Protector)
	[11] = {x = 0.15, y = 0.42}, -- Ultimate Strength (Warrior)
	[12] = {x = 0.35, y = 0.42}, -- Eagle Eye (Ranger)
	[13] = {x = 0.22, y = 0.48}, -- Rapid Heal (Protector)
	[14] = {x = 0.28, y = 0.48}, -- Rapid Restore (Protector)
	
	-- TIER 3 - Priest (Level 36-60)
	[15] = {x = 0.20, y = 0.60}, -- Protect from Melee (Protector)
	[16] = {x = 0.25, y = 0.58}, -- Protect from Ranged (Protector)
	[17] = {x = 0.30, y = 0.60}, -- Protect from Magic (Protector)
	[18] = {x = 0.12, y = 0.62}, -- Retribution (Warrior)
	[19] = {x = 0.25, y = 0.67}, -- Redemption (Protector)
	[20] = {x = 0.15, y = 0.70}, -- Smite (Warrior)
	[21] = {x = 0.10, y = 0.75}, -- Holy Strength (Warrior)
	[22] = {x = 0.38, y = 0.62}, -- Divine Aim (Ranger)
	
	-- TIER 4 - High Priest (Level 61-99)
	[23] = {x = 0.12, y = 0.82}, -- Chivalry (Warrior)
	[24] = {x = 0.08, y = 0.88}, -- Piety (Warrior)
	[25] = {x = 0.40, y = 0.75}, -- Rigour (Ranger)
	[26] = {x = 0.42, y = 0.82}, -- Augury (Ranger)
	[27] = {x = 0.28, y = 0.82}, -- Soul Split (Protector)
	[28] = {x = 0.05, y = 0.94}, -- Turmoil (Warrior)
	[29] = {x = 0.02, y = 0.99}, -- Wrath (Warrior)
	[30] = {x = 0.32, y = 0.94}, -- Divine Shield (Protector)
}

-- Prayer icons (emojis for each prayer)
local PRAYER_ICONS = {
	[1] = "üõ°Ô∏è", [2] = "üí™", [3] = "üéØ", [4] = "ü™®", [5] = "üß†", [6] = "‚ú®",
	[7] = "üî•", [8] = "‚ö°", [9] = "ü¶Ö", [10] = "‚öôÔ∏è", [11] = "‚öîÔ∏è", [12] = "üëÅÔ∏è",
	[13] = "‚ù§Ô∏è", [14] = "üíô", [15] = "üõ°Ô∏è", [16] = "üèπ", [17] = "üîÆ", [18] = "üíÄ",
	[19] = "üôè", [20] = "‚ö°", [21] = "üëº", [22] = "üéØ", [23] = "üëë", [24] = "‚ú®",
	[25] = "üèπ", [26] = "üåü", [27] = "üëª", [28] = "‚ö´", [29] = "üí•", [30] = "üõ°Ô∏è"
}

-- State
local isOpen = false
local prayerData = {}
local prayerNodes = {}
local connectionLines = {}

-----------------------------------------------------------------------
-- CREATE MAIN UI
-----------------------------------------------------------------------
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "PrayerTreeUI"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

-- Main frame (full screen overlay)
local mainFrame = Instance.new("Frame")
mainFrame.Name = "PrayerTree"
mainFrame.Size = UDim2.new(1, 0, 1, 0)
mainFrame.Position = UDim2.new(0, 0, 0, 0)
mainFrame.BackgroundColor3 = BG_COLOR
mainFrame.BackgroundTransparency = 0.1
mainFrame.Visible = false
mainFrame.Parent = screenGui

-- Background pattern
local bgPattern = Instance.new("ImageLabel")
bgPattern.Size = UDim2.new(1, 0, 1, 0)
bgPattern.BackgroundTransparency = 1
bgPattern.ImageTransparency = 0.9
bgPattern.ScaleType = Enum.ScaleType.Tile
bgPattern.TileSize = UDim2.new(0, 100, 0, 100)
bgPattern.Parent = mainFrame

-- Title
local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(0, 400, 0, 50)
titleLabel.Position = UDim2.new(0.5, -200, 0, 20)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "Prayer Skill Tree"
titleLabel.TextSize = 36
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextColor3 = GOLD
titleLabel.Parent = mainFrame

-- Prayer Points bar
local ppFrame = Instance.new("Frame")
ppFrame.Size = UDim2.new(0, 300, 0, 30)
ppFrame.Position = UDim2.new(0.5, -150, 0, 80)
ppFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
ppFrame.Parent = mainFrame

local ppCorner = Instance.new("UICorner")
ppCorner.CornerRadius = UDim.new(0, 6)
ppCorner.Parent = ppFrame

local ppBar = Instance.new("Frame")
ppBar.Name = "PPBar"
ppBar.Size = UDim2.new(1, 0, 1, 0)
ppBar.Position = UDim2.new(0, 0, 0, 0)
ppBar.BackgroundColor3 = GOLD
ppBar.Parent = ppFrame

local ppBarCorner = Instance.new("UICorner")
ppBarCorner.CornerRadius = UDim.new(0, 6)
ppBarCorner.Parent = ppBar

local ppLabel = Instance.new("TextLabel")
ppLabel.Size = UDim2.new(1, 0, 1, 0)
ppLabel.BackgroundTransparency = 1
ppLabel.Text = "Prayer Points: 100 / 100"
ppLabel.TextSize = 14
ppLabel.Font = Enum.Font.GothamBold
ppLabel.TextColor3 = WHITE
ppLabel.ZIndex = 2
ppLabel.Parent = ppFrame

-- PP drain rate display
local drainLabel = Instance.new("TextLabel")
drainLabel.Size = UDim2.new(0, 250, 0, 20)
drainLabel.Position = UDim2.new(0.5, -125, 0, 115)
drainLabel.BackgroundTransparency = 1
drainLabel.Text = "PP Drain: 0 / minute"
drainLabel.TextSize = 12
drainLabel.Font = Enum.Font.Gotham
drainLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
drainLabel.Parent = mainFrame

-- Branch labels
local branchLabels = {
	{text = "WARRIOR", pos = UDim2.new(0.15, -50, 0, 140), color = Color3.fromRGB(220, 20, 60)},
	{text = "PROTECTOR", pos = UDim2.new(0.25, -50, 0, 140), color = Color3.fromRGB(70, 130, 180)},
	{text = "RANGER", pos = UDim2.new(0.35, -50, 0, 140), color = Color3.fromRGB(34, 139, 34)},
}

for _, branch in ipairs(branchLabels) do
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(0, 100, 0, 25)
	label.Position = branch.pos
	label.BackgroundTransparency = 1
	label.Text = branch.text
	label.TextSize = 14
	label.Font = Enum.Font.GothamBold
	label.TextColor3 = branch.color
	label.Parent = mainFrame
end

-- Close button
local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, 40, 0, 40)
closeBtn.Position = UDim2.new(1, -50, 0, 10)
closeBtn.BackgroundColor3 = Color3.fromRGB(180, 50, 50)
closeBtn.Text = "X"
closeBtn.TextSize = 24
closeBtn.Font = Enum.Font.GothamBold
closeBtn.TextColor3 = WHITE
closeBtn.Parent = mainFrame

local closeBtnCorner = Instance.new("UICorner")
closeBtnCorner.CornerRadius = UDim.new(0, 8)
closeBtnCorner.Parent = closeBtn

-----------------------------------------------------------------------
-- CREATE PRAYER NODES
-----------------------------------------------------------------------
local function createPrayerNode(prayerId)
	local pos = PRAYER_POSITIONS[prayerId]
	if not pos then return end
	
	local nodeFrame = Instance.new("Frame")
	nodeFrame.Size = UDim2.new(0, 80, 0, 80)
	nodeFrame.Position = UDim2.new(pos.x, -40, pos.y, -40)
	nodeFrame.BackgroundColor3 = LOCKED_COLOR
	nodeFrame.Parent = mainFrame
	
	local nodeCorner = Instance.new("UICorner")
	nodeCorner.CornerRadius = UDim.new(0, 12)
	nodeCorner.Parent = nodeFrame
	
	local nodeStroke = Instance.new("UIStroke")
	nodeStroke.Name = "NodeStroke"
	nodeStroke.Color = LOCKED_COLOR
	nodeStroke.Thickness = 3
	nodeStroke.Parent = nodeFrame
	
	-- Prayer icon
	local iconLabel = Instance.new("TextLabel")
	iconLabel.Size = UDim2.new(1, 0, 0, 32)
	iconLabel.Position = UDim2.new(0, 0, 0, 8)
	iconLabel.BackgroundTransparency = 1
	iconLabel.Text = PRAYER_ICONS[prayerId] or "üîí"
	iconLabel.TextSize = 28
	iconLabel.Font = Enum.Font.GothamBold
	iconLabel.TextColor3 = LOCKED_COLOR
	iconLabel.Parent = nodeFrame
	
	-- Prayer name
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(1, -4, 0, 20)
	nameLabel.Position = UDim2.new(0, 2, 0, 42)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = "Locked"
	nameLabel.TextSize = 8
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.TextColor3 = LOCKED_COLOR
	nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
	nameLabel.Parent = nodeFrame
	
	-- Level requirement
	local levelLabel = Instance.new("TextLabel")
	levelLabel.Size = UDim2.new(1, 0, 0, 14)
	levelLabel.Position = UDim2.new(0, 0, 1, -16)
	levelLabel.BackgroundTransparency = 1
	levelLabel.Text = "Lv. ?"
	levelLabel.TextSize = 10
	levelLabel.Font = Enum.Font.Gotham
	levelLabel.TextColor3 = LOCKED_COLOR
	levelLabel.Parent = nodeFrame
	
	-- Click button
	local clickBtn = Instance.new("TextButton")
	clickBtn.Size = UDim2.new(1, 0, 1, 0)
	clickBtn.BackgroundTransparency = 1
	clickBtn.Text = ""
	clickBtn.Parent = nodeFrame
	
	-- Glowing effect for active prayers
	local glowEffect = Instance.new("Frame")
	glowEffect.Name = "Glow"
	glowEffect.Size = UDim2.new(1, 20, 1, 20)
	glowEffect.Position = UDim2.new(0, -10, 0, -10)
	glowEffect.BackgroundColor3 = ACTIVE_COLOR
	glowEffect.BackgroundTransparency = 0.7
	glowEffect.Visible = false
	glowEffect.ZIndex = 0
	glowEffect.Parent = nodeFrame
	
	local glowCorner = Instance.new("UICorner")
	glowCorner.CornerRadius = UDim.new(0, 16)
	glowCorner.Parent = glowEffect
	
	-- Store references
	prayerNodes[prayerId] = {
		frame = nodeFrame,
		icon = iconLabel,
		name = nameLabel,
		level = levelLabel,
		button = clickBtn,
		stroke = nodeStroke,
		glow = glowEffect
	}
	
	-- Click handler
	clickBtn.MouseButton1Click:Connect(function()
		onPrayerClick(prayerId)
	end)
	
	return nodeFrame
end

-- Create all prayer nodes
for i = 1, 30 do
	createPrayerNode(i)
end

-----------------------------------------------------------------------
-- CONNECTION LINES (showing prerequisites)
-----------------------------------------------------------------------
local function drawConnectionLine(fromId, toId)
	local fromPos = PRAYER_POSITIONS[fromId]
	local toPos = PRAYER_POSITIONS[toId]
	if not fromPos or not toPos then return end
	
	-- Calculate line properties
	local startX = fromPos.x
	local startY = fromPos.y
	local endX = toPos.x
	local endY = toPos.y
	
	local deltaX = endX - startX
	local deltaY = endY - startY
	local distance = math.sqrt(deltaX^2 + deltaY^2)
	local angle = math.atan2(deltaY, deltaX)
	
	-- Create line
	local line = Instance.new("Frame")
	line.Size = UDim2.new(0, distance * 1000, 0, 2) -- Scale by screen size
	line.Position = UDim2.new(startX, 0, startY, -1)
	line.Rotation = math.deg(angle)
	line.BackgroundColor3 = DARK_GOLD
	line.BorderSizePixel = 0
	line.ZIndex = 0
	line.Parent = mainFrame
	
	connectionLines[fromId] = connectionLines[fromId] or {}
	table.insert(connectionLines[fromId], line)
end

-- Draw prerequisite connections (this would be based on the prayer prereq data)
-- For now, drawing some key connections manually
drawConnectionLine(1, 4)  -- Thick Skin -> Rock Skin
drawConnectionLine(2, 5)  -- Burst of Strength -> Clarity of Thought
drawConnectionLine(3, 6)  -- Sharp Eye -> Mystic Will
drawConnectionLine(4, 8)  -- Rock Skin -> Improved Reflexes
drawConnectionLine(2, 7)  -- Burst of Strength -> Superhuman Strength
drawConnectionLine(3, 9)  -- Sharp Eye -> Hawk Eye
drawConnectionLine(8, 10) -- Improved Reflexes -> Steel Skin
drawConnectionLine(7, 11) -- Superhuman Strength -> Ultimate Strength
drawConnectionLine(9, 12) -- Hawk Eye -> Eagle Eye

-----------------------------------------------------------------------
-- PRAYER INTERACTION
-----------------------------------------------------------------------
local function onPrayerClick(prayerId)
	if not prayerData.prayers or not prayerData.prayers[prayerId] then return end
	
	local prayer = prayerData.prayers[prayerId]
	if not prayer.canUse then
		print("[PrayerUI] Cannot use prayer:", prayer.name)
		return
	end
	
	-- Toggle the prayer
	toggleEvent:FireServer(prayerId)
end

-----------------------------------------------------------------------
-- UPDATE DISPLAY
-----------------------------------------------------------------------
local function updatePrayerDisplay()
	if not prayerData.prayers then return end
	
	-- Update PP bar
	local currentPP = prayerData.currentPP or 0
	local maxPP = prayerData.maxPP or 1
	local ppPercent = currentPP / maxPP
	
	ppBar.Size = UDim2.new(ppPercent, 0, 1, 0)
	ppLabel.Text = "Prayer Points: " .. currentPP .. " / " .. maxPP
	
	-- Update drain rate
	drainLabel.Text = "PP Drain: " .. (prayerData.ppDrainRate or 0) .. " / minute"
	
	-- Update each prayer node
	for prayerId, prayer in pairs(prayerData.prayers) do
		local node = prayerNodes[prayerId]
		if node then
			-- Set colors and text based on prayer state
			if prayer.active then
				-- Active prayer
				node.frame.BackgroundColor3 = ACTIVE_COLOR
				node.stroke.Color = ACTIVE_COLOR
				node.icon.TextColor3 = WHITE
				node.name.TextColor3 = WHITE
				node.level.TextColor3 = WHITE
				node.glow.Visible = true
				
				-- Animate glow
				local tween = TweenService:Create(node.glow, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {
					BackgroundTransparency = 0.3
				})
				tween:Play()
			elseif prayer.canUse then
				-- Available prayer
				node.frame.BackgroundColor3 = AVAILABLE_COLOR
				node.stroke.Color = AVAILABLE_COLOR
				node.icon.TextColor3 = WHITE
				node.name.TextColor3 = WHITE
				node.level.TextColor3 = WHITE
				node.glow.Visible = false
			else
				-- Locked prayer
				node.frame.BackgroundColor3 = LOCKED_COLOR
				node.stroke.Color = LOCKED_COLOR
				node.icon.TextColor3 = LOCKED_COLOR
				node.name.TextColor3 = LOCKED_COLOR
				node.level.TextColor3 = LOCKED_COLOR
				node.glow.Visible = false
			end
			
			-- Set text
			node.name.Text = prayer.name
			node.level.Text = "Lv. " .. prayer.level
			node.icon.Text = PRAYER_ICONS[prayerId] or (prayer.canUse and "‚ú®" or "üîí")
		end
	end
end

-----------------------------------------------------------------------
-- TOOLTIP SYSTEM
-----------------------------------------------------------------------
local tooltip = Instance.new("Frame")
tooltip.Name = "Tooltip"
tooltip.Size = UDim2.new(0, 200, 0, 120)
tooltip.BackgroundColor3 = Color3.fromRGB(20, 20, 35)
tooltip.BackgroundTransparency = 0.1
tooltip.Visible = false
tooltip.ZIndex = 100
tooltip.Parent = screenGui

local tooltipCorner = Instance.new("UICorner")
tooltipCorner.CornerRadius = UDim.new(0, 8)
tooltipCorner.Parent = tooltip

local tooltipStroke = Instance.new("UIStroke")
tooltipStroke.Color = GOLD
tooltipStroke.Thickness = 2
tooltipStroke.Parent = tooltip

local tooltipPadding = Instance.new("UIPadding")
tooltipPadding.PaddingLeft = UDim.new(0, 8)
tooltipPadding.PaddingRight = UDim.new(0, 8)
tooltipPadding.PaddingTop = UDim.new(0, 6)
tooltipPadding.PaddingBottom = UDim.new(0, 6)
tooltipPadding.Parent = tooltip

local tooltipName = Instance.new("TextLabel")
tooltipName.Size = UDim2.new(1, 0, 0, 20)
tooltipName.BackgroundTransparency = 1
tooltipName.Text = "Prayer Name"
tooltipName.TextSize = 14
tooltipName.Font = Enum.Font.GothamBold
tooltipName.TextColor3 = GOLD
tooltipName.TextXAlignment = Enum.TextXAlignment.Left
tooltipName.ZIndex = 101
tooltipName.Parent = tooltip

local tooltipLevel = Instance.new("TextLabel")
tooltipLevel.Size = UDim2.new(1, 0, 0, 16)
tooltipLevel.Position = UDim2.new(0, 0, 0, 22)
tooltipLevel.BackgroundTransparency = 1
tooltipLevel.Text = "Level: 1"
tooltipLevel.TextSize = 12
tooltipLevel.Font = Enum.Font.Gotham
tooltipLevel.TextColor3 = WHITE
tooltipLevel.TextXAlignment = Enum.TextXAlignment.Left
tooltipLevel.ZIndex = 101
tooltipLevel.Parent = tooltip

local tooltipDesc = Instance.new("TextLabel")
tooltipDesc.Size = UDim2.new(1, 0, 0, 40)
tooltipDesc.Position = UDim2.new(0, 0, 0, 40)
tooltipDesc.BackgroundTransparency = 1
tooltipDesc.Text = "Effect description"
tooltipDesc.TextSize = 11
tooltipDesc.Font = Enum.Font.Gotham
tooltipDesc.TextColor3 = Color3.fromRGB(200, 200, 200)
tooltipDesc.TextXAlignment = Enum.TextXAlignment.Left
tooltipDesc.TextWrapped = true
tooltipDesc.ZIndex = 101
tooltipDesc.Parent = tooltip

local tooltipCost = Instance.new("TextLabel")
tooltipCost.Size = UDim2.new(1, 0, 0, 16)
tooltipCost.Position = UDim2.new(0, 0, 1, -18)
tooltipCost.BackgroundTransparency = 1
tooltipCost.Text = "PP Cost: 1 / min"
tooltipCost.TextSize = 10
tooltipCost.Font = Enum.Font.GothamBold
tooltipCost.TextColor3 = Color3.fromRGB(255, 200, 100)
tooltipCost.TextXAlignment = Enum.TextXAlignment.Left
tooltipCost.ZIndex = 101
tooltipCost.Parent = tooltip

-- Tooltip handlers
for prayerId, node in pairs(prayerNodes) do
	node.button.MouseEnter:Connect(function()
		if not prayerData.prayers or not prayerData.prayers[prayerId] then return end
		
		local prayer = prayerData.prayers[prayerId]
		tooltipName.Text = prayer.name
		tooltipLevel.Text = "Level: " .. prayer.level
		tooltipDesc.Text = prayer.description
		tooltipCost.Text = "PP Cost: " .. prayer.ppRate .. " / min"
		
		-- Position tooltip
		local nodePos = node.frame.AbsolutePosition
		tooltip.Position = UDim2.fromOffset(nodePos.X + 90, nodePos.Y - 60)
		tooltip.Visible = true
	end)
	
	node.button.MouseLeave:Connect(function()
		tooltip.Visible = false
	end)
end

-----------------------------------------------------------------------
-- UI CONTROL
-----------------------------------------------------------------------
local function toggleUI()
	isOpen = not isOpen
	mainFrame.Visible = isOpen
	
	if isOpen then
		-- Refresh data when opening
		refreshPrayerData()
	end
end

local function refreshPrayerData()
	local success, data = pcall(function()
		return getDataFunc:InvokeServer()
	end)
	
	if success and data then
		prayerData = data
		updatePrayerDisplay()
	else
		warn("[PrayerUI] Failed to get prayer data")
	end
end

-- Input handling
UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end
	
	if input.KeyCode == Enum.KeyCode.P then
		toggleUI()
	end
end)

-- Close button
closeBtn.MouseButton1Click:Connect(function()
	toggleUI()
end)

-- Listen for prayer updates
updateEvent.OnClientEvent:Connect(function()
	if isOpen then
		refreshPrayerData()
	end
end)

-----------------------------------------------------------------------
-- INITIALIZATION
-----------------------------------------------------------------------
task.spawn(function()
	task.wait(3) -- Wait for other systems to initialize
	refreshPrayerData()
	print("[PrayerUI] New visual skill tree ready! Press P to open.")
end)</string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="72">
        <Properties>
          <string name="Name">QuestUI</string>
          <string name="Source"><![CDATA[--[[
	QuestUI.client.lua
	Full quest journal/tracker UI for Roscape Runeblocks.
	Press J to toggle. Dark medieval theme with gold accents.
]]

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Require QuestDatabase
local QuestDatabase
do
	local ok, result = pcall(function()
		return require(game.ReplicatedStorage.Modules.QuestDatabase)
	end)
	if ok then
		QuestDatabase = result
	else
		warn("[QuestUI] Failed to load QuestDatabase:", result)
		QuestDatabase = { Quests = {}, ById = {} }
	end
end

------------------------------------------------------------
-- Theme
------------------------------------------------------------
local C = {
	bg        = Color3.fromHex("#1a1a2e"),
	bgDark    = Color3.fromHex("#0f0f23"),
	bgLight   = Color3.fromHex("#16213e"),
	gold      = Color3.fromHex("#f0c040"),
	goldDim   = Color3.fromHex("#a08030"),
	text      = Color3.fromHex("#e0e0e0"),
	textDim   = Color3.fromHex("#888899"),
	green     = Color3.fromHex("#40c060"),
	red       = Color3.fromHex("#c04040"),
	locked    = Color3.fromHex("#555566"),
}

local TWEEN_OPEN = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
local TWEEN_CLOSE = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In)

------------------------------------------------------------
-- State
------------------------------------------------------------
local isOpen = false
local selectedQuestId = nil
local playerLevel = 1 -- placeholder, would come from server

-- Mock progress: first quest active, none completed
local questProgress = {
	activeQuest = "quest_01",
	completedQuests = {},
	questProgress = {},
}

-- Try to get real progress from server
local getProgressRemote = ReplicatedStorage:FindFirstChild("GetQuestProgress")
if getProgressRemote and getProgressRemote:IsA("RemoteFunction") then
	local ok, result = pcall(function()
		return getProgressRemote:InvokeServer()
	end)
	if ok and result then
		questProgress = result
	end
end

-- Try to get player level
local getStatsRemote = ReplicatedStorage:FindFirstChild("GetStatsPanel")
if getStatsRemote and getStatsRemote:IsA("RemoteFunction") then
	local ok, result = pcall(function()
		return getStatsRemote:InvokeServer()
	end)
	if ok and result and result.level then
		playerLevel = result.level
	end
end

------------------------------------------------------------
-- Helpers
------------------------------------------------------------
local function clearChildren(parent)
	for _, child in parent:GetChildren() do
		if not child:IsA("UIListLayout") and not child:IsA("UIPadding") and not child:IsA("UICorner") and not child:IsA("UIGridLayout") then
			child:Destroy()
		end
	end
end

local function getQuestStatus(quest)
	-- Check completed
	for _, cid in questProgress.completedQuests do
		if cid == quest.id then
			return "completed"
		end
	end
	-- Check active
	if questProgress.activeQuest == quest.id then
		return "active"
	end
	-- Check level lock
	if quest.level > playerLevel then
		return "locked"
	end
	return "available"
end

local function getStatusIcon(status)
	if status == "completed" then return "‚úÖ" end
	if status == "active" then return "üü¢" end
	if status == "locked" then return "üîí" end
	return "‚≠ê"
end

local function getStatusColor(status)
	if status == "completed" then return C.green end
	if status == "active" then return C.green end
	if status == "locked" then return C.locked end
	return C.gold
end

local function getObjectiveProgress(questId, objIndex)
	local qp = questProgress.questProgress[questId]
	if qp and qp[objIndex] then
		return qp[objIndex]
	end
	return { current = 0, done = false }
end

local function getObjectiveDescription(obj)
	if obj.label then
		return obj.label
	end
	local target = obj.target or obj.item or obj.npc or obj.location or ""
	if obj.type == "kill" then
		return "Kill " .. target
	elseif obj.type == "gather" then
		return "Gather " .. target
	elseif obj.type == "talk" then
		return "Talk to " .. target
	elseif obj.type == "visit" or obj.type == "travel" then
		return "Go to " .. (obj.location or target)
	elseif obj.type == "pay" then
		return "Pay " .. tostring(obj.amount or 0) .. " Gold"
	elseif obj.type == "interact" then
		return "Use " .. target
	elseif obj.type == "choice" then
		return obj.label or "Make a choice"
	end
	return obj.type .. ": " .. target
end

local function getObjectiveTypeIcon(objType)
	if objType == "kill" then return "‚öî" end
	if objType == "gather" then return "üì¶" end
	if objType == "talk" then return "üí¨" end
	if objType == "visit" or objType == "travel" then return "üó∫" end
	if objType == "pay" then return "ü™ô" end
	if objType == "interact" then return "üîÆ" end
	if objType == "choice" then return "‚öñ" end
	return "‚Ä¢"
end

------------------------------------------------------------
-- ScreenGui
------------------------------------------------------------
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "QuestUI"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.DisplayOrder = 5
screenGui.Parent = playerGui

------------------------------------------------------------
-- Active Quest HUD (always visible, top-right)
------------------------------------------------------------
local hudFrame = Instance.new("Frame")
hudFrame.Name = "QuestHUD"
hudFrame.Size = UDim2.fromOffset(240, 70)
hudFrame.Position = UDim2.new(1, -250, 0, 100)
hudFrame.BackgroundColor3 = C.bg
hudFrame.BackgroundTransparency = 0.15
hudFrame.BorderSizePixel = 0
hudFrame.Parent = screenGui

local hudCorner = Instance.new("UICorner")
hudCorner.CornerRadius = UDim.new(0, 8)
hudCorner.Parent = hudFrame

local hudStroke = Instance.new("UIStroke")
hudStroke.Color = C.goldDim
hudStroke.Thickness = 1.5
hudStroke.Parent = hudFrame

local hudPad = Instance.new("UIPadding")
hudPad.PaddingLeft = UDim.new(0, 10)
hudPad.PaddingRight = UDim.new(0, 10)
hudPad.PaddingTop = UDim.new(0, 8)
hudPad.PaddingBottom = UDim.new(0, 8)
hudPad.Parent = hudFrame

local hudQuestName = Instance.new("TextLabel")
hudQuestName.Name = "QuestName"
hudQuestName.Size = UDim2.new(1, 0, 0, 20)
hudQuestName.BackgroundTransparency = 1
hudQuestName.TextColor3 = C.gold
hudQuestName.Font = Enum.Font.GothamBold
hudQuestName.TextSize = 14
hudQuestName.TextXAlignment = Enum.TextXAlignment.Left
hudQuestName.TextTruncate = Enum.TextTruncate.AtEnd
hudQuestName.Text = ""
hudQuestName.Parent = hudFrame

local hudObjective = Instance.new("TextLabel")
hudObjective.Name = "Objective"
hudObjective.Size = UDim2.new(1, 0, 0, 32)
hudObjective.Position = UDim2.fromOffset(0, 22)
hudObjective.BackgroundTransparency = 1
hudObjective.TextColor3 = C.text
hudObjective.Font = Enum.Font.Gotham
hudObjective.TextSize = 12
hudObjective.TextXAlignment = Enum.TextXAlignment.Left
hudObjective.TextYAlignment = Enum.TextYAlignment.Top
hudObjective.TextWrapped = true
hudObjective.Text = ""
hudObjective.Parent = hudFrame

local hudButton = Instance.new("TextButton")
hudButton.Name = "ClickArea"
hudButton.Size = UDim2.new(1, 0, 1, 0)
hudButton.BackgroundTransparency = 1
hudButton.Text = ""
hudButton.Parent = hudFrame

local function updateHUD()
	local activeId = questProgress.activeQuest
	if not activeId then
		hudFrame.Visible = false
		return
	end
	local quest = QuestDatabase.ById[activeId]
	if not quest then
		hudFrame.Visible = false
		return
	end
	hudFrame.Visible = true
	hudQuestName.Text = quest.name

	-- Find first incomplete objective
	local objectives = quest.objectives
	local foundObj = nil
	for i, obj in objectives do
		local prog = getObjectiveProgress(activeId, i)
		if not prog.done then
			local desc = getObjectiveDescription(obj)
			if obj.amount and obj.amount > 0 then
				local cur = prog.current or 0
				desc = desc .. " " .. tostring(cur) .. "/" .. tostring(obj.amount)
			end
			foundObj = getObjectiveTypeIcon(obj.type) .. " " .. desc
			break
		end
	end
	hudObjective.Text = foundObj or "All objectives complete!"
end

------------------------------------------------------------
-- Main Journal Frame
------------------------------------------------------------
local mainFrame = Instance.new("Frame")
mainFrame.Name = "QuestJournal"
mainFrame.Size = UDim2.fromOffset(450, 500)
mainFrame.Position = UDim2.fromScale(0.5, 0.5)
mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
mainFrame.BackgroundColor3 = C.bg
mainFrame.BorderSizePixel = 0
mainFrame.Visible = false
mainFrame.BackgroundTransparency = 1
mainFrame.Parent = screenGui

local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 8)
mainCorner.Parent = mainFrame

local mainStroke = Instance.new("UIStroke")
mainStroke.Color = C.gold
mainStroke.Thickness = 2
mainStroke.Parent = mainFrame

-- Title bar
local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.Size = UDim2.new(1, 0, 0, 38)
titleBar.BackgroundColor3 = C.bgDark
titleBar.BorderSizePixel = 0
titleBar.Parent = mainFrame

local titleCorner = Instance.new("UICorner")
titleCorner.CornerRadius = UDim.new(0, 8)
titleCorner.Parent = titleBar

local titleLabel = Instance.new("TextLabel")
titleLabel.Text = "‚öî Quest Journal"
titleLabel.Size = UDim2.new(1, -40, 1, 0)
titleLabel.Position = UDim2.fromOffset(12, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.TextColor3 = C.gold
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextSize = 18
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = titleBar

local closeBtn = Instance.new("TextButton")
closeBtn.Text = "‚úï"
closeBtn.Size = UDim2.fromOffset(38, 38)
closeBtn.Position = UDim2.new(1, -38, 0, 0)
closeBtn.BackgroundTransparency = 1
closeBtn.TextColor3 = C.textDim
closeBtn.Font = Enum.Font.GothamBold
closeBtn.TextSize = 18
closeBtn.Parent = titleBar

-- Content area: left list + right detail
local contentFrame = Instance.new("Frame")
contentFrame.Name = "Content"
contentFrame.Size = UDim2.new(1, -8, 1, -46)
contentFrame.Position = UDim2.fromOffset(4, 42)
contentFrame.BackgroundTransparency = 1
contentFrame.Parent = mainFrame

-- Left panel: quest list (40%)
local listPanel = Instance.new("ScrollingFrame")
listPanel.Name = "QuestList"
listPanel.Size = UDim2.new(0.4, -2, 1, 0)
listPanel.Position = UDim2.fromOffset(0, 0)
listPanel.BackgroundColor3 = C.bgDark
listPanel.BorderSizePixel = 0
listPanel.ScrollBarThickness = 4
listPanel.ScrollBarImageColor3 = C.goldDim
listPanel.CanvasSize = UDim2.new(0, 0, 0, 0)
listPanel.AutomaticCanvasSize = Enum.AutomaticSize.Y
listPanel.Parent = contentFrame

local listCorner = Instance.new("UICorner")
listCorner.CornerRadius = UDim.new(0, 6)
listCorner.Parent = listPanel

local listLayout = Instance.new("UIListLayout")
listLayout.Padding = UDim.new(0, 2)
listLayout.Parent = listPanel

local listPad = Instance.new("UIPadding")
listPad.PaddingLeft = UDim.new(0, 4)
listPad.PaddingRight = UDim.new(0, 4)
listPad.PaddingTop = UDim.new(0, 4)
listPad.PaddingBottom = UDim.new(0, 4)
listPad.Parent = listPanel

-- Right panel: quest details (60%)
local detailPanel = Instance.new("ScrollingFrame")
detailPanel.Name = "QuestDetail"
detailPanel.Size = UDim2.new(0.6, -2, 1, 0)
detailPanel.Position = UDim2.new(0.4, 2, 0, 0)
detailPanel.BackgroundColor3 = C.bgDark
detailPanel.BorderSizePixel = 0
detailPanel.ScrollBarThickness = 4
detailPanel.ScrollBarImageColor3 = C.goldDim
detailPanel.CanvasSize = UDim2.new(0, 0, 0, 0)
detailPanel.AutomaticCanvasSize = Enum.AutomaticSize.Y
detailPanel.Parent = contentFrame

local detailCorner = Instance.new("UICorner")
detailCorner.CornerRadius = UDim.new(0, 6)
detailCorner.Parent = detailPanel

local detailLayout = Instance.new("UIListLayout")
detailLayout.Padding = UDim.new(0, 6)
detailLayout.Parent = detailPanel

local detailPad = Instance.new("UIPadding")
detailPad.PaddingLeft = UDim.new(0, 10)
detailPad.PaddingRight = UDim.new(0, 10)
detailPad.PaddingTop = UDim.new(0, 10)
detailPad.PaddingBottom = UDim.new(0, 10)
detailPad.Parent = detailPanel

------------------------------------------------------------
-- UI Factory Helpers
------------------------------------------------------------
local function makeLabel(parent, text, size, color, font)
	local label = Instance.new("TextLabel")
	label.Text = text
	label.Size = UDim2.new(1, 0, 0, 0)
	label.AutomaticSize = Enum.AutomaticSize.Y
	label.BackgroundTransparency = 1
	label.TextColor3 = color or C.text
	label.Font = font or Enum.Font.Gotham
	label.TextSize = size or 13
	label.TextWrapped = true
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Parent = parent
	return label
end

local function makeSeparator(parent)
	local sep = Instance.new("Frame")
	sep.Size = UDim2.new(1, 0, 0, 1)
	sep.BackgroundColor3 = C.goldDim
	sep.BackgroundTransparency = 0.5
	sep.BorderSizePixel = 0
	sep.Parent = parent
end

------------------------------------------------------------
-- Render Quest List
------------------------------------------------------------
local function renderList()
	clearChildren(listPanel)

	for _, quest in QuestDatabase.Quests do
		local status = getQuestStatus(quest)
		local icon = getStatusIcon(status)
		local statusColor = getStatusColor(status)

		local btn = Instance.new("TextButton")
		btn.Name = quest.id
		btn.Size = UDim2.new(1, 0, 0, 38)
		btn.BackgroundColor3 = (selectedQuestId == quest.id) and C.bgLight or C.bg
		btn.BorderSizePixel = 0
		btn.AutoButtonColor = false
		btn.Text = ""
		btn.Parent = listPanel

		local btnCorner = Instance.new("UICorner")
		btnCorner.CornerRadius = UDim.new(0, 4)
		btnCorner.Parent = btn

		-- Status icon
		local iconLabel = Instance.new("TextLabel")
		iconLabel.Size = UDim2.fromOffset(24, 38)
		iconLabel.Position = UDim2.fromOffset(4, 0)
		iconLabel.BackgroundTransparency = 1
		iconLabel.Text = icon
		iconLabel.TextSize = 14
		iconLabel.Font = Enum.Font.Gotham
		iconLabel.TextColor3 = statusColor
		iconLabel.Parent = btn

		-- Quest name
		local nameLabel = Instance.new("TextLabel")
		nameLabel.Size = UDim2.new(1, -60, 0, 20)
		nameLabel.Position = UDim2.fromOffset(28, 2)
		nameLabel.BackgroundTransparency = 1
		nameLabel.Text = quest.name
		nameLabel.TextSize = 13
		nameLabel.Font = Enum.Font.GothamMedium
		nameLabel.TextColor3 = (status == "locked") and C.locked or C.text
		nameLabel.TextXAlignment = Enum.TextXAlignment.Left
		nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
		nameLabel.Parent = btn

		-- Level requirement
		local lvlLabel = Instance.new("TextLabel")
		lvlLabel.Size = UDim2.new(1, -32, 0, 14)
		lvlLabel.Position = UDim2.fromOffset(28, 21)
		lvlLabel.BackgroundTransparency = 1
		lvlLabel.Text = "Lv. " .. tostring(quest.level)
		lvlLabel.TextSize = 11
		lvlLabel.Font = Enum.Font.Gotham
		lvlLabel.TextColor3 = (status == "locked") and C.locked or C.textDim
		lvlLabel.TextXAlignment = Enum.TextXAlignment.Left
		lvlLabel.Parent = btn

		-- Highlight on hover
		btn.MouseEnter:Connect(function()
			if selectedQuestId ~= quest.id then
				TweenService:Create(btn, TweenInfo.new(0.15), { BackgroundColor3 = C.bgLight }):Play()
			end
		end)
		btn.MouseLeave:Connect(function()
			if selectedQuestId ~= quest.id then
				TweenService:Create(btn, TweenInfo.new(0.15), { BackgroundColor3 = C.bg }):Play()
			end
		end)

		btn.MouseButton1Click:Connect(function()
			selectedQuestId = quest.id
			renderList()
		end)
	end
end

------------------------------------------------------------
-- Render Quest Detail
------------------------------------------------------------
local function renderDetail()
	clearChildren(detailPanel)

	if not selectedQuestId then
		makeLabel(detailPanel, "Select a quest to view details.", 14, C.textDim)
		return
	end

	local quest = QuestDatabase.ById[selectedQuestId]
	if not quest then
		makeLabel(detailPanel, "Quest not found.", 14, C.textDim)
		return
	end

	local status = getQuestStatus(quest)

	-- Quest Name
	makeLabel(detailPanel, quest.name, 18, C.gold, Enum.Font.GothamBold)

	-- Given by
	makeLabel(detailPanel, "Given by: " .. (quest.giver or "Unknown"), 13, C.text)

	-- Level requirement
	local lvlColor = (quest.level > playerLevel) and C.red or C.textDim
	makeLabel(detailPanel, "Level Required: " .. tostring(quest.level), 12, lvlColor)

	-- Status badge
	local statusText = getStatusIcon(status) .. " " .. status:sub(1, 1):upper() .. status:sub(2)
	makeLabel(detailPanel, statusText, 12, getStatusColor(status), Enum.Font.GothamMedium)

	makeSeparator(detailPanel)

	-- Description
	makeLabel(detailPanel, quest.description, 13, C.text)

	makeSeparator(detailPanel)

	-- Objectives
	makeLabel(detailPanel, "Objectives", 15, C.gold, Enum.Font.GothamBold)

	for i, obj in quest.objectives do
		local prog = getObjectiveProgress(quest.id, i)
		local isDone = prog.done or false
		local current = prog.current or 0
		local total = obj.amount or 1

		local checkIcon = isDone and "‚úÖ" or "‚òê"
		local desc = getObjectiveDescription(obj)
		local typeIcon = getObjectiveTypeIcon(obj.type)
		local objColor = isDone and C.green or C.text

		-- Create objective container frame
		local objFrame = Instance.new("Frame")
		objFrame.Name = "Objective_" .. i
		objFrame.Size = UDim2.new(1, 0, 0, 0)
		objFrame.AutomaticSize = Enum.AutomaticSize.Y
		objFrame.BackgroundTransparency = 1
		objFrame.Parent = detailPanel

		local objLayout = Instance.new("UIListLayout")
		objLayout.Padding = UDim.new(0, 2)
		objLayout.Parent = objFrame

		-- Objective description
		local objLabel = Instance.new("TextLabel")
		objLabel.Name = "Description"
		objLabel.Size = UDim2.new(1, 0, 0, 0)
		objLabel.AutomaticSize = Enum.AutomaticSize.Y
		objLabel.BackgroundTransparency = 1
		objLabel.Text = checkIcon .. " " .. typeIcon .. " " .. desc
		objLabel.TextColor3 = objColor
		objLabel.TextXAlignment = Enum.TextXAlignment.Left
		objLabel.Font = Enum.Font.Gotham
		objLabel.TextSize = 12
		objLabel.TextWrapped = true
		objLabel.Parent = objFrame

		-- Progress bar (only for active quests with amounts > 1)
		if status == "active" and total > 1 then
			local progressFrame = Instance.new("Frame")
			progressFrame.Name = "ProgressFrame"
			progressFrame.Size = UDim2.new(1, -20, 0, 20)
			progressFrame.Position = UDim2.new(0, 10, 0, 0)
			progressFrame.BackgroundColor3 = C.bgLight
			progressFrame.BorderSizePixel = 0
			progressFrame.Parent = objFrame

			local progressCorner = Instance.new("UICorner")
			progressCorner.CornerRadius = UDim.new(0, 4)
			progressCorner.Parent = progressFrame

			-- Progress fill
			local progressBar = Instance.new("Frame")
			progressBar.Name = "ProgressBar"
			progressBar.Size = UDim2.new(math.min(current / total, 1), 0, 1, 0)
			progressBar.Position = UDim2.new(0, 0, 0, 0)
			progressBar.BackgroundColor3 = isDone and C.green or C.gold
			progressBar.BorderSizePixel = 0
			progressBar.Parent = progressFrame

			local barCorner = Instance.new("UICorner")
			barCorner.CornerRadius = UDim.new(0, 4)
			barCorner.Parent = progressBar

			-- Progress text overlay
			local progressText = Instance.new("TextLabel")
			progressText.Name = "ProgressText"
			progressText.Size = UDim2.new(1, 0, 1, 0)
			progressText.Position = UDim2.new(0, 0, 0, 0)
			progressText.BackgroundTransparency = 1
			progressText.Text = current .. " / " .. total
			progressText.TextColor3 = C.text
			progressText.TextScaled = true
			progressText.Font = Enum.Font.GothamBold
			progressText.Parent = progressFrame
		elseif total > 1 then
			-- Show simple progress text for non-active quests
			local simpleProgress = Instance.new("TextLabel")
			simpleProgress.Name = "SimpleProgress"
			simpleProgress.Size = UDim2.new(1, -20, 0, 16)
			simpleProgress.Position = UDim2.new(0, 10, 0, 0)
			simpleProgress.BackgroundTransparency = 1
			simpleProgress.Text = "Progress: " .. current .. " / " .. total
			simpleProgress.TextColor3 = C.textDim
			simpleProgress.TextXAlignment = Enum.TextXAlignment.Left
			simpleProgress.Font = Enum.Font.Gotham
			simpleProgress.TextSize = 11
			simpleProgress.Parent = objFrame
		end
	end

	-- Choice objectives (if quest has choices and is active)
	if quest.choices and status == "active" then
		makeSeparator(detailPanel)
		makeLabel(detailPanel, "Choose a Path", 14, C.gold, Enum.Font.GothamMedium)
		for _, choice in quest.choices do
			local choiceFrame = Instance.new("Frame")
			choiceFrame.Size = UDim2.new(1, 0, 0, 0)
			choiceFrame.AutomaticSize = Enum.AutomaticSize.Y
			choiceFrame.BackgroundColor3 = C.bg
			choiceFrame.BorderSizePixel = 0
			choiceFrame.Parent = detailPanel

			local choiceCorner = Instance.new("UICorner")
			choiceCorner.CornerRadius = UDim.new(0, 4)
			choiceCorner.Parent = choiceFrame

			local choicePad = Instance.new("UIPadding")
			choicePad.PaddingLeft = UDim.new(0, 6)
			choicePad.PaddingRight = UDim.new(0, 6)
			choicePad.PaddingTop = UDim.new(0, 6)
			choicePad.PaddingBottom = UDim.new(0, 6)
			choicePad.Parent = choiceFrame

			local choiceLayout = Instance.new("UIListLayout")
			choiceLayout.Padding = UDim.new(0, 2)
			choiceLayout.Parent = choiceFrame

			makeLabel(choiceFrame, "‚öñ " .. choice.label, 13, C.gold, Enum.Font.GothamMedium)
			makeLabel(choiceFrame, choice.description, 11, C.textDim)
		end
	end

	makeSeparator(detailPanel)

	-- Rewards
	makeLabel(detailPanel, "Rewards", 15, C.gold, Enum.Font.GothamBold)

	local rewards = quest.rewards
	if rewards then
		if rewards.gold and rewards.gold > 0 then
			makeLabel(detailPanel, "ü™ô " .. tostring(rewards.gold) .. " Gold", 13, C.text)
		end
		if rewards.xp then
			for skill, amount in rewards.xp do
				makeLabel(detailPanel, "‚≠ê " .. tostring(amount) .. " " .. tostring(skill) .. " XP", 13, C.text)
			end
		end
		if rewards.items then
			for _, item in rewards.items do
				makeLabel(detailPanel, "üéÅ " .. tostring(item), 13, C.text)
			end
		end
	end

	-- Show choice-specific rewards too
	if quest.choices then
		for _, choice in quest.choices do
			if choice.rewards and choice.rewards.xp then
				makeLabel(detailPanel, "Path: " .. choice.label, 12, C.goldDim, Enum.Font.GothamMedium)
				for skill, amount in choice.rewards.xp do
					makeLabel(detailPanel, "  ‚≠ê " .. tostring(amount) .. " " .. tostring(skill) .. " XP", 12, C.textDim)
				end
			end
		end
	end
end

------------------------------------------------------------
-- Render All
------------------------------------------------------------
local function refreshUI()
	renderList()
	renderDetail()
	updateHUD()
end

------------------------------------------------------------
-- Open / Close Animation
------------------------------------------------------------
local function openJournal()
	if isOpen then return end
	isOpen = true
	mainFrame.Visible = true
	mainFrame.BackgroundTransparency = 1
	mainFrame.Size = UDim2.fromOffset(450, 500)
	TweenService:Create(mainFrame, TWEEN_OPEN, {
		BackgroundTransparency = 0,
	}):Play()
	refreshUI()
end

local function closeJournal()
	if not isOpen then return end
	isOpen = false
	local tween = TweenService:Create(mainFrame, TWEEN_CLOSE, {
		BackgroundTransparency = 1,
	})
	tween:Play()
	tween.Completed:Connect(function()
		if not isOpen then
			mainFrame.Visible = false
		end
	end)
end

local function toggleJournal()
	if isOpen then
		closeJournal()
	else
		openJournal()
	end
end

------------------------------------------------------------
-- Input Bindings
------------------------------------------------------------
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == Enum.KeyCode.J then
		toggleJournal()
	end
end)

closeBtn.MouseButton1Click:Connect(function()
	closeJournal()
end)

hudButton.MouseButton1Click:Connect(function()
	openJournal()
end)

------------------------------------------------------------
-- Listen for server updates (if remotes exist)
------------------------------------------------------------
local questProgressEvent = ReplicatedStorage:FindFirstChild("QuestProgress")
if questProgressEvent and questProgressEvent:IsA("RemoteEvent") then
	questProgressEvent.OnClientEvent:Connect(function(data)
		if data then
			questProgress = data
			if isOpen then
				refreshUI()
			else
				updateHUD()
			end
		end
	end)
end

local questCompleteEvent = ReplicatedStorage:FindFirstChild("QuestComplete")
if questCompleteEvent and questCompleteEvent:IsA("RemoteEvent") then
	questCompleteEvent.OnClientEvent:Connect(function(questId, rewards)
		-- Show notification
		local notif = Instance.new("Frame")
		notif.Size = UDim2.fromOffset(300, 50)
		notif.Position = UDim2.new(0.5, -150, 0, 80)
		notif.BackgroundColor3 = C.bgDark
		notif.BorderSizePixel = 0
		notif.Parent = screenGui

		local nCorner = Instance.new("UICorner")
		nCorner.CornerRadius = UDim.new(0, 8)
		nCorner.Parent = notif

		local nStroke = Instance.new("UIStroke")
		nStroke.Color = C.gold
		nStroke.Thickness = 1.5
		nStroke.Parent = notif

		local nLabel = Instance.new("TextLabel")
		nLabel.Size = UDim2.new(1, 0, 1, 0)
		nLabel.BackgroundTransparency = 1
		nLabel.TextColor3 = C.gold
		nLabel.Font = Enum.Font.GothamBold
		nLabel.TextSize = 16
		nLabel.Text = "‚úÖ Quest Complete!"
		if rewards and rewards.gold then
			nLabel.Text = nLabel.Text .. " +" .. tostring(rewards.gold) .. " Gold"
		end
		nLabel.Parent = notif

		task.delay(3, function()
			local fadeOut = TweenService:Create(notif, TweenInfo.new(0.5), { BackgroundTransparency = 1 })
			local fadeTxt = TweenService:Create(nLabel, TweenInfo.new(0.5), { TextTransparency = 1 })
			local fadeStk = TweenService:Create(nStroke, TweenInfo.new(0.5), { Transparency = 1 })
			fadeOut:Play()
			fadeTxt:Play()
			fadeStk:Play()
			fadeOut.Completed:Connect(function()
				notif:Destroy()
			end)
		end)
	end)
end

------------------------------------------------------------
-- Initial HUD update
------------------------------------------------------------
updateHUD()

print("[QuestUI] Loaded - Press J to open quest journal")
]]></string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="73">
        <Properties>
          <string name="Name">ShopUI</string>
          <string name="Source">--[[
	ShopUI.client.lua
	Client-side shop interface for merchant NPCs.
	Dark theme with gold accents, buy/sell functionality.
]]

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Require modules
local ItemDatabase
local DataManager
do
	local ok, result = pcall(function()
		return require(game.ReplicatedStorage.Modules.ItemDatabase)
	end)
	if ok then
		ItemDatabase = result
	else
		warn("[ShopUI] Failed to load ItemDatabase:", result)
		ItemDatabase = { Items = {} }
	end

	ok, result = pcall(function()
		return require(game.ReplicatedStorage.Modules.DataManager)
	end)
	if ok then
		DataManager = result
	else
		warn("[ShopUI] Failed to load DataManager:", result)
	end
end

------------------------------------------------------------
-- Theme
------------------------------------------------------------
local C = {
	bg        = Color3.fromHex("#1a1a2e"),
	bgDark    = Color3.fromHex("#0f0f23"),
	bgLight   = Color3.fromHex("#16213e"),
	gold      = Color3.fromHex("#f0c040"),
	goldDim   = Color3.fromHex("#a08030"),
	text      = Color3.fromHex("#e0e0e0"),
	textDim   = Color3.fromHex("#888899"),
	green     = Color3.fromHex("#40c060"),
	red       = Color3.fromHex("#c04040"),
	locked    = Color3.fromHex("#555566"),
}

local TWEEN_OPEN = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
local TWEEN_CLOSE = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In)

------------------------------------------------------------
-- Remote Events
------------------------------------------------------------
local function getRemote(name: string): RemoteEvent?
	return ReplicatedStorage:WaitForChild(name, 5)
end

local BuyItemEvent = getRemote("BuyItem")
local SellItemEvent = getRemote("SellItem")
local NPCInteractEvent = getRemote("NPCInteract")

------------------------------------------------------------
-- State
------------------------------------------------------------
local currentShop = nil
local currentNPCName = ""
local isShopOpen = false

------------------------------------------------------------
-- Shop Inventories (same as server)
------------------------------------------------------------
local ShopInventories = {
	["Mara the Merchant"] = {
		{ item = "Bread", stock = 50, basePrice = 10 },
		{ item = "Meat Pie", stock = 25, basePrice = 25 },
		{ item = "Apple", stock = 30, basePrice = 5 },
		{ item = "Fishing Rod", stock = 5, basePrice = 50 },
		{ item = "Pickaxe", stock = 5, basePrice = 75 },
		{ item = "Hatchet", stock = 5, basePrice = 60 },
		{ item = "Rope", stock = 20, basePrice = 15 },
		{ item = "Tinderbox", stock = 10, basePrice = 8 },
	},
	["Captain Blackbeard"] = {
		{ item = "Cutlass", stock = 3, basePrice = 200 },
		{ item = "Pirate Hat", stock = 2, basePrice = 150 },
		{ item = "Rum", stock = 15, basePrice = 30 },
		{ item = "Rope", stock = 10, basePrice = 15 },
		{ item = "Cannon Ball", stock = 25, basePrice = 20 },
		{ item = "Treasure Map", stock = 1, basePrice = 500 },
		{ item = "Spyglass", stock = 2, basePrice = 100 },
	},
	["Priestess Solara"] = {
		{ item = "Prayer Book", stock = 3, basePrice = 100 },
		{ item = "Holy Water", stock = 20, basePrice = 25 },
		{ item = "Blessed Bones", stock = 15, basePrice = 40 },
		{ item = "Healing Potion", stock = 30, basePrice = 35 },
		{ item = "Prayer Beads", stock = 10, basePrice = 60 },
		{ item = "Candle", stock = 25, basePrice = 12 },
		{ item = "Incense", stock = 15, basePrice = 18 },
	},
	["Grimnir the Smith"] = {
		{ item = "Hammer", stock = 5, basePrice = 40 },
		{ item = "Copper Bar", stock = 20, basePrice = 25 },
		{ item = "Iron Bar", stock = 15, basePrice = 50 },
		{ item = "Gold Bar", stock = 5, basePrice = 200 },
		{ item = "Bronze Sword", stock = 10, basePrice = 80 },
		{ item = "Iron Sword", stock = 5, basePrice = 150 },
		{ item = "Shield", stock = 8, basePrice = 100 },
		{ item = "Anvil Plans", stock = 1, basePrice = 300 },
	},
	["Old Bess the Cook"] = {
		{ item = "Cooking Pot", stock = 3, basePrice = 45 },
		{ item = "Flour", stock = 30, basePrice = 8 },
		{ item = "Salt", stock = 25, basePrice = 5 },
		{ item = "Cooked Shrimp", stock = 20, basePrice = 15 },
		{ item = "Cooked Trout", stock = 15, basePrice = 25 },
		{ item = "Bread", stock = 40, basePrice = 10 },
		{ item = "Meat Pie", stock = 20, basePrice = 25 },
		{ item = "Chef's Hat", stock = 2, basePrice = 75 },
	},
	["Fisher Tom"] = {
		{ item = "Fishing Rod", stock = 8, basePrice = 50 },
		{ item = "Net", stock = 5, basePrice = 80 },
		{ item = "Bait", stock = 50, basePrice = 3 },
		{ item = "Raw Shrimp", stock = 25, basePrice = 8 },
		{ item = "Raw Sardine", stock = 20, basePrice = 12 },
		{ item = "Raw Trout", stock = 15, basePrice = 18 },
		{ item = "Fishing Basket", stock = 10, basePrice = 30 },
	},
	["Woodsman Jake"] = {
		{ item = "Hatchet", stock = 6, basePrice = 60 },
		{ item = "Logs", stock = 50, basePrice = 10 },
		{ item = "Oak Logs", stock = 30, basePrice = 20 },
		{ item = "Willow Logs", stock = 15, basePrice = 35 },
		{ item = "Bow String", stock = 20, basePrice = 15 },
		{ item = "Arrow Shaft", stock = 100, basePrice = 2 },
		{ item = "Feather", stock = 50, basePrice = 5 },
	},
}

------------------------------------------------------------
-- UI Creation
------------------------------------------------------------
local function createShopUI()
	-- Main frame
	local shopGui = Instance.new("ScreenGui")
	shopGui.Name = "ShopUI"
	shopGui.Parent = playerGui
	shopGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

	-- Background overlay
	local overlay = Instance.new("Frame")
	overlay.Name = "Overlay"
	overlay.Size = UDim2.new(1, 0, 1, 0)
	overlay.Position = UDim2.new(0, 0, 0, 0)
	overlay.BackgroundColor3 = Color3.new(0, 0, 0)
	overlay.BackgroundTransparency = 0.5
	overlay.BorderSizePixel = 0
	overlay.Parent = shopGui

	-- Main shop frame
	local mainFrame = Instance.new("Frame")
	mainFrame.Name = "MainFrame"
	mainFrame.Size = UDim2.new(0, 800, 0, 600)
	mainFrame.Position = UDim2.new(0.5, -400, 0.5, -300)
	mainFrame.BackgroundColor3 = C.bg
	mainFrame.BorderSizePixel = 0
	mainFrame.Parent = shopGui

	-- Add corner rounding
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = mainFrame

	-- Header
	local header = Instance.new("Frame")
	header.Name = "Header"
	header.Size = UDim2.new(1, 0, 0, 60)
	header.Position = UDim2.new(0, 0, 0, 0)
	header.BackgroundColor3 = C.bgDark
	header.BorderSizePixel = 0
	header.Parent = mainFrame

	local headerCorner = Instance.new("UICorner")
	headerCorner.CornerRadius = UDim.new(0, 12)
	headerCorner.Parent = header

	-- Shop title
	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.Size = UDim2.new(1, -80, 1, 0)
	title.Position = UDim2.new(0, 20, 0, 0)
	title.BackgroundTransparency = 1
	title.Text = "Shop"
	title.TextColor3 = C.gold
	title.TextScaled = true
	title.Font = Enum.Font.GothamBold
	title.Parent = header

	-- Close button
	local closeBtn = Instance.new("TextButton")
	closeBtn.Name = "CloseButton"
	closeBtn.Size = UDim2.new(0, 40, 0, 40)
	closeBtn.Position = UDim2.new(1, -50, 0.5, -20)
	closeBtn.BackgroundColor3 = C.red
	closeBtn.Text = "√ó"
	closeBtn.TextColor3 = C.text
	closeBtn.TextScaled = true
	closeBtn.Font = Enum.Font.GothamBold
	closeBtn.Parent = header

	local closeBtnCorner = Instance.new("UICorner")
	closeBtnCorner.CornerRadius = UDim.new(0, 8)
	closeBtnCorner.Parent = closeBtn

	-- Gold display
	local goldFrame = Instance.new("Frame")
	goldFrame.Name = "GoldFrame"
	goldFrame.Size = UDim2.new(1, -20, 0, 40)
	goldFrame.Position = UDim2.new(0, 10, 0, 70)
	goldFrame.BackgroundColor3 = C.bgLight
	goldFrame.BorderSizePixel = 0
	goldFrame.Parent = mainFrame

	local goldCorner = Instance.new("UICorner")
	goldCorner.CornerRadius = UDim.new(0, 8)
	goldCorner.Parent = goldFrame

	local goldLabel = Instance.new("TextLabel")
	goldLabel.Name = "GoldLabel"
	goldLabel.Size = UDim2.new(1, -20, 1, 0)
	goldLabel.Position = UDim2.new(0, 10, 0, 0)
	goldLabel.BackgroundTransparency = 1
	goldLabel.Text = "Gold: 0"
	goldLabel.TextColor3 = C.gold
	goldLabel.TextScaled = true
	goldLabel.Font = Enum.Font.Gotham
	goldLabel.TextXAlignment = Enum.TextXAlignment.Left
	goldLabel.Parent = goldFrame

	-- Content area with tabs
	local contentFrame = Instance.new("Frame")
	contentFrame.Name = "ContentFrame"
	contentFrame.Size = UDim2.new(1, -20, 1, -130)
	contentFrame.Position = UDim2.new(0, 10, 0, 120)
	contentFrame.BackgroundTransparency = 1
	contentFrame.Parent = mainFrame

	-- Tab buttons
	local tabFrame = Instance.new("Frame")
	tabFrame.Name = "TabFrame"
	tabFrame.Size = UDim2.new(1, 0, 0, 40)
	tabFrame.Position = UDim2.new(0, 0, 0, 0)
	tabFrame.BackgroundTransparency = 1
	tabFrame.Parent = contentFrame

	local buyTab = Instance.new("TextButton")
	buyTab.Name = "BuyTab"
	buyTab.Size = UDim2.new(0.5, -5, 1, 0)
	buyTab.Position = UDim2.new(0, 0, 0, 0)
	buyTab.BackgroundColor3 = C.gold
	buyTab.Text = "BUY"
	buyTab.TextColor3 = C.bgDark
	buyTab.TextScaled = true
	buyTab.Font = Enum.Font.GothamBold
	buyTab.Parent = tabFrame

	local buyTabCorner = Instance.new("UICorner")
	buyTabCorner.CornerRadius = UDim.new(0, 8)
	buyTabCorner.Parent = buyTab

	local sellTab = Instance.new("TextButton")
	sellTab.Name = "SellTab"
	sellTab.Size = UDim2.new(0.5, -5, 1, 0)
	sellTab.Position = UDim2.new(0.5, 5, 0, 0)
	sellTab.BackgroundColor3 = C.bgLight
	sellTab.Text = "SELL"
	sellTab.TextColor3 = C.text
	sellTab.TextScaled = true
	sellTab.Font = Enum.Font.GothamBold
	sellTab.Parent = tabFrame

	local sellTabCorner = Instance.new("UICorner")
	sellTabCorner.CornerRadius = UDim.new(0, 8)
	sellTabCorner.Parent = sellTab

	-- Items scroll frame
	local scrollFrame = Instance.new("ScrollingFrame")
	scrollFrame.Name = "ItemsScroll"
	scrollFrame.Size = UDim2.new(1, 0, 1, -50)
	scrollFrame.Position = UDim2.new(0, 0, 0, 50)
	scrollFrame.BackgroundColor3 = C.bgLight
	scrollFrame.BorderSizePixel = 0
	scrollFrame.ScrollBarThickness = 8
	scrollFrame.ScrollBarImageColor3 = C.gold
	scrollFrame.Parent = contentFrame

	local scrollCorner = Instance.new("UICorner")
	scrollCorner.CornerRadius = UDim.new(0, 8)
	scrollCorner.Parent = scrollFrame

	-- Grid layout for items
	local gridLayout = Instance.new("UIGridLayout")
	gridLayout.CellPadding = UDim2.new(0, 5, 0, 5)
	gridLayout.CellSize = UDim2.new(0, 180, 0, 80)
	gridLayout.SortOrder = Enum.SortOrder.Name
	gridLayout.Parent = scrollFrame

	local padding = Instance.new("UIPadding")
	padding.PaddingTop = UDim.new(0, 10)
	padding.PaddingLeft = UDim.new(0, 10)
	padding.PaddingRight = UDim.new(0, 10)
	padding.PaddingBottom = UDim.new(0, 10)
	padding.Parent = scrollFrame

	-- Store references
	shopGui.MainFrame = mainFrame
	shopGui.Title = title
	shopGui.GoldLabel = goldLabel
	shopGui.ItemsScroll = scrollFrame
	shopGui.BuyTab = buyTab
	shopGui.SellTab = sellTab

	-- Initial state
	shopGui.MainFrame.Size = UDim2.new(0, 800, 0, 0)
	shopGui.MainFrame.Position = UDim2.new(0.5, -400, 0.5, 0)

	-- Event handlers
	closeBtn.MouseButton1Click:Connect(function()
		closeShop()
	end)

	buyTab.MouseButton1Click:Connect(function()
		switchTab("buy")
	end)

	sellTab.MouseButton1Click:Connect(function()
		switchTab("sell")
	end)

	-- Close on overlay click
	overlay.MouseButton1Click:Connect(function()
		closeShop()
	end)

	return shopGui
end

------------------------------------------------------------
-- Tab Switching
------------------------------------------------------------
local function switchTab(tabName)
	if not currentShop then return end

	local buyTab = currentShop.BuyTab
	local sellTab = currentShop.SellTab

	if tabName == "buy" then
		buyTab.BackgroundColor3 = C.gold
		buyTab.TextColor3 = C.bgDark
		sellTab.BackgroundColor3 = C.bgLight
		sellTab.TextColor3 = C.text
		populateShopItems()
	else
		sellTab.BackgroundColor3 = C.gold
		sellTab.TextColor3 = C.bgDark
		buyTab.BackgroundColor3 = C.bgLight
		buyTab.TextColor3 = C.text
		populateInventoryItems()
	end
end

------------------------------------------------------------
-- Item Population
------------------------------------------------------------
local function createItemFrame(itemName, quantity, price, isBuying)
	local frame = Instance.new("Frame")
	frame.Name = itemName
	frame.Size = UDim2.new(0, 180, 0, 80)
	frame.BackgroundColor3 = C.bgDark
	frame.BorderSizePixel = 0

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = frame

	-- Item name
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(1, -10, 0, 20)
	nameLabel.Position = UDim2.new(0, 5, 0, 5)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = itemName
	nameLabel.TextColor3 = C.text
	nameLabel.TextScaled = true
	nameLabel.Font = Enum.Font.GothamSemibold
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.Parent = frame

	-- Quantity/Stock
	local qtyLabel = Instance.new("TextLabel")
	qtyLabel.Size = UDim2.new(1, -10, 0, 15)
	qtyLabel.Position = UDim2.new(0, 5, 0, 25)
	qtyLabel.BackgroundTransparency = 1
	qtyLabel.Text = isBuying and ("Stock: " .. quantity) or ("You have: " .. quantity)
	qtyLabel.TextColor3 = C.textDim
	qtyLabel.TextScaled = true
	qtyLabel.Font = Enum.Font.Gotham
	qtyLabel.TextXAlignment = Enum.TextXAlignment.Left
	qtyLabel.Parent = frame

	-- Price
	local priceLabel = Instance.new("TextLabel")
	priceLabel.Size = UDim2.new(1, -10, 0, 15)
	priceLabel.Position = UDim2.new(0, 5, 0, 42)
	priceLabel.BackgroundTransparency = 1
	priceLabel.Text = "Price: " .. price .. " gold"
	priceLabel.TextColor3 = C.gold
	priceLabel.TextScaled = true
	priceLabel.Font = Enum.Font.Gotham
	priceLabel.TextXAlignment = Enum.TextXAlignment.Left
	priceLabel.Parent = frame

	-- Action button
	local actionBtn = Instance.new("TextButton")
	actionBtn.Size = UDim2.new(0, 60, 0, 20)
	actionBtn.Position = UDim2.new(1, -65, 1, -25)
	actionBtn.BackgroundColor3 = isBuying and C.green or C.goldDim
	actionBtn.Text = isBuying and "BUY" or "SELL"
	actionBtn.TextColor3 = C.text
	actionBtn.TextScaled = true
	actionBtn.Font = Enum.Font.GothamBold
	actionBtn.Parent = frame

	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 4)
	btnCorner.Parent = actionBtn

	-- Button handler
	actionBtn.MouseButton1Click:Connect(function()
		if isBuying then
			buyItem(itemName, 1)
		else
			sellItem(itemName, 1)
		end
	end)

	return frame
end

local function populateShopItems()
	if not currentShop or not currentNPCName then return end

	-- Clear existing items
	for _, child in ipairs(currentShop.ItemsScroll:GetChildren()) do
		if child:IsA("Frame") then
			child:Destroy()
		end
	end

	-- Get shop inventory
	local shopItems = ShopInventories[currentNPCName]
	if not shopItems then return end

	-- Create item frames
	for _, shopItem in ipairs(shopItems) do
		local frame = createItemFrame(shopItem.item, shopItem.stock, shopItem.basePrice, true)
		frame.Parent = currentShop.ItemsScroll
	end

	-- Update scroll canvas size
	local gridLayout = currentShop.ItemsScroll:FindFirstChild("UIGridLayout")
	if gridLayout then
		currentShop.ItemsScroll.CanvasSize = UDim2.new(0, 0, 0, gridLayout.AbsoluteContentSize.Y + 20)
	end
end

local function populateInventoryItems()
	if not currentShop or not DataManager then return end

	-- Clear existing items
	for _, child in ipairs(currentShop.ItemsScroll:GetChildren()) do
		if child:IsA("Frame") then
			child:Destroy()
		end
	end

	-- Get player inventory
	local playerData = DataManager:GetPlayerData(player)
	if not playerData then return end

	-- Create item frames for sellable items
	for _, invItem in ipairs(playerData.Inventory) do
		local itemData = ItemDatabase.Items[invItem.name]
		if itemData and itemData.value then
			local sellPrice = math.floor(itemData.value * 0.6) -- 60% of base value
			local frame = createItemFrame(invItem.name, invItem.quantity, sellPrice, false)
			frame.Parent = currentShop.ItemsScroll
		end
	end

	-- Update scroll canvas size
	local gridLayout = currentShop.ItemsScroll:FindFirstChild("UIGridLayout")
	if gridLayout then
		currentShop.ItemsScroll.CanvasSize = UDim2.new(0, 0, 0, gridLayout.AbsoluteContentSize.Y + 20)
	end
end

------------------------------------------------------------
-- Actions
------------------------------------------------------------
local function buyItem(itemName, quantity)
	if BuyItemEvent and currentNPCName then
		BuyItemEvent:FireServer(currentNPCName, itemName, quantity)
		-- Refresh shop after purchase
		task.wait(0.1)
		populateShopItems()
		updateGoldDisplay()
	end
end

local function sellItem(itemName, quantity)
	if SellItemEvent and currentNPCName then
		SellItemEvent:FireServer(currentNPCName, itemName, quantity)
		-- Refresh inventory after sale
		task.wait(0.1)
		populateInventoryItems()
		updateGoldDisplay()
	end
end

local function updateGoldDisplay()
	if not currentShop or not DataManager then return end

	local playerData = DataManager:GetPlayerData(player)
	if playerData then
		currentShop.GoldLabel.Text = "Gold: " .. tostring(playerData.Gold)
	end
end

------------------------------------------------------------
-- Shop Management
------------------------------------------------------------
local function openShop(npcName)
	if isShopOpen then return end

	-- Check if NPC has a shop
	if not ShopInventories[npcName] then return end

	currentNPCName = npcName
	isShopOpen = true

	-- Create UI
	currentShop = createShopUI()
	currentShop.Title.Text = npcName .. "'s Shop"

	-- Update gold display
	updateGoldDisplay()

	-- Show buy tab by default
	switchTab("buy")

	-- Animate open
	TweenService:Create(currentShop.MainFrame, TWEEN_OPEN, {
		Size = UDim2.new(0, 800, 0, 600),
		Position = UDim2.new(0.5, -400, 0.5, -300)
	}):Play()
end

function closeShop()
	if not isShopOpen or not currentShop then return end

	isShopOpen = false

	-- Animate close
	local closeTween = TweenService:Create(currentShop.MainFrame, TWEEN_CLOSE, {
		Size = UDim2.new(0, 800, 0, 0),
		Position = UDim2.new(0.5, -400, 0.5, 0)
	})

	closeTween:Play()
	closeTween.Completed:Connect(function()
		if currentShop then
			currentShop:Destroy()
			currentShop = nil
		end
		currentNPCName = ""
	end)
end

------------------------------------------------------------
-- NPC Interaction Handler
------------------------------------------------------------
if NPCInteractEvent then
	NPCInteractEvent.OnClientEvent:Connect(function(npcName, npcRole)
		-- Check if this NPC is a merchant
		if ShopInventories[npcName] then
			openShop(npcName)
		end
	end)
end

-- Close shop on Escape key
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	if input.KeyCode == Enum.KeyCode.Escape and isShopOpen then
		closeShop()
	end
end)

print("[ShopUI] Initialized")</string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="74">
        <Properties>
          <string name="Name">SkillTreeUI</string>
          <string name="Source"><![CDATA[--[[
	SkillTreeUI.client.lua
	A RuneScape-inspired Skill Tree UI for an MMO game.
	Press K to toggle. Shows 6 skills with vertical perk trees.
]]

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Remote
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local getSkillData = Remotes:WaitForChild("GetSkillData", 10)

-- Config: XP formula ‚Äî level N needs N*N*100 total XP
local function xpForLevel(n: number): number
	return n * n * 100
end

local function levelFromXP(totalXP: number): number
	local lv = 1
	for i = 1, 99 do
		if totalXP >= xpForLevel(i) then
			lv = i
		else
			break
		end
	end
	return lv
end

-- Colors
local DARK_BG = Color3.fromHex("#1a1a2e")
local GOLD = Color3.fromHex("#f0c040")
local GOLD_DIM = Color3.fromHex("#b8922e")
local GREY = Color3.fromHex("#555566")
local GREY_DARK = Color3.fromHex("#2a2a3e")
local GREY_LIGHT = Color3.fromHex("#888899")
local WHITE = Color3.fromHex("#eeeeee")
local GREEN = Color3.fromHex("#44cc66")
local LOCKED_COLOR = Color3.fromHex("#3a3a4e")
local NEXT_GLOW = Color3.fromHex("#f0c040")

-- Skill tree data
local SKILL_TREES = {
	Mining = {
		icon = "‚õèÔ∏è",
		nodes = {
			{level = 1,  name = "Copper Miner",       desc = "Can mine Copper Ore"},
			{level = 15, name = "Iron Miner",          desc = "Can mine Iron Ore"},
			{level = 25, name = "Efficient Miner",     desc = "10% chance to mine double ore"},
			{level = 40, name = "Gold Miner",           desc = "Can mine Gold Ore"},
			{level = 55, name = "Master Prospector",    desc = "15% faster mining"},
			{level = 70, name = "Runite Miner",         desc = "Can mine Runite Ore"},
			{level = 85, name = "Mining Legend",         desc = "20% chance double ore"},
			{level = 99, name = "Grandmaster Miner",    desc = "Mining cape unlocked"},
		},
	},
	Woodcutting = {
		icon = "ü™ì",
		nodes = {
			{level = 1,  name = "Oak Chopper",          desc = "Can chop Oak Trees"},
			{level = 20, name = "Willow Chopper",        desc = "Can chop Willow Trees"},
			{level = 30, name = "Lumberjack",            desc = "10% chance double logs"},
			{level = 50, name = "Yew Chopper",           desc = "Can chop Yew Trees"},
			{level = 60, name = "Master Lumberjack",     desc = "15% faster chopping"},
			{level = 75, name = "Magic Chopper",         desc = "Can chop Magic Trees"},
			{level = 85, name = "Forest Guardian",       desc = "20% chance double logs"},
			{level = 99, name = "Grandmaster Woodcutter",desc = "Woodcutting cape"},
		},
	},
	Fishing = {
		icon = "üé£",
		nodes = {
			{level = 1,  name = "Shrimper",             desc = "Can catch Shrimp"},
			{level = 20, name = "Angler",                desc = "Can catch Trout"},
			{level = 30, name = "Lucky Fisher",          desc = "10% chance extra fish"},
			{level = 40, name = "Lobster Trapper",       desc = "Can catch Lobster"},
			{level = 55, name = "Master Angler",         desc = "15% faster fishing"},
			{level = 70, name = "Deep Sea Fisher",       desc = "Can catch Dark Crab"},
			{level = 85, name = "Ocean Master",          desc = "20% chance extra fish"},
			{level = 99, name = "Grandmaster Fisher",    desc = "Fishing cape"},
		},
	},
	Smithing = {
		icon = "üî®",
		nodes = {
			{level = 1,  name = "Copper Smith",          desc = "Can smelt Copper"},
			{level = 15, name = "Iron Smith",             desc = "Can smelt Iron"},
			{level = 25, name = "Efficient Smith",        desc = "10% chance save materials"},
			{level = 40, name = "Gold Smith",             desc = "Can smelt Gold"},
			{level = 55, name = "Weaponsmith",            desc = "Weapons deal +5% damage"},
			{level = 70, name = "Master Smith",           desc = "15% chance save materials"},
			{level = 85, name = "Legendary Forger",       desc = "Weapons deal +10% damage"},
			{level = 99, name = "Grandmaster Smith",      desc = "Smithing cape"},
		},
	},
	Cooking = {
		icon = "üç≥",
		nodes = {
			{level = 1,  name = "Apprentice Cook",       desc = "Can cook basic food"},
			{level = 20, name = "Competent Cook",         desc = "Less burn chance"},
			{level = 30, name = "Seasoned Chef",          desc = "Food heals 10% more"},
			{level = 40, name = "Expert Cook",            desc = "Can cook Lobster"},
			{level = 55, name = "Master Chef",            desc = "Food heals 20% more"},
			{level = 70, name = "Gourmet",                desc = "Can cook Dark Crab"},
			{level = 85, name = "Culinary Master",        desc = "Food heals 30% more"},
			{level = 99, name = "Grandmaster Chef",       desc = "Cooking cape"},
		},
	},
	Strength = {
		icon = "üí™",
		nodes = {
			{level = 1,  name = "Brawler",               desc = "Basic melee attacks"},
			{level = 5,  name = "Power Strike",           desc = "2x damage active (30s CD)"},
			{level = 15, name = "Iron Grip",              desc = "Can equip Iron weapons"},
			{level = 25, name = "Combo Hit",              desc = "3rd hit does 1.5x damage"},
			{level = 40, name = "Gold Wielder",           desc = "Can equip Gold weapons"},
			{level = 50, name = "Berserker",              desc = "Below 30% HP = +25% damage"},
			{level = 60, name = "Life Steal",             desc = "5% of damage heals you"},
			{level = 75, name = "Dragon Wielder",         desc = "Can equip Dragon weapons"},
			{level = 80, name = "Double Strike",          desc = "10% chance to hit twice"},
			{level = 90, name = "Undying",                desc = "Survive lethal hit 1HP (5min CD)"},
			{level = 99, name = "Grandmaster Warrior",    desc = "Strength mastery cape"},
		},
	},
	Defense = {
		icon = "üõ°Ô∏è",
		nodes = {
			{level = 1,  name = "Tough Skin",             desc = "Base damage reduction"},
			{level = 10, name = "Iron Skin",              desc = "+5% damage reduction"},
			{level = 15, name = "Iron Armor",             desc = "Can equip Iron armor/shields"},
			{level = 25, name = "Shield Wall",            desc = "+15% block with shield"},
			{level = 35, name = "War Cry",                desc = "AoE taunt monsters"},
			{level = 40, name = "Gold Armor",             desc = "Can equip Gold armor/shields"},
			{level = 55, name = "Shield Bash",            desc = "Stun enemy 2s (45s CD)"},
			{level = 70, name = "Vengeance",              desc = "Reflect 15% damage taken"},
			{level = 80, name = "Runite Armor",           desc = "Can equip Runite gear"},
			{level = 90, name = "Fortress",               desc = "+50 max HP"},
			{level = 99, name = "Grandmaster Defender",   desc = "Defense mastery cape"},
		},
	},
	Ranged = {
		icon = "üèπ",
		nodes = {
			{level = 1,  name = "Archer",                 desc = "Can use Oak bows"},
			{level = 5,  name = "Quick Draw",             desc = "10% faster arrows"},
			{level = 20, name = "Willow Archer",          desc = "Can use Willow bows"},
			{level = 25, name = "Eagle Eye",              desc = "+15% long range accuracy"},
			{level = 45, name = "Rapid Fire",             desc = "Fire 3 arrows in 1s (45s CD)"},
			{level = 55, name = "Yew Archer",             desc = "Can use Yew bows"},
			{level = 60, name = "Piercing Shot",          desc = "20% chance ignore armor"},
			{level = 80, name = "Multi-Shot",             desc = "15% chance hit 2 enemies"},
			{level = 85, name = "Magic Archer",           desc = "Can use Magic bows"},
			{level = 90, name = "Dead Eye",               desc = "+30% crit while still"},
			{level = 99, name = "Grandmaster Ranger",     desc = "Ranged mastery cape"},
		},
	},
	Fletching = {
		icon = "ü™∂",
		nodes = {
			{level = 1,  name = "Whittler",               desc = "Craft bronze arrows"},
			{level = 5,  name = "Bowyer",                  desc = "Craft Oak bows"},
			{level = 10, name = "Precise Cut",             desc = "10% bonus arrows"},
			{level = 25, name = "Willow Crafter",          desc = "Craft Willow bows"},
			{level = 35, name = "Quick Fingers",           desc = "15% faster fletching"},
			{level = 50, name = "Bulk Craft",              desc = "Make 2x arrows per craft"},
			{level = 65, name = "Yew Crafter",             desc = "Craft Yew bows"},
			{level = 70, name = "Master Fletcher",         desc = "20% Superior ammo chance"},
			{level = 80, name = "Magic Crafter",           desc = "Craft Magic bows"},
			{level = 90, name = "Enchanted Arrows",        desc = "5% poison on arrows"},
			{level = 99, name = "Grandmaster Fletcher",    desc = "Fletching mastery cape"},
		},
	},
	Prayer = {
		icon = "üôè",
		nodes = {
			{level = 1,  name = "Thick Skin",             desc = "+5% Defense boost"},
			{level = 5,  name = "Burst of Strength",      desc = "+5% Strength boost"},
			{level = 10, name = "Clarity of Thought",      desc = "+5% Ranged accuracy"},
			{level = 15, name = "Sharp Eye",               desc = "+10% Ranged boost"},
			{level = 20, name = "Rock Skin",               desc = "+10% Defense boost"},
			{level = 25, name = "Protect from Melee",      desc = "Block 50% melee damage"},
			{level = 30, name = "Protect from Ranged",     desc = "Block 50% ranged damage"},
			{level = 40, name = "Superhuman Strength",     desc = "+15% Strength boost"},
			{level = 50, name = "Steel Skin",              desc = "+15% Defense boost"},
			{level = 60, name = "Eagle Eye",               desc = "+15% Ranged boost"},
			{level = 70, name = "Piety",                   desc = "+20% Str, Def, Ranged"},
			{level = 80, name = "Rigour",                  desc = "+25% Ranged + Defense"},
			{level = 90, name = "Soul Split",              desc = "Heal 10% of damage dealt"},
			{level = 99, name = "Grandmaster Prayer",      desc = "Prayer mastery cape"},
		},
	},
}

local SKILL_ORDER = {"Mining", "Woodcutting", "Fishing", "Smithing", "Cooking", "Strength", "Defense", "Ranged", "Fletching", "Prayer"}

-- State
local isOpen = false
local selectedSkill = "Mining"
local skillData = {} -- {SkillName = {level=N, xp=N}}
local pulseConnections = {}

--------------------------------------------------------------------------------
-- Helper: create Instance with props
--------------------------------------------------------------------------------
local function create(className: string, props: {[string]: any}, children: {Instance}?): Instance
	local inst = Instance.new(className)
	for k, v in props do
		if k ~= "Parent" then
			(inst :: any)[k] = v
		end
	end
	if children then
		for _, c in children do
			c.Parent = inst
		end
	end
	if props.Parent then
		inst.Parent = props.Parent
	end
	return inst
end

--------------------------------------------------------------------------------
-- Build GUI
--------------------------------------------------------------------------------
local screenGui = create("ScreenGui", {
	Name = "SkillTreeUI",
	ResetOnSpawn = false,
	DisplayOrder = 10,
	IgnoreGuiInset = true,
	Enabled = false,
	Parent = playerGui,
})

-- Main overlay
local overlay = create("Frame", {
	Name = "Overlay",
	Size = UDim2.fromScale(1, 1),
	BackgroundColor3 = DARK_BG,
	BackgroundTransparency = 0.1,
	BorderSizePixel = 0,
	Parent = screenGui,
})

-- Container (centered, 90% of screen)
local container = create("Frame", {
	Name = "Container",
	Size = UDim2.fromScale(0.88, 0.88),
	Position = UDim2.fromScale(0.5, 0.5),
	AnchorPoint = Vector2.new(0.5, 0.5),
	BackgroundColor3 = DARK_BG,
	BackgroundTransparency = 0,
	BorderSizePixel = 0,
	Parent = overlay,
}, {
	create("UICorner", {CornerRadius = UDim.new(0, 16)}),
	create("UIStroke", {Color = GOLD_DIM, Thickness = 2, Transparency = 0.5}),
})

-- Title bar
local titleBar = create("Frame", {
	Name = "TitleBar",
	Size = UDim2.new(1, 0, 0, 50),
	BackgroundTransparency = 1,
	Parent = container,
})

create("TextLabel", {
	Name = "Title",
	Text = "‚öú SKILL TREE ‚öú",
	Size = UDim2.fromScale(1, 1),
	BackgroundTransparency = 1,
	TextColor3 = GOLD,
	TextSize = 28,
	Font = Enum.Font.GothamBold,
	Parent = titleBar,
})

-- Close button
local closeBtn = create("TextButton", {
	Name = "CloseBtn",
	Text = "‚úï",
	Size = UDim2.fromOffset(40, 40),
	Position = UDim2.new(1, -10, 0, 5),
	AnchorPoint = Vector2.new(1, 0),
	BackgroundColor3 = Color3.fromHex("#cc3344"),
	TextColor3 = WHITE,
	TextSize = 22,
	Font = Enum.Font.GothamBold,
	Parent = container,
}, {
	create("UICorner", {CornerRadius = UDim.new(0, 8)}),
})

-- Tabs bar
local tabsBar = create("Frame", {
	Name = "TabsBar",
	Size = UDim2.new(1, -40, 0, 48),
	Position = UDim2.fromOffset(20, 55),
	BackgroundTransparency = 1,
	Parent = container,
})

create("UIListLayout", {
	FillDirection = Enum.FillDirection.Horizontal,
	HorizontalAlignment = Enum.HorizontalAlignment.Center,
	Padding = UDim.new(0, 8),
	Parent = tabsBar,
})

-- Content area
local contentArea = create("Frame", {
	Name = "ContentArea",
	Size = UDim2.new(1, -40, 1, -120),
	Position = UDim2.fromOffset(20, 110),
	BackgroundTransparency = 1,
	Parent = container,
})

-- Left panel: level + XP ring
local leftPanel = create("Frame", {
	Name = "LeftPanel",
	Size = UDim2.new(0.3, 0, 1, 0),
	BackgroundColor3 = GREY_DARK,
	BackgroundTransparency = 0,
	BorderSizePixel = 0,
	Parent = contentArea,
}, {
	create("UICorner", {CornerRadius = UDim.new(0, 12)}),
})

-- Right panel: skill tree
local rightPanel = create("Frame", {
	Name = "RightPanel",
	Size = UDim2.new(0.68, 0, 1, 0),
	Position = UDim2.fromScale(0.32, 0),
	BackgroundColor3 = GREY_DARK,
	BackgroundTransparency = 0,
	BorderSizePixel = 0,
	ClipsDescendants = true,
	Parent = contentArea,
}, {
	create("UICorner", {CornerRadius = UDim.new(0, 12)}),
})

-- Scrolling frame for tree nodes
local treeScroll = create("ScrollingFrame", {
	Name = "TreeScroll",
	Size = UDim2.new(1, -20, 1, -20),
	Position = UDim2.fromOffset(10, 10),
	BackgroundTransparency = 1,
	BorderSizePixel = 0,
	ScrollBarThickness = 6,
	ScrollBarImageColor3 = GOLD_DIM,
	CanvasSize = UDim2.fromOffset(0, 0),
	AutomaticCanvasSize = Enum.AutomaticSize.Y,
	Parent = rightPanel,
})

-- Left panel elements
local skillIconLabel = create("TextLabel", {
	Name = "SkillIcon",
	Size = UDim2.new(1, 0, 0, 50),
	Position = UDim2.fromOffset(0, 20),
	BackgroundTransparency = 1,
	TextColor3 = GOLD,
	TextSize = 36,
	Font = Enum.Font.GothamBold,
	Text = "",
	Parent = leftPanel,
})

local skillNameLabel = create("TextLabel", {
	Name = "SkillName",
	Size = UDim2.new(1, 0, 0, 30),
	Position = UDim2.fromOffset(0, 70),
	BackgroundTransparency = 1,
	TextColor3 = GOLD,
	TextSize = 22,
	Font = Enum.Font.GothamBold,
	Text = "",
	Parent = leftPanel,
})

local levelLabel = create("TextLabel", {
	Name = "Level",
	Size = UDim2.new(1, 0, 0, 80),
	Position = UDim2.fromOffset(0, 110),
	BackgroundTransparency = 1,
	TextColor3 = WHITE,
	TextSize = 64,
	Font = Enum.Font.GothamBold,
	Text = "1",
	Parent = leftPanel,
})

-- XP ring (using frames to simulate a circular progress ring)
local ringContainer = create("Frame", {
	Name = "RingContainer",
	Size = UDim2.fromOffset(160, 160),
	Position = UDim2.new(0.5, 0, 0, 200),
	AnchorPoint = Vector2.new(0.5, 0),
	BackgroundTransparency = 1,
	Parent = leftPanel,
})

-- Background ring circle
local ringBg = create("Frame", {
	Name = "RingBg",
	Size = UDim2.fromScale(1, 1),
	BackgroundColor3 = Color3.fromHex("#222233"),
	Parent = ringContainer,
}, {
	create("UICorner", {CornerRadius = UDim.new(0.5, 0)}),
	create("UIStroke", {Color = GREY, Thickness = 6}),
})

-- Inner circle
local ringInner = create("Frame", {
	Name = "RingInner",
	Size = UDim2.fromScale(0.75, 0.75),
	Position = UDim2.fromScale(0.5, 0.5),
	AnchorPoint = Vector2.new(0.5, 0.5),
	BackgroundColor3 = GREY_DARK,
	Parent = ringContainer,
}, {
	create("UICorner", {CornerRadius = UDim.new(0.5, 0)}),
})

-- Progress arc (we'll use a UIStroke on the bg ring and tween its thickness/color)
local ringStroke = create("UIStroke", {
	Name = "ProgressStroke",
	Color = GOLD,
	Thickness = 6,
	Parent = ringBg,
})

-- XP percentage in center of ring
local xpPercentLabel = create("TextLabel", {
	Name = "XPPercent",
	Size = UDim2.fromScale(1, 0.4),
	Position = UDim2.fromScale(0.5, 0.35),
	AnchorPoint = Vector2.new(0.5, 0),
	BackgroundTransparency = 1,
	TextColor3 = GOLD,
	TextSize = 28,
	Font = Enum.Font.GothamBold,
	Text = "0%",
	Parent = ringInner,
})

local xpDetailLabel = create("TextLabel", {
	Name = "XPDetail",
	Size = UDim2.fromScale(1, 0.3),
	Position = UDim2.fromScale(0.5, 0.6),
	AnchorPoint = Vector2.new(0.5, 0),
	BackgroundTransparency = 1,
	TextColor3 = GREY_LIGHT,
	TextSize = 12,
	Font = Enum.Font.Gotham,
	Text = "0 / 100 XP",
	TextWrapped = true,
	Parent = ringInner,
})

-- Total XP label
local totalXPLabel = create("TextLabel", {
	Name = "TotalXP",
	Size = UDim2.new(1, 0, 0, 30),
	Position = UDim2.fromOffset(0, 375),
	BackgroundTransparency = 1,
	TextColor3 = GREY_LIGHT,
	TextSize = 16,
	Font = Enum.Font.Gotham,
	Text = "Total XP: 0",
	Parent = leftPanel,
})

-- XP bar (linear, below ring)
local xpBarBg = create("Frame", {
	Name = "XPBarBg",
	Size = UDim2.new(0.8, 0, 0, 12),
	Position = UDim2.new(0.5, 0, 0, 410),
	AnchorPoint = Vector2.new(0.5, 0),
	BackgroundColor3 = Color3.fromHex("#222233"),
	Parent = leftPanel,
}, {
	create("UICorner", {CornerRadius = UDim.new(0, 6)}),
})

local xpBarFill = create("Frame", {
	Name = "XPBarFill",
	Size = UDim2.fromScale(0, 1),
	BackgroundColor3 = GOLD,
	Parent = xpBarBg,
}, {
	create("UICorner", {CornerRadius = UDim.new(0, 6)}),
})

local nextLevelLabel = create("TextLabel", {
	Name = "NextLevel",
	Size = UDim2.new(1, 0, 0, 20),
	Position = UDim2.fromOffset(0, 428),
	BackgroundTransparency = 1,
	TextColor3 = GREY_LIGHT,
	TextSize = 13,
	Font = Enum.Font.Gotham,
	Text = "",
	Parent = leftPanel,
})

-- Hover tooltip
local tooltip = create("Frame", {
	Name = "Tooltip",
	Size = UDim2.fromOffset(280, 80),
	BackgroundColor3 = Color3.fromHex("#111122"),
	BorderSizePixel = 0,
	Visible = false,
	ZIndex = 100,
	Parent = screenGui,
}, {
	create("UICorner", {CornerRadius = UDim.new(0, 8)}),
	create("UIStroke", {Color = GOLD_DIM, Thickness = 1}),
	create("UIPadding", {
		PaddingLeft = UDim.new(0, 10),
		PaddingRight = UDim.new(0, 10),
		PaddingTop = UDim.new(0, 8),
		PaddingBottom = UDim.new(0, 8),
	}),
})

local tooltipName = create("TextLabel", {
	Name = "Name",
	Size = UDim2.new(1, 0, 0, 22),
	BackgroundTransparency = 1,
	TextColor3 = GOLD,
	TextSize = 16,
	Font = Enum.Font.GothamBold,
	TextXAlignment = Enum.TextXAlignment.Left,
	ZIndex = 101,
	Parent = tooltip,
})

local tooltipLevel = create("TextLabel", {
	Name = "Level",
	Size = UDim2.new(1, 0, 0, 18),
	Position = UDim2.fromOffset(0, 22),
	BackgroundTransparency = 1,
	TextColor3 = GREY_LIGHT,
	TextSize = 13,
	Font = Enum.Font.Gotham,
	TextXAlignment = Enum.TextXAlignment.Left,
	ZIndex = 101,
	Parent = tooltip,
})

local tooltipDesc = create("TextLabel", {
	Name = "Desc",
	Size = UDim2.new(1, 0, 0, 20),
	Position = UDim2.fromOffset(0, 42),
	BackgroundTransparency = 1,
	TextColor3 = WHITE,
	TextSize = 14,
	Font = Enum.Font.Gotham,
	TextXAlignment = Enum.TextXAlignment.Left,
	TextWrapped = true,
	ZIndex = 101,
	Parent = tooltip,
})

--------------------------------------------------------------------------------
-- Tab buttons
--------------------------------------------------------------------------------
local tabButtons = {}

for _, skillName in SKILL_ORDER do
	local tree = SKILL_TREES[skillName]
	local btn = create("TextButton", {
		Name = "Tab_" .. skillName,
		Size = UDim2.fromOffset(140, 40),
		BackgroundColor3 = GREY_DARK,
		TextColor3 = GREY_LIGHT,
		Text = tree.icon .. " " .. skillName,
		TextSize = 16,
		Font = Enum.Font.GothamBold,
		AutoButtonColor = false,
		Parent = tabsBar,
	}, {
		create("UICorner", {CornerRadius = UDim.new(0, 8)}),
		create("UIStroke", {Color = GREY, Thickness = 1}),
	})

	tabButtons[skillName] = btn

	btn.MouseButton1Click:Connect(function()
		selectedSkill = skillName
		refreshUI()
	end)

	btn.MouseEnter:Connect(function()
		if selectedSkill ~= skillName then
			TweenService:Create(btn, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromHex("#3a3a5e")}):Play()
		end
	end)
	btn.MouseLeave:Connect(function()
		if selectedSkill ~= skillName then
			TweenService:Create(btn, TweenInfo.new(0.15), {BackgroundColor3 = GREY_DARK}):Play()
		end
	end)
end

--------------------------------------------------------------------------------
-- Build tree nodes
--------------------------------------------------------------------------------
local NODE_HEIGHT = 80
local NODE_SPACING = 16
local NODE_WIDTH_SCALE = 0.85

local function clearPulseConnections()
	for _, conn in pulseConnections do
		conn:Disconnect()
	end
	table.clear(pulseConnections)
end

local function buildTreeNodes(skillName: string, currentLevel: number)
	-- Clear existing
	clearPulseConnections()
	for _, child in treeScroll:GetChildren() do
		child:Destroy()
	end

	local tree = SKILL_TREES[skillName]
	if not tree then return end

	local nodes = tree.nodes
	local nextUnlockIndex = nil

	-- Find next unlock
	for i, node in nodes do
		if node.level > currentLevel then
			nextUnlockIndex = i
			break
		end
	end

	for i, node in nodes do
		local unlocked = currentLevel >= node.level
		local isNext = (i == nextUnlockIndex)
		local yPos = (i - 1) * (NODE_HEIGHT + NODE_SPACING) + 20

		-- Connector line to previous node
		if i > 1 then
			local prevUnlocked = currentLevel >= nodes[i - 1].level
			local lineY = yPos - NODE_SPACING
			create("Frame", {
				Name = "Line_" .. i,
				Size = UDim2.new(0, 3, 0, NODE_SPACING),
				Position = UDim2.new(0.5, -1, 0, lineY),
				BackgroundColor3 = if unlocked then GOLD else GREY,
				BorderSizePixel = 0,
				Parent = treeScroll,
			})
		end

		-- Node frame
		local nodeFrame = create("Frame", {
			Name = "Node_" .. i,
			Size = UDim2.new(NODE_WIDTH_SCALE, 0, 0, NODE_HEIGHT),
			Position = UDim2.new((1 - NODE_WIDTH_SCALE) / 2, 0, 0, yPos),
			BackgroundColor3 = if unlocked then Color3.fromHex("#2a2a1e") else LOCKED_COLOR,
			BorderSizePixel = 0,
			Parent = treeScroll,
		}, {
			create("UICorner", {CornerRadius = UDim.new(0, 10)}),
			create("UIStroke", {
				Name = "NodeStroke",
				Color = if unlocked then GOLD elseif isNext then NEXT_GLOW else GREY,
				Thickness = if isNext then 2 else 1,
			}),
		})

		-- Status icon (left side)
		local statusIcon = create("TextLabel", {
			Name = "StatusIcon",
			Size = UDim2.fromOffset(40, 40),
			Position = UDim2.fromOffset(12, 20),
			BackgroundColor3 = if unlocked then GOLD else GREY,
			BackgroundTransparency = 0,
			TextColor3 = if unlocked then DARK_BG else GREY_LIGHT,
			TextSize = 20,
			Font = Enum.Font.GothamBold,
			Text = if unlocked then "‚úì" else "üîí",
			Parent = nodeFrame,
		}, {
			create("UICorner", {CornerRadius = UDim.new(0.5, 0)}),
		})

		-- Level badge
		create("TextLabel", {
			Name = "LevelBadge",
			Size = UDim2.fromOffset(50, 24),
			Position = UDim2.new(1, -12, 0, 8),
			AnchorPoint = Vector2.new(1, 0),
			BackgroundColor3 = if unlocked then GOLD else GREY,
			TextColor3 = DARK_BG,
			TextSize = 13,
			Font = Enum.Font.GothamBold,
			Text = "Lv " .. node.level,
			Parent = nodeFrame,
		}, {
			create("UICorner", {CornerRadius = UDim.new(0, 6)}),
		})

		-- Node name
		create("TextLabel", {
			Name = "NodeName",
			Size = UDim2.new(1, -120, 0, 24),
			Position = UDim2.fromOffset(62, 14),
			BackgroundTransparency = 1,
			TextColor3 = if unlocked then GOLD else GREY_LIGHT,
			TextSize = 16,
			Font = Enum.Font.GothamBold,
			Text = node.name,
			TextXAlignment = Enum.TextXAlignment.Left,
			TextTruncate = Enum.TextTruncate.AtEnd,
			Parent = nodeFrame,
		})

		-- Description
		create("TextLabel", {
			Name = "NodeDesc",
			Size = UDim2.new(1, -120, 0, 20),
			Position = UDim2.fromOffset(62, 40),
			BackgroundTransparency = 1,
			TextColor3 = if unlocked then WHITE else GREY,
			TextSize = 13,
			Font = Enum.Font.Gotham,
			Text = node.desc,
			TextXAlignment = Enum.TextXAlignment.Left,
			TextTruncate = Enum.TextTruncate.AtEnd,
			Parent = nodeFrame,
		})

		-- Pulse animation for next unlock
		if isNext then
			local stroke = nodeFrame:FindFirstChild("NodeStroke")
			if stroke then
				local pulseUp = true
				local elapsed = 0
				local conn = RunService.Heartbeat:Connect(function(dt)
					elapsed += dt * 2
					local alpha = (math.sin(elapsed * math.pi) + 1) / 2
					stroke.Transparency = alpha * 0.6
					stroke.Thickness = 2 + alpha * 2
				end)
				table.insert(pulseConnections, conn)
			end
		end

		-- Hover tooltip
		local hoverBtn = create("TextButton", {
			Name = "HoverArea",
			Size = UDim2.fromScale(1, 1),
			BackgroundTransparency = 1,
			Text = "",
			ZIndex = 10,
			Parent = nodeFrame,
		})

		hoverBtn.MouseEnter:Connect(function()
			tooltip.Visible = true
			tooltipName.Text = node.name
			tooltipLevel.Text = "Required Level: " .. node.level .. (if unlocked then "  ‚úì Unlocked" else "  üîí Locked")
			tooltipDesc.Text = node.desc
		end)
		hoverBtn.MouseMoved:Connect(function(x, y)
			tooltip.Position = UDim2.fromOffset(x + 15, y + 15)
		end)
		hoverBtn.MouseLeave:Connect(function()
			tooltip.Visible = false
		end)
	end
end

--------------------------------------------------------------------------------
-- Refresh UI
--------------------------------------------------------------------------------
function refreshUI()
	local data = skillData[selectedSkill] or {level = 1, xp = 0}
	local lv = data.level
	local xp = data.xp

	-- Tab highlights
	for name, btn in tabButtons do
		local isSelected = (name == selectedSkill)
		local tabData = skillData[name] or {level = 1}
		btn.BackgroundColor3 = if isSelected then GOLD else GREY_DARK
		btn.TextColor3 = if isSelected then DARK_BG else GREY_LIGHT

		local stroke = btn:FindFirstChildOfClass("UIStroke")
		if stroke then
			stroke.Color = if isSelected then GOLD else GREY
		end
	end

	-- Left panel
	local tree = SKILL_TREES[selectedSkill]
	skillIconLabel.Text = tree.icon
	skillNameLabel.Text = selectedSkill
	levelLabel.Text = tostring(lv)

	-- XP calculations
	local currentLevelXP = xpForLevel(lv)
	local nextLevelXP = xpForLevel(math.min(lv + 1, 99))
	local xpIntoLevel = xp - currentLevelXP
	local xpNeeded = nextLevelXP - currentLevelXP

	local progress = 0
	if lv >= 99 then
		progress = 1
		xpPercentLabel.Text = "MAX"
		xpDetailLabel.Text = "Level 99!"
		nextLevelLabel.Text = "Maximum level reached!"
	else
		progress = math.clamp(if xpNeeded > 0 then xpIntoLevel / xpNeeded else 0, 0, 1)
		xpPercentLabel.Text = math.floor(progress * 100) .. "%"
		xpDetailLabel.Text = string.format("%s / %s", tostring(math.floor(xpIntoLevel)), tostring(math.floor(xpNeeded)))
		nextLevelLabel.Text = string.format("Next level: %d XP needed", math.floor(xpNeeded - xpIntoLevel))
	end

	totalXPLabel.Text = "Total XP: " .. string.format("%d", xp)

	-- XP bar fill
	TweenService:Create(xpBarFill, TweenInfo.new(0.3, Enum.EasingStyle.Quad), {
		Size = UDim2.fromScale(progress, 1)
	}):Play()

	-- Ring stroke color based on progress
	ringStroke.Color = GOLD

	-- Build tree
	buildTreeNodes(selectedSkill, lv)
end

--------------------------------------------------------------------------------
-- Fetch data from server
--------------------------------------------------------------------------------
local function fetchSkillData()
	local ok, result = pcall(function()
		return getSkillData:InvokeServer()
	end)
	if ok and result then
		for _, skillName in SKILL_ORDER do
			local d = result[skillName]
			if d then
				local lv = d.level or levelFromXP(d.xp or 0)
				skillData[skillName] = {level = lv, xp = d.xp or 0}
			else
				skillData[skillName] = {level = 1, xp = 0}
			end
		end
	else
		-- Fallback: default data
		for _, skillName in SKILL_ORDER do
			if not skillData[skillName] then
				skillData[skillName] = {level = 1, xp = 0}
			end
		end
	end
end

--------------------------------------------------------------------------------
-- Toggle open/close
--------------------------------------------------------------------------------
local function toggleUI()
	isOpen = not isOpen
	if isOpen then
		fetchSkillData()
		screenGui.Enabled = true
		-- Fade in
		overlay.BackgroundTransparency = 1
		TweenService:Create(overlay, TweenInfo.new(0.25), {BackgroundTransparency = 0.1}):Play()
		-- Scale in
		container.Size = UDim2.fromScale(0.8, 0.8)
		TweenService:Create(container, TweenInfo.new(0.25, Enum.EasingStyle.Back), {
			Size = UDim2.fromScale(0.88, 0.88)
		}):Play()
		refreshUI()
	else
		clearPulseConnections()
		tooltip.Visible = false
		TweenService:Create(overlay, TweenInfo.new(0.2), {BackgroundTransparency = 1}):Play()
		TweenService:Create(container, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {
			Size = UDim2.fromScale(0.8, 0.8)
		}):Play()
		task.delay(0.2, function()
			if not isOpen then
				screenGui.Enabled = false
			end
		end)
	end
end

--------------------------------------------------------------------------------
-- Input
--------------------------------------------------------------------------------
UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end
	if input.KeyCode == Enum.KeyCode.K then
		toggleUI()
	end
end)

closeBtn.MouseButton1Click:Connect(function()
	if isOpen then
		toggleUI()
	end
end)

-- Close on overlay click (outside container)
overlay.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		-- Check if click is outside container
		local mouse = UserInputService:GetMouseLocation()
		local absPos = container.AbsolutePosition
		local absSize = container.AbsoluteSize
		if mouse.X < absPos.X or mouse.X > absPos.X + absSize.X
			or mouse.Y < absPos.Y or mouse.Y > absPos.Y + absSize.Y then
			if isOpen then
				toggleUI()
			end
		end
	end
end)

print("[SkillTreeUI] Loaded!")
]]></string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="75">
        <Properties>
          <string name="Name">StatsPanel</string>
          <string name="Source"><![CDATA[--[[
	StatsPanel.client.lua
	RuneScape-style Stats / Inventory / Equipment panel
	Toggle: B key or on-screen button
	REWRITTEN: Simple, no CanvasGroup, no fancy helpers ‚Äî just works.
]]

local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[StatsPanel] Starting...")

-- Remotes
local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
if not Remotes then warn("[StatsPanel] No Remotes folder!") return end

local GetStatsPanel = Remotes:WaitForChild("GetStatsPanel", 10)
if not GetStatsPanel then warn("[StatsPanel] No GetStatsPanel remote!") return end

print("[StatsPanel] Remotes found")

-- Load modules early so refreshData can use them
local Modules = ReplicatedStorage:WaitForChild("Modules", 10)
local ItemDatabase = require(Modules:WaitForChild("ItemDatabase"))
local ItemVisuals = require(Modules:WaitForChild("ItemVisuals"))

-- Colors
local BG = Color3.fromRGB(26, 26, 46)
local GOLD = Color3.fromRGB(240, 192, 64)
local DARK = Color3.fromRGB(17, 17, 34)
local BORDER = Color3.fromRGB(139, 117, 54)
local TEXT = Color3.fromRGB(220, 220, 210)
local TAB_ON = Color3.fromRGB(42, 42, 78)
local TAB_OFF = Color3.fromRGB(18, 18, 31)

local RARITY = {
	common = Color3.fromRGB(157, 157, 157),
	uncommon = Color3.fromRGB(30, 255, 0),
	rare = Color3.fromRGB(0, 112, 221),
	epic = Color3.fromRGB(163, 53, 238),
	legendary = Color3.fromRGB(255, 128, 0),
}

local SKILL_LIST = {
	{name = "Mining", icon = "Pick", color = Color3.fromRGB(139, 115, 85)},
	{name = "Woodcutting", icon = "Axe", color = Color3.fromRGB(34, 139, 34)},
	{name = "Fishing", icon = "Fish", color = Color3.fromRGB(70, 130, 180)},
	{name = "Smithing", icon = "Ham", color = Color3.fromRGB(176, 176, 176)},
	{name = "Cooking", icon = "Cook", color = Color3.fromRGB(255, 140, 0)},
	{name = "Strength", icon = "Str", color = Color3.fromRGB(220, 20, 60)},
	{name = "Defense", icon = "Def", color = Color3.fromRGB(100, 149, 237)},
	{name = "Ranged", icon = "Bow", color = Color3.fromRGB(0, 180, 0)},
	{name = "Fletching", icon = "Flt", color = Color3.fromRGB(180, 140, 60)},
	{name = "Prayer", icon = "Pry", color = Color3.fromRGB(220, 220, 255)},
}

local PANEL_W = 230
local PANEL_H = 440

-----------------------------------------------------------------------
-- SCREEN GUI
-----------------------------------------------------------------------
local gui = Instance.new("ScreenGui")
gui.Name = "StatsPanelGui"
gui.ResetOnSpawn = false
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
gui.Parent = playerGui

-----------------------------------------------------------------------
-- TOGGLE BUTTON ‚Äî left side to avoid minimap conflict
-----------------------------------------------------------------------
local toggleBtn = Instance.new("TextButton")
toggleBtn.Name = "StatsToggle"
toggleBtn.Size = UDim2.new(0, 44, 0, 44)
toggleBtn.Position = UDim2.new(0, 10, 0.5, -22)
toggleBtn.BackgroundColor3 = BG
toggleBtn.Text = "B"
toggleBtn.TextSize = 18
toggleBtn.Font = Enum.Font.GothamBold
toggleBtn.TextColor3 = GOLD
toggleBtn.Parent = gui
local tc = Instance.new("UICorner")
tc.CornerRadius = UDim.new(0, 8)
tc.Parent = toggleBtn
local ts = Instance.new("UIStroke")
ts.Color = GOLD
ts.Thickness = 2
ts.Parent = toggleBtn

-----------------------------------------------------------------------
-- MAIN PANEL
-----------------------------------------------------------------------
local panel = Instance.new("Frame")
panel.Name = "StatsPanel"
panel.Size = UDim2.new(0, PANEL_W, 0, PANEL_H)
panel.Position = UDim2.new(0, 60, 0.5, -(PANEL_H / 2))
panel.BackgroundColor3 = BG
panel.BackgroundTransparency = 0.05
panel.Visible = false
panel.Parent = gui
local pc = Instance.new("UICorner")
pc.CornerRadius = UDim.new(0, 8)
pc.Parent = panel
local ps = Instance.new("UIStroke")
ps.Color = GOLD
ps.Thickness = 3
ps.Parent = panel

-----------------------------------------------------------------------
-- TAB BUTTONS
-----------------------------------------------------------------------
local TAB_NAMES = {"Skills", "Inventory", "Loadout"}
local tabBtns = {}
local tabFrames = {}
local currentTab = 1

local tabBar = Instance.new("Frame")
tabBar.Name = "TabBar"
tabBar.Size = UDim2.new(1, -10, 0, 30)
tabBar.Position = UDim2.new(0, 5, 0, 5)
tabBar.BackgroundTransparency = 1
tabBar.Parent = panel

for i, name in ipairs(TAB_NAMES) do
	local btn = Instance.new("TextButton")
	btn.Name = "Tab_" .. name
	btn.Size = UDim2.new(1/3, -3, 1, 0)
	btn.Position = UDim2.new((i-1)/3, 1, 0, 0)
	btn.BackgroundColor3 = i == 1 and TAB_ON or TAB_OFF
	btn.Text = name
	btn.TextSize = 12
	btn.Font = Enum.Font.GothamBold
	btn.TextColor3 = i == 1 and GOLD or TEXT
	btn.Parent = tabBar
	local bc = Instance.new("UICorner")
	bc.CornerRadius = UDim.new(0, 4)
	bc.Parent = btn
	tabBtns[i] = btn
end

-- Content area
local content = Instance.new("Frame")
content.Name = "Content"
content.Size = UDim2.new(1, -10, 1, -42)
content.Position = UDim2.new(0, 5, 0, 38)
content.BackgroundTransparency = 1
content.ClipsDescendants = true
content.Parent = panel

-----------------------------------------------------------------------
-- SKILLS TAB
-----------------------------------------------------------------------
local skillsFrame = Instance.new("Frame")
skillsFrame.Name = "Skills"
skillsFrame.Size = UDim2.new(1, 0, 1, 0)
skillsFrame.BackgroundTransparency = 1
skillsFrame.Parent = content

local skillLevelLabels = {}
local COLS = 3
local cellW = math.floor((PANEL_W - 14) / COLS)
local cellH = 48

for i, sk in ipairs(SKILL_LIST) do
	local row = math.floor((i-1) / COLS)
	local col = (i-1) % COLS

	local cell = Instance.new("Frame")
	cell.Name = "Cell_" .. sk.name
	cell.Size = UDim2.new(0, cellW - 4, 0, cellH - 4)
	cell.Position = UDim2.new(0, col * cellW + 2, 0, row * cellH + 2)
	cell.BackgroundColor3 = DARK
	cell.Parent = skillsFrame
	local cc = Instance.new("UICorner")
	cc.CornerRadius = UDim.new(0, 4)
	cc.Parent = cell

	-- Color bar on left
	local bar = Instance.new("Frame")
	bar.Size = UDim2.new(0, 4, 1, -4)
	bar.Position = UDim2.new(0, 2, 0, 2)
	bar.BackgroundColor3 = sk.color
	bar.BorderSizePixel = 0
	bar.Parent = cell

	-- Icon text
	local iconLbl = Instance.new("TextLabel")
	iconLbl.Size = UDim2.new(0, 30, 0, 18)
	iconLbl.Position = UDim2.new(0, 8, 0, 2)
	iconLbl.BackgroundTransparency = 1
	iconLbl.Text = sk.icon
	iconLbl.TextSize = 10
	iconLbl.Font = Enum.Font.GothamBold
	iconLbl.TextColor3 = sk.color
	iconLbl.Parent = cell

	-- Level number (big)
	local lvl = Instance.new("TextLabel")
	lvl.Name = "Level"
	lvl.Size = UDim2.new(1, -10, 0, 22)
	lvl.Position = UDim2.new(0, 8, 0, 14)
	lvl.BackgroundTransparency = 1
	lvl.Text = "1"
	lvl.TextSize = 18
	lvl.Font = Enum.Font.GothamBold
	lvl.TextColor3 = GOLD
	lvl.TextXAlignment = Enum.TextXAlignment.Right
	lvl.Parent = cell

	-- Skill name
	local nm = Instance.new("TextLabel")
	nm.Size = UDim2.new(1, -4, 0, 12)
	nm.Position = UDim2.new(0, 2, 1, -13)
	nm.BackgroundTransparency = 1
	nm.Text = sk.name
	nm.TextSize = 9
	nm.Font = Enum.Font.Gotham
	nm.TextColor3 = Color3.fromRGB(140, 140, 140)
	nm.Parent = cell

	skillLevelLabels[sk.name] = lvl
end

-- Total level
local totalRows = math.ceil(#SKILL_LIST / COLS)
local totalLbl = Instance.new("TextLabel")
totalLbl.Name = "TotalLevel"
totalLbl.Size = UDim2.new(1, 0, 0, 26)
totalLbl.Position = UDim2.new(0, 0, 0, totalRows * cellH + 8)
totalLbl.BackgroundColor3 = DARK
totalLbl.Text = "Total Level: 6"
totalLbl.TextSize = 14
totalLbl.Font = Enum.Font.GothamBold
totalLbl.TextColor3 = GOLD
totalLbl.Parent = skillsFrame
local tlc = Instance.new("UICorner")
tlc.CornerRadius = UDim.new(0, 4)
tlc.Parent = totalLbl

-- Gold display
local goldLbl = Instance.new("TextLabel")
goldLbl.Name = "GoldDisplay"
goldLbl.Size = UDim2.new(1, 0, 0, 22)
goldLbl.Position = UDim2.new(0, 0, 0, totalRows * cellH + 38)
goldLbl.BackgroundColor3 = DARK
goldLbl.Text = "Gold: 0"
goldLbl.TextSize = 13
goldLbl.Font = Enum.Font.GothamBold
goldLbl.TextColor3 = Color3.fromRGB(255, 215, 0)
goldLbl.Parent = skillsFrame
local gc = Instance.new("UICorner")
gc.CornerRadius = UDim.new(0, 4)
gc.Parent = goldLbl

-----------------------------------------------------------------------
-- INVENTORY TAB
-----------------------------------------------------------------------
local invFrame = Instance.new("Frame")
invFrame.Name = "Inventory"
invFrame.Size = UDim2.new(1, 0, 1, 0)
invFrame.BackgroundTransparency = 1
invFrame.Visible = false
invFrame.Parent = content

local invSlots = {}
local INV_COLS = 4
local INV_TOTAL = 28
local slotSize = math.floor((PANEL_W - 14) / INV_COLS)

for i = 1, INV_TOTAL do
	local row = math.floor((i-1) / INV_COLS)
	local col = (i-1) % INV_COLS

	local cell = Instance.new("Frame")
	cell.Name = "Slot" .. i
	cell.Size = UDim2.new(0, slotSize - 3, 0, slotSize - 3)
	cell.Position = UDim2.new(0, col * slotSize + 1, 0, row * slotSize + 1)
	cell.BackgroundColor3 = DARK
	cell.Parent = invFrame
	local sc = Instance.new("UICorner")
	sc.CornerRadius = UDim.new(0, 3)
	sc.Parent = cell

	-- Rarity border stroke on the cell itself
	local itemStroke = Instance.new("UIStroke")
	itemStroke.Name = "RarityStroke"
	itemStroke.Color = Color3.fromRGB(60, 60, 70)
	itemStroke.Thickness = 1.5
	itemStroke.Transparency = 0.5
	itemStroke.Parent = cell

	-- Icon background that fills the slot with rarity color
	local itemColor = Instance.new("Frame")
	itemColor.Name = "Color"
	itemColor.Size = UDim2.new(1, -4, 0, 28)
	itemColor.Position = UDim2.new(0, 2, 0, 2)
	itemColor.BackgroundTransparency = 1
	itemColor.Parent = cell
	local icc = Instance.new("UICorner")
	icc.CornerRadius = UDim.new(0, 4)
	icc.Parent = itemColor

	-- Item icon (emoji)
	local itemIcon = Instance.new("TextLabel")
	itemIcon.Name = "Icon"
	itemIcon.Size = UDim2.new(1, 0, 0, 24)
	itemIcon.Position = UDim2.new(0, 0, 0, 3)
	itemIcon.BackgroundTransparency = 1
	itemIcon.Text = ""
	itemIcon.TextSize = 20
	itemIcon.Font = Enum.Font.GothamBold
	itemIcon.TextColor3 = Color3.fromRGB(255, 255, 255)
	itemIcon.Parent = cell

	local itemName = Instance.new("TextLabel")
	itemName.Name = "ItemName"
	itemName.Size = UDim2.new(1, -2, 0, 10)
	itemName.Position = UDim2.new(0, 1, 0, 28)
	itemName.BackgroundTransparency = 1
	itemName.Text = ""
	itemName.TextSize = 7
	itemName.Font = Enum.Font.Gotham
	itemName.TextColor3 = TEXT
	itemName.TextTruncate = Enum.TextTruncate.AtEnd
	itemName.Parent = cell

	local countLbl = Instance.new("TextLabel")
	countLbl.Name = "Count"
	countLbl.Size = UDim2.new(1, 0, 0, 10)
	countLbl.Position = UDim2.new(0, 0, 1, -11)
	countLbl.BackgroundTransparency = 1
	countLbl.Text = ""
	countLbl.TextSize = 9
	countLbl.Font = Enum.Font.GothamBold
	countLbl.TextColor3 = GOLD
	countLbl.Parent = cell

	-- Click button overlay for equip/use
	local clickBtn = Instance.new("TextButton")
	clickBtn.Name = "Click"
	clickBtn.Size = UDim2.new(1, 0, 1, 0)
	clickBtn.BackgroundTransparency = 1
	clickBtn.Text = ""
	clickBtn.Parent = cell

	invSlots[i] = {cell = cell, color = itemColor, name = itemName, count = countLbl, btn = clickBtn, itemData = nil, stroke = itemStroke, icon = itemIcon}
end

-- Set up the global clear function now that invSlots exist
_G.ClearInventorySelection = function()
	for j = 1, INV_TOTAL do
		local item = invSlots[j].itemData
		if item and item.name then
			local rarity = item.rarity or "common"
			invSlots[j].stroke.Color = RARITY[rarity] or RARITY.common
			invSlots[j].stroke.Thickness = 2
		else
			invSlots[j].stroke.Color = Color3.fromRGB(60, 60, 70)
			invSlots[j].stroke.Thickness = 1.5
		end
	end
end

-----------------------------------------------------------------------
-- LOADOUT TAB
-----------------------------------------------------------------------
local loadFrame = Instance.new("Frame")
loadFrame.Name = "Loadout"
loadFrame.Size = UDim2.new(1, 0, 1, 0)
loadFrame.BackgroundTransparency = 1
loadFrame.Visible = false
loadFrame.Parent = content

-- Combat level
local combatLbl = Instance.new("TextLabel")
combatLbl.Size = UDim2.new(1, 0, 0, 30)
combatLbl.Position = UDim2.new(0, 0, 0, 0)
combatLbl.BackgroundColor3 = DARK
combatLbl.Text = "Combat Level: 1"
combatLbl.TextSize = 16
combatLbl.Font = Enum.Font.GothamBold
combatLbl.TextColor3 = GOLD
combatLbl.Parent = loadFrame
local clc = Instance.new("UICorner")
clc.CornerRadius = UDim.new(0, 4)
clc.Parent = combatLbl

-- Equipment slots
local SLOT_LAYOUT = {
	{name = "Head",   label = "Head",   x = 0.5, y = 45},
	{name = "Weapon", label = "Weapon", x = 0.15, y = 110},
	{name = "Body",   label = "Body",   x = 0.5, y = 110},
	{name = "Shield", label = "Shield", x = 0.85, y = 110},
	{name = "Legs",   label = "Legs",   x = 0.5, y = 175},
	{name = "Tool",   label = "Tool",   x = 0.15, y = 175},
}

local equipLabels = {}
for _, info in ipairs(SLOT_LAYOUT) do
	local slot = Instance.new("Frame")
	slot.Name = "Equip_" .. info.name
	slot.Size = UDim2.new(0, 60, 0, 55)
	slot.Position = UDim2.new(info.x, -30, 0, info.y)
	slot.BackgroundColor3 = DARK
	slot.Parent = loadFrame
	local slc = Instance.new("UICorner")
	slc.CornerRadius = UDim.new(0, 4)
	slc.Parent = slot
	local sls = Instance.new("UIStroke")
	sls.Color = BORDER
	sls.Thickness = 1
	sls.Parent = slot

	local slotTitle = Instance.new("TextLabel")
	slotTitle.Size = UDim2.new(1, 0, 0, 14)
	slotTitle.Position = UDim2.new(0, 0, 0, 2)
	slotTitle.BackgroundTransparency = 1
	slotTitle.Text = info.label
	slotTitle.TextSize = 10
	slotTitle.Font = Enum.Font.GothamBold
	slotTitle.TextColor3 = BORDER
	slotTitle.Parent = slot

	local itemLbl = Instance.new("TextLabel")
	itemLbl.Name = "ItemName"
	itemLbl.Size = UDim2.new(1, -4, 0, 30)
	itemLbl.Position = UDim2.new(0, 2, 0, 18)
	itemLbl.BackgroundTransparency = 1
	itemLbl.Text = "Empty"
	itemLbl.TextSize = 9
	itemLbl.Font = Enum.Font.Gotham
	itemLbl.TextColor3 = Color3.fromRGB(100, 100, 100)
	itemLbl.TextWrapped = true
	itemLbl.Parent = slot

	equipLabels[info.name] = itemLbl
end

-----------------------------------------------------------------------
-- TAB FRAMES
-----------------------------------------------------------------------
tabFrames = {skillsFrame, invFrame, loadFrame}

-----------------------------------------------------------------------
-- TAB SWITCHING
-----------------------------------------------------------------------
local function switchTab(idx)
	currentTab = idx
	for i, btn in ipairs(tabBtns) do
		btn.BackgroundColor3 = i == idx and TAB_ON or TAB_OFF
		btn.TextColor3 = i == idx and GOLD or TEXT
	end
	for i, f in ipairs(tabFrames) do
		f.Visible = (i == idx)
	end
end

for i, btn in ipairs(tabBtns) do
	btn.MouseButton1Click:Connect(function()
		switchTab(i)
	end)
end

-----------------------------------------------------------------------
-- REFRESH DATA
-----------------------------------------------------------------------
local function refreshData()
	local ok, data = pcall(function()
		return GetStatsPanel:InvokeServer()
	end)
	if not ok or not data then
		warn("[StatsPanel] Failed to get data:", data)
		return
	end
	print("[StatsPanel] Got data, updating UI...")

	-- Skills tab
	if data.skills then
		local total = 0
		for _, sk in ipairs(SKILL_LIST) do
			local lvl = data.skills[sk.name]
			if type(lvl) == "number" then
				total = total + lvl
				if skillLevelLabels[sk.name] then
					skillLevelLabels[sk.name].Text = tostring(lvl)
				end
			else
				total = total + 1
			end
		end
		totalLbl.Text = "Total Level: " .. total
	end

	-- Gold
	if data.gold then
		goldLbl.Text = "Gold: " .. tostring(data.gold)
	end

	-- Now using ItemVisuals module for consistent item display

	-- Inventory tab
	if data.inventory then
		for i = 1, INV_TOTAL do
			local item = data.inventory[i]
			local s = invSlots[i]
			if item and item.name then
				local rarity = item.rarity or "common"
				local rarityColor = RARITY[rarity] or RARITY.common
				
				-- Get item visuals from ItemVisuals module
				local visual = ItemVisuals.GetVisual(item.name)
				local itemColor = visual.color
				
				-- Background tinted to item's unique color at low opacity
				s.color.BackgroundTransparency = 0.15
				s.color.BackgroundColor3 = itemColor
				
				-- Border uses rarity color
				s.stroke.Color = rarityColor
				s.stroke.Transparency = 0
				s.stroke.Thickness = 2
				
				-- Use emoji icon from ItemVisuals
				s.icon.Text = visual.emoji
				s.icon.TextColor3 = itemColor
				
				s.name.Text = item.name
				s.count.Text = (item.count and item.count > 1) and ("x" .. item.count) or ""
				s.itemData = item
			else
				s.color.BackgroundTransparency = 1
				s.stroke.Color = Color3.fromRGB(60, 60, 70)
				s.stroke.Transparency = 0.5
				s.stroke.Thickness = 1.5
				s.icon.Text = ""
				s.name.Text = ""
				s.count.Text = ""
				s.itemData = nil
			end
		end
	end

	-- Equipment tab
	if data.equipment then
		for _, info in ipairs(SLOT_LAYOUT) do
			local equipped = data.equipment[info.name]
			local lbl = equipLabels[info.name]
			if lbl then
				if equipped and equipped ~= "" then
					lbl.Text = equipped
					lbl.TextColor3 = GOLD
				else
					lbl.Text = "Empty"
					lbl.TextColor3 = Color3.fromRGB(100, 100, 100)
				end
			end
		end
	end

	-- Combat level
	if data.combatLevel then
		combatLbl.Text = "Combat Level: " .. tostring(data.combatLevel)
	end
end

-----------------------------------------------------------------------
-- TOGGLE
-----------------------------------------------------------------------
local panelOpen = false

local function togglePanel()
	panelOpen = not panelOpen
	panel.Visible = panelOpen
	if panelOpen then
		print("[StatsPanel] Panel opened")
		refreshData()
	else
		print("[StatsPanel] Panel closed")
	end
end

toggleBtn.MouseButton1Click:Connect(togglePanel)

UIS.InputBegan:Connect(function(input, processed)
	if processed then return end
	if input.KeyCode == Enum.KeyCode.B then
		togglePanel()
	end
end)

-----------------------------------------------------------------------
-- REAL-TIME UPDATES
-----------------------------------------------------------------------
local xpRemote = Remotes:FindFirstChild("XPUpdate")
if xpRemote then
	xpRemote.OnClientEvent:Connect(function()
		if panelOpen then refreshData() end
	end)
end

local invRemote = Remotes:FindFirstChild("InventoryUpdate")
if invRemote then
	invRemote.OnClientEvent:Connect(function()
		if panelOpen then refreshData() end
	end)
end

local lvlRemote = Remotes:FindFirstChild("LevelUp")
if lvlRemote then
	lvlRemote.OnClientEvent:Connect(function()
		if panelOpen then refreshData() end
	end)
end

local equipRemote = Remotes:FindFirstChild("EquipmentUpdate")
if equipRemote then
	equipRemote.OnClientEvent:Connect(function()
		if panelOpen then refreshData() end
	end)
end

-----------------------------------------------------------------------
-- INVENTORY HOVER TOOLTIPS
-----------------------------------------------------------------------
local tooltipFrame = Instance.new("Frame")
tooltipFrame.Name = "Tooltip"
tooltipFrame.Size = UDim2.new(0, 160, 0, 100)
tooltipFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 30)
tooltipFrame.BackgroundTransparency = 0.05
tooltipFrame.Visible = false
tooltipFrame.ZIndex = 50
tooltipFrame.Parent = gui

local ttCorner = Instance.new("UICorner")
ttCorner.CornerRadius = UDim.new(0, 6)
ttCorner.Parent = tooltipFrame

local ttStroke = Instance.new("UIStroke")
ttStroke.Color = GOLD
ttStroke.Thickness = 2
ttStroke.Parent = tooltipFrame

local ttPad = Instance.new("UIPadding")
ttPad.PaddingLeft = UDim.new(0, 6)
ttPad.PaddingRight = UDim.new(0, 6)
ttPad.PaddingTop = UDim.new(0, 4)
ttPad.PaddingBottom = UDim.new(0, 4)
ttPad.Parent = tooltipFrame

local ttName = Instance.new("TextLabel")
ttName.Name = "TTName"
ttName.Size = UDim2.new(1, 0, 0, 16)
ttName.Position = UDim2.new(0, 0, 0, 0)
ttName.BackgroundTransparency = 1
ttName.Text = "Item Name"
ttName.TextSize = 13
ttName.Font = Enum.Font.GothamBold
ttName.TextColor3 = GOLD
ttName.TextXAlignment = Enum.TextXAlignment.Left
ttName.ZIndex = 51
ttName.Parent = tooltipFrame

local ttRarity = Instance.new("TextLabel")
ttRarity.Name = "TTRarity"
ttRarity.Size = UDim2.new(1, 0, 0, 12)
ttRarity.Position = UDim2.new(0, 0, 0, 17)
ttRarity.BackgroundTransparency = 1
ttRarity.Text = "Common"
ttRarity.TextSize = 10
ttRarity.Font = Enum.Font.GothamBold
ttRarity.TextColor3 = Color3.fromRGB(157, 157, 157)
ttRarity.TextXAlignment = Enum.TextXAlignment.Left
ttRarity.ZIndex = 51
ttRarity.Parent = tooltipFrame

local ttDesc = Instance.new("TextLabel")
ttDesc.Name = "TTDesc"
ttDesc.Size = UDim2.new(1, 0, 0, 36)
ttDesc.Position = UDim2.new(0, 0, 0, 32)
ttDesc.BackgroundTransparency = 1
ttDesc.Text = ""
ttDesc.TextSize = 10
ttDesc.Font = Enum.Font.Gotham
ttDesc.TextColor3 = TEXT
ttDesc.TextXAlignment = Enum.TextXAlignment.Left
ttDesc.TextWrapped = true
ttDesc.ZIndex = 51
ttDesc.Parent = tooltipFrame

local ttValue = Instance.new("TextLabel")
ttValue.Name = "TTValue"
ttValue.Size = UDim2.new(1, 0, 0, 14)
ttValue.Position = UDim2.new(0, 0, 1, -16)
ttValue.BackgroundTransparency = 1
ttValue.Text = "Value: 0 gold"
ttValue.TextSize = 10
ttValue.Font = Enum.Font.GothamBold
ttValue.TextColor3 = Color3.fromRGB(255, 215, 0)
ttValue.TextXAlignment = Enum.TextXAlignment.Left
ttValue.ZIndex = 51
ttValue.Parent = tooltipFrame

-- Hook hover events on inventory slots
for i = 1, INV_TOTAL do
	local s = invSlots[i]

	s.btn.MouseEnter:Connect(function()
		if not s.itemData or not s.itemData.name then
			tooltipFrame.Visible = false
			return
		end

		local itemName = s.itemData.name
		local itemDef = nil
		pcall(function()
			itemDef = ItemDatabase.GetItem(itemName)
		end)

		ttName.Text = itemName
		local rarity = (s.itemData.rarity or (itemDef and itemDef.rarity) or "common")
		ttRarity.Text = rarity:sub(1, 1):upper() .. rarity:sub(2)
		ttRarity.TextColor3 = RARITY[rarity] or RARITY.common
		ttStroke.Color = RARITY[rarity] or GOLD

		local desc = (itemDef and itemDef.description) or ""
		ttDesc.Text = desc

		local value = (itemDef and itemDef.value) or 0
		ttValue.Text = "Value: " .. tostring(value) .. " gold"

		-- Position tooltip to the right of the panel
		local absPos = s.cell.AbsolutePosition
		tooltipFrame.Position = UDim2.fromOffset(
			panel.AbsolutePosition.X + PANEL_W + 5,
			absPos.Y
		)
		tooltipFrame.Visible = true
	end)

	s.btn.MouseLeave:Connect(function()
		tooltipFrame.Visible = false
	end)
end

-----------------------------------------------------------------------
-- EQUIP/USE FROM INVENTORY
-----------------------------------------------------------------------
local EquipItemRemote = ReplicatedStorage:FindFirstChild("EquipItem")
local UnequipItemRemote = ReplicatedStorage:FindFirstChild("UnequipItem")
local EatFoodRemote = Remotes:FindFirstChild("EatFood")
local BuryBonesRemote = ReplicatedStorage:FindFirstChild("BuryBones") or (Remotes and Remotes:FindFirstChild("BuryBones"))

-- ItemDatabase and ItemVisuals already loaded at top

-- Global function to clear inventory selection highlight (called by Hotbar)
_G.ClearInventorySelection = function()
	-- Will be set up after invSlots are created
end

-- Hotbar assignment state
local selectedInventoryItem = nil

-- Click inventory slot ‚Üí select for hotbar assignment or use directly
for i = 1, INV_TOTAL do
	local s = invSlots[i]
	s.btn.MouseButton1Click:Connect(function()
		if not s.itemData or not s.itemData.name then return end
		local itemName = s.itemData.name
		local itemDef = ItemDatabase.GetItem(itemName)
		if not itemDef then return end
		
		-- Shift+click = DROP item on ground
		if UIS:IsKeyDown(Enum.KeyCode.LeftShift) or UIS:IsKeyDown(Enum.KeyCode.RightShift) then
			local dropRemote = Remotes:FindFirstChild("DropItem") or ReplicatedStorage:FindFirstChild("DropItem")
			if dropRemote then
				print("[StatsPanel] Dropping " .. itemName)
				dropRemote:FireServer(itemName, 1)
				task.wait(0.2)
				refreshData()
			else
				warn("[StatsPanel] No DropItem remote found")
			end
			return
		end
		
		-- Ctrl+click = select for hotbar assignment
		if UIS:IsKeyDown(Enum.KeyCode.LeftControl) or UIS:IsKeyDown(Enum.KeyCode.RightControl) then
			selectedInventoryItem = {
				name = itemName,
				quantity = s.itemData.count,
				slot = i
			}
			print("[StatsPanel] Selected " .. itemName .. " for hotbar (press 1-9)")
			for j = 1, INV_TOTAL do
				if j == i then
					invSlots[j].stroke.Thickness = 4
					invSlots[j].stroke.Color = Color3.fromRGB(255, 255, 0)
				else
					local item = invSlots[j].itemData
					if item and item.name then
						local rarity = item.rarity or "common"
						invSlots[j].stroke.Color = RARITY[rarity] or RARITY.common
						invSlots[j].stroke.Thickness = 2
					end
				end
			end
			return
		end

		-- Right-click = select for hotbar assignment (click hotbar slot to assign)
		-- Also set _G.PendingHotbarItem so hotbar can pick it up on click
		if UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
			_G.PendingHotbarItem = { name = itemName, quantity = s.itemData.count or 1 }
			print("[StatsPanel] Item ready for hotbar: " .. itemName .. " (click a hotbar slot)")
			for j = 1, INV_TOTAL do
				if j == i then
					invSlots[j].stroke.Thickness = 4
					invSlots[j].stroke.Color = Color3.fromRGB(0, 255, 128)
				else
					local item = invSlots[j].itemData
					if item and item.name then
						local rarity = item.rarity or "common"
						invSlots[j].stroke.Color = RARITY[rarity] or RARITY.common
						invSlots[j].stroke.Thickness = 2
					end
				end
			end
			return
		end

		-- Normal click behavior - use/equip item directly
		if itemDef.equipSlot and EquipItemRemote then
			print("[StatsPanel] Equipping " .. itemName .. " to " .. itemDef.equipSlot)
			EquipItemRemote:FireServer(itemDef.equipSlot, itemName)
			task.wait(0.2)
			refreshData()
		elseif itemDef.type == "food" and EatFoodRemote then
			print("[StatsPanel] Eating " .. itemName)
			EatFoodRemote:FireServer(itemName)
			task.wait(0.2)
			refreshData()
		elseif (itemName == "Bones" or itemName == "Big Bones" or itemName == "Dragon Bones") and BuryBonesRemote then
			print("[StatsPanel] Burying " .. itemName)
			BuryBonesRemote:FireServer(itemName)
			task.wait(0.2)
			refreshData()
		end
	end)
end

-- Hotbar assignment handling - listen for number key presses while item is selected
UIS.InputBegan:Connect(function(input, processed)
	if processed or not selectedInventoryItem then return end
	
	local hotbarSlot = nil
	if input.KeyCode == Enum.KeyCode.One then hotbarSlot = 1
	elseif input.KeyCode == Enum.KeyCode.Two then hotbarSlot = 2
	elseif input.KeyCode == Enum.KeyCode.Three then hotbarSlot = 3
	elseif input.KeyCode == Enum.KeyCode.Four then hotbarSlot = 4
	elseif input.KeyCode == Enum.KeyCode.Five then hotbarSlot = 5
	elseif input.KeyCode == Enum.KeyCode.Six then hotbarSlot = 6
	elseif input.KeyCode == Enum.KeyCode.Seven then hotbarSlot = 7
	elseif input.KeyCode == Enum.KeyCode.Eight then hotbarSlot = 8
	elseif input.KeyCode == Enum.KeyCode.Nine then hotbarSlot = 9
	end
	
	if hotbarSlot and _G.HotbarAssignItem then
		_G.HotbarAssignItem(hotbarSlot, selectedInventoryItem.name, selectedInventoryItem.quantity)
		print("[StatsPanel] Assigned " .. selectedInventoryItem.name .. " to hotbar slot " .. hotbarSlot)
		
		-- Clear selection and reset visual feedback
		selectedInventoryItem = nil
		for j = 1, INV_TOTAL do
			local item = invSlots[j].itemData
			if item and item.name then
				local rarity = item.rarity or "common"
				invSlots[j].stroke.Color = RARITY[rarity] or RARITY.common
				invSlots[j].stroke.Thickness = 2
			end
		end
	end
end)

-- Click equipment slot ‚Üí unequip
for _, info in ipairs(SLOT_LAYOUT) do
	local lbl = equipLabels[info.name]
	if lbl and UnequipItemRemote then
		-- Make the parent frame clickable
		local slotFrame = lbl.Parent
		local unequipBtn = Instance.new("TextButton")
		unequipBtn.Name = "Unequip"
		unequipBtn.Size = UDim2.new(1, 0, 1, 0)
		unequipBtn.BackgroundTransparency = 1
		unequipBtn.Text = ""
		unequipBtn.Parent = slotFrame
		unequipBtn.MouseButton1Click:Connect(function()
			print("[StatsPanel] Unequipping " .. info.name)
			UnequipItemRemote:FireServer(info.name)
			task.wait(0.2)
			refreshData()
		end)
	end
end

-----------------------------------------------------------------------
-- INIT
-----------------------------------------------------------------------
task.spawn(refreshData)
print("[StatsPanel] Ready! Press B to toggle.")
]]></string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="76">
        <Properties>
          <string name="Name">TradeUI</string>
          <string name="Source"><![CDATA[--[[
	TradeUI.client.lua
	Client-side trade window UI for a RuneScape-inspired full-loot PvP MMO.
	Two-column layout with dark theme and gold accents.
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local TradeRequest = Remotes:WaitForChild("TradeRequest")
local TradeResponse = Remotes:WaitForChild("TradeResponse")
local TradeUpdate = Remotes:WaitForChild("TradeUpdate")
local TradeConfirm = Remotes:WaitForChild("TradeConfirm")
local TradeCancel = Remotes:WaitForChild("TradeCancel")
local TradeComplete = Remotes:WaitForChild("TradeComplete")

--------------------------------------------------------------------------------
-- Theme
--------------------------------------------------------------------------------

local COLORS = {
	bg = Color3.fromHex("#1a1a2e"),
	bgLight = Color3.fromHex("#16213e"),
	gold = Color3.fromHex("#f0c040"),
	goldDim = Color3.fromHex("#a08020"),
	text = Color3.fromRGB(220, 220, 220),
	textDim = Color3.fromRGB(150, 150, 150),
	red = Color3.fromHex("#e74c3c"),
	green = Color3.fromHex("#2ecc71"),
	slot = Color3.fromHex("#0f3460"),
	slotBorder = Color3.fromHex("#1a5276"),
}

local GRID_COLS = 4
local GRID_ROWS = 7
local SLOT_SIZE = 50
local SLOT_PAD = 4

--------------------------------------------------------------------------------
-- UI Construction
--------------------------------------------------------------------------------

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "TradeUI"
screenGui.ResetOnSpawn = false
screenGui.Enabled = false
screenGui.Parent = playerGui

-- Main frame
local PANEL_W = (SLOT_SIZE + SLOT_PAD) * GRID_COLS + SLOT_PAD
local TOTAL_W = PANEL_W * 2 + 40  -- two panels + divider + padding
local TOTAL_H = (SLOT_SIZE + SLOT_PAD) * GRID_ROWS + SLOT_PAD + 120  -- grid + header + buttons

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.fromOffset(TOTAL_W, TOTAL_H)
mainFrame.Position = UDim2.fromScale(0.5, 0.5)
mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
mainFrame.BackgroundColor3 = COLORS.bg
mainFrame.BorderSizePixel = 0
mainFrame.Parent = screenGui

-- Rounded corners
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = mainFrame

-- Gold border stroke
local stroke = Instance.new("UIStroke")
stroke.Color = COLORS.gold
stroke.Thickness = 2
stroke.Parent = mainFrame

--- Helper: create a TextLabel
local function makeLabel(props: { [string]: any }): TextLabel
	local label = Instance.new("TextLabel")
	label.BackgroundTransparency = 1
	label.TextColor3 = props.Color or COLORS.text
	label.Font = Enum.Font.GothamBold
	label.TextSize = props.TextSize or 14
	label.Text = props.Text or ""
	label.Size = props.Size or UDim2.new(1, 0, 0, 24)
	label.Position = props.Position or UDim2.new()
	label.TextXAlignment = props.Align or Enum.TextXAlignment.Center
	label.Parent = props.Parent
	return label
end

--- Helper: create a TextButton
local function makeButton(props: { [string]: any }): TextButton
	local btn = Instance.new("TextButton")
	btn.Size = props.Size or UDim2.fromOffset(90, 32)
	btn.Position = props.Position or UDim2.new()
	btn.AnchorPoint = props.AnchorPoint or Vector2.zero
	btn.BackgroundColor3 = props.Color or COLORS.gold
	btn.TextColor3 = props.TextColor or COLORS.bg
	btn.Font = Enum.Font.GothamBold
	btn.TextSize = 14
	btn.Text = props.Text or "Button"
	btn.BorderSizePixel = 0
	btn.AutoButtonColor = true
	btn.Parent = props.Parent

	local c = Instance.new("UICorner")
	c.CornerRadius = UDim.new(0, 6)
	c.Parent = btn
	return btn
end

-- Title bar
local titleBar = Instance.new("Frame")
titleBar.Size = UDim2.new(1, 0, 0, 36)
titleBar.BackgroundColor3 = COLORS.bgLight
titleBar.BorderSizePixel = 0
titleBar.Parent = mainFrame

local titleCorner = Instance.new("UICorner")
titleCorner.CornerRadius = UDim.new(0, 8)
titleCorner.Parent = titleBar

makeLabel({
	Text = "‚öîÔ∏è  TRADE  ‚öîÔ∏è",
	TextSize = 16,
	Color = COLORS.gold,
	Size = UDim2.new(1, 0, 1, 0),
	Parent = titleBar,
})

-- Close button (X)
local closeBtn = makeButton({
	Text = "X",
	Size = UDim2.fromOffset(32, 32),
	Position = UDim2.new(1, -36, 0, 2),
	Color = COLORS.red,
	TextColor = Color3.new(1, 1, 1),
	Parent = titleBar,
})

-- Column headers
makeLabel({
	Text = "My Offer",
	TextSize = 14,
	Color = COLORS.gold,
	Size = UDim2.fromOffset(PANEL_W, 20),
	Position = UDim2.fromOffset(10, 42),
	Parent = mainFrame,
})

makeLabel({
	Text = "Their Offer",
	TextSize = 14,
	Color = COLORS.gold,
	Size = UDim2.fromOffset(PANEL_W, 20),
	Position = UDim2.fromOffset(PANEL_W + 30, 42),
	Parent = mainFrame,
})

-- Divider line
local divider = Instance.new("Frame")
divider.Size = UDim2.new(0, 2, 0, (SLOT_SIZE + SLOT_PAD) * GRID_ROWS + SLOT_PAD + 20)
divider.Position = UDim2.fromOffset(PANEL_W + 14, 40)
divider.BackgroundColor3 = COLORS.goldDim
divider.BorderSizePixel = 0
divider.Parent = mainFrame

--- Create a grid of item slots and return slot frames.
local function createGrid(offsetX: number, offsetY: number): { Frame }
	local slots = {}
	for row = 0, GRID_ROWS - 1 do
		for col = 0, GRID_COLS - 1 do
			local slot = Instance.new("Frame")
			slot.Size = UDim2.fromOffset(SLOT_SIZE, SLOT_SIZE)
			slot.Position = UDim2.fromOffset(
				offsetX + col * (SLOT_SIZE + SLOT_PAD) + SLOT_PAD,
				offsetY + row * (SLOT_SIZE + SLOT_PAD) + SLOT_PAD
			)
			slot.BackgroundColor3 = COLORS.slot
			slot.BorderSizePixel = 0
			slot.Parent = mainFrame

			local sc = Instance.new("UICorner")
			sc.CornerRadius = UDim.new(0, 4)
			sc.Parent = slot

			local ss = Instance.new("UIStroke")
			ss.Color = COLORS.slotBorder
			ss.Thickness = 1
			ss.Parent = slot

			-- Item name label inside slot
			local nameLabel = Instance.new("TextLabel")
			nameLabel.Name = "ItemName"
			nameLabel.Size = UDim2.new(1, -4, 0.6, 0)
			nameLabel.Position = UDim2.new(0, 2, 0, 2)
			nameLabel.BackgroundTransparency = 1
			nameLabel.TextColor3 = COLORS.text
			nameLabel.Font = Enum.Font.Gotham
			nameLabel.TextSize = 10
			nameLabel.TextWrapped = true
			nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
			nameLabel.Text = ""
			nameLabel.Parent = slot

			-- Quantity label
			local qtyLabel = Instance.new("TextLabel")
			qtyLabel.Name = "Quantity"
			qtyLabel.Size = UDim2.new(1, -4, 0.35, 0)
			qtyLabel.Position = UDim2.new(0, 2, 0.65, 0)
			qtyLabel.BackgroundTransparency = 1
			qtyLabel.TextColor3 = COLORS.gold
			qtyLabel.Font = Enum.Font.GothamBold
			qtyLabel.TextSize = 11
			qtyLabel.Text = ""
			qtyLabel.Parent = slot

			table.insert(slots, slot)
		end
	end
	return slots
end

local mySlots = createGrid(10, 64)
local theirSlots = createGrid(PANEL_W + 30, 64)

-- Bottom bar: status + buttons
local bottomY = 64 + (SLOT_SIZE + SLOT_PAD) * GRID_ROWS + SLOT_PAD + 6

local statusLabel = makeLabel({
	Text = "Waiting for items...",
	TextSize = 13,
	Color = COLORS.textDim,
	Size = UDim2.new(1, -20, 0, 20),
	Position = UDim2.fromOffset(10, bottomY),
	Parent = mainFrame,
})

local btnY = bottomY + 26

local acceptBtn = makeButton({
	Text = "‚úî Accept",
	Position = UDim2.fromOffset(TOTAL_W / 2 - 145, btnY),
	Color = COLORS.green,
	TextColor = Color3.new(1, 1, 1),
	Parent = mainFrame,
})

local declineBtn = makeButton({
	Text = "‚úñ Decline",
	Position = UDim2.fromOffset(TOTAL_W / 2 - 45, btnY),
	Color = COLORS.red,
	TextColor = Color3.new(1, 1, 1),
	Parent = mainFrame,
})

local cancelBtn = makeButton({
	Text = "Cancel",
	Position = UDim2.fromOffset(TOTAL_W / 2 + 55, btnY),
	Color = COLORS.goldDim,
	TextColor = COLORS.text,
	Parent = mainFrame,
})

--------------------------------------------------------------------------------
-- Trade Request Popup (incoming request)
--------------------------------------------------------------------------------

local requestGui = Instance.new("ScreenGui")
requestGui.Name = "TradeRequestUI"
requestGui.ResetOnSpawn = false
requestGui.Enabled = false
requestGui.Parent = playerGui

local requestFrame = Instance.new("Frame")
requestFrame.Size = UDim2.fromOffset(280, 120)
requestFrame.Position = UDim2.fromScale(0.5, 0.3)
requestFrame.AnchorPoint = Vector2.new(0.5, 0.5)
requestFrame.BackgroundColor3 = COLORS.bg
requestFrame.BorderSizePixel = 0
requestFrame.Parent = requestGui

local rc = Instance.new("UICorner")
rc.CornerRadius = UDim.new(0, 8)
rc.Parent = requestFrame

local rs = Instance.new("UIStroke")
rs.Color = COLORS.gold
rs.Thickness = 2
rs.Parent = requestFrame

local requestLabel = makeLabel({
	Text = "",
	TextSize = 14,
	Color = COLORS.text,
	Size = UDim2.new(1, -20, 0, 50),
	Position = UDim2.fromOffset(10, 10),
	Parent = requestFrame,
})
requestLabel.TextWrapped = true

local pendingRequesterId: number? = nil

local acceptRequestBtn = makeButton({
	Text = "Accept",
	Size = UDim2.fromOffset(100, 30),
	Position = UDim2.fromOffset(30, 70),
	Color = COLORS.green,
	TextColor = Color3.new(1, 1, 1),
	Parent = requestFrame,
})

local declineRequestBtn = makeButton({
	Text = "Decline",
	Size = UDim2.fromOffset(100, 30),
	Position = UDim2.fromOffset(150, 70),
	Color = COLORS.red,
	TextColor = Color3.new(1, 1, 1),
	Parent = requestFrame,
})

acceptRequestBtn.MouseButton1Click:Connect(function()
	if pendingRequesterId then
		TradeResponse:FireServer(pendingRequesterId, true)
		pendingRequesterId = nil
		requestGui.Enabled = false
	end
end)

declineRequestBtn.MouseButton1Click:Connect(function()
	if pendingRequesterId then
		TradeResponse:FireServer(pendingRequesterId, false)
		pendingRequesterId = nil
		requestGui.Enabled = false
	end
end)

--------------------------------------------------------------------------------
-- State
--------------------------------------------------------------------------------

local isTrading = false
local myPlayerIndex: number? = nil  -- 1 or 2 (which side am I?)

--- Populate a slot grid from an items dictionary.
local function populateSlots(slots: { Frame }, items: { [string]: number })
	-- Clear all
	for _, slot in slots do
		slot:FindFirstChild("ItemName").Text = ""
		slot:FindFirstChild("Quantity").Text = ""
	end
	-- Fill
	local idx = 1
	for itemName, qty in items do
		if idx > #slots then break end
		local slot = slots[idx]
		slot:FindFirstChild("ItemName").Text = itemName
		slot:FindFirstChild("Quantity").Text = `x{qty}`
		idx += 1
	end
end

--------------------------------------------------------------------------------
-- Remote Handlers
--------------------------------------------------------------------------------

-- Incoming trade request from another player
TradeRequest.OnClientEvent:Connect(function(fromUserId: number, fromName: string)
	pendingRequesterId = fromUserId
	requestLabel.Text = `{fromName} wants to trade with you!`
	requestGui.Enabled = true
end)

-- Trade state update from server
TradeUpdate.OnClientEvent:Connect(function(data)
	if not isTrading then
		isTrading = true
		screenGui.Enabled = true
		-- Figure out which side I am
		if data.partner1 == player.Name then
			myPlayerIndex = 1
		else
			myPlayerIndex = 2
		end
	end

	local myItems = if myPlayerIndex == 1 then data.items1 else data.items2
	local theirItems = if myPlayerIndex == 1 then data.items2 else data.items1
	local myConfirmed = if myPlayerIndex == 1 then data.confirmed1 else data.confirmed2
	local theirConfirmed = if myPlayerIndex == 1 then data.confirmed2 else data.confirmed1

	populateSlots(mySlots, myItems)
	populateSlots(theirSlots, theirItems)

	-- Status text
	if myConfirmed and theirConfirmed then
		statusLabel.Text = "Both accepted! Completing trade..."
		statusLabel.TextColor3 = COLORS.green
	elseif myConfirmed then
		statusLabel.Text = "Waiting for partner to accept..."
		statusLabel.TextColor3 = COLORS.gold
	elseif theirConfirmed then
		statusLabel.Text = "Partner accepted. Review and accept!"
		statusLabel.TextColor3 = COLORS.gold
	else
		statusLabel.Text = "Add items and accept when ready."
		statusLabel.TextColor3 = COLORS.textDim
	end
end)

-- Trade cancelled
TradeCancel.OnClientEvent:Connect(function(reason: string?)
	isTrading = false
	myPlayerIndex = nil
	screenGui.Enabled = false
	requestGui.Enabled = false
	if reason then
		-- Brief notification (could be replaced with a toast system)
		warn(`[TradeUI] {reason}`)
	end
end)

-- Trade completed
TradeComplete.OnClientEvent:Connect(function(_summary)
	isTrading = false
	myPlayerIndex = nil
	statusLabel.Text = "Trade complete!"
	statusLabel.TextColor3 = COLORS.green
	task.delay(1.5, function()
		screenGui.Enabled = false
	end)
end)

--------------------------------------------------------------------------------
-- Button Actions
--------------------------------------------------------------------------------

acceptBtn.MouseButton1Click:Connect(function()
	if isTrading then
		TradeConfirm:FireServer()
	end
end)

declineBtn.MouseButton1Click:Connect(function()
	if isTrading then
		TradeCancel:FireServer()
	end
end)

cancelBtn.MouseButton1Click:Connect(function()
	if isTrading then
		TradeCancel:FireServer()
	end
end)

closeBtn.MouseButton1Click:Connect(function()
	if isTrading then
		TradeCancel:FireServer()
	end
end)

--------------------------------------------------------------------------------
-- Click-to-trade: click another player's character to send a request
--------------------------------------------------------------------------------

local mouse = player:GetMouse()
mouse.Button1Down:Connect(function()
	if isTrading then return end
	local target = mouse.Target
	if not target then return end
	local model = target:FindFirstAncestorOfClass("Model")
	if not model then return end
	local targetPlayer = Players:GetPlayerFromCharacter(model)
	if targetPlayer and targetPlayer ~= player then
		TradeRequest:FireServer(targetPlayer.UserId)
	end
end)

print("[TradeUI] Loaded!")
]]></string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="77">
        <Properties>
          <string name="Name">UIController</string>
          <string name="Source"><![CDATA[-- UIController.client.lua
-- Handles: zone indicator, damage numbers, level ups, zone warnings, attack input, gather feedback
-- Skills/Inventory/Equipment panels are handled by StatsPanel.client.lua

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local Remotes = ReplicatedStorage:WaitForChild("Remotes")

-- === MAIN SCREEN GUI ===
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "WildernessUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

-- === ZONE INDICATOR (top center) ===
local zoneFrame = Instance.new("Frame")
zoneFrame.Name = "ZoneIndicator"
zoneFrame.Size = UDim2.new(0, 300, 0, 50)
zoneFrame.Position = UDim2.new(0.5, -150, 0, 10)
zoneFrame.BackgroundColor3 = Color3.fromRGB(0, 150, 0)
zoneFrame.BackgroundTransparency = 0.3
zoneFrame.BorderSizePixel = 0
zoneFrame.Parent = screenGui

local zoneCorner = Instance.new("UICorner")
zoneCorner.CornerRadius = UDim.new(0, 8)
zoneCorner.Parent = zoneFrame

local zoneLabel = Instance.new("TextLabel")
zoneLabel.Name = "ZoneText"
zoneLabel.Size = UDim2.new(1, 0, 1, 0)
zoneLabel.BackgroundTransparency = 1
zoneLabel.Text = "üõ°Ô∏è SAFE ZONE"
zoneLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
zoneLabel.TextScaled = true
zoneLabel.Font = Enum.Font.GothamBold
zoneLabel.Parent = zoneFrame

-- === DAMAGE NUMBERS ===
local function showDamageNumber(text, color)
	local dmgLabel = Instance.new("TextLabel")
	dmgLabel.Size = UDim2.new(0, 200, 0, 40)
	dmgLabel.Position = UDim2.new(0.5, -100, 0.4, 0)
	dmgLabel.BackgroundTransparency = 1
	dmgLabel.Text = text
	dmgLabel.TextColor3 = color
	dmgLabel.TextScaled = true
	dmgLabel.Font = Enum.Font.GothamBold
	dmgLabel.TextStrokeTransparency = 0.5
	dmgLabel.Parent = screenGui

	local tween = TweenService:Create(dmgLabel, TweenInfo.new(1.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Position = UDim2.new(0.5, -100, 0.3, 0),
		TextTransparency = 1,
		TextStrokeTransparency = 1,
	})
	tween:Play()
	tween.Completed:Connect(function()
		dmgLabel:Destroy()
	end)
end

-- === LEVEL UP NOTIFICATION ===
local function showLevelUp(skillName, newLevel)
	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(0, 350, 0, 60)
	frame.Position = UDim2.new(0.5, -175, 0.3, 0)
	frame.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
	frame.BackgroundTransparency = 0.1
	frame.BorderSizePixel = 0
	frame.Parent = screenGui

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = frame

	local text = Instance.new("TextLabel")
	text.Size = UDim2.new(1, 0, 1, 0)
	text.BackgroundTransparency = 1
	text.Text = "üéâ " .. skillName .. " LEVEL UP! Level " .. newLevel .. " üéâ"
	text.TextColor3 = Color3.fromRGB(20, 20, 20)
	text.TextScaled = true
	text.Font = Enum.Font.GothamBold
	text.Parent = frame

	task.delay(2, function()
		local tween = TweenService:Create(frame, TweenInfo.new(1), { BackgroundTransparency = 1 })
		local textTween = TweenService:Create(text, TweenInfo.new(1), { TextTransparency = 1 })
		tween:Play()
		textTween:Play()
		textTween.Completed:Connect(function()
			frame:Destroy()
		end)
	end)
end

-- === WILDERNESS WARNING ===
local function showZoneWarning()
	local warning = Instance.new("Frame")
	warning.Size = UDim2.new(1, 0, 0, 80)
	warning.Position = UDim2.new(0, 0, 0.15, 0)
	warning.BackgroundColor3 = Color3.fromRGB(150, 0, 0)
	warning.BackgroundTransparency = 0.3
	warning.BorderSizePixel = 0
	warning.Parent = screenGui

	local text = Instance.new("TextLabel")
	text.Size = UDim2.new(1, 0, 1, 0)
	text.BackgroundTransparency = 1
	text.Text = "‚ò†Ô∏è WARNING: You are entering the WILDERNESS!\nPvP is ENABLED ‚Äî You will LOSE ALL ITEMS on death! ‚ò†Ô∏è"
	text.TextColor3 = Color3.fromRGB(255, 255, 255)
	text.TextScaled = true
	text.Font = Enum.Font.GothamBold
	text.Parent = warning

	task.delay(4, function()
		local tween = TweenService:Create(warning, TweenInfo.new(1), { BackgroundTransparency = 1 })
		local textTween = TweenService:Create(text, TweenInfo.new(1), { TextTransparency = 1 })
		tween:Play()
		textTween:Play()
		textTween.Completed:Connect(function()
			warning:Destroy()
		end)
	end)
end

-- === CONNECT REMOTES ===

-- Level Up
Remotes:WaitForChild("LevelUp").OnClientEvent:Connect(function(skillName, newLevel)
	showLevelUp(skillName, newLevel)
end)

-- Zone Changed
Remotes:WaitForChild("ZoneChanged").OnClientEvent:Connect(function(zone)
	if zone == "Wilderness" then
		zoneFrame.BackgroundColor3 = Color3.fromRGB(150, 0, 0)
		zoneLabel.Text = "‚ò†Ô∏è WILDERNESS ‚Äî PVP ENABLED"
		showZoneWarning()
	else
		zoneFrame.BackgroundColor3 = Color3.fromRGB(0, 150, 0)
		zoneLabel.Text = "üõ°Ô∏è SAFE ZONE"
	end
end)

-- Damage
Remotes:WaitForChild("DamageDealt").OnClientEvent:Connect(function(direction, damage, otherName)
	if direction == "dealt" then
		showDamageNumber("üí• " .. damage .. " ‚Üí " .. otherName, Color3.fromRGB(255, 100, 100))
	else
		showDamageNumber("üíî -" .. damage .. " from " .. otherName, Color3.fromRGB(255, 50, 50))
	end
end)

-- === ATTACK INPUT ===
-- Attack animations and input are now handled by AttackAnimations.client.lua
-- UIController only handles damage number display from DamageDealt remote

-- === GATHER FEEDBACK ===
local gatherRemote = Remotes:FindFirstChild("GatherFeedback")
if gatherRemote then
	-- Gather progress bar
	local gatherBarFrame = Instance.new("Frame")
	gatherBarFrame.Name = "GatherBar"
	gatherBarFrame.Size = UDim2.new(0, 200, 0, 24)
	gatherBarFrame.Position = UDim2.new(0.5, -100, 0.65, 0)
	gatherBarFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 50)
	gatherBarFrame.BorderSizePixel = 0
	gatherBarFrame.Visible = false
	gatherBarFrame.Parent = screenGui

	local gatherBarBorder = Instance.new("UIStroke")
	gatherBarBorder.Color = Color3.fromRGB(240, 192, 64)
	gatherBarBorder.Thickness = 2
	gatherBarBorder.Parent = gatherBarFrame

	local gatherBarCorner = Instance.new("UICorner")
	gatherBarCorner.CornerRadius = UDim.new(0, 6)
	gatherBarCorner.Parent = gatherBarFrame

	local gatherBarFill = Instance.new("Frame")
	gatherBarFill.Name = "Fill"
	gatherBarFill.Size = UDim2.new(0, 0, 1, 0)
	gatherBarFill.BackgroundColor3 = Color3.fromRGB(100, 200, 100)
	gatherBarFill.BorderSizePixel = 0
	gatherBarFill.Parent = gatherBarFrame

	local gatherFillCorner = Instance.new("UICorner")
	gatherFillCorner.CornerRadius = UDim.new(0, 6)
	gatherFillCorner.Parent = gatherBarFill

	local gatherBarLabel = Instance.new("TextLabel")
	gatherBarLabel.Size = UDim2.new(1, 0, 1, 0)
	gatherBarLabel.BackgroundTransparency = 1
	gatherBarLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	gatherBarLabel.Font = Enum.Font.GothamBold
	gatherBarLabel.TextSize = 14
	gatherBarLabel.Text = ""
	gatherBarLabel.ZIndex = 2
	gatherBarLabel.Parent = gatherBarFrame

	local gatherTween = nil

	gatherRemote.OnClientEvent:Connect(function(action, itemName, xpOrLevel)
		if action == "start" then
			-- xpOrLevel is the gather duration in seconds
			local duration = xpOrLevel
			gatherBarLabel.Text = "Gathering " .. itemName .. "..."
			gatherBarFill.Size = UDim2.new(0, 0, 1, 0)
			gatherBarFrame.Visible = true
			-- Tween the fill bar
			local TweenService = game:GetService("TweenService")
			gatherTween = TweenService:Create(gatherBarFill, TweenInfo.new(duration, Enum.EasingStyle.Linear), {
				Size = UDim2.new(1, 0, 1, 0)
			})
			gatherTween:Play()
		elseif action == "gather" then
			gatherBarFrame.Visible = false
			if gatherTween then gatherTween:Cancel() end
			showDamageNumber("+" .. itemName .. " (+" .. xpOrLevel .. " XP)", Color3.fromRGB(100, 255, 100))
		elseif action == "cancel" then
			gatherBarFrame.Visible = false
			if gatherTween then gatherTween:Cancel() end
			showDamageNumber("Cancelled!", Color3.fromRGB(200, 200, 200))
		elseif action == "full" then
			gatherBarFrame.Visible = false
			if gatherTween then gatherTween:Cancel() end
			showDamageNumber("Inventory Full!", Color3.fromRGB(255, 100, 100))
		elseif action == "level" then
			showDamageNumber("Need Level " .. xpOrLevel .. "!", Color3.fromRGB(255, 200, 50))
		elseif action == "notool" then
			showDamageNumber("You need a " .. itemName .. "!", Color3.fromRGB(255, 150, 50))
		end
	end)
end

-- === CLIENT-SIDE ZONE CHECK (backup) ===
local WILDERNESS_Z = -100
task.spawn(function()
	local lastZone = "safe"
	while true do
		task.wait(0.3)
		local character = player.Character
		if character then
			local root = character:FindFirstChild("HumanoidRootPart")
			if root then
				local currentZone = root.Position.Z < WILDERNESS_Z and "wild" or "safe"
				if currentZone ~= lastZone then
					lastZone = currentZone
					if currentZone == "wild" then
						zoneFrame.BackgroundColor3 = Color3.fromRGB(150, 0, 0)
						zoneLabel.Text = "‚ò†Ô∏è WILDERNESS ‚Äî PVP ENABLED"
						showZoneWarning()
					else
						zoneFrame.BackgroundColor3 = Color3.fromRGB(0, 150, 0)
						zoneLabel.Text = "üõ°Ô∏è SAFE ZONE"
					end
				end
			end
		end
	end
end)

print("[UIController] Client UI loaded!")
]]></string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="78">
        <Properties>
          <string name="Name">XPPopup</string>
          <string name="Source"><![CDATA[--[[
	XPPopup.client.lua
	Shows floating "+XP!" text at monster death locations
	and damage numbers above monsters when hit.
]]

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer

--------------------------------------------------------------------------------
-- XP POPUP (on monster kill)
--------------------------------------------------------------------------------
local XPPopupEvent = ReplicatedStorage:WaitForChild("XPPopup", 10)

if XPPopupEvent then
	XPPopupEvent.OnClientEvent:Connect(function(worldPos, xpAmount, monsterName)
		if not worldPos then return end

		-- Create a temporary part to attach billboard to
		local anchor = Instance.new("Part")
		anchor.Name = "XPAnchor"
		anchor.Size = Vector3.new(0.1, 0.1, 0.1)
		anchor.Position = worldPos + Vector3.new(0, 3, 0)
		anchor.Anchored = true
		anchor.CanCollide = false
		anchor.Transparency = 1
		anchor.Parent = workspace

		local bbg = Instance.new("BillboardGui")
		bbg.Size = UDim2.new(6, 0, 2, 0)
		bbg.StudsOffset = Vector3.new(0, 0, 0)
		bbg.AlwaysOnTop = true
		bbg.Adornee = anchor
		bbg.Parent = anchor

		-- XP text
		local xpLabel = Instance.new("TextLabel")
		xpLabel.Size = UDim2.new(1, 0, 0.6, 0)
		xpLabel.Position = UDim2.new(0, 0, 0, 0)
		xpLabel.BackgroundTransparency = 1
		xpLabel.Text = "+" .. xpAmount .. " XP!"
		xpLabel.TextColor3 = Color3.fromRGB(50, 255, 100)
		xpLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
		xpLabel.TextStrokeTransparency = 0
		xpLabel.TextScaled = true
		xpLabel.Font = Enum.Font.GothamBold
		xpLabel.Parent = bbg

		-- Monster name below (smaller)
		local nameLabel = Instance.new("TextLabel")
		nameLabel.Size = UDim2.new(1, 0, 0.35, 0)
		nameLabel.Position = UDim2.new(0, 0, 0.6, 0)
		nameLabel.BackgroundTransparency = 1
		nameLabel.Text = monsterName .. " defeated!"
		nameLabel.TextColor3 = Color3.fromRGB(255, 220, 100)
		nameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
		nameLabel.TextStrokeTransparency = 0.3
		nameLabel.TextScaled = true
		nameLabel.Font = Enum.Font.GothamBold
		nameLabel.Parent = bbg

		-- Animate: float up and fade
		local startPos = anchor.Position
		local endPos = startPos + Vector3.new(0, 6, 0)

		TweenService:Create(anchor, TweenInfo.new(2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			Position = endPos,
		}):Play()

		-- Fade out after 1.5s
		task.delay(1.2, function()
			if xpLabel and xpLabel.Parent then
				TweenService:Create(xpLabel, TweenInfo.new(0.8), {
					TextTransparency = 1,
					TextStrokeTransparency = 1,
				}):Play()
			end
			if nameLabel and nameLabel.Parent then
				TweenService:Create(nameLabel, TweenInfo.new(0.8), {
					TextTransparency = 1,
					TextStrokeTransparency = 1,
				}):Play()
			end
		end)

		-- Cleanup
		task.delay(2.5, function()
			if anchor and anchor.Parent then anchor:Destroy() end
		end)
	end)
end

--------------------------------------------------------------------------------
-- DAMAGE NUMBERS (on monster hit)
--------------------------------------------------------------------------------
local MonsterDamageEvent = ReplicatedStorage:WaitForChild("MonsterDamage", 10)

if MonsterDamageEvent then
	MonsterDamageEvent.OnClientEvent:Connect(function(model, damage, currentHP, maxHP)
		if not model or not model.Parent then return end
		local body = model:FindFirstChild("Body") or model.PrimaryPart
		if not body then return end

		-- Create floating damage number
		local anchor = Instance.new("Part")
		anchor.Name = "DmgAnchor"
		anchor.Size = Vector3.new(0.1, 0.1, 0.1)
		anchor.Position = body.Position + Vector3.new(math.random(-2, 2), 2 + math.random(), math.random(-2, 2))
		anchor.Anchored = true
		anchor.CanCollide = false
		anchor.Transparency = 1
		anchor.Parent = workspace

		local bbg = Instance.new("BillboardGui")
		bbg.Size = UDim2.new(3, 0, 1, 0)
		bbg.AlwaysOnTop = true
		bbg.Adornee = anchor
		bbg.Parent = anchor

		local isBigHit = damage >= (maxHP * 0.15)

		local dmgLabel = Instance.new("TextLabel")
		dmgLabel.Size = UDim2.new(1, 0, 1, 0)
		dmgLabel.BackgroundTransparency = 1
		dmgLabel.Text = tostring(damage)
		dmgLabel.TextColor3 = isBigHit and Color3.fromRGB(255, 50, 50) or Color3.fromRGB(255, 255, 255)
		dmgLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
		dmgLabel.TextStrokeTransparency = 0
		dmgLabel.TextScaled = true
		dmgLabel.Font = Enum.Font.GothamBold
		dmgLabel.Parent = bbg

		-- Scale pop on big hits
		if isBigHit then
			bbg.Size = UDim2.new(4, 0, 1.5, 0)
		end

		-- Float up and fade
		TweenService:Create(anchor, TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			Position = anchor.Position + Vector3.new(0, 3, 0),
		}):Play()

		task.delay(0.5, function()
			if dmgLabel and dmgLabel.Parent then
				TweenService:Create(dmgLabel, TweenInfo.new(0.5), {
					TextTransparency = 1,
					TextStrokeTransparency = 1,
				}):Play()
			end
		end)

		task.delay(1.2, function()
			if anchor and anchor.Parent then anchor:Destroy() end
		end)
	end)
end

print("[XPPopup] Loaded ‚Äî XP popups + damage numbers!")
]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="Workspace" referent="79">
    <Properties>
      <string name="Name">Workspace</string>
      <bool name="NeedsPivotMigration">false</bool>
    </Properties>
  </Item>
</roblox>